exports.ccxtex=function(e){var t={};function i(s){if(t[s])return t[s].exports;var r=t[s]={i:s,l:!1,exports:{}};return e[s].call(r.exports,r,r.exports,i),r.l=!0,r.exports}return i.m=e,i.c=t,i.d=function(e,t,s){i.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:s})},i.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i.t=function(e,t){if(1&t&&(e=i(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var s=Object.create(null);if(i.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var r in e)i.d(s,r,function(t){return e[t]}.bind(null,r));return s},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="",i(i.s=38)}([function(e,t,i){"use strict";const s=i(73);e.exports=function e(t,i,s={}){for(const[r,a]of Object.entries(i)){const i=Object.assign(s,{[r]:class extends t{constructor(e){super(e),this.constructor=i,this.__proto__=i.prototype,this.name=r,this.message=e}}})[r];e(i,a,s)}return s}(Error,s)},function(e,t,i){"use strict";const s=i(15),{isNode:r,keys:a,values:o,deepExtend:n,extend:d,clone:c,flatten:h,unique:l,indexBy:u,sortBy:f,groupBy:p,aggregate:m,uuid:y,unCamelCase:b,precisionFromString:v,throttle:g,capitalize:w,now:k,microseconds:T,seconds:O,iso8601:_,parse8601:C,parseDate:S,sleep:x,timeout:M,TimedOut:I,buildOHLCVC:F,decimalToPrecision:B,defaultFetch:A}=s,{ExchangeError:E,BadSymbol:P,InvalidAddress:q,NotSupported:D,AuthenticationError:V,DDoSProtection:R,RequestTimeout:G,ExchangeNotAvailable:L}=i(0),{TRUNCATE:N,ROUND:H,DECIMAL_PLACES:U}=s.precisionConstants;let j=void 0,K=void 0,X=void 0,z=void 0;try{j=i(!function(){var e=new Error("Cannot find module 'web3'");throw e.code="MODULE_NOT_FOUND",e}()),K=i(!function(){var e=new Error("Cannot find module 'ethereumjs-abi'");throw e.code="MODULE_NOT_FOUND",e}()),X=i(!function(){var e=new Error("Cannot find module 'ethereumjs-util'");throw e.code="MODULE_NOT_FOUND",e}()),z=i(!function(){var e=new Error("Cannot find module 'bignumber.js'");throw e.code="MODULE_NOT_FOUND",e}())}catch(e){}e.exports=class e{describe(){return{id:void 0,name:void 0,countries:void 0,enableRateLimit:!1,rateLimit:2e3,certified:!1,has:{cancelAllOrders:!1,cancelOrder:!0,cancelOrders:!1,CORS:!1,createDepositAddress:!1,createLimitOrder:!0,createMarketOrder:!0,createOrder:!0,deposit:!1,editOrder:"emulated",fetchBalance:!0,fetchBidsAsks:!1,fetchClosedOrders:!1,fetchCurrencies:!1,fetchDepositAddress:!1,fetchDeposits:!1,fetchFundingFees:!1,fetchL2OrderBook:!0,fetchLedger:!1,fetchMarkets:!0,fetchMyTrades:!1,fetchOHLCV:"emulated",fetchOpenOrders:!1,fetchOrder:!1,fetchOrderBook:!0,fetchOrderBooks:!1,fetchOrders:!1,fetchStatus:"emulated",fetchTicker:!0,fetchTickers:!1,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTradingLimits:!1,fetchTransactions:!1,fetchWithdrawals:!1,privateAPI:!0,publicAPI:!0,withdraw:!1},urls:{logo:void 0,api:void 0,www:void 0,doc:void 0,fees:void 0},api:void 0,requiredCredentials:{apiKey:!0,secret:!0,uid:!1,login:!1,password:!1,twofa:!1,privateKey:!1,walletAddress:!1,token:!1},markets:void 0,currencies:{},timeframes:void 0,fees:{trading:{tierBased:void 0,percentage:void 0,taker:void 0,maker:void 0},funding:{tierBased:void 0,percentage:void 0,withdraw:{},deposit:{}}},status:{status:"ok",updated:void 0,eta:void 0,url:void 0},exceptions:void 0,httpExceptions:{422:E,418:R,429:R,404:L,409:L,500:L,501:L,502:L,520:L,521:L,522:L,525:L,526:L,400:L,403:L,405:L,503:L,530:L,408:G,504:G,401:V,511:V},dontGetUsedBalanceFromStaleCache:!1,commonCurrencies:{XBT:"BTC",BCC:"BCH",DRK:"DASH",BCHABC:"BCH",BCHSV:"BSV"},precisionMode:U,limits:{amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}}}}constructor(e={}){Object.assign(this,s),this.options={},this.fetchOptions={},this.userAgents={chrome:"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36",chrome39:"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36"},this.headers={},this.proxy="",this.origin="*",this.iso8601=_,this.parse8601=C,this.parseDate=S,this.microseconds=T,this.seconds=O,this.minFundingAddressLength=1,this.substituteCommonCurrencyCodes=!0,this.fetchImplementation=A,this.timeout=1e4,this.verbose=!1,this.debug=!1,this.userAgent=void 0,this.twofa=void 0,this.apiKey=void 0,this.secret=void 0,this.uid=void 0,this.login=void 0,this.password=void 0,this.privateKey=void 0,this.walletAddress=void 0,this.token=void 0,this.balance={},this.orderbooks={},this.tickers={},this.orders={},this.trades={},this.transactions={},this.requiresWeb3=!1,this.precision={},this.enableLastJsonResponse=!0,this.enableLastHttpResponse=!0,this.enableLastResponseHeaders=!0,this.last_http_response=void 0,this.last_json_response=void 0,this.last_response_headers=void 0,this.arrayConcat=((e,t)=>e.concat(t));const t=(e=this)=>{if(null!==e){for(const t of Object.getOwnPropertyNames(e))this[b(t)]=this[t];t(Object.getPrototypeOf(e))}};t();const i=n(this.describe(),e);for(const[e,t]of Object.entries(i))this[e]=n(this[e],t);for(const e in this.has)this["has"+w(e)]=!!this.has[e];if(this.api&&this.defineRestApi(this.api,"request"),this.initRestRateLimiter(),this.markets&&this.setMarkets(this.markets),this.requiresWeb3&&!this.web3&&j){const e=this.web3ProviderURL?new j.providers.HttpProvider(this.web3ProviderURL):new j.providers.HttpProvider;this.web3=new j(j.givenProvider||e)}}defaults(){return{}}nonce(){return this.seconds()}milliseconds(){return k()}encodeURIComponent(...e){return encodeURIComponent(...e)}checkRequiredCredentials(e=!0){Object.keys(this.requiredCredentials).forEach(t=>{if(this.requiredCredentials[t]&&!this[t]){if(e)throw new V(this.id+" requires `"+t+"` credential");return e}})}checkAddress(e){if(void 0===e)throw new q(this.id+" address is undefined");if(1===l(e).length||e.length<this.minFundingAddressLength||e.includes(" "))throw new q(this.id+" address is invalid or has less than "+this.minFundingAddressLength.toString()+' characters: "'+this.json(e)+'"');return e}initRestRateLimiter(){if(void 0===this.rateLimit)throw new Error(this.id+".rateLimit property is not configured");this.tokenBucket=this.extend({refillRate:1/this.rateLimit,delay:1,capacity:1,defaultCost:1,maxCapacity:1e3},this.tokenBucket),this.throttle=g(this.tokenBucket),this.executeRestRequest=((e,t="GET",i,s)=>{const a=this.fetchImplementation,o={method:t,headers:i,body:s,timeout:this.timeout};if(this.httpAgent&&0===e.indexOf("http://"))o.agent=this.httpAgent;else if(this.httpsAgent&&0===e.indexOf("https://"))o.agent=this.httpsAgent;else if(this.agent){const[t,...i]=e.split("//");t===this.agent.protocol&&(o.agent=this.agent)}const n=a(e,this.extend(o,this.fetchOptions)).catch(i=>{if(r)throw new L([this.id,t,e,i.type,i.message].join(" "));throw i}).then(r=>this.handleRestResponse(r,e,t,i,s));return M(this.timeout,n).catch(i=>{if(i instanceof I)throw new G(this.id+" "+t+" "+e+" request timed out ("+this.timeout+" ms)");throw i})})}setSandboxMode(e){if(e){if(!("test"in this.urls))throw new D(this.id+" does not have a sandbox URL");"string"==typeof this.urls.api?(this.urls.api_backup=this.urls.api,this.urls.api=this.urls.test):(this.urls.api_backup=c(this.urls.api),this.urls.api=c(this.urls.test))}else"api_backup"in this.urls&&("string"==typeof this.urls.api?this.urls.api=this.urls.api_backup:this.urls.api=c(this.urls.api_backup))}defineRestApi(e,t,i={}){for(const s of Object.keys(e))for(const r of Object.keys(e[s])){let a=e[s][r];for(let e=0;e<a.length;e++){let o=a[e].trim(),n=o.split(/[^a-zA-Z0-9]/),d=r.toUpperCase(),c=r.toLowerCase(),h=this.capitalize(c),l=n.map(this.capitalize).join(""),u=n.map(e=>e.trim().toLowerCase()).filter(e=>e.length>0).join("_"),f=s+h+this.capitalize(l),p=s+"_"+c+"_"+u;"suffixes"in i&&("camelcase"in i.suffixes&&(f+=i.suffixes.camelcase),"underscore"in i.suffixes&&(p+=i.suffixes.underscore)),"underscore_suffix"in i&&(p+=i.underscoreSuffix),"camelcase_suffix"in i&&(f+=i.camelcaseSuffix);let m=async e=>this[t](o,s,d,e||{});this[f]=m,this[p]=m}}}fetch(e,t="GET",i,s){return r&&this.userAgent&&("string"==typeof this.userAgent?i=d({"User-Agent":this.userAgent},i):"object"==typeof this.userAgent&&"User-Agent"in this.userAgent&&(i=d(this.userAgent,i))),"function"==typeof this.proxy?(e=this.proxy(e),r&&(i=d({Origin:this.origin},i))):"string"==typeof this.proxy&&(this.proxy.length&&r&&(i=d({Origin:this.origin},i)),e=this.proxy+e),i=d(this.headers,i),this.verbose&&console.log("fetch:\n",this.id,t,e,"\nRequest:\n",i,"\n",s,"\n"),this.executeRestRequest(e,t,i,s)}async fetch2(e,t="public",i="GET",s={},r,a){this.enableRateLimit&&await this.throttle();const o=this.sign(e,t,i,s,r,a);return this.fetch(o.url,o.method,o.headers,o.body)}request(e,t="public",i="GET",s={},r,a){return this.fetch2(e,t,i,s,r,a)}parseJson(e){try{if(this.isJsonEncodedObject(e))return JSON.parse(e)}catch(e){return}}findBroadlyMatchedKey(e,t){const i=Object.keys(e);for(let e=0;e<i.length;e++){const s=i[e];if(t.indexOf(s)>=0)return s}}handleErrors(e,t,i,s,r,a,o,n,d){}defaultErrorHandler(e,t,i,s,r,a,o){if(e>=200&&e<=299)return;let n=a;const d=e.toString();let c=void 0;if(d in this.httpExceptions&&(c=this.httpExceptions[d]),void 0===o){const e=a.match(/offline|busy|retry|wait|unavailable|maintain|maintenance|maintenancing/i),t=a.match(/cloudflare|incapsula|overload|ddos/i);e&&(c=L,n+=" offline, on maintenance, or unreachable from this location at the moment"),t&&(c=R)}if(c===L&&(n+=" (possible reasons: "+["invalid API keys","bad or old nonce","exchange is down or offline","on maintenance","DDoS protection","rate-limiting"].join(", ")+")"),void 0!==c)throw new c([this.id,s,i,e,t,n].join(" "))}isJsonEncodedObject(e){return"string"==typeof e&&e.length>=2&&("{"===e[0]||"["===e[0])}getResponseHeaders(e){const t={};return e.headers.forEach((e,i)=>{i=i.split("-").map(e=>w(e)).join("-"),t[i]=e}),t}handleRestResponse(e,t,i="GET",s,r){return e.text().then(a=>{const o=this.parseJson(a),n=this.getResponseHeaders(e);return this.enableLastResponseHeaders&&(this.last_response_headers=n),this.enableLastHttpResponse&&(this.last_http_response=a),this.enableLastJsonResponse&&(this.last_json_response=o),this.verbose&&console.log("handleRestResponse:\n",this.id,i,t,e.status,e.statusText,"\nResponse:\n",n,"\n",a,"\n"),this.handleErrors(e.status,e.statusText,t,i,n,a,o,s,r),this.defaultErrorHandler(e.status,e.statusText,t,i,n,a,o),o||a})}setMarkets(e,t){const i=Object.values(e).map(e=>n({limits:this.limits,precision:this.precision},this.fees.trading,e));if(this.markets=n(this.markets,u(i,"symbol")),this.marketsById=u(e,"id"),this.markets_by_id=this.marketsById,this.symbols=Object.keys(this.markets).sort(),this.ids=Object.keys(this.markets_by_id).sort(),t)this.currencies=n(t,this.currencies);else{const e=i.filter(e=>"base"in e).map(e=>({id:e.baseId||e.base,numericId:void 0!==e.baseNumericId?e.baseNumericId:void 0,code:e.base,precision:e.precision?e.precision.base||e.precision.amount:8})),t=i.filter(e=>"quote"in e).map(e=>({id:e.quoteId||e.quote,numericId:void 0!==e.quoteNumericId?e.quoteNumericId:void 0,code:e.quote,precision:e.precision?e.precision.quote||e.precision.price:8})),s=e.concat(t),r=p(s,"code"),a=Object.keys(r).map(e=>r[e].reduce((e,t)=>e.precision>t.precision?e:t,r[e][0])),o=f(h(a),"code");this.currencies=n(u(o,"code"),this.currencies)}return this.currencies_by_id=u(this.currencies,"id"),this.markets}async loadMarkets(e=!1,t={}){if(!e&&this.markets)return this.markets_by_id?this.markets:this.setMarkets(this.markets);let i=void 0;this.has.fetchCurrencies&&(i=await this.fetchCurrencies());const s=await this.fetchMarkets(t);return this.setMarkets(s,i)}async loadAccounts(e=!1,t={}){if(e)this.accounts=await this.fetchAccounts(t);else{if(this.accounts)return this.accounts;this.accounts=await this.fetchAccounts(t)}return this.accountsById=this.indexBy(this.accounts,"id"),this.accounts}fetchBidsAsks(e,t={}){throw new D(this.id+" fetchBidsAsks not supported yet")}async fetchOHLCVC(e,t="1m",i,s,r={}){if(!this.has.fetchTrades)throw new D(this.id+" fetchOHLCV() not supported yet");await this.loadMarkets();const a=await this.fetchTrades(e,i,s,r);return F(a,t,i,s)}async fetchOHLCV(e,t="1m",i,s,r={}){if(!this.has.fetchTrades)throw new D(this.id+" fetchOHLCV() not supported yet");await this.loadMarkets();const a=await this.fetchTrades(e,i,s,r);return F(a,t,i,s).map(e=>e.slice(0,-1))}parseTradingViewOHLCV(e,t,i="1m",s,r){const a=this.convertTradingViewToOHLCV(e);return this.parseOHLCVs(a,t,i,s,r)}convertTradingViewToOHLCV(e){const t=[];for(let i=0;i<e.t.length;i++)t.push([1e3*e.t[i],e.o[i],e.h[i],e.l[i],e.c[i],e.v[i]]);return t}convertOHLCVToTradingView(e){const t={t:[],o:[],h:[],l:[],c:[],v:[]};for(let i=0;i<e.length;i++)t.t.push(parseInt(e[i][0]/1e3)),t.o.push(e[i][1]),t.h.push(e[i][2]),t.l.push(e[i][3]),t.c.push(e[i][4]),t.v.push(e[i][5]);return t}fetchTicker(e,t={}){throw new D(this.id+" fetchTicker not supported yet")}fetchTickers(e,t={}){throw new D(this.id+" fetchTickers not supported yet")}purgeCachedOrders(e){const t=Object.values(this.orders).filter(t=>"open"===t.status||t.timestamp>=e);return this.orders=u(t,"id"),this.orders}fetchOrder(e,t,i={}){throw new D(this.id+" fetchOrder not supported yet")}fetchOrders(e,t,i,s={}){throw new D(this.id+" fetchOrders not supported yet")}fetchOpenOrders(e,t,i,s={}){throw new D(this.id+" fetchOpenOrders not supported yet")}fetchClosedOrders(e,t,i,s={}){throw new D(this.id+" fetchClosedOrders not supported yet")}fetchMyTrades(e,t,i,s={}){throw new D(this.id+" fetchMyTrades not supported yet")}fetchTransactions(e,t,i,s={}){throw new D(this.id+" fetchTransactions not supported yet")}fetchDeposits(e,t,i,s={}){throw new D(this.id+" fetchDeposits not supported yet")}fetchWithdrawals(e,t,i,s={}){throw new D(this.id+" fetchWithdrawals not supported yet")}fetchCurrencies(e={}){return new Promise((e,t)=>e(this.currencies))}fetchMarkets(e={}){return new Promise((e,t)=>e(Object.values(this.markets)))}async fetchOrderStatus(e,t,i={}){return(await this.fetchOrder(e,t,i)).status}account(){return{free:void 0,used:void 0,total:void 0}}commonCurrencyCode(e){return this.substituteCommonCurrencyCodes?this.safeString(this.commonCurrencies,e,e):e}currencyId(e){if(void 0===this.currencies)throw new E(this.id+" currencies not loaded");if(e in this.currencies)return this.currencies[e].id;const t={},i=Object.keys(this.commonCurrencies);for(let e=0;e<i.length;e++){const s=i[e];t[this.commonCurrencies[s]]=s}return this.safeString(t,e,e)}currency(e){if(void 0===this.currencies)throw new E(this.id+" currencies not loaded");if("string"==typeof e&&e in this.currencies)return this.currencies[e];throw new E(this.id+" does not have currency code "+e)}findMarket(e){if(void 0===this.markets)throw new E(this.id+" markets not loaded");if("string"==typeof e){if(e in this.markets_by_id)return this.markets_by_id[e];if(e in this.markets)return this.markets[e]}return e}findSymbol(e,t){return void 0===t&&(t=this.findMarket(e)),"object"==typeof t?t.symbol:e}market(e){if(void 0===this.markets)throw new E(this.id+" markets not loaded");if("string"==typeof e&&e in this.markets)return this.markets[e];throw new P(this.id+" does not have market symbol "+e)}marketId(e){const t=this.market(e);return void 0!==t?t.id:e}marketIds(e){return e.map(e=>this.marketId(e))}symbol(e){return this.market(e).symbol||e}url(e,t={}){let i=this.implodeParams(e,t);const s=this.omit(t,this.extractParams(e));return Object.keys(s).length&&(i+="?"+this.urlencode(s)),i}parseBidAsk(e,t=0,i=1){return[parseFloat(e[t]),parseFloat(e[i])]}parseBidsAsks(e,t=0,i=1){return Object.values(e||[]).map(e=>this.parseBidAsk(e,t,i))}async fetchL2OrderBook(e,t,i={}){const s=await this.fetchOrderBook(e,t,i);return d(s,{bids:f(m(s.bids),0,!0),asks:f(m(s.asks),0)})}parseOrderBook(e,t,i="bids",s="asks",r=0,a=1){return{bids:f(i in e?this.parseBidsAsks(e[i],r,a):[],0,!0),asks:f(s in e?this.parseBidsAsks(e[s],r,a):[],0),timestamp:t,datetime:this.iso8601(t),nonce:void 0}}getCurrencyUsedOnOpenOrders(e){return Object.values(this.orders).filter(e=>"open"===e.status).reduce((t,i)=>{const s=i.symbol,r=this.markets[s],a=i.remaining;return e===r.base&&"sell"===i.side?t+a:e===r.quote&&"buy"===i.side?t+i.price*a:t},0)}parseBalance(e){const t=Object.keys(this.omit(e,"info"));return e.free={},e.used={},e.total={},t.forEach(t=>{void 0===e[t].total&&void 0!==e[t].free&&void 0!==e[t].used&&(e[t].total=this.sum(e[t].free,e[t].used)),void 0===e[t].free&&void 0!==e[t].total&&void 0!==e[t].used&&(e[t].free=this.sum(e[t].total,-e[t].used)),void 0===e[t].used&&void 0!==e[t].total&&void 0!==e[t].free&&(e[t].used=this.sum(e[t].total,-e[t].free)),["free","used","total"].forEach(i=>{e[i]=e[i]||{},e[i][t]=e[t][i]})}),e}async fetchPartialBalance(e,t={}){return(await this.fetchBalance(t))[e]}fetchFreeBalance(e={}){return this.fetchPartialBalance("free",e)}fetchUsedBalance(e={}){return this.fetchPartialBalance("used",e)}fetchTotalBalance(e={}){return this.fetchPartialBalance("total",e)}async fetchStatus(e={}){if(this.has.fetchTime){const t=await this.fetchTime(e);return this.status=this.extend(this.status,{updated:t})}return this.status}async fetchTradingFees(e={}){throw new D(this.id+" fetchTradingFees not supported yet")}async fetchTradingFee(e,t={}){if(!this.has.fetchTradingFees)throw new D(this.id+" fetchTradingFee not supported yet");return await this.fetchTradingFees(t)}async loadTradingLimits(e,t=!1,i={}){if(this.has.fetchTradingLimits&&(t||!("limitsLoaded"in this.options))){const t=await this.fetchTradingLimits(e);for(let i=0;i<e.length;i++){const s=e[i];this.markets[s]=this.deepExtend(this.markets[s],t[s])}this.options.limitsLoaded=this.milliseconds()}return this.markets}filterBySinceLimit(e,t,i){return null!=t&&(e=e.filter(e=>e.timestamp>=t)),null!=i&&(e=e.slice(0,i)),e}filterByValueSinceLimit(e,t,i,s,r){const a=null!=i,o=null!=s;return(a||o)&&(e=Object.values(e).filter(e=>(!a||e[t]===i)&&(!o||e.timestamp>=s))),null!=r&&(e=Object.values(e).slice(0,r)),e}filterBySymbolSinceLimit(e,t,i,s){return this.filterByValueSinceLimit(e,"symbol",t,i,s)}filterByCurrencySinceLimit(e,t,i,s){return this.filterByValueSinceLimit(e,"currency",t,i,s)}filterByArray(e,t,i,s=!0){if(e=Object.values(e),null==i)return s?u(e,t):e;const r=[];for(let s=0;s<e.length;s++)i.includes(e[s][t])&&r.push(e[s]);return s?u(r,t):r}parseTrades(e,t,i,s,r={}){let a=Object.values(e||[]).map(e=>this.extend(this.parseTrade(e,t),r));a=f(a,"timestamp");const o=void 0!==t?t.symbol:void 0;return this.filterBySymbolSinceLimit(a,o,i,s)}parseTransactions(e,t,i,s,r={}){let a=Object.values(e||[]).map(e=>this.extend(this.parseTransaction(e,t),r));a=this.sortBy(a,"timestamp");const o=void 0!==t?t.code:void 0;return this.filterByCurrencySinceLimit(a,o,i,s)}parseLedger(e,t,i,s,r={}){let a=[];const o=Object.values(e||[]);for(let e=0;e<o.length;e++){const i=this.parseLedgerEntry(o[e],t);if(Array.isArray(i))for(let e=0;e<i.length;e++)a.push(this.extend(i[e],r));else a.push(this.extend(i,r))}a=this.sortBy(a,"timestamp");const n=void 0!==t?t.code:void 0;return this.filterByCurrencySinceLimit(a,n,i,s)}parseOrders(e,t,i,s,r={}){let a=Object.values(e).map(e=>this.extend(this.parseOrder(e,t),r));a=f(a,"timestamp");const o=void 0!==t?t.symbol:void 0;return this.filterBySymbolSinceLimit(a,o,i,s)}safeCurrencyCode(e,t){let i=void 0;return void 0!==e&&(i=void 0!==this.currencies_by_id&&e in this.currencies_by_id?this.currencies_by_id[e].code:this.commonCurrencyCode(e.toUpperCase())),void 0===i&&void 0!==t&&(i=t.code),i}filterBySymbol(e,t){return void 0!==t?e.filter(e=>e.symbol===t):e}parseOHLCV(e,t,i="1m",s,r){return Array.isArray(e)?e.slice(0,6):e}parseOHLCVs(e,t,i="1m",s,r){e=Object.values(e||[]);const a=[];for(let o=0;o<e.length&&!(r&&a.length>=r);o++){const n=this.parseOHLCV(e[o],t,i,s,r);s&&n[0]<s||a.push(n)}return this.sortBy(a,0)}editLimitBuyOrder(e,t,...i){return this.editLimitOrder(e,t,"buy",...i)}editLimitSellOrder(e,t,...i){return this.editLimitOrder(e,t,"sell",...i)}editLimitOrder(e,t,...i){return this.editOrder(e,t,"limit",...i)}async editOrder(e,t,...i){if(!this.enableRateLimit)throw new E(this.id+" editOrder() requires enableRateLimit = true");return await this.cancelOrder(e,t),this.createOrder(t,...i)}createLimitOrder(e,...t){return this.createOrder(e,"limit",...t)}createMarketOrder(e,...t){return this.createOrder(e,"market",...t)}createLimitBuyOrder(e,...t){return this.createOrder(e,"limit","buy",...t)}createLimitSellOrder(e,...t){return this.createOrder(e,"limit","sell",...t)}createMarketBuyOrder(e,t,i={}){return this.createOrder(e,"market","buy",t,void 0,i)}createMarketSellOrder(e,t,i={}){return this.createOrder(e,"market","sell",t,void 0,i)}costToPrecision(e,t){return B(t,H,this.markets[e].precision.price,this.precisionMode)}priceToPrecision(e,t){return B(t,H,this.markets[e].precision.price,this.precisionMode)}amountToPrecision(e,t){return B(t,N,this.markets[e].precision.amount,this.precisionMode)}feeToPrecision(e,t){return B(t,H,this.markets[e].precision.price,this.precisionMode)}currencyToPrecision(e,t){return this.decimalToPrecision(t,H,this.currencies[e].precision,this.precisionMode)}calculateFee(e,t,i,s,r,a="taker",o={}){const n=this.markets[e],d=n[a],c=parseFloat(this.costToPrecision(e,s*r));return{type:a,currency:n.quote,rate:d,cost:parseFloat(this.feeToPrecision(e,d*c))}}static hasWeb3(){return j&&X&&K&&z}checkRequiredDependencies(){if(!e.hasWeb3())throw new E("Required dependencies missing: \nnpm i web3 ethereumjs-util ethereumjs-abi bignumber.js --no-save")}ethDecimals(e="ether"){return this.safeValue({wei:0,kwei:3,babbage:3,femtoether:3,mwei:6,lovelace:6,picoether:6,gwei:9,shannon:9,nanoether:9,nano:9,szabo:12,microether:12,micro:12,finney:15,milliether:15,milli:15,ether:18,kether:21,grand:21,mether:24,gether:27,tether:30},e)}ethUnit(e=18){return this.safeValue({0:"wei",3:"kwei",6:"mwei",9:"gwei",12:"szabo",15:"finney",18:"ether",21:"kether",24:"mether",27:"gether",30:"tether"},e)}fromWei(e,t="ether",i=18){return void 0===e?e:(e=18!==i?new z(e).times(new z(10**(18-i))).toFixed():new z(e).toFixed(),parseFloat(this.web3.utils.fromWei(e,t)))}toWei(e,t="ether",i=18){return void 0===e?e:(e=18!==i?new z(this.numberToString(e)).div(new z(10**(18-i))).toFixed():this.numberToString(e),this.web3.utils.toWei(e,t))}soliditySha3(e){const t=this.solidityValues(e),i=this.solidityTypes(t);return"0x"+K.soliditySHA3(i,t).toString("hex")}solidityTypes(e){return e.map(e=>this.web3.utils.isAddress(e)?"address":"uint256")}solidityValues(e){return e.map(e=>this.web3.utils.isAddress(e)?e:new z(e).toFixed())}getZeroExOrderHash(e){return this.soliditySha3([e.exchangeContractAddress,e.maker,e.taker,e.makerTokenAddress,e.takerTokenAddress,e.feeRecipient,e.makerTokenAmount,e.takerTokenAmount,e.makerFee,e.takerFee,e.expirationUnixTimestampSec,e.salt])}getZeroExOrderHashV2(e){const t="000000000000000000000000",i=K.soliditySHA3(["bytes","bytes","address"],[Buffer.from("91ab3d17e3a50a9d89e63fd30b92be7f5336b03b287bb946787a83a9d62a2766f0f24618f4c4be1e62e026fb039a20ef96f4495294817d1027ffaa6d1f70e61ead7c5bef027816a800da1736444fb58a807ef4c9603b7848673f7e3a68eb14a5","hex"),Buffer.from(t,"hex"),e.exchangeAddress]),s=K.soliditySHA3(["bytes","bytes","address","bytes","address","bytes","address","bytes","address","uint256","uint256","uint256","uint256","uint256","uint256","string","string"],[Buffer.from("770501f88a26ede5c04a20ef877969e961eb11fc13b78aaf414b633da0d4f86f","hex"),Buffer.from(t,"hex"),e.makerAddress,Buffer.from(t,"hex"),e.takerAddress,Buffer.from(t,"hex"),e.feeRecipientAddress,Buffer.from(t,"hex"),e.senderAddress,e.makerAssetAmount,e.takerAssetAmount,e.makerFee,e.takerFee,e.expirationTimeSeconds,e.salt,X.keccak(Buffer.from(e.makerAssetData.slice(2),"hex")),X.keccak(Buffer.from(e.takerAssetData.slice(2),"hex"))]);return"0x"+X.keccak(Buffer.concat([Buffer.from("1901","hex"),i,s])).toString("hex")}signZeroExOrder(e,t){const i=this.getZeroExOrderHash(e),s=this.signMessage(i,t);return this.extend(e,{orderHash:i,ecSignature:s})}signZeroExOrderV2(e,t){const i=this.getZeroExOrderHashV2(e),s=this.signMessage(i,t);return this.extend(e,{orderHash:i,signature:this.convertECSignatureToSignatureHex(s)})}convertECSignatureToSignatureHex(e){let t=e.v;return 27!==t&&28!==t&&(t+=27),"0x"+t.toString(16)+e.r.slice(-64)+e.s.slice(-64)+"03"}static remove0xPrefix(e){return"0x"===e.slice(0,2)?e.slice(2):e}hashMessage(t){const i=this.base16ToBinary(e.remove0xPrefix(t)),s=this.stringToBinary("Ethereum Signed Message:\n"+i.sigBytes);return"0x"+this.hash(this.binaryConcat(s,i),"keccak","hex")}signHash(e,t){const i=this.ecdsa(e.slice(-64),t.slice(-64),"secp256k1",void 0);return{r:"0x"+i.r,s:"0x"+i.s,v:27+i.v}}signMessage(e,t){return this.signHash(this.hashMessage(e),t.slice(-64))}oath(){if(void 0!==this.twofa)return this.totp(this.twofa);throw new E(this.id+" this.twofa has not been set")}}},function(e,t,i){"use strict";const s={ROUND:0,TRUNCATE:1,ROUND_UP:2,ROUND_DOWN:3,DECIMAL_PLACES:0,SIGNIFICANT_DIGITS:1,TICK_SIZE:2,NO_PADDING:0,PAD_WITH_ZERO:1};function r(e){if("string"==typeof e)return e;if(Math.abs(e)<1){const t=e.toString(),i=parseInt(t.split("e-")[1]),s="-"===t[0];i&&(e*=Math.pow(10,i-1),e=(s?"-":"")+"0."+new Array(i).join("0")+e.toString().substring(s?3:2))}else{let t=parseInt(e.toString().split("+")[1]);t>20&&(t-=20,e/=Math.pow(10,t),e+=new Array(t+1).join("0"))}return e.toString()}const a=[],o=(e,t=0)=>{if(e=r(e),t>0){const i=a[t]||(a[t]=new RegExp("([-]*\\d+\\.\\d{"+t+"})(\\d)")),[,s]=e.toString().match(i)||[null,e];return s.toString()}return parseInt(e).toString()};function n(e){const t=e.replace(/0+$/g,"").split(".");return t.length>1?t[1].length:0}const d=(e,t,i,s=0,a=0)=>{if(i<0){if(2===s)throw new Error("TICK_SIZE cant be used with negative numPrecisionDigits");const r=Math.pow(10,-i);if(0===t)return(r*d(e/r,t,0,s,a)).toString();if(1===t)return(e-e%r).toString()}if(2===s){const s=e%i,r=e/i;r!==Math.floor(r)&&(0===t?e>0?s>=i/2?e=e-s+i:e-=s:e=s>=i/2?Number(e)-s:Number(e)-s-i:1===t&&(e-=s));const o=n(d(i,0,100,0,0));return d(e,0,o,0,a)}const o=r(e),c="-"===o[0],h=c?1:0,l=o.length;for(var u=0;u<l&&"."!==o[u];u++);const f=u<o.length,p=new Uint8Array(l-h+(f?0:1));p[0]=48;let m=p.length,y=-1,b=-1;for(var v=1,g=h;g<l;g++,v++){const e=o.charCodeAt(g);if(46===e)m=v--;else{if(e<48||e>57)throw new Error(`${o}: invalid number (contains an illegal character '${o[v-1]}')`);p[v]=e,48!==e&&y<0&&(y=v)}}y<0&&(y=1);let w=0===s?m:y,k=w+i;b=-1;let T=!0,O=c;for(let e=p.length-1,s=0;e>=0;e--){let r=p[e];if(0!==e){if(r+=s,e>=w+i){r=0===t&&r>=53&&!(53===r&&s)?58:48}r>57?(r=48,s=1):s=0}else s&&(r=49);p[e]=r,48!==r&&(T=!1,y=e,b=b<0?e+1:b)}1===s&&(k=(w=y)+i),T&&(O=!1);const _=y>=m||T?m-1:y,C=b<m?m:b,S=O?1:0,x=S+(m-_),M=Math.max(C-m,0),I=C-_,F=0===a?I:k-_,B=Math.max(F-I,0),A=x+1+M,E=A+B,P=M+B===0,q=new Uint8Array(x+(P?0:1)+M+B);for(O&&(q[0]=45),v=S,g=_;v<x;v++,g++)q[v]=p[g];for(P||(q[x]=46),v=x+1,g=m;v<A;v++,g++)q[v]=p[g];for(v=A;v<E;v++)q[v]=48;return String.fromCharCode(...q)};e.exports={numberToString:r,precisionFromString:n,decimalToPrecision:d,truncate_to_string:o,truncate:(e,t=0)=>parseFloat(o(e,t)),precisionConstants:s,ROUND:0,TRUNCATE:1,ROUND_UP:2,ROUND_DOWN:3,DECIMAL_PLACES:0,SIGNIFICANT_DIGITS:1,TICK_SIZE:2,NO_PADDING:0,PAD_WITH_ZERO:1}},function(e,t){e.exports.linebrk=function(e,t){for(var i="",s=0;s+t<e.length;)i+=e.substring(s,s+t)+"\n",s+=t;return i+e.substring(s,e.length)},e.exports.get32IntFromBuffer=function(e,t){t=t||0;var i;if((i=e.length-t)>0){if(i>=4)return e.readUInt32BE(t);for(var s=0,r=t+i,a=0;r>t;r--,a+=2)s+=e[r-1]*Math.pow(16,a);return s}return NaN},e.exports._={isObject:function(e){var t=typeof e;return!!e&&("object"==t||"function"==t)},isString:function(e){return"string"==typeof e||e instanceof String},isNumber:function(e){return"number"==typeof e||!isNaN(parseFloat(e))&&isFinite(e)},omit:function(e,t){var i={};for(var s in e)e.hasOwnProperty(s)&&s!==t&&(i[s]=e[s]);return i}},e.exports.trimSurroundingText=function(e,t,i){var s=0,r=e.length,a=e.indexOf(t);a>=0&&(s=a+t.length);var o=e.indexOf(i,a);return o>=0&&(r=o),e.substring(s,r)}},function(e,t,i){"use strict";var s=t;s.inherits=function(e,t){e.super_=t;var i=function(){};i.prototype=t.prototype,e.prototype=new i,e.prototype.constructor=e},s.version="6.5.0",s.utils=i(27),s.curve=i(7),s.curves=i(67),s.ec=i(69)},function(e,t,i){(function(e){!function(e,t){"use strict";function s(e,t){if(!e)throw new Error(t||"Assertion failed")}function r(e,t){e.super_=t;var i=function(){};i.prototype=t.prototype,e.prototype=new i,e.prototype.constructor=e}function a(e,t,i){if(a.isBN(e))return e;this.negative=0,this.words=null,this.length=0,this.red=null,null!==e&&("le"!==t&&"be"!==t||(i=t,t=10),this._init(e||0,t||10,i||"be"))}var o;"object"==typeof e?e.exports=a:t.BN=a,a.BN=a,a.wordSize=26;try{o=i(62).Buffer}catch(e){}function n(e,t,i){for(var r=0,a=Math.min(e.length,i),o=0,n=t;n<a;n++){var d,c=e.charCodeAt(n)-48;r<<=4,r|=d=c>=49&&c<=54?c-49+10:c>=17&&c<=22?c-17+10:c,o|=d}return s(!(240&o),"Invalid character in "+e),r}function d(e,t,i,r){for(var a=0,o=0,n=Math.min(e.length,i),d=t;d<n;d++){var c=e.charCodeAt(d)-48;a*=r,o=c>=49?c-49+10:c>=17?c-17+10:c,s(c>=0&&o<r,"Invalid character"),a+=o}return a}function c(){return(this.red?"<BN-R: ":"<BN: ")+this.toString(16)+">"}a.isBN=function(e){return e instanceof a||null!==e&&"object"==typeof e&&e.constructor.wordSize===a.wordSize&&Array.isArray(e.words)},a.max=function(e,t){return e.cmp(t)>0?e:t},a.min=function(e,t){return e.cmp(t)<0?e:t},a.prototype._init=function(e,t,i){if("number"==typeof e)return this._initNumber(e,t,i);if("object"==typeof e)return this._initArray(e,t,i);"hex"===t&&(t=16),s(t===(0|t)&&t>=2&&t<=36);var r=0;"-"===(e=e.toString().replace(/\s+/g,""))[0]&&r++,16===t?this._parseHex(e,r):this._parseBase(e,t,r),"-"===e[0]&&(this.negative=1),this._strip(),"le"===i&&this._initArray(this.toArray(),t,i)},a.prototype._initNumber=function(e,t,i){e<0&&(this.negative=1,e=-e),e<67108864?(this.words=[67108863&e],this.length=1):e<4503599627370496?(this.words=[67108863&e,e/67108864&67108863],this.length=2):(s(e<9007199254740992),this.words=[67108863&e,e/67108864&67108863,1],this.length=3),"le"===i&&this._initArray(this.toArray(),t,i)},a.prototype._initArray=function(e,t,i){if(s("number"==typeof e.length),e.length<=0)return this.words=[0],this.length=1,this;this.length=Math.ceil(e.length/3),this.words=new Array(this.length);for(var r=0;r<this.length;r++)this.words[r]=0;var a,o,n=0;if("be"===i)for(r=e.length-1,a=0;r>=0;r-=3)o=e[r]|e[r-1]<<8|e[r-2]<<16,this.words[a]|=o<<n&67108863,this.words[a+1]=o>>>26-n&67108863,(n+=24)>=26&&(n-=26,a++);else if("le"===i)for(r=0,a=0;r<e.length;r+=3)o=e[r]|e[r+1]<<8|e[r+2]<<16,this.words[a]|=o<<n&67108863,this.words[a+1]=o>>>26-n&67108863,(n+=24)>=26&&(n-=26,a++);return this._strip()},a.prototype._parseHex=function(e,t){this.length=Math.ceil((e.length-t)/6),this.words=new Array(this.length);for(var i=0;i<this.length;i++)this.words[i]=0;var s,r,a=0;for(i=e.length-6,s=0;i>=t;i-=6)r=n(e,i,i+6),this.words[s]|=r<<a&67108863,this.words[s+1]|=r>>>26-a&4194303,(a+=24)>=26&&(a-=26,s++);i+6!==t&&(r=n(e,t,i+6),this.words[s]|=r<<a&67108863,this.words[s+1]|=r>>>26-a&4194303),this._strip()},a.prototype._parseBase=function(e,t,i){this.words=[0],this.length=1;for(var s=0,r=1;r<=67108863;r*=t)s++;s--,r=r/t|0;for(var a=e.length-i,o=a%s,n=Math.min(a,a-o)+i,c=0,h=i;h<n;h+=s)c=d(e,h,h+s,t),this.imuln(r),this.words[0]+c<67108864?this.words[0]+=c:this._iaddn(c);if(0!==o){var l=1;for(c=d(e,h,e.length,t),h=0;h<o;h++)l*=t;this.imuln(l),this.words[0]+c<67108864?this.words[0]+=c:this._iaddn(c)}},a.prototype.copy=function(e){e.words=new Array(this.length);for(var t=0;t<this.length;t++)e.words[t]=this.words[t];e.length=this.length,e.negative=this.negative,e.red=this.red},a.prototype._move=function(e){e.words=this.words,e.length=this.length,e.negative=this.negative,e.red=this.red},a.prototype.clone=function(){var e=new a(null);return this.copy(e),e},a.prototype._expand=function(e){for(;this.length<e;)this.words[this.length++]=0;return this},a.prototype._strip=function(){for(;this.length>1&&0===this.words[this.length-1];)this.length--;return this._normSign()},a.prototype._normSign=function(){return 1===this.length&&0===this.words[0]&&(this.negative=0),this},"undefined"!=typeof Symbol&&"function"==typeof Symbol.for?a.prototype[Symbol.for("nodejs.util.inspect.custom")]=c:a.prototype.inspect=c;var h=["","0","00","000","0000","00000","000000","0000000","00000000","000000000","0000000000","00000000000","000000000000","0000000000000","00000000000000","000000000000000","0000000000000000","00000000000000000","000000000000000000","0000000000000000000","00000000000000000000","000000000000000000000","0000000000000000000000","00000000000000000000000","000000000000000000000000","0000000000000000000000000"],l=[0,0,25,16,12,11,10,9,8,8,7,7,7,7,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5],u=[0,0,33554432,43046721,16777216,48828125,60466176,40353607,16777216,43046721,1e7,19487171,35831808,62748517,7529536,11390625,16777216,24137569,34012224,47045881,64e6,4084101,5153632,6436343,7962624,9765625,11881376,14348907,17210368,20511149,243e5,28629151,33554432,39135393,45435424,52521875,60466176];a.prototype.toString=function(e,t){var i;if(t=0|t||1,16===(e=e||10)||"hex"===e){i="";for(var r=0,a=0,o=0;o<this.length;o++){var n=this.words[o],d=(16777215&(n<<r|a)).toString(16);i=0!==(a=n>>>24-r&16777215)||o!==this.length-1?h[6-d.length]+d+i:d+i,(r+=2)>=26&&(r-=26,o--)}for(0!==a&&(i=a.toString(16)+i);i.length%t!=0;)i="0"+i;return 0!==this.negative&&(i="-"+i),i}if(e===(0|e)&&e>=2&&e<=36){var c=l[e],f=u[e];i="";var p=this.clone();for(p.negative=0;!p.isZero();){var m=p.modrn(f).toString(e);i=(p=p.idivn(f)).isZero()?m+i:h[c-m.length]+m+i}for(this.isZero()&&(i="0"+i);i.length%t!=0;)i="0"+i;return 0!==this.negative&&(i="-"+i),i}s(!1,"Base should be between 2 and 36")},a.prototype.toNumber=function(){var e=this.words[0];return 2===this.length?e+=67108864*this.words[1]:3===this.length&&1===this.words[2]?e+=4503599627370496+67108864*this.words[1]:this.length>2&&s(!1,"Number can only safely store up to 53 bits"),0!==this.negative?-e:e},a.prototype.toJSON=function(){return this.toString(16,2)},o&&(a.prototype.toBuffer=function(e,t){return this.toArrayLike(o,e,t)}),a.prototype.toArray=function(e,t){return this.toArrayLike(Array,e,t)};function f(e,t,i){i.negative=t.negative^e.negative;var s=e.length+t.length|0;i.length=s,s=s-1|0;var r=0|e.words[0],a=0|t.words[0],o=r*a,n=67108863&o,d=o/67108864|0;i.words[0]=n;for(var c=1;c<s;c++){for(var h=d>>>26,l=67108863&d,u=Math.min(c,t.length-1),f=Math.max(0,c-e.length+1);f<=u;f++){var p=c-f|0;h+=(o=(r=0|e.words[p])*(a=0|t.words[f])+l)/67108864|0,l=67108863&o}i.words[c]=0|l,d=0|h}return 0!==d?i.words[c]=0|d:i.length--,i._strip()}a.prototype.toArrayLike=function(e,t,i){this._strip();var r=this.byteLength(),a=i||Math.max(1,r);s(r<=a,"byte array longer than desired length"),s(a>0,"Requested array length <= 0");var o=function(e,t){return e.allocUnsafe?e.allocUnsafe(t):new e(t)}(e,a);return this["_toArrayLike"+("le"===t?"LE":"BE")](o,r),o},a.prototype._toArrayLikeLE=function(e,t){for(var i=0,s=0,r=0,a=0;r<this.length;r++){var o=this.words[r]<<a|s;e[i++]=255&o,i<e.length&&(e[i++]=o>>8&255),i<e.length&&(e[i++]=o>>16&255),6===a?(i<e.length&&(e[i++]=o>>24&255),s=0,a=0):(s=o>>>24,a+=2)}if(i<e.length)for(e[i++]=s;i<e.length;)e[i++]=0},a.prototype._toArrayLikeBE=function(e,t){for(var i=e.length-1,s=0,r=0,a=0;r<this.length;r++){var o=this.words[r]<<a|s;e[i--]=255&o,i>=0&&(e[i--]=o>>8&255),i>=0&&(e[i--]=o>>16&255),6===a?(i>=0&&(e[i--]=o>>24&255),s=0,a=0):(s=o>>>24,a+=2)}if(i>=0)for(e[i--]=s;i>=0;)e[i--]=0},Math.clz32?a.prototype._countBits=function(e){return 32-Math.clz32(e)}:a.prototype._countBits=function(e){var t=e,i=0;return t>=4096&&(i+=13,t>>>=13),t>=64&&(i+=7,t>>>=7),t>=8&&(i+=4,t>>>=4),t>=2&&(i+=2,t>>>=2),i+t},a.prototype._zeroBits=function(e){if(0===e)return 26;var t=e,i=0;return 0==(8191&t)&&(i+=13,t>>>=13),0==(127&t)&&(i+=7,t>>>=7),0==(15&t)&&(i+=4,t>>>=4),0==(3&t)&&(i+=2,t>>>=2),0==(1&t)&&i++,i},a.prototype.bitLength=function(){var e=this.words[this.length-1],t=this._countBits(e);return 26*(this.length-1)+t},a.prototype.zeroBits=function(){if(this.isZero())return 0;for(var e=0,t=0;t<this.length;t++){var i=this._zeroBits(this.words[t]);if(e+=i,26!==i)break}return e},a.prototype.byteLength=function(){return Math.ceil(this.bitLength()/8)},a.prototype.toTwos=function(e){return 0!==this.negative?this.abs().inotn(e).iaddn(1):this.clone()},a.prototype.fromTwos=function(e){return this.testn(e-1)?this.notn(e).iaddn(1).ineg():this.clone()},a.prototype.isNeg=function(){return 0!==this.negative},a.prototype.neg=function(){return this.clone().ineg()},a.prototype.ineg=function(){return this.isZero()||(this.negative^=1),this},a.prototype.iuor=function(e){for(;this.length<e.length;)this.words[this.length++]=0;for(var t=0;t<e.length;t++)this.words[t]=this.words[t]|e.words[t];return this._strip()},a.prototype.ior=function(e){return s(0==(this.negative|e.negative)),this.iuor(e)},a.prototype.or=function(e){return this.length>e.length?this.clone().ior(e):e.clone().ior(this)},a.prototype.uor=function(e){return this.length>e.length?this.clone().iuor(e):e.clone().iuor(this)},a.prototype.iuand=function(e){var t;t=this.length>e.length?e:this;for(var i=0;i<t.length;i++)this.words[i]=this.words[i]&e.words[i];return this.length=t.length,this._strip()},a.prototype.iand=function(e){return s(0==(this.negative|e.negative)),this.iuand(e)},a.prototype.and=function(e){return this.length>e.length?this.clone().iand(e):e.clone().iand(this)},a.prototype.uand=function(e){return this.length>e.length?this.clone().iuand(e):e.clone().iuand(this)},a.prototype.iuxor=function(e){var t,i;this.length>e.length?(t=this,i=e):(t=e,i=this);for(var s=0;s<i.length;s++)this.words[s]=t.words[s]^i.words[s];if(this!==t)for(;s<t.length;s++)this.words[s]=t.words[s];return this.length=t.length,this._strip()},a.prototype.ixor=function(e){return s(0==(this.negative|e.negative)),this.iuxor(e)},a.prototype.xor=function(e){return this.length>e.length?this.clone().ixor(e):e.clone().ixor(this)},a.prototype.uxor=function(e){return this.length>e.length?this.clone().iuxor(e):e.clone().iuxor(this)},a.prototype.inotn=function(e){s("number"==typeof e&&e>=0);var t=0|Math.ceil(e/26),i=e%26;this._expand(t),i>0&&t--;for(var r=0;r<t;r++)this.words[r]=67108863&~this.words[r];return i>0&&(this.words[r]=~this.words[r]&67108863>>26-i),this._strip()},a.prototype.notn=function(e){return this.clone().inotn(e)},a.prototype.setn=function(e,t){s("number"==typeof e&&e>=0);var i=e/26|0,r=e%26;return this._expand(i+1),this.words[i]=t?this.words[i]|1<<r:this.words[i]&~(1<<r),this._strip()},a.prototype.iadd=function(e){var t,i,s;if(0!==this.negative&&0===e.negative)return this.negative=0,t=this.isub(e),this.negative^=1,this._normSign();if(0===this.negative&&0!==e.negative)return e.negative=0,t=this.isub(e),e.negative=1,t._normSign();this.length>e.length?(i=this,s=e):(i=e,s=this);for(var r=0,a=0;a<s.length;a++)t=(0|i.words[a])+(0|s.words[a])+r,this.words[a]=67108863&t,r=t>>>26;for(;0!==r&&a<i.length;a++)t=(0|i.words[a])+r,this.words[a]=67108863&t,r=t>>>26;if(this.length=i.length,0!==r)this.words[this.length]=r,this.length++;else if(i!==this)for(;a<i.length;a++)this.words[a]=i.words[a];return this},a.prototype.add=function(e){var t;return 0!==e.negative&&0===this.negative?(e.negative=0,t=this.sub(e),e.negative^=1,t):0===e.negative&&0!==this.negative?(this.negative=0,t=e.sub(this),this.negative=1,t):this.length>e.length?this.clone().iadd(e):e.clone().iadd(this)},a.prototype.isub=function(e){if(0!==e.negative){e.negative=0;var t=this.iadd(e);return e.negative=1,t._normSign()}if(0!==this.negative)return this.negative=0,this.iadd(e),this.negative=1,this._normSign();var i,s,r=this.cmp(e);if(0===r)return this.negative=0,this.length=1,this.words[0]=0,this;r>0?(i=this,s=e):(i=e,s=this);for(var a=0,o=0;o<s.length;o++)a=(t=(0|i.words[o])-(0|s.words[o])+a)>>26,this.words[o]=67108863&t;for(;0!==a&&o<i.length;o++)a=(t=(0|i.words[o])+a)>>26,this.words[o]=67108863&t;if(0===a&&o<i.length&&i!==this)for(;o<i.length;o++)this.words[o]=i.words[o];return this.length=Math.max(this.length,o),i!==this&&(this.negative=1),this._strip()},a.prototype.sub=function(e){return this.clone().isub(e)};var p=function(e,t,i){var s,r,a,o=e.words,n=t.words,d=i.words,c=0,h=0|o[0],l=8191&h,u=h>>>13,f=0|o[1],p=8191&f,m=f>>>13,y=0|o[2],b=8191&y,v=y>>>13,g=0|o[3],w=8191&g,k=g>>>13,T=0|o[4],O=8191&T,_=T>>>13,C=0|o[5],S=8191&C,x=C>>>13,M=0|o[6],I=8191&M,F=M>>>13,B=0|o[7],A=8191&B,E=B>>>13,P=0|o[8],q=8191&P,D=P>>>13,V=0|o[9],R=8191&V,G=V>>>13,L=0|n[0],N=8191&L,H=L>>>13,U=0|n[1],j=8191&U,K=U>>>13,X=0|n[2],z=8191&X,W=X>>>13,Y=0|n[3],Z=8191&Y,Q=Y>>>13,J=0|n[4],$=8191&J,ee=J>>>13,te=0|n[5],ie=8191&te,se=te>>>13,re=0|n[6],ae=8191&re,oe=re>>>13,ne=0|n[7],de=8191&ne,ce=ne>>>13,he=0|n[8],le=8191&he,ue=he>>>13,fe=0|n[9],pe=8191&fe,me=fe>>>13;i.negative=e.negative^t.negative,i.length=19;var ye=(c+(s=Math.imul(l,N))|0)+((8191&(r=(r=Math.imul(l,H))+Math.imul(u,N)|0))<<13)|0;c=((a=Math.imul(u,H))+(r>>>13)|0)+(ye>>>26)|0,ye&=67108863,s=Math.imul(p,N),r=(r=Math.imul(p,H))+Math.imul(m,N)|0,a=Math.imul(m,H);var be=(c+(s=s+Math.imul(l,j)|0)|0)+((8191&(r=(r=r+Math.imul(l,K)|0)+Math.imul(u,j)|0))<<13)|0;c=((a=a+Math.imul(u,K)|0)+(r>>>13)|0)+(be>>>26)|0,be&=67108863,s=Math.imul(b,N),r=(r=Math.imul(b,H))+Math.imul(v,N)|0,a=Math.imul(v,H),s=s+Math.imul(p,j)|0,r=(r=r+Math.imul(p,K)|0)+Math.imul(m,j)|0,a=a+Math.imul(m,K)|0;var ve=(c+(s=s+Math.imul(l,z)|0)|0)+((8191&(r=(r=r+Math.imul(l,W)|0)+Math.imul(u,z)|0))<<13)|0;c=((a=a+Math.imul(u,W)|0)+(r>>>13)|0)+(ve>>>26)|0,ve&=67108863,s=Math.imul(w,N),r=(r=Math.imul(w,H))+Math.imul(k,N)|0,a=Math.imul(k,H),s=s+Math.imul(b,j)|0,r=(r=r+Math.imul(b,K)|0)+Math.imul(v,j)|0,a=a+Math.imul(v,K)|0,s=s+Math.imul(p,z)|0,r=(r=r+Math.imul(p,W)|0)+Math.imul(m,z)|0,a=a+Math.imul(m,W)|0;var ge=(c+(s=s+Math.imul(l,Z)|0)|0)+((8191&(r=(r=r+Math.imul(l,Q)|0)+Math.imul(u,Z)|0))<<13)|0;c=((a=a+Math.imul(u,Q)|0)+(r>>>13)|0)+(ge>>>26)|0,ge&=67108863,s=Math.imul(O,N),r=(r=Math.imul(O,H))+Math.imul(_,N)|0,a=Math.imul(_,H),s=s+Math.imul(w,j)|0,r=(r=r+Math.imul(w,K)|0)+Math.imul(k,j)|0,a=a+Math.imul(k,K)|0,s=s+Math.imul(b,z)|0,r=(r=r+Math.imul(b,W)|0)+Math.imul(v,z)|0,a=a+Math.imul(v,W)|0,s=s+Math.imul(p,Z)|0,r=(r=r+Math.imul(p,Q)|0)+Math.imul(m,Z)|0,a=a+Math.imul(m,Q)|0;var we=(c+(s=s+Math.imul(l,$)|0)|0)+((8191&(r=(r=r+Math.imul(l,ee)|0)+Math.imul(u,$)|0))<<13)|0;c=((a=a+Math.imul(u,ee)|0)+(r>>>13)|0)+(we>>>26)|0,we&=67108863,s=Math.imul(S,N),r=(r=Math.imul(S,H))+Math.imul(x,N)|0,a=Math.imul(x,H),s=s+Math.imul(O,j)|0,r=(r=r+Math.imul(O,K)|0)+Math.imul(_,j)|0,a=a+Math.imul(_,K)|0,s=s+Math.imul(w,z)|0,r=(r=r+Math.imul(w,W)|0)+Math.imul(k,z)|0,a=a+Math.imul(k,W)|0,s=s+Math.imul(b,Z)|0,r=(r=r+Math.imul(b,Q)|0)+Math.imul(v,Z)|0,a=a+Math.imul(v,Q)|0,s=s+Math.imul(p,$)|0,r=(r=r+Math.imul(p,ee)|0)+Math.imul(m,$)|0,a=a+Math.imul(m,ee)|0;var ke=(c+(s=s+Math.imul(l,ie)|0)|0)+((8191&(r=(r=r+Math.imul(l,se)|0)+Math.imul(u,ie)|0))<<13)|0;c=((a=a+Math.imul(u,se)|0)+(r>>>13)|0)+(ke>>>26)|0,ke&=67108863,s=Math.imul(I,N),r=(r=Math.imul(I,H))+Math.imul(F,N)|0,a=Math.imul(F,H),s=s+Math.imul(S,j)|0,r=(r=r+Math.imul(S,K)|0)+Math.imul(x,j)|0,a=a+Math.imul(x,K)|0,s=s+Math.imul(O,z)|0,r=(r=r+Math.imul(O,W)|0)+Math.imul(_,z)|0,a=a+Math.imul(_,W)|0,s=s+Math.imul(w,Z)|0,r=(r=r+Math.imul(w,Q)|0)+Math.imul(k,Z)|0,a=a+Math.imul(k,Q)|0,s=s+Math.imul(b,$)|0,r=(r=r+Math.imul(b,ee)|0)+Math.imul(v,$)|0,a=a+Math.imul(v,ee)|0,s=s+Math.imul(p,ie)|0,r=(r=r+Math.imul(p,se)|0)+Math.imul(m,ie)|0,a=a+Math.imul(m,se)|0;var Te=(c+(s=s+Math.imul(l,ae)|0)|0)+((8191&(r=(r=r+Math.imul(l,oe)|0)+Math.imul(u,ae)|0))<<13)|0;c=((a=a+Math.imul(u,oe)|0)+(r>>>13)|0)+(Te>>>26)|0,Te&=67108863,s=Math.imul(A,N),r=(r=Math.imul(A,H))+Math.imul(E,N)|0,a=Math.imul(E,H),s=s+Math.imul(I,j)|0,r=(r=r+Math.imul(I,K)|0)+Math.imul(F,j)|0,a=a+Math.imul(F,K)|0,s=s+Math.imul(S,z)|0,r=(r=r+Math.imul(S,W)|0)+Math.imul(x,z)|0,a=a+Math.imul(x,W)|0,s=s+Math.imul(O,Z)|0,r=(r=r+Math.imul(O,Q)|0)+Math.imul(_,Z)|0,a=a+Math.imul(_,Q)|0,s=s+Math.imul(w,$)|0,r=(r=r+Math.imul(w,ee)|0)+Math.imul(k,$)|0,a=a+Math.imul(k,ee)|0,s=s+Math.imul(b,ie)|0,r=(r=r+Math.imul(b,se)|0)+Math.imul(v,ie)|0,a=a+Math.imul(v,se)|0,s=s+Math.imul(p,ae)|0,r=(r=r+Math.imul(p,oe)|0)+Math.imul(m,ae)|0,a=a+Math.imul(m,oe)|0;var Oe=(c+(s=s+Math.imul(l,de)|0)|0)+((8191&(r=(r=r+Math.imul(l,ce)|0)+Math.imul(u,de)|0))<<13)|0;c=((a=a+Math.imul(u,ce)|0)+(r>>>13)|0)+(Oe>>>26)|0,Oe&=67108863,s=Math.imul(q,N),r=(r=Math.imul(q,H))+Math.imul(D,N)|0,a=Math.imul(D,H),s=s+Math.imul(A,j)|0,r=(r=r+Math.imul(A,K)|0)+Math.imul(E,j)|0,a=a+Math.imul(E,K)|0,s=s+Math.imul(I,z)|0,r=(r=r+Math.imul(I,W)|0)+Math.imul(F,z)|0,a=a+Math.imul(F,W)|0,s=s+Math.imul(S,Z)|0,r=(r=r+Math.imul(S,Q)|0)+Math.imul(x,Z)|0,a=a+Math.imul(x,Q)|0,s=s+Math.imul(O,$)|0,r=(r=r+Math.imul(O,ee)|0)+Math.imul(_,$)|0,a=a+Math.imul(_,ee)|0,s=s+Math.imul(w,ie)|0,r=(r=r+Math.imul(w,se)|0)+Math.imul(k,ie)|0,a=a+Math.imul(k,se)|0,s=s+Math.imul(b,ae)|0,r=(r=r+Math.imul(b,oe)|0)+Math.imul(v,ae)|0,a=a+Math.imul(v,oe)|0,s=s+Math.imul(p,de)|0,r=(r=r+Math.imul(p,ce)|0)+Math.imul(m,de)|0,a=a+Math.imul(m,ce)|0;var _e=(c+(s=s+Math.imul(l,le)|0)|0)+((8191&(r=(r=r+Math.imul(l,ue)|0)+Math.imul(u,le)|0))<<13)|0;c=((a=a+Math.imul(u,ue)|0)+(r>>>13)|0)+(_e>>>26)|0,_e&=67108863,s=Math.imul(R,N),r=(r=Math.imul(R,H))+Math.imul(G,N)|0,a=Math.imul(G,H),s=s+Math.imul(q,j)|0,r=(r=r+Math.imul(q,K)|0)+Math.imul(D,j)|0,a=a+Math.imul(D,K)|0,s=s+Math.imul(A,z)|0,r=(r=r+Math.imul(A,W)|0)+Math.imul(E,z)|0,a=a+Math.imul(E,W)|0,s=s+Math.imul(I,Z)|0,r=(r=r+Math.imul(I,Q)|0)+Math.imul(F,Z)|0,a=a+Math.imul(F,Q)|0,s=s+Math.imul(S,$)|0,r=(r=r+Math.imul(S,ee)|0)+Math.imul(x,$)|0,a=a+Math.imul(x,ee)|0,s=s+Math.imul(O,ie)|0,r=(r=r+Math.imul(O,se)|0)+Math.imul(_,ie)|0,a=a+Math.imul(_,se)|0,s=s+Math.imul(w,ae)|0,r=(r=r+Math.imul(w,oe)|0)+Math.imul(k,ae)|0,a=a+Math.imul(k,oe)|0,s=s+Math.imul(b,de)|0,r=(r=r+Math.imul(b,ce)|0)+Math.imul(v,de)|0,a=a+Math.imul(v,ce)|0,s=s+Math.imul(p,le)|0,r=(r=r+Math.imul(p,ue)|0)+Math.imul(m,le)|0,a=a+Math.imul(m,ue)|0;var Ce=(c+(s=s+Math.imul(l,pe)|0)|0)+((8191&(r=(r=r+Math.imul(l,me)|0)+Math.imul(u,pe)|0))<<13)|0;c=((a=a+Math.imul(u,me)|0)+(r>>>13)|0)+(Ce>>>26)|0,Ce&=67108863,s=Math.imul(R,j),r=(r=Math.imul(R,K))+Math.imul(G,j)|0,a=Math.imul(G,K),s=s+Math.imul(q,z)|0,r=(r=r+Math.imul(q,W)|0)+Math.imul(D,z)|0,a=a+Math.imul(D,W)|0,s=s+Math.imul(A,Z)|0,r=(r=r+Math.imul(A,Q)|0)+Math.imul(E,Z)|0,a=a+Math.imul(E,Q)|0,s=s+Math.imul(I,$)|0,r=(r=r+Math.imul(I,ee)|0)+Math.imul(F,$)|0,a=a+Math.imul(F,ee)|0,s=s+Math.imul(S,ie)|0,r=(r=r+Math.imul(S,se)|0)+Math.imul(x,ie)|0,a=a+Math.imul(x,se)|0,s=s+Math.imul(O,ae)|0,r=(r=r+Math.imul(O,oe)|0)+Math.imul(_,ae)|0,a=a+Math.imul(_,oe)|0,s=s+Math.imul(w,de)|0,r=(r=r+Math.imul(w,ce)|0)+Math.imul(k,de)|0,a=a+Math.imul(k,ce)|0,s=s+Math.imul(b,le)|0,r=(r=r+Math.imul(b,ue)|0)+Math.imul(v,le)|0,a=a+Math.imul(v,ue)|0;var Se=(c+(s=s+Math.imul(p,pe)|0)|0)+((8191&(r=(r=r+Math.imul(p,me)|0)+Math.imul(m,pe)|0))<<13)|0;c=((a=a+Math.imul(m,me)|0)+(r>>>13)|0)+(Se>>>26)|0,Se&=67108863,s=Math.imul(R,z),r=(r=Math.imul(R,W))+Math.imul(G,z)|0,a=Math.imul(G,W),s=s+Math.imul(q,Z)|0,r=(r=r+Math.imul(q,Q)|0)+Math.imul(D,Z)|0,a=a+Math.imul(D,Q)|0,s=s+Math.imul(A,$)|0,r=(r=r+Math.imul(A,ee)|0)+Math.imul(E,$)|0,a=a+Math.imul(E,ee)|0,s=s+Math.imul(I,ie)|0,r=(r=r+Math.imul(I,se)|0)+Math.imul(F,ie)|0,a=a+Math.imul(F,se)|0,s=s+Math.imul(S,ae)|0,r=(r=r+Math.imul(S,oe)|0)+Math.imul(x,ae)|0,a=a+Math.imul(x,oe)|0,s=s+Math.imul(O,de)|0,r=(r=r+Math.imul(O,ce)|0)+Math.imul(_,de)|0,a=a+Math.imul(_,ce)|0,s=s+Math.imul(w,le)|0,r=(r=r+Math.imul(w,ue)|0)+Math.imul(k,le)|0,a=a+Math.imul(k,ue)|0;var xe=(c+(s=s+Math.imul(b,pe)|0)|0)+((8191&(r=(r=r+Math.imul(b,me)|0)+Math.imul(v,pe)|0))<<13)|0;c=((a=a+Math.imul(v,me)|0)+(r>>>13)|0)+(xe>>>26)|0,xe&=67108863,s=Math.imul(R,Z),r=(r=Math.imul(R,Q))+Math.imul(G,Z)|0,a=Math.imul(G,Q),s=s+Math.imul(q,$)|0,r=(r=r+Math.imul(q,ee)|0)+Math.imul(D,$)|0,a=a+Math.imul(D,ee)|0,s=s+Math.imul(A,ie)|0,r=(r=r+Math.imul(A,se)|0)+Math.imul(E,ie)|0,a=a+Math.imul(E,se)|0,s=s+Math.imul(I,ae)|0,r=(r=r+Math.imul(I,oe)|0)+Math.imul(F,ae)|0,a=a+Math.imul(F,oe)|0,s=s+Math.imul(S,de)|0,r=(r=r+Math.imul(S,ce)|0)+Math.imul(x,de)|0,a=a+Math.imul(x,ce)|0,s=s+Math.imul(O,le)|0,r=(r=r+Math.imul(O,ue)|0)+Math.imul(_,le)|0,a=a+Math.imul(_,ue)|0;var Me=(c+(s=s+Math.imul(w,pe)|0)|0)+((8191&(r=(r=r+Math.imul(w,me)|0)+Math.imul(k,pe)|0))<<13)|0;c=((a=a+Math.imul(k,me)|0)+(r>>>13)|0)+(Me>>>26)|0,Me&=67108863,s=Math.imul(R,$),r=(r=Math.imul(R,ee))+Math.imul(G,$)|0,a=Math.imul(G,ee),s=s+Math.imul(q,ie)|0,r=(r=r+Math.imul(q,se)|0)+Math.imul(D,ie)|0,a=a+Math.imul(D,se)|0,s=s+Math.imul(A,ae)|0,r=(r=r+Math.imul(A,oe)|0)+Math.imul(E,ae)|0,a=a+Math.imul(E,oe)|0,s=s+Math.imul(I,de)|0,r=(r=r+Math.imul(I,ce)|0)+Math.imul(F,de)|0,a=a+Math.imul(F,ce)|0,s=s+Math.imul(S,le)|0,r=(r=r+Math.imul(S,ue)|0)+Math.imul(x,le)|0,a=a+Math.imul(x,ue)|0;var Ie=(c+(s=s+Math.imul(O,pe)|0)|0)+((8191&(r=(r=r+Math.imul(O,me)|0)+Math.imul(_,pe)|0))<<13)|0;c=((a=a+Math.imul(_,me)|0)+(r>>>13)|0)+(Ie>>>26)|0,Ie&=67108863,s=Math.imul(R,ie),r=(r=Math.imul(R,se))+Math.imul(G,ie)|0,a=Math.imul(G,se),s=s+Math.imul(q,ae)|0,r=(r=r+Math.imul(q,oe)|0)+Math.imul(D,ae)|0,a=a+Math.imul(D,oe)|0,s=s+Math.imul(A,de)|0,r=(r=r+Math.imul(A,ce)|0)+Math.imul(E,de)|0,a=a+Math.imul(E,ce)|0,s=s+Math.imul(I,le)|0,r=(r=r+Math.imul(I,ue)|0)+Math.imul(F,le)|0,a=a+Math.imul(F,ue)|0;var Fe=(c+(s=s+Math.imul(S,pe)|0)|0)+((8191&(r=(r=r+Math.imul(S,me)|0)+Math.imul(x,pe)|0))<<13)|0;c=((a=a+Math.imul(x,me)|0)+(r>>>13)|0)+(Fe>>>26)|0,Fe&=67108863,s=Math.imul(R,ae),r=(r=Math.imul(R,oe))+Math.imul(G,ae)|0,a=Math.imul(G,oe),s=s+Math.imul(q,de)|0,r=(r=r+Math.imul(q,ce)|0)+Math.imul(D,de)|0,a=a+Math.imul(D,ce)|0,s=s+Math.imul(A,le)|0,r=(r=r+Math.imul(A,ue)|0)+Math.imul(E,le)|0,a=a+Math.imul(E,ue)|0;var Be=(c+(s=s+Math.imul(I,pe)|0)|0)+((8191&(r=(r=r+Math.imul(I,me)|0)+Math.imul(F,pe)|0))<<13)|0;c=((a=a+Math.imul(F,me)|0)+(r>>>13)|0)+(Be>>>26)|0,Be&=67108863,s=Math.imul(R,de),r=(r=Math.imul(R,ce))+Math.imul(G,de)|0,a=Math.imul(G,ce),s=s+Math.imul(q,le)|0,r=(r=r+Math.imul(q,ue)|0)+Math.imul(D,le)|0,a=a+Math.imul(D,ue)|0;var Ae=(c+(s=s+Math.imul(A,pe)|0)|0)+((8191&(r=(r=r+Math.imul(A,me)|0)+Math.imul(E,pe)|0))<<13)|0;c=((a=a+Math.imul(E,me)|0)+(r>>>13)|0)+(Ae>>>26)|0,Ae&=67108863,s=Math.imul(R,le),r=(r=Math.imul(R,ue))+Math.imul(G,le)|0,a=Math.imul(G,ue);var Ee=(c+(s=s+Math.imul(q,pe)|0)|0)+((8191&(r=(r=r+Math.imul(q,me)|0)+Math.imul(D,pe)|0))<<13)|0;c=((a=a+Math.imul(D,me)|0)+(r>>>13)|0)+(Ee>>>26)|0,Ee&=67108863;var Pe=(c+(s=Math.imul(R,pe))|0)+((8191&(r=(r=Math.imul(R,me))+Math.imul(G,pe)|0))<<13)|0;return c=((a=Math.imul(G,me))+(r>>>13)|0)+(Pe>>>26)|0,Pe&=67108863,d[0]=ye,d[1]=be,d[2]=ve,d[3]=ge,d[4]=we,d[5]=ke,d[6]=Te,d[7]=Oe,d[8]=_e,d[9]=Ce,d[10]=Se,d[11]=xe,d[12]=Me,d[13]=Ie,d[14]=Fe,d[15]=Be,d[16]=Ae,d[17]=Ee,d[18]=Pe,0!==c&&(d[19]=c,i.length++),i};function m(e,t,i){i.negative=t.negative^e.negative,i.length=e.length+t.length;for(var s=0,r=0,a=0;a<i.length-1;a++){var o=r;r=0;for(var n=67108863&s,d=Math.min(a,t.length-1),c=Math.max(0,a-e.length+1);c<=d;c++){var h=a-c,l=(0|e.words[h])*(0|t.words[c]),u=67108863&l;n=67108863&(u=u+n|0),r+=(o=(o=o+(l/67108864|0)|0)+(u>>>26)|0)>>>26,o&=67108863}i.words[a]=n,s=o,o=r}return 0!==s?i.words[a]=s:i.length--,i._strip()}function y(e,t,i){return m(e,t,i)}function b(e,t){this.x=e,this.y=t}Math.imul||(p=f),a.prototype.mulTo=function(e,t){var i=this.length+e.length;return 10===this.length&&10===e.length?p(this,e,t):i<63?f(this,e,t):i<1024?m(this,e,t):y(this,e,t)},b.prototype.makeRBT=function(e){for(var t=new Array(e),i=a.prototype._countBits(e)-1,s=0;s<e;s++)t[s]=this.revBin(s,i,e);return t},b.prototype.revBin=function(e,t,i){if(0===e||e===i-1)return e;for(var s=0,r=0;r<t;r++)s|=(1&e)<<t-r-1,e>>=1;return s},b.prototype.permute=function(e,t,i,s,r,a){for(var o=0;o<a;o++)s[o]=t[e[o]],r[o]=i[e[o]]},b.prototype.transform=function(e,t,i,s,r,a){this.permute(a,e,t,i,s,r);for(var o=1;o<r;o<<=1)for(var n=o<<1,d=Math.cos(2*Math.PI/n),c=Math.sin(2*Math.PI/n),h=0;h<r;h+=n)for(var l=d,u=c,f=0;f<o;f++){var p=i[h+f],m=s[h+f],y=i[h+f+o],b=s[h+f+o],v=l*y-u*b;b=l*b+u*y,y=v,i[h+f]=p+y,s[h+f]=m+b,i[h+f+o]=p-y,s[h+f+o]=m-b,f!==n&&(v=d*l-c*u,u=d*u+c*l,l=v)}},b.prototype.guessLen13b=function(e,t){var i=1|Math.max(t,e),s=1&i,r=0;for(i=i/2|0;i;i>>>=1)r++;return 1<<r+1+s},b.prototype.conjugate=function(e,t,i){if(!(i<=1))for(var s=0;s<i/2;s++){var r=e[s];e[s]=e[i-s-1],e[i-s-1]=r,r=t[s],t[s]=-t[i-s-1],t[i-s-1]=-r}},b.prototype.normalize13b=function(e,t){for(var i=0,s=0;s<t/2;s++){var r=8192*Math.round(e[2*s+1]/t)+Math.round(e[2*s]/t)+i;e[s]=67108863&r,i=r<67108864?0:r/67108864|0}return e},b.prototype.convert13b=function(e,t,i,r){for(var a=0,o=0;o<t;o++)a+=0|e[o],i[2*o]=8191&a,a>>>=13,i[2*o+1]=8191&a,a>>>=13;for(o=2*t;o<r;++o)i[o]=0;s(0===a),s(0==(-8192&a))},b.prototype.stub=function(e){for(var t=new Array(e),i=0;i<e;i++)t[i]=0;return t},b.prototype.mulp=function(e,t,i){var s=2*this.guessLen13b(e.length,t.length),r=this.makeRBT(s),a=this.stub(s),o=new Array(s),n=new Array(s),d=new Array(s),c=new Array(s),h=new Array(s),l=new Array(s),u=i.words;u.length=s,this.convert13b(e.words,e.length,o,s),this.convert13b(t.words,t.length,c,s),this.transform(o,a,n,d,s,r),this.transform(c,a,h,l,s,r);for(var f=0;f<s;f++){var p=n[f]*h[f]-d[f]*l[f];d[f]=n[f]*l[f]+d[f]*h[f],n[f]=p}return this.conjugate(n,d,s),this.transform(n,d,u,a,s,r),this.conjugate(u,a,s),this.normalize13b(u,s),i.negative=e.negative^t.negative,i.length=e.length+t.length,i._strip()},a.prototype.mul=function(e){var t=new a(null);return t.words=new Array(this.length+e.length),this.mulTo(e,t)},a.prototype.mulf=function(e){var t=new a(null);return t.words=new Array(this.length+e.length),y(this,e,t)},a.prototype.imul=function(e){return this.clone().mulTo(e,this)},a.prototype.imuln=function(e){var t=e<0;t&&(e=-e),s("number"==typeof e),s(e<67108864);for(var i=0,r=0;r<this.length;r++){var a=(0|this.words[r])*e,o=(67108863&a)+(67108863&i);i>>=26,i+=a/67108864|0,i+=o>>>26,this.words[r]=67108863&o}return 0!==i&&(this.words[r]=i,this.length++),t?this.ineg():this},a.prototype.muln=function(e){return this.clone().imuln(e)},a.prototype.sqr=function(){return this.mul(this)},a.prototype.isqr=function(){return this.imul(this.clone())},a.prototype.pow=function(e){var t=function(e){for(var t=new Array(e.bitLength()),i=0;i<t.length;i++){var s=i/26|0,r=i%26;t[i]=e.words[s]>>>r&1}return t}(e);if(0===t.length)return new a(1);for(var i=this,s=0;s<t.length&&0===t[s];s++,i=i.sqr());if(++s<t.length)for(var r=i.sqr();s<t.length;s++,r=r.sqr())0!==t[s]&&(i=i.mul(r));return i},a.prototype.iushln=function(e){s("number"==typeof e&&e>=0);var t,i=e%26,r=(e-i)/26,a=67108863>>>26-i<<26-i;if(0!==i){var o=0;for(t=0;t<this.length;t++){var n=this.words[t]&a,d=(0|this.words[t])-n<<i;this.words[t]=d|o,o=n>>>26-i}o&&(this.words[t]=o,this.length++)}if(0!==r){for(t=this.length-1;t>=0;t--)this.words[t+r]=this.words[t];for(t=0;t<r;t++)this.words[t]=0;this.length+=r}return this._strip()},a.prototype.ishln=function(e){return s(0===this.negative),this.iushln(e)},a.prototype.iushrn=function(e,t,i){var r;s("number"==typeof e&&e>=0),r=t?(t-t%26)/26:0;var a=e%26,o=Math.min((e-a)/26,this.length),n=67108863^67108863>>>a<<a,d=i;if(r-=o,r=Math.max(0,r),d){for(var c=0;c<o;c++)d.words[c]=this.words[c];d.length=o}if(0===o);else if(this.length>o)for(this.length-=o,c=0;c<this.length;c++)this.words[c]=this.words[c+o];else this.words[0]=0,this.length=1;var h=0;for(c=this.length-1;c>=0&&(0!==h||c>=r);c--){var l=0|this.words[c];this.words[c]=h<<26-a|l>>>a,h=l&n}return d&&0!==h&&(d.words[d.length++]=h),0===this.length&&(this.words[0]=0,this.length=1),this._strip()},a.prototype.ishrn=function(e,t,i){return s(0===this.negative),this.iushrn(e,t,i)},a.prototype.shln=function(e){return this.clone().ishln(e)},a.prototype.ushln=function(e){return this.clone().iushln(e)},a.prototype.shrn=function(e){return this.clone().ishrn(e)},a.prototype.ushrn=function(e){return this.clone().iushrn(e)},a.prototype.testn=function(e){s("number"==typeof e&&e>=0);var t=e%26,i=(e-t)/26,r=1<<t;return!(this.length<=i)&&!!(this.words[i]&r)},a.prototype.imaskn=function(e){s("number"==typeof e&&e>=0);var t=e%26,i=(e-t)/26;if(s(0===this.negative,"imaskn works only with positive numbers"),this.length<=i)return this;if(0!==t&&i++,this.length=Math.min(i,this.length),0!==t){var r=67108863^67108863>>>t<<t;this.words[this.length-1]&=r}return this._strip()},a.prototype.maskn=function(e){return this.clone().imaskn(e)},a.prototype.iaddn=function(e){return s("number"==typeof e),s(e<67108864),e<0?this.isubn(-e):0!==this.negative?1===this.length&&(0|this.words[0])<=e?(this.words[0]=e-(0|this.words[0]),this.negative=0,this):(this.negative=0,this.isubn(e),this.negative=1,this):this._iaddn(e)},a.prototype._iaddn=function(e){this.words[0]+=e;for(var t=0;t<this.length&&this.words[t]>=67108864;t++)this.words[t]-=67108864,t===this.length-1?this.words[t+1]=1:this.words[t+1]++;return this.length=Math.max(this.length,t+1),this},a.prototype.isubn=function(e){if(s("number"==typeof e),s(e<67108864),e<0)return this.iaddn(-e);if(0!==this.negative)return this.negative=0,this.iaddn(e),this.negative=1,this;if(this.words[0]-=e,1===this.length&&this.words[0]<0)this.words[0]=-this.words[0],this.negative=1;else for(var t=0;t<this.length&&this.words[t]<0;t++)this.words[t]+=67108864,this.words[t+1]-=1;return this._strip()},a.prototype.addn=function(e){return this.clone().iaddn(e)},a.prototype.subn=function(e){return this.clone().isubn(e)},a.prototype.iabs=function(){return this.negative=0,this},a.prototype.abs=function(){return this.clone().iabs()},a.prototype._ishlnsubmul=function(e,t,i){var r,a,o=e.length+i;this._expand(o);var n=0;for(r=0;r<e.length;r++){a=(0|this.words[r+i])+n;var d=(0|e.words[r])*t;n=((a-=67108863&d)>>26)-(d/67108864|0),this.words[r+i]=67108863&a}for(;r<this.length-i;r++)n=(a=(0|this.words[r+i])+n)>>26,this.words[r+i]=67108863&a;if(0===n)return this._strip();for(s(-1===n),n=0,r=0;r<this.length;r++)n=(a=-(0|this.words[r])+n)>>26,this.words[r]=67108863&a;return this.negative=1,this._strip()},a.prototype._wordDiv=function(e,t){var i=(this.length,e.length),s=this.clone(),r=e,o=0|r.words[r.length-1];0!==(i=26-this._countBits(o))&&(r=r.ushln(i),s.iushln(i),o=0|r.words[r.length-1]);var n,d=s.length-r.length;if("mod"!==t){(n=new a(null)).length=d+1,n.words=new Array(n.length);for(var c=0;c<n.length;c++)n.words[c]=0}var h=s.clone()._ishlnsubmul(r,1,d);0===h.negative&&(s=h,n&&(n.words[d]=1));for(var l=d-1;l>=0;l--){var u=67108864*(0|s.words[r.length+l])+(0|s.words[r.length+l-1]);for(u=Math.min(u/o|0,67108863),s._ishlnsubmul(r,u,l);0!==s.negative;)u--,s.negative=0,s._ishlnsubmul(r,1,l),s.isZero()||(s.negative^=1);n&&(n.words[l]=u)}return n&&n._strip(),s._strip(),"div"!==t&&0!==i&&s.iushrn(i),{div:n||null,mod:s}},a.prototype.divmod=function(e,t,i){return s(!e.isZero()),this.isZero()?{div:new a(0),mod:new a(0)}:0!==this.negative&&0===e.negative?(n=this.neg().divmod(e,t),"mod"!==t&&(r=n.div.neg()),"div"!==t&&(o=n.mod.neg(),i&&0!==o.negative&&o.iadd(e)),{div:r,mod:o}):0===this.negative&&0!==e.negative?(n=this.divmod(e.neg(),t),"mod"!==t&&(r=n.div.neg()),{div:r,mod:n.mod}):0!=(this.negative&e.negative)?(n=this.neg().divmod(e.neg(),t),"div"!==t&&(o=n.mod.neg(),i&&0!==o.negative&&o.isub(e)),{div:n.div,mod:o}):e.length>this.length||this.cmp(e)<0?{div:new a(0),mod:this}:1===e.length?"div"===t?{div:this.divn(e.words[0]),mod:null}:"mod"===t?{div:null,mod:new a(this.modrn(e.words[0]))}:{div:this.divn(e.words[0]),mod:new a(this.modrn(e.words[0]))}:this._wordDiv(e,t);var r,o,n},a.prototype.div=function(e){return this.divmod(e,"div",!1).div},a.prototype.mod=function(e){return this.divmod(e,"mod",!1).mod},a.prototype.umod=function(e){return this.divmod(e,"mod",!0).mod},a.prototype.divRound=function(e){var t=this.divmod(e);if(t.mod.isZero())return t.div;var i=0!==t.div.negative?t.mod.isub(e):t.mod,s=e.ushrn(1),r=e.andln(1),a=i.cmp(s);return a<0||1===r&&0===a?t.div:0!==t.div.negative?t.div.isubn(1):t.div.iaddn(1)},a.prototype.modrn=function(e){var t=e<0;t&&(e=-e),s(e<=67108863);for(var i=(1<<26)%e,r=0,a=this.length-1;a>=0;a--)r=(i*r+(0|this.words[a]))%e;return t?-r:r},a.prototype.modn=function(e){return this.modrn(e)},a.prototype.idivn=function(e){var t=e<0;t&&(e=-e),s(e<=67108863);for(var i=0,r=this.length-1;r>=0;r--){var a=(0|this.words[r])+67108864*i;this.words[r]=a/e|0,i=a%e}return this._strip(),t?this.ineg():this},a.prototype.divn=function(e){return this.clone().idivn(e)},a.prototype.egcd=function(e){s(0===e.negative),s(!e.isZero());var t=this,i=e.clone();t=0!==t.negative?t.umod(e):t.clone();for(var r=new a(1),o=new a(0),n=new a(0),d=new a(1),c=0;t.isEven()&&i.isEven();)t.iushrn(1),i.iushrn(1),++c;for(var h=i.clone(),l=t.clone();!t.isZero();){for(var u=0,f=1;0==(t.words[0]&f)&&u<26;++u,f<<=1);if(u>0)for(t.iushrn(u);u-- >0;)(r.isOdd()||o.isOdd())&&(r.iadd(h),o.isub(l)),r.iushrn(1),o.iushrn(1);for(var p=0,m=1;0==(i.words[0]&m)&&p<26;++p,m<<=1);if(p>0)for(i.iushrn(p);p-- >0;)(n.isOdd()||d.isOdd())&&(n.iadd(h),d.isub(l)),n.iushrn(1),d.iushrn(1);t.cmp(i)>=0?(t.isub(i),r.isub(n),o.isub(d)):(i.isub(t),n.isub(r),d.isub(o))}return{a:n,b:d,gcd:i.iushln(c)}},a.prototype._invmp=function(e){s(0===e.negative),s(!e.isZero());var t=this,i=e.clone();t=0!==t.negative?t.umod(e):t.clone();for(var r,o=new a(1),n=new a(0),d=i.clone();t.cmpn(1)>0&&i.cmpn(1)>0;){for(var c=0,h=1;0==(t.words[0]&h)&&c<26;++c,h<<=1);if(c>0)for(t.iushrn(c);c-- >0;)o.isOdd()&&o.iadd(d),o.iushrn(1);for(var l=0,u=1;0==(i.words[0]&u)&&l<26;++l,u<<=1);if(l>0)for(i.iushrn(l);l-- >0;)n.isOdd()&&n.iadd(d),n.iushrn(1);t.cmp(i)>=0?(t.isub(i),o.isub(n)):(i.isub(t),n.isub(o))}return(r=0===t.cmpn(1)?o:n).cmpn(0)<0&&r.iadd(e),r},a.prototype.gcd=function(e){if(this.isZero())return e.abs();if(e.isZero())return this.abs();var t=this.clone(),i=e.clone();t.negative=0,i.negative=0;for(var s=0;t.isEven()&&i.isEven();s++)t.iushrn(1),i.iushrn(1);for(;;){for(;t.isEven();)t.iushrn(1);for(;i.isEven();)i.iushrn(1);var r=t.cmp(i);if(r<0){var a=t;t=i,i=a}else if(0===r||0===i.cmpn(1))break;t.isub(i)}return i.iushln(s)},a.prototype.invm=function(e){return this.egcd(e).a.umod(e)},a.prototype.isEven=function(){return 0==(1&this.words[0])},a.prototype.isOdd=function(){return 1==(1&this.words[0])},a.prototype.andln=function(e){return this.words[0]&e},a.prototype.bincn=function(e){s("number"==typeof e);var t=e%26,i=(e-t)/26,r=1<<t;if(this.length<=i)return this._expand(i+1),this.words[i]|=r,this;for(var a=r,o=i;0!==a&&o<this.length;o++){var n=0|this.words[o];a=(n+=a)>>>26,n&=67108863,this.words[o]=n}return 0!==a&&(this.words[o]=a,this.length++),this},a.prototype.isZero=function(){return 1===this.length&&0===this.words[0]},a.prototype.cmpn=function(e){var t,i=e<0;if(0!==this.negative&&!i)return-1;if(0===this.negative&&i)return 1;if(this._strip(),this.length>1)t=1;else{i&&(e=-e),s(e<=67108863,"Number is too big");var r=0|this.words[0];t=r===e?0:r<e?-1:1}return 0!==this.negative?0|-t:t},a.prototype.cmp=function(e){if(0!==this.negative&&0===e.negative)return-1;if(0===this.negative&&0!==e.negative)return 1;var t=this.ucmp(e);return 0!==this.negative?0|-t:t},a.prototype.ucmp=function(e){if(this.length>e.length)return 1;if(this.length<e.length)return-1;for(var t=0,i=this.length-1;i>=0;i--){var s=0|this.words[i],r=0|e.words[i];if(s!==r){s<r?t=-1:s>r&&(t=1);break}}return t},a.prototype.gtn=function(e){return 1===this.cmpn(e)},a.prototype.gt=function(e){return 1===this.cmp(e)},a.prototype.gten=function(e){return this.cmpn(e)>=0},a.prototype.gte=function(e){return this.cmp(e)>=0},a.prototype.ltn=function(e){return-1===this.cmpn(e)},a.prototype.lt=function(e){return-1===this.cmp(e)},a.prototype.lten=function(e){return this.cmpn(e)<=0},a.prototype.lte=function(e){return this.cmp(e)<=0},a.prototype.eqn=function(e){return 0===this.cmpn(e)},a.prototype.eq=function(e){return 0===this.cmp(e)},a.red=function(e){return new _(e)},a.prototype.toRed=function(e){return s(!this.red,"Already a number in reduction context"),s(0===this.negative,"red works only with positives"),e.convertTo(this)._forceRed(e)},a.prototype.fromRed=function(){return s(this.red,"fromRed works only with numbers in reduction context"),this.red.convertFrom(this)},a.prototype._forceRed=function(e){return this.red=e,this},a.prototype.forceRed=function(e){return s(!this.red,"Already a number in reduction context"),this._forceRed(e)},a.prototype.redAdd=function(e){return s(this.red,"redAdd works only with red numbers"),this.red.add(this,e)},a.prototype.redIAdd=function(e){return s(this.red,"redIAdd works only with red numbers"),this.red.iadd(this,e)},a.prototype.redSub=function(e){return s(this.red,"redSub works only with red numbers"),this.red.sub(this,e)},a.prototype.redISub=function(e){return s(this.red,"redISub works only with red numbers"),this.red.isub(this,e)},a.prototype.redShl=function(e){return s(this.red,"redShl works only with red numbers"),this.red.shl(this,e)},a.prototype.redMul=function(e){return s(this.red,"redMul works only with red numbers"),this.red._verify2(this,e),this.red.mul(this,e)},a.prototype.redIMul=function(e){return s(this.red,"redMul works only with red numbers"),this.red._verify2(this,e),this.red.imul(this,e)},a.prototype.redSqr=function(){return s(this.red,"redSqr works only with red numbers"),this.red._verify1(this),this.red.sqr(this)},a.prototype.redISqr=function(){return s(this.red,"redISqr works only with red numbers"),this.red._verify1(this),this.red.isqr(this)},a.prototype.redSqrt=function(){return s(this.red,"redSqrt works only with red numbers"),this.red._verify1(this),this.red.sqrt(this)},a.prototype.redInvm=function(){return s(this.red,"redInvm works only with red numbers"),this.red._verify1(this),this.red.invm(this)},a.prototype.redNeg=function(){return s(this.red,"redNeg works only with red numbers"),this.red._verify1(this),this.red.neg(this)},a.prototype.redPow=function(e){return s(this.red&&!e.red,"redPow(normalNum)"),this.red._verify1(this),this.red.pow(this,e)};var v={k256:null,p224:null,p192:null,p25519:null};function g(e,t){this.name=e,this.p=new a(t,16),this.n=this.p.bitLength(),this.k=new a(1).iushln(this.n).isub(this.p),this.tmp=this._tmp()}function w(){g.call(this,"k256","ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")}function k(){g.call(this,"p224","ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")}function T(){g.call(this,"p192","ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")}function O(){g.call(this,"25519","7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")}function _(e){if("string"==typeof e){var t=a._prime(e);this.m=t.p,this.prime=t}else s(e.gtn(1),"modulus must be greater than 1"),this.m=e,this.prime=null}function C(e){_.call(this,e),this.shift=this.m.bitLength(),this.shift%26!=0&&(this.shift+=26-this.shift%26),this.r=new a(1).iushln(this.shift),this.r2=this.imod(this.r.sqr()),this.rinv=this.r._invmp(this.m),this.minv=this.rinv.mul(this.r).isubn(1).div(this.m),this.minv=this.minv.umod(this.r),this.minv=this.r.sub(this.minv)}g.prototype._tmp=function(){var e=new a(null);return e.words=new Array(Math.ceil(this.n/13)),e},g.prototype.ireduce=function(e){var t,i=e;do{this.split(i,this.tmp),t=(i=(i=this.imulK(i)).iadd(this.tmp)).bitLength()}while(t>this.n);var s=t<this.n?-1:i.ucmp(this.p);return 0===s?(i.words[0]=0,i.length=1):s>0?i.isub(this.p):i._strip(),i},g.prototype.split=function(e,t){e.iushrn(this.n,0,t)},g.prototype.imulK=function(e){return e.imul(this.k)},r(w,g),w.prototype.split=function(e,t){for(var i=Math.min(e.length,9),s=0;s<i;s++)t.words[s]=e.words[s];if(t.length=i,e.length<=9)return e.words[0]=0,void(e.length=1);var r=e.words[9];for(t.words[t.length++]=4194303&r,s=10;s<e.length;s++){var a=0|e.words[s];e.words[s-10]=(4194303&a)<<4|r>>>22,r=a}r>>>=22,e.words[s-10]=r,0===r&&e.length>10?e.length-=10:e.length-=9},w.prototype.imulK=function(e){e.words[e.length]=0,e.words[e.length+1]=0,e.length+=2;for(var t=0,i=0;i<e.length;i++){var s=0|e.words[i];t+=977*s,e.words[i]=67108863&t,t=64*s+(t/67108864|0)}return 0===e.words[e.length-1]&&(e.length--,0===e.words[e.length-1]&&e.length--),e},r(k,g),r(T,g),r(O,g),O.prototype.imulK=function(e){for(var t=0,i=0;i<e.length;i++){var s=19*(0|e.words[i])+t,r=67108863&s;s>>>=26,e.words[i]=r,t=s}return 0!==t&&(e.words[e.length++]=t),e},a._prime=function(e){if(v[e])return v[e];var t;if("k256"===e)t=new w;else if("p224"===e)t=new k;else if("p192"===e)t=new T;else{if("p25519"!==e)throw new Error("Unknown prime "+e);t=new O}return v[e]=t,t},_.prototype._verify1=function(e){s(0===e.negative,"red works only with positives"),s(e.red,"red works only with red numbers")},_.prototype._verify2=function(e,t){s(0==(e.negative|t.negative),"red works only with positives"),s(e.red&&e.red===t.red,"red works only with red numbers")},_.prototype.imod=function(e){return this.prime?this.prime.ireduce(e)._forceRed(this):(e.umod(this.m)._forceRed(this)._move(e),e)},_.prototype.neg=function(e){return e.isZero()?e.clone():this.m.sub(e)._forceRed(this)},_.prototype.add=function(e,t){this._verify2(e,t);var i=e.add(t);return i.cmp(this.m)>=0&&i.isub(this.m),i._forceRed(this)},_.prototype.iadd=function(e,t){this._verify2(e,t);var i=e.iadd(t);return i.cmp(this.m)>=0&&i.isub(this.m),i},_.prototype.sub=function(e,t){this._verify2(e,t);var i=e.sub(t);return i.cmpn(0)<0&&i.iadd(this.m),i._forceRed(this)},_.prototype.isub=function(e,t){this._verify2(e,t);var i=e.isub(t);return i.cmpn(0)<0&&i.iadd(this.m),i},_.prototype.shl=function(e,t){return this._verify1(e),this.imod(e.ushln(t))},_.prototype.imul=function(e,t){return this._verify2(e,t),this.imod(e.imul(t))},_.prototype.mul=function(e,t){return this._verify2(e,t),this.imod(e.mul(t))},_.prototype.isqr=function(e){return this.imul(e,e.clone())},_.prototype.sqr=function(e){return this.mul(e,e)},_.prototype.sqrt=function(e){if(e.isZero())return e.clone();var t=this.m.andln(3);if(s(t%2==1),3===t){var i=this.m.add(new a(1)).iushrn(2);return this.pow(e,i)}for(var r=this.m.subn(1),o=0;!r.isZero()&&0===r.andln(1);)o++,r.iushrn(1);s(!r.isZero());var n=new a(1).toRed(this),d=n.redNeg(),c=this.m.subn(1).iushrn(1),h=this.m.bitLength();for(h=new a(2*h*h).toRed(this);0!==this.pow(h,c).cmp(d);)h.redIAdd(d);for(var l=this.pow(h,r),u=this.pow(e,r.addn(1).iushrn(1)),f=this.pow(e,r),p=o;0!==f.cmp(n);){for(var m=f,y=0;0!==m.cmp(n);y++)m=m.redSqr();s(y<p);var b=this.pow(l,new a(1).iushln(p-y-1));u=u.redMul(b),l=b.redSqr(),f=f.redMul(l),p=y}return u},_.prototype.invm=function(e){var t=e._invmp(this.m);return 0!==t.negative?(t.negative=0,this.imod(t).redNeg()):this.imod(t)},_.prototype.pow=function(e,t){if(t.isZero())return new a(1).toRed(this);if(0===t.cmpn(1))return e.clone();var i=new Array(16);i[0]=new a(1).toRed(this),i[1]=e;for(var s=2;s<i.length;s++)i[s]=this.mul(i[s-1],e);var r=i[0],o=0,n=0,d=t.bitLength()%26;for(0===d&&(d=26),s=t.length-1;s>=0;s--){for(var c=t.words[s],h=d-1;h>=0;h--){var l=c>>h&1;r!==i[0]&&(r=this.sqr(r)),0!==l||0!==o?(o<<=1,o|=l,(4===++n||0===s&&0===h)&&(r=this.mul(r,i[o]),n=0,o=0)):n=0}d=26}return r},_.prototype.convertTo=function(e){var t=e.umod(this.m);return t===e?t.clone():t},_.prototype.convertFrom=function(e){var t=e.clone();return t.red=null,t},a.mont=function(e){return new C(e)},r(C,_),C.prototype.convertTo=function(e){return this.imod(e.ushln(this.shift))},C.prototype.convertFrom=function(e){var t=this.imod(e.mul(this.rinv));return t.red=null,t},C.prototype.imul=function(e,t){if(e.isZero()||t.isZero())return e.words[0]=0,e.length=1,e;var i=e.imul(t),s=i.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),r=i.isub(s).iushrn(this.shift),a=r;return r.cmp(this.m)>=0?a=r.isub(this.m):r.cmpn(0)<0&&(a=r.iadd(this.m)),a._forceRed(this)},C.prototype.mul=function(e,t){if(e.isZero()||t.isZero())return new a(0)._forceRed(this);var i=e.mul(t),s=i.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),r=i.isub(s).iushrn(this.shift),o=r;return r.cmp(this.m)>=0?o=r.isub(this.m):r.cmpn(0)<0&&(o=r.iadd(this.m)),o._forceRed(this)},C.prototype.invm=function(e){return this.imod(e._invmp(this.m).mul(this.r2))._forceRed(this)}}(e,this)}).call(this,i(61)(e))},function(e,t,i){var s,r,a,o,n,d;e.exports=(s=s||function(e,t){var i=Object.create||function(){function e(){}return function(t){var i;return e.prototype=t,i=new e,e.prototype=null,i}}(),s={},r=s.lib={},a=r.Base={extend:function(e){var t=i(this);return e&&t.mixIn(e),t.hasOwnProperty("init")&&this.init!==t.init||(t.init=function(){t.$super.init.apply(this,arguments)}),t.init.prototype=t,t.$super=this,t},create:function(){var e=this.extend();return e.init.apply(e,arguments),e},init:function(){},mixIn:function(e){for(var t in e)e.hasOwnProperty(t)&&(this[t]=e[t]);e.hasOwnProperty("toString")&&(this.toString=e.toString)},clone:function(){return this.init.prototype.extend(this)}},o=r.WordArray=a.extend({init:function(e,t){e=this.words=e||[],this.sigBytes=null!=t?t:4*e.length},toString:function(e){return(e||d).stringify(this)},concat:function(e){var t=this.words,i=e.words,s=this.sigBytes,r=e.sigBytes;if(this.clamp(),s%4)for(var a=0;a<r;a++){var o=i[a>>>2]>>>24-a%4*8&255;t[s+a>>>2]|=o<<24-(s+a)%4*8}else for(var a=0;a<r;a+=4)t[s+a>>>2]=i[a>>>2];return this.sigBytes+=r,this},clamp:function(){var t=this.words,i=this.sigBytes;t[i>>>2]&=4294967295<<32-i%4*8,t.length=e.ceil(i/4)},clone:function(){var e=a.clone.call(this);return e.words=this.words.slice(0),e},random:function(t){for(var i,s=[],r=function(t){var t=t,i=987654321,s=4294967295;return function(){var r=((i=36969*(65535&i)+(i>>16)&s)<<16)+(t=18e3*(65535&t)+(t>>16)&s)&s;return r/=4294967296,(r+=.5)*(e.random()>.5?1:-1)}},a=0;a<t;a+=4){var n=r(4294967296*(i||e.random()));i=987654071*n(),s.push(4294967296*n()|0)}return new o.init(s,t)}}),n=s.enc={},d=n.Hex={stringify:function(e){for(var t=e.words,i=e.sigBytes,s=[],r=0;r<i;r++){var a=t[r>>>2]>>>24-r%4*8&255;s.push((a>>>4).toString(16)),s.push((15&a).toString(16))}return s.join("")},parse:function(e){for(var t=e.length,i=[],s=0;s<t;s+=2)i[s>>>3]|=parseInt(e.substr(s,2),16)<<24-s%8*4;return new o.init(i,t/2)}},c=n.Latin1={stringify:function(e){for(var t=e.words,i=e.sigBytes,s=[],r=0;r<i;r++){var a=t[r>>>2]>>>24-r%4*8&255;s.push(String.fromCharCode(a))}return s.join("")},parse:function(e){for(var t=e.length,i=[],s=0;s<t;s++)i[s>>>2]|=(255&e.charCodeAt(s))<<24-s%4*8;return new o.init(i,t)}},h=n.Utf8={stringify:function(e){try{return decodeURIComponent(escape(c.stringify(e)))}catch(e){throw new Error("Malformed UTF-8 data")}},parse:function(e){return c.parse(unescape(encodeURIComponent(e)))}},l=r.BufferedBlockAlgorithm=a.extend({reset:function(){this._data=new o.init,this._nDataBytes=0},_append:function(e){"string"==typeof e&&(e=h.parse(e)),this._data.concat(e),this._nDataBytes+=e.sigBytes},_process:function(t){var i=this._data,s=i.words,r=i.sigBytes,a=this.blockSize,n=4*a,d=r/n,c=(d=t?e.ceil(d):e.max((0|d)-this._minBufferSize,0))*a,h=e.min(4*c,r);if(c){for(var l=0;l<c;l+=a)this._doProcessBlock(s,l);var u=s.splice(0,c);i.sigBytes-=h}return new o.init(u,h)},clone:function(){var e=a.clone.call(this);return e._data=this._data.clone(),e},_minBufferSize:0}),u=(r.Hasher=l.extend({cfg:a.extend(),init:function(e){this.cfg=this.cfg.extend(e),this.reset()},reset:function(){l.reset.call(this),this._doReset()},update:function(e){return this._append(e),this._process(),this},finalize:function(e){e&&this._append(e);var t=this._doFinalize();return t},blockSize:16,_createHelper:function(e){return function(t,i){return new e.init(i).finalize(t)}},_createHmacHelper:function(e){return function(t,i){return new u.HMAC.init(e,i).finalize(t)}}}),s.algo={});return s}(Math),d=(n=s).lib.WordArray,n.enc.Base64={stringify:function(e){var t=e.words,i=e.sigBytes,s=this._map;e.clamp();for(var r=[],a=0;a<i;a+=3)for(var o=(t[a>>>2]>>>24-a%4*8&255)<<16|(t[a+1>>>2]>>>24-(a+1)%4*8&255)<<8|t[a+2>>>2]>>>24-(a+2)%4*8&255,n=0;n<4&&a+.75*n<i;n++)r.push(s.charAt(o>>>6*(3-n)&63));var d=s.charAt(64);if(d)for(;r.length%4;)r.push(d);return r.join("")},parse:function(e){var t=e.length,i=this._map,s=this._reverseMap;if(!s){s=this._reverseMap=[];for(var r=0;r<i.length;r++)s[i.charCodeAt(r)]=r}var a=i.charAt(64);if(a){var o=e.indexOf(a);-1!==o&&(t=o)}return function(e,t,i){for(var s=[],r=0,a=0;a<t;a++)if(a%4){var o=i[e.charCodeAt(a-1)]<<a%4*2,n=i[e.charCodeAt(a)]>>>6-a%4*2;s[r>>>2]|=(o|n)<<24-r%4*8,r++}return d.create(s,r)}(e,t,s)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="},function(e){var t=s,i=t.lib,r=i.WordArray,a=i.Hasher,o=t.algo,n=[];!function(){for(var t=0;t<64;t++)n[t]=4294967296*e.abs(e.sin(t+1))|0}();var d=o.MD5=a.extend({_doReset:function(){this._hash=new r.init([1732584193,4023233417,2562383102,271733878])},_doProcessBlock:function(e,t){for(var i=0;i<16;i++){var s=t+i,r=e[s];e[s]=16711935&(r<<8|r>>>24)|4278255360&(r<<24|r>>>8)}var a=this._hash.words,o=e[t+0],d=e[t+1],f=e[t+2],p=e[t+3],m=e[t+4],y=e[t+5],b=e[t+6],v=e[t+7],g=e[t+8],w=e[t+9],k=e[t+10],T=e[t+11],O=e[t+12],_=e[t+13],C=e[t+14],S=e[t+15],x=a[0],M=a[1],I=a[2],F=a[3];x=c(x,M,I,F,o,7,n[0]),F=c(F,x,M,I,d,12,n[1]),I=c(I,F,x,M,f,17,n[2]),M=c(M,I,F,x,p,22,n[3]),x=c(x,M,I,F,m,7,n[4]),F=c(F,x,M,I,y,12,n[5]),I=c(I,F,x,M,b,17,n[6]),M=c(M,I,F,x,v,22,n[7]),x=c(x,M,I,F,g,7,n[8]),F=c(F,x,M,I,w,12,n[9]),I=c(I,F,x,M,k,17,n[10]),M=c(M,I,F,x,T,22,n[11]),x=c(x,M,I,F,O,7,n[12]),F=c(F,x,M,I,_,12,n[13]),I=c(I,F,x,M,C,17,n[14]),x=h(x,M=c(M,I,F,x,S,22,n[15]),I,F,d,5,n[16]),F=h(F,x,M,I,b,9,n[17]),I=h(I,F,x,M,T,14,n[18]),M=h(M,I,F,x,o,20,n[19]),x=h(x,M,I,F,y,5,n[20]),F=h(F,x,M,I,k,9,n[21]),I=h(I,F,x,M,S,14,n[22]),M=h(M,I,F,x,m,20,n[23]),x=h(x,M,I,F,w,5,n[24]),F=h(F,x,M,I,C,9,n[25]),I=h(I,F,x,M,p,14,n[26]),M=h(M,I,F,x,g,20,n[27]),x=h(x,M,I,F,_,5,n[28]),F=h(F,x,M,I,f,9,n[29]),I=h(I,F,x,M,v,14,n[30]),x=l(x,M=h(M,I,F,x,O,20,n[31]),I,F,y,4,n[32]),F=l(F,x,M,I,g,11,n[33]),I=l(I,F,x,M,T,16,n[34]),M=l(M,I,F,x,C,23,n[35]),x=l(x,M,I,F,d,4,n[36]),F=l(F,x,M,I,m,11,n[37]),I=l(I,F,x,M,v,16,n[38]),M=l(M,I,F,x,k,23,n[39]),x=l(x,M,I,F,_,4,n[40]),F=l(F,x,M,I,o,11,n[41]),I=l(I,F,x,M,p,16,n[42]),M=l(M,I,F,x,b,23,n[43]),x=l(x,M,I,F,w,4,n[44]),F=l(F,x,M,I,O,11,n[45]),I=l(I,F,x,M,S,16,n[46]),x=u(x,M=l(M,I,F,x,f,23,n[47]),I,F,o,6,n[48]),F=u(F,x,M,I,v,10,n[49]),I=u(I,F,x,M,C,15,n[50]),M=u(M,I,F,x,y,21,n[51]),x=u(x,M,I,F,O,6,n[52]),F=u(F,x,M,I,p,10,n[53]),I=u(I,F,x,M,k,15,n[54]),M=u(M,I,F,x,d,21,n[55]),x=u(x,M,I,F,g,6,n[56]),F=u(F,x,M,I,S,10,n[57]),I=u(I,F,x,M,b,15,n[58]),M=u(M,I,F,x,_,21,n[59]),x=u(x,M,I,F,m,6,n[60]),F=u(F,x,M,I,T,10,n[61]),I=u(I,F,x,M,f,15,n[62]),M=u(M,I,F,x,w,21,n[63]),a[0]=a[0]+x|0,a[1]=a[1]+M|0,a[2]=a[2]+I|0,a[3]=a[3]+F|0},_doFinalize:function(){var t=this._data,i=t.words,s=8*this._nDataBytes,r=8*t.sigBytes;i[r>>>5]|=128<<24-r%32;var a=e.floor(s/4294967296),o=s;i[15+(r+64>>>9<<4)]=16711935&(a<<8|a>>>24)|4278255360&(a<<24|a>>>8),i[14+(r+64>>>9<<4)]=16711935&(o<<8|o>>>24)|4278255360&(o<<24|o>>>8),t.sigBytes=4*(i.length+1),this._process();for(var n=this._hash,d=n.words,c=0;c<4;c++){var h=d[c];d[c]=16711935&(h<<8|h>>>24)|4278255360&(h<<24|h>>>8)}return n},clone:function(){var e=a.clone.call(this);return e._hash=this._hash.clone(),e}});function c(e,t,i,s,r,a,o){var n=e+(t&i|~t&s)+r+o;return(n<<a|n>>>32-a)+t}function h(e,t,i,s,r,a,o){var n=e+(t&s|i&~s)+r+o;return(n<<a|n>>>32-a)+t}function l(e,t,i,s,r,a,o){var n=e+(t^i^s)+r+o;return(n<<a|n>>>32-a)+t}function u(e,t,i,s,r,a,o){var n=e+(i^(t|~s))+r+o;return(n<<a|n>>>32-a)+t}t.MD5=a._createHelper(d),t.HmacMD5=a._createHmacHelper(d)}(Math),function(){var e=s,t=e.lib,i=t.WordArray,r=t.Hasher,a=e.algo,o=[],n=a.SHA1=r.extend({_doReset:function(){this._hash=new i.init([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(e,t){for(var i=this._hash.words,s=i[0],r=i[1],a=i[2],n=i[3],d=i[4],c=0;c<80;c++){if(c<16)o[c]=0|e[t+c];else{var h=o[c-3]^o[c-8]^o[c-14]^o[c-16];o[c]=h<<1|h>>>31}var l=(s<<5|s>>>27)+d+o[c];l+=c<20?1518500249+(r&a|~r&n):c<40?1859775393+(r^a^n):c<60?(r&a|r&n|a&n)-1894007588:(r^a^n)-899497514,d=n,n=a,a=r<<30|r>>>2,r=s,s=l}i[0]=i[0]+s|0,i[1]=i[1]+r|0,i[2]=i[2]+a|0,i[3]=i[3]+n|0,i[4]=i[4]+d|0},_doFinalize:function(){var e=this._data,t=e.words,i=8*this._nDataBytes,s=8*e.sigBytes;return t[s>>>5]|=128<<24-s%32,t[14+(s+64>>>9<<4)]=Math.floor(i/4294967296),t[15+(s+64>>>9<<4)]=i,e.sigBytes=4*t.length,this._process(),this._hash},clone:function(){var e=r.clone.call(this);return e._hash=this._hash.clone(),e}});e.SHA1=r._createHelper(n),e.HmacSHA1=r._createHmacHelper(n)}(),function(e){var t=s,i=t.lib,r=i.WordArray,a=i.Hasher,o=t.algo,n=[],d=[];!function(){function t(t){for(var i=e.sqrt(t),s=2;s<=i;s++)if(!(t%s))return!1;return!0}function i(e){return 4294967296*(e-(0|e))|0}for(var s=2,r=0;r<64;)t(s)&&(r<8&&(n[r]=i(e.pow(s,.5))),d[r]=i(e.pow(s,1/3)),r++),s++}();var c=[],h=o.SHA256=a.extend({_doReset:function(){this._hash=new r.init(n.slice(0))},_doProcessBlock:function(e,t){for(var i=this._hash.words,s=i[0],r=i[1],a=i[2],o=i[3],n=i[4],h=i[5],l=i[6],u=i[7],f=0;f<64;f++){if(f<16)c[f]=0|e[t+f];else{var p=c[f-15],m=(p<<25|p>>>7)^(p<<14|p>>>18)^p>>>3,y=c[f-2],b=(y<<15|y>>>17)^(y<<13|y>>>19)^y>>>10;c[f]=m+c[f-7]+b+c[f-16]}var v=s&r^s&a^r&a,g=(s<<30|s>>>2)^(s<<19|s>>>13)^(s<<10|s>>>22),w=u+((n<<26|n>>>6)^(n<<21|n>>>11)^(n<<7|n>>>25))+(n&h^~n&l)+d[f]+c[f];u=l,l=h,h=n,n=o+w|0,o=a,a=r,r=s,s=w+(g+v)|0}i[0]=i[0]+s|0,i[1]=i[1]+r|0,i[2]=i[2]+a|0,i[3]=i[3]+o|0,i[4]=i[4]+n|0,i[5]=i[5]+h|0,i[6]=i[6]+l|0,i[7]=i[7]+u|0},_doFinalize:function(){var t=this._data,i=t.words,s=8*this._nDataBytes,r=8*t.sigBytes;return i[r>>>5]|=128<<24-r%32,i[14+(r+64>>>9<<4)]=e.floor(s/4294967296),i[15+(r+64>>>9<<4)]=s,t.sigBytes=4*i.length,this._process(),this._hash},clone:function(){var e=a.clone.call(this);return e._hash=this._hash.clone(),e}});t.SHA256=a._createHelper(h),t.HmacSHA256=a._createHmacHelper(h)}(Math),function(){var e=s,t=e.lib.WordArray,i=e.enc;function r(e){return e<<8&4278255360|e>>>8&16711935}i.Utf16=i.Utf16BE={stringify:function(e){for(var t=e.words,i=e.sigBytes,s=[],r=0;r<i;r+=2){var a=t[r>>>2]>>>16-r%4*8&65535;s.push(String.fromCharCode(a))}return s.join("")},parse:function(e){for(var i=e.length,s=[],r=0;r<i;r++)s[r>>>1]|=e.charCodeAt(r)<<16-r%2*16;return t.create(s,2*i)}},i.Utf16LE={stringify:function(e){for(var t=e.words,i=e.sigBytes,s=[],a=0;a<i;a+=2){var o=r(t[a>>>2]>>>16-a%4*8&65535);s.push(String.fromCharCode(o))}return s.join("")},parse:function(e){for(var i=e.length,s=[],a=0;a<i;a++)s[a>>>1]|=r(e.charCodeAt(a)<<16-a%2*16);return t.create(s,2*i)}}}(),function(){if("function"==typeof ArrayBuffer){var e=s.lib.WordArray,t=e.init;(e.init=function(e){if(e instanceof ArrayBuffer&&(e=new Uint8Array(e)),(e instanceof Int8Array||"undefined"!=typeof Uint8ClampedArray&&e instanceof Uint8ClampedArray||e instanceof Int16Array||e instanceof Uint16Array||e instanceof Int32Array||e instanceof Uint32Array||e instanceof Float32Array||e instanceof Float64Array)&&(e=new Uint8Array(e.buffer,e.byteOffset,e.byteLength)),e instanceof Uint8Array){for(var i=e.byteLength,s=[],r=0;r<i;r++)s[r>>>2]|=e[r]<<24-r%4*8;t.call(this,s,i)}else t.apply(this,arguments)}).prototype=e}}(),
/** @preserve
	(c) 2012 by Cdric Mesnil. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
function(e){var t=s,i=t.lib,r=i.WordArray,a=i.Hasher,o=t.algo,n=r.create([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13]),d=r.create([5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11]),c=r.create([11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6]),h=r.create([8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11]),l=r.create([0,1518500249,1859775393,2400959708,2840853838]),u=r.create([1352829926,1548603684,1836072691,2053994217,0]),f=o.RIPEMD160=a.extend({_doReset:function(){this._hash=r.create([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(e,t){for(var i=0;i<16;i++){var s=t+i,r=e[s];e[s]=16711935&(r<<8|r>>>24)|4278255360&(r<<24|r>>>8)}var a,o,f,w,k,T,O,_,C,S,x,M=this._hash.words,I=l.words,F=u.words,B=n.words,A=d.words,E=c.words,P=h.words;for(T=a=M[0],O=o=M[1],_=f=M[2],C=w=M[3],S=k=M[4],i=0;i<80;i+=1)x=a+e[t+B[i]]|0,x+=i<16?p(o,f,w)+I[0]:i<32?m(o,f,w)+I[1]:i<48?y(o,f,w)+I[2]:i<64?b(o,f,w)+I[3]:v(o,f,w)+I[4],x=(x=g(x|=0,E[i]))+k|0,a=k,k=w,w=g(f,10),f=o,o=x,x=T+e[t+A[i]]|0,x+=i<16?v(O,_,C)+F[0]:i<32?b(O,_,C)+F[1]:i<48?y(O,_,C)+F[2]:i<64?m(O,_,C)+F[3]:p(O,_,C)+F[4],x=(x=g(x|=0,P[i]))+S|0,T=S,S=C,C=g(_,10),_=O,O=x;x=M[1]+f+C|0,M[1]=M[2]+w+S|0,M[2]=M[3]+k+T|0,M[3]=M[4]+a+O|0,M[4]=M[0]+o+_|0,M[0]=x},_doFinalize:function(){var e=this._data,t=e.words,i=8*this._nDataBytes,s=8*e.sigBytes;t[s>>>5]|=128<<24-s%32,t[14+(s+64>>>9<<4)]=16711935&(i<<8|i>>>24)|4278255360&(i<<24|i>>>8),e.sigBytes=4*(t.length+1),this._process();for(var r=this._hash,a=r.words,o=0;o<5;o++){var n=a[o];a[o]=16711935&(n<<8|n>>>24)|4278255360&(n<<24|n>>>8)}return r},clone:function(){var e=a.clone.call(this);return e._hash=this._hash.clone(),e}});function p(e,t,i){return e^t^i}function m(e,t,i){return e&t|~e&i}function y(e,t,i){return(e|~t)^i}function b(e,t,i){return e&i|t&~i}function v(e,t,i){return e^(t|~i)}function g(e,t){return e<<t|e>>>32-t}t.RIPEMD160=a._createHelper(f),t.HmacRIPEMD160=a._createHmacHelper(f)}(Math),function(){var e=s,t=e.lib.Base,i=e.enc.Utf8;e.algo.HMAC=t.extend({init:function(e,t){e=this._hasher=new e.init,"string"==typeof t&&(t=i.parse(t));var s=e.blockSize,r=4*s;t.sigBytes>r&&(t=e.finalize(t)),t.clamp();for(var a=this._oKey=t.clone(),o=this._iKey=t.clone(),n=a.words,d=o.words,c=0;c<s;c++)n[c]^=1549556828,d[c]^=909522486;a.sigBytes=o.sigBytes=r,this.reset()},reset:function(){var e=this._hasher;e.reset(),e.update(this._iKey)},update:function(e){return this._hasher.update(e),this},finalize:function(e){var t=this._hasher,i=t.finalize(e);return t.reset(),t.finalize(this._oKey.clone().concat(i))}})}(),function(){var e=s,t=e.lib,i=t.Base,r=t.WordArray,a=e.algo,o=a.SHA1,n=a.HMAC,d=a.PBKDF2=i.extend({cfg:i.extend({keySize:4,hasher:o,iterations:1}),init:function(e){this.cfg=this.cfg.extend(e)},compute:function(e,t){for(var i=this.cfg,s=n.create(i.hasher,e),a=r.create(),o=r.create([1]),d=a.words,c=o.words,h=i.keySize,l=i.iterations;d.length<h;){var u=s.update(t).finalize(o);s.reset();for(var f=u.words,p=f.length,m=u,y=1;y<l;y++){m=s.finalize(m),s.reset();for(var b=m.words,v=0;v<p;v++)f[v]^=b[v]}a.concat(u),c[0]++}return a.sigBytes=4*h,a}});e.PBKDF2=function(e,t,i){return d.create(i).compute(e,t)}}(),function(){var e=s,t=e.lib,i=t.Base,r=t.WordArray,a=e.algo,o=a.MD5,n=a.EvpKDF=i.extend({cfg:i.extend({keySize:4,hasher:o,iterations:1}),init:function(e){this.cfg=this.cfg.extend(e)},compute:function(e,t){for(var i=this.cfg,s=i.hasher.create(),a=r.create(),o=a.words,n=i.keySize,d=i.iterations;o.length<n;){c&&s.update(c);var c=s.update(e).finalize(t);s.reset();for(var h=1;h<d;h++)c=s.finalize(c),s.reset();a.concat(c)}return a.sigBytes=4*n,a}});e.EvpKDF=function(e,t,i){return n.create(i).compute(e,t)}}(),function(){var e=s,t=e.lib.WordArray,i=e.algo,r=i.SHA256,a=i.SHA224=r.extend({_doReset:function(){this._hash=new t.init([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428])},_doFinalize:function(){var e=r._doFinalize.call(this);return e.sigBytes-=4,e}});e.SHA224=r._createHelper(a),e.HmacSHA224=r._createHmacHelper(a)}(),function(e){var t=s,i=t.lib,r=i.Base,a=i.WordArray,o=t.x64={};o.Word=r.extend({init:function(e,t){this.high=e,this.low=t}}),o.WordArray=r.extend({init:function(e,t){e=this.words=e||[],this.sigBytes=null!=t?t:8*e.length},toX32:function(){for(var e=this.words,t=e.length,i=[],s=0;s<t;s++){var r=e[s];i.push(r.high),i.push(r.low)}return a.create(i,this.sigBytes)},clone:function(){for(var e=r.clone.call(this),t=e.words=this.words.slice(0),i=t.length,s=0;s<i;s++)t[s]=t[s].clone();return e}})}(),function(e){var t=s,i=t.lib,r=i.WordArray,a=i.Hasher,o=t.x64.Word,n=t.algo,d=[],c=[],h=[];!function(){for(var e=1,t=0,i=0;i<24;i++){d[e+5*t]=(i+1)*(i+2)/2%64;var s=(2*e+3*t)%5;e=t%5,t=s}for(e=0;e<5;e++)for(t=0;t<5;t++)c[e+5*t]=t+(2*e+3*t)%5*5;for(var r=1,a=0;a<24;a++){for(var n=0,l=0,u=0;u<7;u++){if(1&r){var f=(1<<u)-1;f<32?l^=1<<f:n^=1<<f-32}128&r?r=r<<1^113:r<<=1}h[a]=o.create(n,l)}}();var l=[];!function(){for(var e=0;e<25;e++)l[e]=o.create()}();var u=n.SHA3=a.extend({cfg:a.cfg.extend({outputLength:512}),_doReset:function(){for(var e=this._state=[],t=0;t<25;t++)e[t]=new o.init;this.blockSize=(1600-2*this.cfg.outputLength)/32},_doProcessBlock:function(e,t){for(var i=this._state,s=this.blockSize/2,r=0;r<s;r++){var a=e[t+2*r],o=e[t+2*r+1];a=16711935&(a<<8|a>>>24)|4278255360&(a<<24|a>>>8),o=16711935&(o<<8|o>>>24)|4278255360&(o<<24|o>>>8),(M=i[r]).high^=o,M.low^=a}for(var n=0;n<24;n++){for(var u=0;u<5;u++){for(var f=0,p=0,m=0;m<5;m++)f^=(M=i[u+5*m]).high,p^=M.low;var y=l[u];y.high=f,y.low=p}for(u=0;u<5;u++){var b=l[(u+4)%5],v=l[(u+1)%5],g=v.high,w=v.low;for(f=b.high^(g<<1|w>>>31),p=b.low^(w<<1|g>>>31),m=0;m<5;m++)(M=i[u+5*m]).high^=f,M.low^=p}for(var k=1;k<25;k++){var T=(M=i[k]).high,O=M.low,_=d[k];_<32?(f=T<<_|O>>>32-_,p=O<<_|T>>>32-_):(f=O<<_-32|T>>>64-_,p=T<<_-32|O>>>64-_);var C=l[c[k]];C.high=f,C.low=p}var S=l[0],x=i[0];for(S.high=x.high,S.low=x.low,u=0;u<5;u++)for(m=0;m<5;m++){var M=i[k=u+5*m],I=l[k],F=l[(u+1)%5+5*m],B=l[(u+2)%5+5*m];M.high=I.high^~F.high&B.high,M.low=I.low^~F.low&B.low}M=i[0];var A=h[n];M.high^=A.high,M.low^=A.low}},_doFinalize:function(){var t=this._data,i=t.words,s=(this._nDataBytes,8*t.sigBytes),a=32*this.blockSize;i[s>>>5]|=1<<24-s%32,i[(e.ceil((s+1)/a)*a>>>5)-1]|=128,t.sigBytes=4*i.length,this._process();for(var o=this._state,n=this.cfg.outputLength/8,d=n/8,c=[],h=0;h<d;h++){var l=o[h],u=l.high,f=l.low;u=16711935&(u<<8|u>>>24)|4278255360&(u<<24|u>>>8),f=16711935&(f<<8|f>>>24)|4278255360&(f<<24|f>>>8),c.push(f),c.push(u)}return new r.init(c,n)},clone:function(){for(var e=a.clone.call(this),t=e._state=this._state.slice(0),i=0;i<25;i++)t[i]=t[i].clone();return e}});t.SHA3=a._createHelper(u),t.HmacSHA3=a._createHmacHelper(u)}(Math),function(){var e=s,t=e.lib.Hasher,i=e.x64,r=i.Word,a=i.WordArray,o=e.algo;function n(){return r.create.apply(r,arguments)}var d=[n(1116352408,3609767458),n(1899447441,602891725),n(3049323471,3964484399),n(3921009573,2173295548),n(961987163,4081628472),n(1508970993,3053834265),n(2453635748,2937671579),n(2870763221,3664609560),n(3624381080,2734883394),n(310598401,1164996542),n(607225278,1323610764),n(1426881987,3590304994),n(1925078388,4068182383),n(2162078206,991336113),n(2614888103,633803317),n(3248222580,3479774868),n(3835390401,2666613458),n(4022224774,944711139),n(264347078,2341262773),n(604807628,2007800933),n(770255983,1495990901),n(1249150122,1856431235),n(1555081692,3175218132),n(1996064986,2198950837),n(2554220882,3999719339),n(2821834349,766784016),n(2952996808,2566594879),n(3210313671,3203337956),n(3336571891,1034457026),n(3584528711,2466948901),n(113926993,3758326383),n(338241895,168717936),n(666307205,1188179964),n(773529912,1546045734),n(1294757372,1522805485),n(1396182291,2643833823),n(1695183700,2343527390),n(1986661051,1014477480),n(2177026350,1206759142),n(2456956037,344077627),n(2730485921,1290863460),n(2820302411,3158454273),n(3259730800,3505952657),n(3345764771,106217008),n(3516065817,3606008344),n(3600352804,1432725776),n(4094571909,1467031594),n(275423344,851169720),n(430227734,3100823752),n(506948616,1363258195),n(659060556,3750685593),n(883997877,3785050280),n(958139571,3318307427),n(1322822218,3812723403),n(1537002063,2003034995),n(1747873779,3602036899),n(1955562222,1575990012),n(2024104815,1125592928),n(2227730452,2716904306),n(2361852424,442776044),n(2428436474,593698344),n(2756734187,3733110249),n(3204031479,2999351573),n(3329325298,3815920427),n(3391569614,3928383900),n(3515267271,566280711),n(3940187606,3454069534),n(4118630271,4000239992),n(116418474,1914138554),n(174292421,2731055270),n(289380356,3203993006),n(460393269,320620315),n(685471733,587496836),n(852142971,1086792851),n(1017036298,365543100),n(1126000580,2618297676),n(1288033470,3409855158),n(1501505948,4234509866),n(1607167915,987167468),n(1816402316,1246189591)],c=[];!function(){for(var e=0;e<80;e++)c[e]=n()}();var h=o.SHA512=t.extend({_doReset:function(){this._hash=new a.init([new r.init(1779033703,4089235720),new r.init(3144134277,2227873595),new r.init(1013904242,4271175723),new r.init(2773480762,1595750129),new r.init(1359893119,2917565137),new r.init(2600822924,725511199),new r.init(528734635,4215389547),new r.init(1541459225,327033209)])},_doProcessBlock:function(e,t){for(var i=this._hash.words,s=i[0],r=i[1],a=i[2],o=i[3],n=i[4],h=i[5],l=i[6],u=i[7],f=s.high,p=s.low,m=r.high,y=r.low,b=a.high,v=a.low,g=o.high,w=o.low,k=n.high,T=n.low,O=h.high,_=h.low,C=l.high,S=l.low,x=u.high,M=u.low,I=f,F=p,B=m,A=y,E=b,P=v,q=g,D=w,V=k,R=T,G=O,L=_,N=C,H=S,U=x,j=M,K=0;K<80;K++){var X=c[K];if(K<16)var z=X.high=0|e[t+2*K],W=X.low=0|e[t+2*K+1];else{var Y=c[K-15],Z=Y.high,Q=Y.low,J=(Z>>>1|Q<<31)^(Z>>>8|Q<<24)^Z>>>7,$=(Q>>>1|Z<<31)^(Q>>>8|Z<<24)^(Q>>>7|Z<<25),ee=c[K-2],te=ee.high,ie=ee.low,se=(te>>>19|ie<<13)^(te<<3|ie>>>29)^te>>>6,re=(ie>>>19|te<<13)^(ie<<3|te>>>29)^(ie>>>6|te<<26),ae=c[K-7],oe=ae.high,ne=ae.low,de=c[K-16],ce=de.high,he=de.low;z=(z=(z=J+oe+((W=$+ne)>>>0<$>>>0?1:0))+se+((W+=re)>>>0<re>>>0?1:0))+ce+((W+=he)>>>0<he>>>0?1:0),X.high=z,X.low=W}var le,ue=V&G^~V&N,fe=R&L^~R&H,pe=I&B^I&E^B&E,me=F&A^F&P^A&P,ye=(I>>>28|F<<4)^(I<<30|F>>>2)^(I<<25|F>>>7),be=(F>>>28|I<<4)^(F<<30|I>>>2)^(F<<25|I>>>7),ve=(V>>>14|R<<18)^(V>>>18|R<<14)^(V<<23|R>>>9),ge=(R>>>14|V<<18)^(R>>>18|V<<14)^(R<<23|V>>>9),we=d[K],ke=we.high,Te=we.low,Oe=U+ve+((le=j+ge)>>>0<j>>>0?1:0),_e=be+me;U=N,j=H,N=G,H=L,G=V,L=R,V=q+(Oe=(Oe=(Oe=Oe+ue+((le+=fe)>>>0<fe>>>0?1:0))+ke+((le+=Te)>>>0<Te>>>0?1:0))+z+((le+=W)>>>0<W>>>0?1:0))+((R=D+le|0)>>>0<D>>>0?1:0)|0,q=E,D=P,E=B,P=A,B=I,A=F,I=Oe+(ye+pe+(_e>>>0<be>>>0?1:0))+((F=le+_e|0)>>>0<le>>>0?1:0)|0}p=s.low=p+F,s.high=f+I+(p>>>0<F>>>0?1:0),y=r.low=y+A,r.high=m+B+(y>>>0<A>>>0?1:0),v=a.low=v+P,a.high=b+E+(v>>>0<P>>>0?1:0),w=o.low=w+D,o.high=g+q+(w>>>0<D>>>0?1:0),T=n.low=T+R,n.high=k+V+(T>>>0<R>>>0?1:0),_=h.low=_+L,h.high=O+G+(_>>>0<L>>>0?1:0),S=l.low=S+H,l.high=C+N+(S>>>0<H>>>0?1:0),M=u.low=M+j,u.high=x+U+(M>>>0<j>>>0?1:0)},_doFinalize:function(){var e=this._data,t=e.words,i=8*this._nDataBytes,s=8*e.sigBytes;return t[s>>>5]|=128<<24-s%32,t[30+(s+128>>>10<<5)]=Math.floor(i/4294967296),t[31+(s+128>>>10<<5)]=i,e.sigBytes=4*t.length,this._process(),this._hash.toX32()},clone:function(){var e=t.clone.call(this);return e._hash=this._hash.clone(),e},blockSize:32});e.SHA512=t._createHelper(h),e.HmacSHA512=t._createHmacHelper(h)}(),function(){var e=s,t=e.x64,i=t.Word,r=t.WordArray,a=e.algo,o=a.SHA512,n=a.SHA384=o.extend({_doReset:function(){this._hash=new r.init([new i.init(3418070365,3238371032),new i.init(1654270250,914150663),new i.init(2438529370,812702999),new i.init(355462360,4144912697),new i.init(1731405415,4290775857),new i.init(2394180231,1750603025),new i.init(3675008525,1694076839),new i.init(1203062813,3204075428)])},_doFinalize:function(){var e=o._doFinalize.call(this);return e.sigBytes-=16,e}});e.SHA384=o._createHelper(n),e.HmacSHA384=o._createHmacHelper(n)}(),s.lib.Cipher||function(e){var t=s,i=t.lib,r=i.Base,a=i.WordArray,o=i.BufferedBlockAlgorithm,n=t.enc,d=(n.Utf8,n.Base64),c=t.algo.EvpKDF,h=i.Cipher=o.extend({cfg:r.extend(),createEncryptor:function(e,t){return this.create(this._ENC_XFORM_MODE,e,t)},createDecryptor:function(e,t){return this.create(this._DEC_XFORM_MODE,e,t)},init:function(e,t,i){this.cfg=this.cfg.extend(i),this._xformMode=e,this._key=t,this.reset()},reset:function(){o.reset.call(this),this._doReset()},process:function(e){return this._append(e),this._process()},finalize:function(e){return e&&this._append(e),this._doFinalize()},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(){function e(e){return"string"==typeof e?g:b}return function(t){return{encrypt:function(i,s,r){return e(s).encrypt(t,i,s,r)},decrypt:function(i,s,r){return e(s).decrypt(t,i,s,r)}}}}()}),l=(i.StreamCipher=h.extend({_doFinalize:function(){return this._process(!0)},blockSize:1}),t.mode={}),u=i.BlockCipherMode=r.extend({createEncryptor:function(e,t){return this.Encryptor.create(e,t)},createDecryptor:function(e,t){return this.Decryptor.create(e,t)},init:function(e,t){this._cipher=e,this._iv=t}}),f=l.CBC=function(){var t=u.extend();function i(t,i,s){var r=this._iv;if(r){var a=r;this._iv=e}else a=this._prevBlock;for(var o=0;o<s;o++)t[i+o]^=a[o]}return t.Encryptor=t.extend({processBlock:function(e,t){var s=this._cipher,r=s.blockSize;i.call(this,e,t,r),s.encryptBlock(e,t),this._prevBlock=e.slice(t,t+r)}}),t.Decryptor=t.extend({processBlock:function(e,t){var s=this._cipher,r=s.blockSize,a=e.slice(t,t+r);s.decryptBlock(e,t),i.call(this,e,t,r),this._prevBlock=a}}),t}(),p=(t.pad={}).Pkcs7={pad:function(e,t){for(var i=4*t,s=i-e.sigBytes%i,r=s<<24|s<<16|s<<8|s,o=[],n=0;n<s;n+=4)o.push(r);var d=a.create(o,s);e.concat(d)},unpad:function(e){var t=255&e.words[e.sigBytes-1>>>2];e.sigBytes-=t}},m=(i.BlockCipher=h.extend({cfg:h.cfg.extend({mode:f,padding:p}),reset:function(){h.reset.call(this);var e=this.cfg,t=e.iv,i=e.mode;if(this._xformMode==this._ENC_XFORM_MODE)var s=i.createEncryptor;else s=i.createDecryptor,this._minBufferSize=1;this._mode&&this._mode.__creator==s?this._mode.init(this,t&&t.words):(this._mode=s.call(i,this,t&&t.words),this._mode.__creator=s)},_doProcessBlock:function(e,t){this._mode.processBlock(e,t)},_doFinalize:function(){var e=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){e.pad(this._data,this.blockSize);var t=this._process(!0)}else t=this._process(!0),e.unpad(t);return t},blockSize:4}),i.CipherParams=r.extend({init:function(e){this.mixIn(e)},toString:function(e){return(e||this.formatter).stringify(this)}})),y=(t.format={}).OpenSSL={stringify:function(e){var t=e.ciphertext,i=e.salt;if(i)var s=a.create([1398893684,1701076831]).concat(i).concat(t);else s=t;return s.toString(d)},parse:function(e){var t=d.parse(e),i=t.words;if(1398893684==i[0]&&1701076831==i[1]){var s=a.create(i.slice(2,4));i.splice(0,4),t.sigBytes-=16}return m.create({ciphertext:t,salt:s})}},b=i.SerializableCipher=r.extend({cfg:r.extend({format:y}),encrypt:function(e,t,i,s){s=this.cfg.extend(s);var r=e.createEncryptor(i,s),a=r.finalize(t),o=r.cfg;return m.create({ciphertext:a,key:i,iv:o.iv,algorithm:e,mode:o.mode,padding:o.padding,blockSize:e.blockSize,formatter:s.format})},decrypt:function(e,t,i,s){return s=this.cfg.extend(s),t=this._parse(t,s.format),e.createDecryptor(i,s).finalize(t.ciphertext)},_parse:function(e,t){return"string"==typeof e?t.parse(e,this):e}}),v=(t.kdf={}).OpenSSL={execute:function(e,t,i,s){s||(s=a.random(8));var r=c.create({keySize:t+i}).compute(e,s),o=a.create(r.words.slice(t),4*i);return r.sigBytes=4*t,m.create({key:r,iv:o,salt:s})}},g=i.PasswordBasedCipher=b.extend({cfg:b.cfg.extend({kdf:v}),encrypt:function(e,t,i,s){var r=(s=this.cfg.extend(s)).kdf.execute(i,e.keySize,e.ivSize);s.iv=r.iv;var a=b.encrypt.call(this,e,t,r.key,s);return a.mixIn(r),a},decrypt:function(e,t,i,s){s=this.cfg.extend(s),t=this._parse(t,s.format);var r=s.kdf.execute(i,e.keySize,e.ivSize,t.salt);return s.iv=r.iv,b.decrypt.call(this,e,t,r.key,s)}})}(),s.mode.CFB=function(){var e=s.lib.BlockCipherMode.extend();function t(e,t,i,s){var r=this._iv;if(r){var a=r.slice(0);this._iv=void 0}else a=this._prevBlock;s.encryptBlock(a,0);for(var o=0;o<i;o++)e[t+o]^=a[o]}return e.Encryptor=e.extend({processBlock:function(e,i){var s=this._cipher,r=s.blockSize;t.call(this,e,i,r,s),this._prevBlock=e.slice(i,i+r)}}),e.Decryptor=e.extend({processBlock:function(e,i){var s=this._cipher,r=s.blockSize,a=e.slice(i,i+r);t.call(this,e,i,r,s),this._prevBlock=a}}),e}(),s.mode.ECB=((o=s.lib.BlockCipherMode.extend()).Encryptor=o.extend({processBlock:function(e,t){this._cipher.encryptBlock(e,t)}}),o.Decryptor=o.extend({processBlock:function(e,t){this._cipher.decryptBlock(e,t)}}),o),s.pad.AnsiX923={pad:function(e,t){var i=e.sigBytes,s=4*t,r=s-i%s,a=i+r-1;e.clamp(),e.words[a>>>2]|=r<<24-a%4*8,e.sigBytes+=r},unpad:function(e){var t=255&e.words[e.sigBytes-1>>>2];e.sigBytes-=t}},s.pad.Iso10126={pad:function(e,t){var i=4*t,r=i-e.sigBytes%i;e.concat(s.lib.WordArray.random(r-1)).concat(s.lib.WordArray.create([r<<24],1))},unpad:function(e){var t=255&e.words[e.sigBytes-1>>>2];e.sigBytes-=t}},s.pad.Iso97971={pad:function(e,t){e.concat(s.lib.WordArray.create([2147483648],1)),s.pad.ZeroPadding.pad(e,t)},unpad:function(e){s.pad.ZeroPadding.unpad(e),e.sigBytes--}},s.mode.OFB=(r=s.lib.BlockCipherMode.extend(),a=r.Encryptor=r.extend({processBlock:function(e,t){var i=this._cipher,s=i.blockSize,r=this._iv,a=this._keystream;r&&(a=this._keystream=r.slice(0),this._iv=void 0),i.encryptBlock(a,0);for(var o=0;o<s;o++)e[t+o]^=a[o]}}),r.Decryptor=a,r),s.pad.NoPadding={pad:function(){},unpad:function(){}},function(e){var t=s,i=t.lib.CipherParams,r=t.enc.Hex;t.format.Hex={stringify:function(e){return e.ciphertext.toString(r)},parse:function(e){var t=r.parse(e);return i.create({ciphertext:t})}}}(),function(){var e=s,t=e.lib.BlockCipher,i=e.algo,r=[],a=[],o=[],n=[],d=[],c=[],h=[],l=[],u=[],f=[];!function(){for(var e=[],t=0;t<256;t++)e[t]=t<128?t<<1:t<<1^283;var i=0,s=0;for(t=0;t<256;t++){var p=s^s<<1^s<<2^s<<3^s<<4;p=p>>>8^255&p^99,r[i]=p,a[p]=i;var m=e[i],y=e[m],b=e[y],v=257*e[p]^16843008*p;o[i]=v<<24|v>>>8,n[i]=v<<16|v>>>16,d[i]=v<<8|v>>>24,c[i]=v,v=16843009*b^65537*y^257*m^16843008*i,h[p]=v<<24|v>>>8,l[p]=v<<16|v>>>16,u[p]=v<<8|v>>>24,f[p]=v,i?(i=m^e[e[e[b^m]]],s^=e[e[s]]):i=s=1}}();var p=[0,1,2,4,8,16,32,64,128,27,54],m=i.AES=t.extend({_doReset:function(){if(!this._nRounds||this._keyPriorReset!==this._key){for(var e=this._keyPriorReset=this._key,t=e.words,i=e.sigBytes/4,s=4*((this._nRounds=i+6)+1),a=this._keySchedule=[],o=0;o<s;o++)if(o<i)a[o]=t[o];else{var n=a[o-1];o%i?i>6&&o%i==4&&(n=r[n>>>24]<<24|r[n>>>16&255]<<16|r[n>>>8&255]<<8|r[255&n]):(n=r[(n=n<<8|n>>>24)>>>24]<<24|r[n>>>16&255]<<16|r[n>>>8&255]<<8|r[255&n],n^=p[o/i|0]<<24),a[o]=a[o-i]^n}for(var d=this._invKeySchedule=[],c=0;c<s;c++)o=s-c,n=c%4?a[o]:a[o-4],d[c]=c<4||o<=4?n:h[r[n>>>24]]^l[r[n>>>16&255]]^u[r[n>>>8&255]]^f[r[255&n]]}},encryptBlock:function(e,t){this._doCryptBlock(e,t,this._keySchedule,o,n,d,c,r)},decryptBlock:function(e,t){var i=e[t+1];e[t+1]=e[t+3],e[t+3]=i,this._doCryptBlock(e,t,this._invKeySchedule,h,l,u,f,a),i=e[t+1],e[t+1]=e[t+3],e[t+3]=i},_doCryptBlock:function(e,t,i,s,r,a,o,n){for(var d=this._nRounds,c=e[t]^i[0],h=e[t+1]^i[1],l=e[t+2]^i[2],u=e[t+3]^i[3],f=4,p=1;p<d;p++){var m=s[c>>>24]^r[h>>>16&255]^a[l>>>8&255]^o[255&u]^i[f++],y=s[h>>>24]^r[l>>>16&255]^a[u>>>8&255]^o[255&c]^i[f++],b=s[l>>>24]^r[u>>>16&255]^a[c>>>8&255]^o[255&h]^i[f++],v=s[u>>>24]^r[c>>>16&255]^a[h>>>8&255]^o[255&l]^i[f++];c=m,h=y,l=b,u=v}m=(n[c>>>24]<<24|n[h>>>16&255]<<16|n[l>>>8&255]<<8|n[255&u])^i[f++],y=(n[h>>>24]<<24|n[l>>>16&255]<<16|n[u>>>8&255]<<8|n[255&c])^i[f++],b=(n[l>>>24]<<24|n[u>>>16&255]<<16|n[c>>>8&255]<<8|n[255&h])^i[f++],v=(n[u>>>24]<<24|n[c>>>16&255]<<16|n[h>>>8&255]<<8|n[255&l])^i[f++],e[t]=m,e[t+1]=y,e[t+2]=b,e[t+3]=v},keySize:8});e.AES=t._createHelper(m)}(),function(){var e=s,t=e.lib,i=t.WordArray,r=t.BlockCipher,a=e.algo,o=[57,49,41,33,25,17,9,1,58,50,42,34,26,18,10,2,59,51,43,35,27,19,11,3,60,52,44,36,63,55,47,39,31,23,15,7,62,54,46,38,30,22,14,6,61,53,45,37,29,21,13,5,28,20,12,4],n=[14,17,11,24,1,5,3,28,15,6,21,10,23,19,12,4,26,8,16,7,27,20,13,2,41,52,31,37,47,55,30,40,51,45,33,48,44,49,39,56,34,53,46,42,50,36,29,32],d=[1,2,4,6,8,10,12,14,15,17,19,21,23,25,27,28],c=[{0:8421888,268435456:32768,536870912:8421378,805306368:2,1073741824:512,1342177280:8421890,1610612736:8389122,1879048192:8388608,2147483648:514,2415919104:8389120,2684354560:33280,2952790016:8421376,3221225472:32770,3489660928:8388610,3758096384:0,4026531840:33282,134217728:0,402653184:8421890,671088640:33282,939524096:32768,1207959552:8421888,1476395008:512,1744830464:8421378,2013265920:2,2281701376:8389120,2550136832:33280,2818572288:8421376,3087007744:8389122,3355443200:8388610,3623878656:32770,3892314112:514,4160749568:8388608,1:32768,268435457:2,536870913:8421888,805306369:8388608,1073741825:8421378,1342177281:33280,1610612737:512,1879048193:8389122,2147483649:8421890,2415919105:8421376,2684354561:8388610,2952790017:33282,3221225473:514,3489660929:8389120,3758096385:32770,4026531841:0,134217729:8421890,402653185:8421376,671088641:8388608,939524097:512,1207959553:32768,1476395009:8388610,1744830465:2,2013265921:33282,2281701377:32770,2550136833:8389122,2818572289:514,3087007745:8421888,3355443201:8389120,3623878657:0,3892314113:33280,4160749569:8421378},{0:1074282512,16777216:16384,33554432:524288,50331648:1074266128,67108864:1073741840,83886080:1074282496,100663296:1073758208,117440512:16,134217728:540672,150994944:1073758224,167772160:1073741824,184549376:540688,201326592:524304,218103808:0,234881024:16400,251658240:1074266112,8388608:1073758208,25165824:540688,41943040:16,58720256:1073758224,75497472:1074282512,92274688:1073741824,109051904:524288,125829120:1074266128,142606336:524304,159383552:0,176160768:16384,192937984:1074266112,209715200:1073741840,226492416:540672,243269632:1074282496,260046848:16400,268435456:0,285212672:1074266128,301989888:1073758224,318767104:1074282496,335544320:1074266112,352321536:16,369098752:540688,385875968:16384,402653184:16400,419430400:524288,436207616:524304,452984832:1073741840,469762048:540672,486539264:1073758208,503316480:1073741824,520093696:1074282512,276824064:540688,293601280:524288,310378496:1074266112,327155712:16384,343932928:1073758208,360710144:1074282512,377487360:16,394264576:1073741824,411041792:1074282496,427819008:1073741840,444596224:1073758224,461373440:524304,478150656:0,494927872:16400,511705088:1074266128,528482304:540672},{0:260,1048576:0,2097152:67109120,3145728:65796,4194304:65540,5242880:67108868,6291456:67174660,7340032:67174400,8388608:67108864,9437184:67174656,10485760:65792,11534336:67174404,12582912:67109124,13631488:65536,14680064:4,15728640:256,524288:67174656,1572864:67174404,2621440:0,3670016:67109120,4718592:67108868,5767168:65536,6815744:65540,7864320:260,8912896:4,9961472:256,11010048:67174400,12058624:65796,13107200:65792,14155776:67109124,15204352:67174660,16252928:67108864,16777216:67174656,17825792:65540,18874368:65536,19922944:67109120,20971520:256,22020096:67174660,23068672:67108868,24117248:0,25165824:67109124,26214400:67108864,27262976:4,28311552:65792,29360128:67174400,30408704:260,31457280:65796,32505856:67174404,17301504:67108864,18350080:260,19398656:67174656,20447232:0,21495808:65540,22544384:67109120,23592960:256,24641536:67174404,25690112:65536,26738688:67174660,27787264:65796,28835840:67108868,29884416:67109124,30932992:67174400,31981568:4,33030144:65792},{0:2151682048,65536:2147487808,131072:4198464,196608:2151677952,262144:0,327680:4198400,393216:2147483712,458752:4194368,524288:2147483648,589824:4194304,655360:64,720896:2147487744,786432:2151678016,851968:4160,917504:4096,983040:2151682112,32768:2147487808,98304:64,163840:2151678016,229376:2147487744,294912:4198400,360448:2151682112,425984:0,491520:2151677952,557056:4096,622592:2151682048,688128:4194304,753664:4160,819200:2147483648,884736:4194368,950272:4198464,1015808:2147483712,1048576:4194368,1114112:4198400,1179648:2147483712,1245184:0,1310720:4160,1376256:2151678016,1441792:2151682048,1507328:2147487808,1572864:2151682112,1638400:2147483648,1703936:2151677952,1769472:4198464,1835008:2147487744,1900544:4194304,1966080:64,2031616:4096,1081344:2151677952,1146880:2151682112,1212416:0,1277952:4198400,1343488:4194368,1409024:2147483648,1474560:2147487808,1540096:64,1605632:2147483712,1671168:4096,1736704:2147487744,1802240:2151678016,1867776:4160,1933312:2151682048,1998848:4194304,2064384:4198464},{0:128,4096:17039360,8192:262144,12288:536870912,16384:537133184,20480:16777344,24576:553648256,28672:262272,32768:16777216,36864:537133056,40960:536871040,45056:553910400,49152:553910272,53248:0,57344:17039488,61440:553648128,2048:17039488,6144:553648256,10240:128,14336:17039360,18432:262144,22528:537133184,26624:553910272,30720:536870912,34816:537133056,38912:0,43008:553910400,47104:16777344,51200:536871040,55296:553648128,59392:16777216,63488:262272,65536:262144,69632:128,73728:536870912,77824:553648256,81920:16777344,86016:553910272,90112:537133184,94208:16777216,98304:553910400,102400:553648128,106496:17039360,110592:537133056,114688:262272,118784:536871040,122880:0,126976:17039488,67584:553648256,71680:16777216,75776:17039360,79872:537133184,83968:536870912,88064:17039488,92160:128,96256:553910272,100352:262272,104448:553910400,108544:0,112640:553648128,116736:16777344,120832:262144,124928:537133056,129024:536871040},{0:268435464,256:8192,512:270532608,768:270540808,1024:268443648,1280:2097152,1536:2097160,1792:268435456,2048:0,2304:268443656,2560:2105344,2816:8,3072:270532616,3328:2105352,3584:8200,3840:270540800,128:270532608,384:270540808,640:8,896:2097152,1152:2105352,1408:268435464,1664:268443648,1920:8200,2176:2097160,2432:8192,2688:268443656,2944:270532616,3200:0,3456:270540800,3712:2105344,3968:268435456,4096:268443648,4352:270532616,4608:270540808,4864:8200,5120:2097152,5376:268435456,5632:268435464,5888:2105344,6144:2105352,6400:0,6656:8,6912:270532608,7168:8192,7424:268443656,7680:270540800,7936:2097160,4224:8,4480:2105344,4736:2097152,4992:268435464,5248:268443648,5504:8200,5760:270540808,6016:270532608,6272:270540800,6528:270532616,6784:8192,7040:2105352,7296:2097160,7552:0,7808:268435456,8064:268443656},{0:1048576,16:33555457,32:1024,48:1049601,64:34604033,80:0,96:1,112:34603009,128:33555456,144:1048577,160:33554433,176:34604032,192:34603008,208:1025,224:1049600,240:33554432,8:34603009,24:0,40:33555457,56:34604032,72:1048576,88:33554433,104:33554432,120:1025,136:1049601,152:33555456,168:34603008,184:1048577,200:1024,216:34604033,232:1,248:1049600,256:33554432,272:1048576,288:33555457,304:34603009,320:1048577,336:33555456,352:34604032,368:1049601,384:1025,400:34604033,416:1049600,432:1,448:0,464:34603008,480:33554433,496:1024,264:1049600,280:33555457,296:34603009,312:1,328:33554432,344:1048576,360:1025,376:34604032,392:33554433,408:34603008,424:0,440:34604033,456:1049601,472:1024,488:33555456,504:1048577},{0:134219808,1:131072,2:134217728,3:32,4:131104,5:134350880,6:134350848,7:2048,8:134348800,9:134219776,10:133120,11:134348832,12:2080,13:0,14:134217760,15:133152,2147483648:2048,2147483649:134350880,2147483650:134219808,2147483651:134217728,2147483652:134348800,2147483653:133120,2147483654:133152,2147483655:32,2147483656:134217760,2147483657:2080,2147483658:131104,2147483659:134350848,2147483660:0,2147483661:134348832,2147483662:134219776,2147483663:131072,16:133152,17:134350848,18:32,19:2048,20:134219776,21:134217760,22:134348832,23:131072,24:0,25:131104,26:134348800,27:134219808,28:134350880,29:133120,30:2080,31:134217728,2147483664:131072,2147483665:2048,2147483666:134348832,2147483667:133152,2147483668:32,2147483669:134348800,2147483670:134217728,2147483671:134219808,2147483672:134350880,2147483673:134217760,2147483674:134219776,2147483675:0,2147483676:133120,2147483677:2080,2147483678:131104,2147483679:134350848}],h=[4160749569,528482304,33030144,2064384,129024,8064,504,2147483679],l=a.DES=r.extend({_doReset:function(){for(var e=this._key.words,t=[],i=0;i<56;i++){var s=o[i]-1;t[i]=e[s>>>5]>>>31-s%32&1}for(var r=this._subKeys=[],a=0;a<16;a++){var c=r[a]=[],h=d[a];for(i=0;i<24;i++)c[i/6|0]|=t[(n[i]-1+h)%28]<<31-i%6,c[4+(i/6|0)]|=t[28+(n[i+24]-1+h)%28]<<31-i%6;for(c[0]=c[0]<<1|c[0]>>>31,i=1;i<7;i++)c[i]=c[i]>>>4*(i-1)+3;c[7]=c[7]<<5|c[7]>>>27}var l=this._invSubKeys=[];for(i=0;i<16;i++)l[i]=r[15-i]},encryptBlock:function(e,t){this._doCryptBlock(e,t,this._subKeys)},decryptBlock:function(e,t){this._doCryptBlock(e,t,this._invSubKeys)},_doCryptBlock:function(e,t,i){this._lBlock=e[t],this._rBlock=e[t+1],u.call(this,4,252645135),u.call(this,16,65535),f.call(this,2,858993459),f.call(this,8,16711935),u.call(this,1,1431655765);for(var s=0;s<16;s++){for(var r=i[s],a=this._lBlock,o=this._rBlock,n=0,d=0;d<8;d++)n|=c[d][((o^r[d])&h[d])>>>0];this._lBlock=o,this._rBlock=a^n}var l=this._lBlock;this._lBlock=this._rBlock,this._rBlock=l,u.call(this,1,1431655765),f.call(this,8,16711935),f.call(this,2,858993459),u.call(this,16,65535),u.call(this,4,252645135),e[t]=this._lBlock,e[t+1]=this._rBlock},keySize:2,ivSize:2,blockSize:2});function u(e,t){var i=(this._lBlock>>>e^this._rBlock)&t;this._rBlock^=i,this._lBlock^=i<<e}function f(e,t){var i=(this._rBlock>>>e^this._lBlock)&t;this._lBlock^=i,this._rBlock^=i<<e}e.DES=r._createHelper(l);var p=a.TripleDES=r.extend({_doReset:function(){var e=this._key.words;this._des1=l.createEncryptor(i.create(e.slice(0,2))),this._des2=l.createEncryptor(i.create(e.slice(2,4))),this._des3=l.createEncryptor(i.create(e.slice(4,6)))},encryptBlock:function(e,t){this._des1.encryptBlock(e,t),this._des2.decryptBlock(e,t),this._des3.encryptBlock(e,t)},decryptBlock:function(e,t){this._des3.decryptBlock(e,t),this._des2.encryptBlock(e,t),this._des1.decryptBlock(e,t)},keySize:6,ivSize:2,blockSize:2});e.TripleDES=r._createHelper(p)}(),function(){var e=s,t=e.lib.StreamCipher,i=e.algo,r=i.RC4=t.extend({_doReset:function(){for(var e=this._key,t=e.words,i=e.sigBytes,s=this._S=[],r=0;r<256;r++)s[r]=r;r=0;for(var a=0;r<256;r++){var o=r%i,n=t[o>>>2]>>>24-o%4*8&255;a=(a+s[r]+n)%256;var d=s[r];s[r]=s[a],s[a]=d}this._i=this._j=0},_doProcessBlock:function(e,t){e[t]^=a.call(this)},keySize:8,ivSize:0});function a(){for(var e=this._S,t=this._i,i=this._j,s=0,r=0;r<4;r++){i=(i+e[t=(t+1)%256])%256;var a=e[t];e[t]=e[i],e[i]=a,s|=e[(e[t]+e[i])%256]<<24-8*r}return this._i=t,this._j=i,s}e.RC4=t._createHelper(r);var o=i.RC4Drop=r.extend({cfg:r.cfg.extend({drop:192}),_doReset:function(){r._doReset.call(this);for(var e=this.cfg.drop;e>0;e--)a.call(this)}});e.RC4Drop=t._createHelper(o)}(),
/** @preserve
	 * Counter block mode compatible with  Dr Brian Gladman fileenc.c
	 * derived from CryptoJS.mode.CTR
	 * Jan Hruby jhruby.web@gmail.com
	 */
s.mode.CTRGladman=function(){var e=s.lib.BlockCipherMode.extend();function t(e){if(255==(e>>24&255)){var t=e>>16&255,i=e>>8&255,s=255&e;255===t?(t=0,255===i?(i=0,255===s?s=0:++s):++i):++t,e=0,e+=t<<16,e+=i<<8,e+=s}else e+=1<<24;return e}var i=e.Encryptor=e.extend({processBlock:function(e,i){var s=this._cipher,r=s.blockSize,a=this._iv,o=this._counter;a&&(o=this._counter=a.slice(0),this._iv=void 0),function(e){0===(e[0]=t(e[0]))&&(e[1]=t(e[1]))}(o);var n=o.slice(0);s.encryptBlock(n,0);for(var d=0;d<r;d++)e[i+d]^=n[d]}});return e.Decryptor=i,e}(),function(){var e=s,t=e.lib.StreamCipher,i=e.algo,r=[],a=[],o=[],n=i.Rabbit=t.extend({_doReset:function(){for(var e=this._key.words,t=this.cfg.iv,i=0;i<4;i++)e[i]=16711935&(e[i]<<8|e[i]>>>24)|4278255360&(e[i]<<24|e[i]>>>8);var s=this._X=[e[0],e[3]<<16|e[2]>>>16,e[1],e[0]<<16|e[3]>>>16,e[2],e[1]<<16|e[0]>>>16,e[3],e[2]<<16|e[1]>>>16],r=this._C=[e[2]<<16|e[2]>>>16,4294901760&e[0]|65535&e[1],e[3]<<16|e[3]>>>16,4294901760&e[1]|65535&e[2],e[0]<<16|e[0]>>>16,4294901760&e[2]|65535&e[3],e[1]<<16|e[1]>>>16,4294901760&e[3]|65535&e[0]];for(this._b=0,i=0;i<4;i++)d.call(this);for(i=0;i<8;i++)r[i]^=s[i+4&7];if(t){var a=t.words,o=a[0],n=a[1],c=16711935&(o<<8|o>>>24)|4278255360&(o<<24|o>>>8),h=16711935&(n<<8|n>>>24)|4278255360&(n<<24|n>>>8),l=c>>>16|4294901760&h,u=h<<16|65535&c;for(r[0]^=c,r[1]^=l,r[2]^=h,r[3]^=u,r[4]^=c,r[5]^=l,r[6]^=h,r[7]^=u,i=0;i<4;i++)d.call(this)}},_doProcessBlock:function(e,t){var i=this._X;d.call(this),r[0]=i[0]^i[5]>>>16^i[3]<<16,r[1]=i[2]^i[7]>>>16^i[5]<<16,r[2]=i[4]^i[1]>>>16^i[7]<<16,r[3]=i[6]^i[3]>>>16^i[1]<<16;for(var s=0;s<4;s++)r[s]=16711935&(r[s]<<8|r[s]>>>24)|4278255360&(r[s]<<24|r[s]>>>8),e[t+s]^=r[s]},blockSize:4,ivSize:2});function d(){for(var e=this._X,t=this._C,i=0;i<8;i++)a[i]=t[i];for(t[0]=t[0]+1295307597+this._b|0,t[1]=t[1]+3545052371+(t[0]>>>0<a[0]>>>0?1:0)|0,t[2]=t[2]+886263092+(t[1]>>>0<a[1]>>>0?1:0)|0,t[3]=t[3]+1295307597+(t[2]>>>0<a[2]>>>0?1:0)|0,t[4]=t[4]+3545052371+(t[3]>>>0<a[3]>>>0?1:0)|0,t[5]=t[5]+886263092+(t[4]>>>0<a[4]>>>0?1:0)|0,t[6]=t[6]+1295307597+(t[5]>>>0<a[5]>>>0?1:0)|0,t[7]=t[7]+3545052371+(t[6]>>>0<a[6]>>>0?1:0)|0,this._b=t[7]>>>0<a[7]>>>0?1:0,i=0;i<8;i++){var s=e[i]+t[i],r=65535&s,n=s>>>16,d=((r*r>>>17)+r*n>>>15)+n*n,c=((4294901760&s)*s|0)+((65535&s)*s|0);o[i]=d^c}e[0]=o[0]+(o[7]<<16|o[7]>>>16)+(o[6]<<16|o[6]>>>16)|0,e[1]=o[1]+(o[0]<<8|o[0]>>>24)+o[7]|0,e[2]=o[2]+(o[1]<<16|o[1]>>>16)+(o[0]<<16|o[0]>>>16)|0,e[3]=o[3]+(o[2]<<8|o[2]>>>24)+o[1]|0,e[4]=o[4]+(o[3]<<16|o[3]>>>16)+(o[2]<<16|o[2]>>>16)|0,e[5]=o[5]+(o[4]<<8|o[4]>>>24)+o[3]|0,e[6]=o[6]+(o[5]<<16|o[5]>>>16)+(o[4]<<16|o[4]>>>16)|0,e[7]=o[7]+(o[6]<<8|o[6]>>>24)+o[5]|0}e.Rabbit=t._createHelper(n)}(),s.mode.CTR=function(){var e=s.lib.BlockCipherMode.extend(),t=e.Encryptor=e.extend({processBlock:function(e,t){var i=this._cipher,s=i.blockSize,r=this._iv,a=this._counter;r&&(a=this._counter=r.slice(0),this._iv=void 0);var o=a.slice(0);i.encryptBlock(o,0),a[s-1]=a[s-1]+1|0;for(var n=0;n<s;n++)e[t+n]^=o[n]}});return e.Decryptor=t,e}(),function(){var e=s,t=e.lib.StreamCipher,i=e.algo,r=[],a=[],o=[],n=i.RabbitLegacy=t.extend({_doReset:function(){var e=this._key.words,t=this.cfg.iv,i=this._X=[e[0],e[3]<<16|e[2]>>>16,e[1],e[0]<<16|e[3]>>>16,e[2],e[1]<<16|e[0]>>>16,e[3],e[2]<<16|e[1]>>>16],s=this._C=[e[2]<<16|e[2]>>>16,4294901760&e[0]|65535&e[1],e[3]<<16|e[3]>>>16,4294901760&e[1]|65535&e[2],e[0]<<16|e[0]>>>16,4294901760&e[2]|65535&e[3],e[1]<<16|e[1]>>>16,4294901760&e[3]|65535&e[0]];this._b=0;for(var r=0;r<4;r++)d.call(this);for(r=0;r<8;r++)s[r]^=i[r+4&7];if(t){var a=t.words,o=a[0],n=a[1],c=16711935&(o<<8|o>>>24)|4278255360&(o<<24|o>>>8),h=16711935&(n<<8|n>>>24)|4278255360&(n<<24|n>>>8),l=c>>>16|4294901760&h,u=h<<16|65535&c;for(s[0]^=c,s[1]^=l,s[2]^=h,s[3]^=u,s[4]^=c,s[5]^=l,s[6]^=h,s[7]^=u,r=0;r<4;r++)d.call(this)}},_doProcessBlock:function(e,t){var i=this._X;d.call(this),r[0]=i[0]^i[5]>>>16^i[3]<<16,r[1]=i[2]^i[7]>>>16^i[5]<<16,r[2]=i[4]^i[1]>>>16^i[7]<<16,r[3]=i[6]^i[3]>>>16^i[1]<<16;for(var s=0;s<4;s++)r[s]=16711935&(r[s]<<8|r[s]>>>24)|4278255360&(r[s]<<24|r[s]>>>8),e[t+s]^=r[s]},blockSize:4,ivSize:2});function d(){for(var e=this._X,t=this._C,i=0;i<8;i++)a[i]=t[i];for(t[0]=t[0]+1295307597+this._b|0,t[1]=t[1]+3545052371+(t[0]>>>0<a[0]>>>0?1:0)|0,t[2]=t[2]+886263092+(t[1]>>>0<a[1]>>>0?1:0)|0,t[3]=t[3]+1295307597+(t[2]>>>0<a[2]>>>0?1:0)|0,t[4]=t[4]+3545052371+(t[3]>>>0<a[3]>>>0?1:0)|0,t[5]=t[5]+886263092+(t[4]>>>0<a[4]>>>0?1:0)|0,t[6]=t[6]+1295307597+(t[5]>>>0<a[5]>>>0?1:0)|0,t[7]=t[7]+3545052371+(t[6]>>>0<a[6]>>>0?1:0)|0,this._b=t[7]>>>0<a[7]>>>0?1:0,i=0;i<8;i++){var s=e[i]+t[i],r=65535&s,n=s>>>16,d=((r*r>>>17)+r*n>>>15)+n*n,c=((4294901760&s)*s|0)+((65535&s)*s|0);o[i]=d^c}e[0]=o[0]+(o[7]<<16|o[7]>>>16)+(o[6]<<16|o[6]>>>16)|0,e[1]=o[1]+(o[0]<<8|o[0]>>>24)+o[7]|0,e[2]=o[2]+(o[1]<<16|o[1]>>>16)+(o[0]<<16|o[0]>>>16)|0,e[3]=o[3]+(o[2]<<8|o[2]>>>24)+o[1]|0,e[4]=o[4]+(o[3]<<16|o[3]>>>16)+(o[2]<<16|o[2]>>>16)|0,e[5]=o[5]+(o[4]<<8|o[4]>>>24)+o[3]|0,e[6]=o[6]+(o[5]<<16|o[5]>>>16)+(o[4]<<16|o[4]>>>16)|0,e[7]=o[7]+(o[6]<<8|o[6]>>>24)+o[5]|0}e.RabbitLegacy=t._createHelper(n)}(),s.pad.ZeroPadding={pad:function(e,t){var i=4*t;e.clamp(),e.sigBytes+=i-(e.sigBytes%i||i)},unpad:function(e){for(var t=e.words,i=e.sigBytes-1;!(t[i>>>2]>>>24-i%4*8&255);)i--;e.sigBytes=i+1}},s)},function(e,t,i){"use strict";var s=t;s.base=i(63),s.short=i(64),s.mont=i(65),s.edwards=i(66)},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,ArgumentsRequired:a,DDoSProtection:o,InsufficientFunds:n,InvalidOrder:d,OrderNotFound:c,AuthenticationError:h,BadRequest:l}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"okcoinusd",name:"OKCoin USD",countries:["CN","US"],version:"v1",rateLimit:1e3,has:{CORS:!1,fetchOHLCV:!0,fetchOrder:!0,fetchOrders:!1,fetchOpenOrders:!0,fetchClosedOrders:!0,fetchTickers:!0,withdraw:!0,futures:!1},extension:".do",timeframes:{"1m":"1min","3m":"3min","5m":"5min","15m":"15min","30m":"30min","1h":"1hour","2h":"2hour","4h":"4hour","6h":"6hour","12h":"12hour","1d":"1day","3d":"3day","1w":"1week"},api:{web:{get:["futures/pc/market/marketOverview","spot/markets/index-tickers","spot/markets/currencies","spot/markets/products","spot/markets/tickers","spot/user-level"],post:["futures/pc/market/futuresCoin"]},public:{get:["depth","exchange_rate","future_depth","future_estimated_price","future_hold_amount","future_index","future_kline","future_price_limit","future_ticker","future_trades","kline","otcs","ticker","tickers","trades"]},private:{post:["account_records","batch_trade","borrow_money","borrow_order_info","borrows_info","cancel_borrow","cancel_order","cancel_otc_order","cancel_withdraw","funds_transfer","future_batch_trade","future_cancel","future_devolve","future_explosive","future_order_info","future_orders_info","future_position","future_position_4fix","future_trade","future_trades_history","future_userinfo","future_userinfo_4fix","lend_depth","order_fee","order_history","order_info","orders_info","otc_order_history","otc_order_info","repayment","submit_otc_order","trade","trade_history","trade_otc_order","wallet_info","withdraw","withdraw_info","unrepayments_info","userinfo"]}},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766791-89ffb502-5ee5-11e7-8a5b-c5950b68ac65.jpg",api:{web:"https://www.okcoin.com/v2",public:"https://www.okcoin.com/api",private:"https://www.okcoin.com"},www:"https://www.okcoin.com",doc:["https://www.okcoin.com/docs/en/","https://www.npmjs.com/package/okcoin.com"],referral:"https://www.okcoin.com/account/register?flag=activity&channelId=600001513",fees:"https://support.okcoin.com/hc/en-us/articles/360015261532-OKCoin-Fee-Rates"},fees:{trading:{taker:.002,maker:.001}},exceptions:{10000:r,10001:o,10005:h,10006:h,10007:h,1002:n,1003:d,1004:d,1013:d,1027:d,1050:d,1217:d,10014:d,1009:c,1019:c,1051:c,10009:c,20015:c,10008:l},options:{marketBuyPrice:!1,fetchOHLCVWarning:!0,contractTypes:{1:"this_week",2:"next_week",4:"quarter"},fetchTickersMethod:"fetch_tickers_from_api"}})}async fetchMarkets(e={}){const t=[],i=await this.webGetSpotMarketsProducts(),s=this.safeValue(i,"data",[]);let r=s;if(this.has.futures){const e=await this.webPostFuturesPcMarketFuturesCoin(),t=this.safeValue(e,"data",[]);r=this.arrayConcat(s,t)}for(let e=0;e<r.length;e++){const i=r[e],s=this.safeString(i,"symbol");let a=void 0,o=void 0,n=void 0,d=void 0,c=void 0,h=void 0,l=void 0,u=void 0,f=void 0;const p={amount:this.safeInteger(i,"maxSizeDigit"),price:this.safeInteger(i,"maxPriceDigit")},m=this.safeFloat(i,"minTradeSize"),y=Math.pow(10,-p.price);let b=this.safeValue(i,"contracts");if(void 0===b){u=s;const e=s.split("_");d=e[0],c=e[1],h=this.safeInteger(i,"baseCurrency"),l=this.safeInteger(i,"quoteCurrency"),o=this.safeCurrencyCode(d),n=this.safeCurrencyCode(c),b=[{}]}else c=this.safeString(i,"quote"),u=(d=(f=this.safeString(i,"symbolDesc")).toLowerCase())+"_"+c,o=this.safeCurrencyCode(f),n=this.safeCurrencyCode(c);for(let e=0;e<b.length;e++){const r=b[e];let f=this.safeString(r,"type","spot"),v=void 0,g=!0,w=!1,k=!0;if("spot"===f)a=o+"/"+n,k=0!==i.online;else{a=o+"-"+n+"-"+this.safeString(r,"id").slice(2,8),v=this.safeString(this.options.contractTypes,f),f="future",g=!1,w=!0}const T=this.safeValue2(this.fees,f,"trading",{});t.push(this.extend(T,{id:s,lowercaseId:u,contractType:v,symbol:a,base:o,quote:n,baseId:d,quoteId:c,baseNumericId:h,quoteNumericId:l,info:i,type:f,spot:g,future:w,active:k,precision:p,limits:{amount:{min:m,max:void 0},price:{min:y,max:void 0},cost:{min:m*y,max:void 0}}}))}}return t}calculateFee(e,t,i,s,r,a="taker",o={}){const n=this.markets[e];let d="quote";const c=n[a];let h=parseFloat(this.costToPrecision(e,s*c));return"sell"===i?h*=r:d="base",{type:a,currency:n[d],rate:c,cost:parseFloat(this.feeToPrecision(e,h))}}async fetchTickersFromApi(e,t={}){await this.loadMarkets();const i=await this.publicGetTickers(this.extend({},t)),s=i.tickers,r=this.safeTimestamp(i,"date"),a={};for(let e=0;e<s.length;e++){let t=s[e];a[(t=this.parseTicker(this.extend(s[e],{timestamp:r}))).symbol]=t}return a}async fetchTickersFromWeb(e,t={}){await this.loadMarkets();const i=await this.webGetSpotMarketsTickers(this.extend({},t)),s=this.safeValue(i,"data"),r={};for(let e=0;e<s.length;e++){const t=this.parseTicker(s[e]);r[t.symbol]=t}return r}async fetchTickers(e,t={}){const i=this.options.fetchTickersMethod;return await this[i](e,t)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s=this.market(e),r=s.future?"publicGetFutureDepth":"publicGetDepth",a=this.createRequest(s,i);void 0!==t&&(a.size=t);const o=await this[r](a);return this.parseOrderBook(o)}parseTicker(e,t){const i=this.safeInteger2(e,"timestamp","createdDate");let s=void 0;if(void 0===t&&"symbol"in e){const i=e.symbol;if(i in this.markets_by_id)t=this.markets_by_id[i];else{const[t,i]=e.symbol.split("_");s=this.safeCurrencyCode(t)+"/"+this.safeCurrencyCode(i)}}void 0!==t&&(s=t.symbol);const r=this.safeFloat(e,"last"),a=this.safeFloat(e,"open"),o=this.safeFloat(e,"change"),n=this.safeFloat(e,"changePercentage");return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"buy"),bidVolume:void 0,ask:this.safeFloat(e,"sell"),askVolume:void 0,vwap:void 0,open:a,close:r,last:r,previousClose:void 0,change:o,percentage:n,average:void 0,baseVolume:this.safeFloat2(e,"vol","volume"),quoteVolume:void 0,info:e}}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s=i.future?"publicGetFutureTicker":"publicGetTicker",a=this.createRequest(i,t),o=await this[s](a);let n=this.safeValue(o,"ticker");if(void 0===n)throw new r(this.id+" fetchTicker returned an empty response: "+this.json(o));const d=this.safeTimestamp(o,"date");return void 0!==d&&(n=this.extend(n,{timestamp:d})),this.parseTicker(n,i)}parseTrade(e,t){let i=void 0;t&&(i=t.symbol);const s=this.safeInteger(e,"date_ms"),r=this.safeString(e,"tid"),a=this.safeString(e,"type"),o=this.safeFloat(e,"price"),n=this.safeFloat(e,"amount");let d=void 0;return void 0!==o&&void 0!==n&&(d=o*n),{id:r,info:e,timestamp:s,datetime:this.iso8601(s),symbol:i,order:void 0,type:void 0,side:a,takerOrMaker:void 0,price:o,amount:n,cost:d,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a=r.future?"publicGetFutureTrades":"publicGetTrades",o=this.createRequest(r,s),n=await this[a](o);return this.parseTrades(n,r,t,i)}parseOHLCV(e,t,i="1m",s,r){const a=e.length>6?6:5;return[e[0],parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3]),parseFloat(e[4]),parseFloat(e[a])]}async fetchOHLCV(e,t="1m",i,s,a={}){await this.loadMarkets();const o=this.market(e),n=o.future?"publicGetFutureKline":"publicGetKline",d=this.createRequest(o,{type:this.timeframes[t]});if(void 0!==i&&(d.since=parseInt((this.milliseconds()-864e5)/1e3)),void 0!==s){if(this.options.fetchOHLCVWarning)throw new r(this.id+' fetchOHLCV counts "limit" candles backwards in chronological ascending order, therefore the "limit" argument for '+this.id+" is disabled. Set "+this.id+'.options["fetchOHLCVWarning"] = false to suppress this warning message.');d.size=parseInt(s)}const c=await this[n](this.extend(d,a));return this.parseOHLCVs(c,o,t,i,s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostUserinfo(e),i=this.safeValue(t,"info",{}),s=this.safeValue(i,"funds",{}),r={info:t};let a=Object.keys(s.free),o="freezed";o in s||(o="holds");const n=Object.keys(s[o]);a=this.arrayConcat(a,n);for(let e=0;e<a.length;e++){const t=a[e],i=this.safeCurrencyCode(t),n=this.account();n.free=this.safeFloat(s.free,t),n.used=this.safeFloat(s[o],t),r[i]=n}return this.parseBalance(r)}async createOrder(e,t,i,s,a,o={}){await this.loadMarkets();const n=this.market(e),d=n.future?"privatePostFutureTrade":"privatePostTrade",c="market"===t?i+"_market":i,h=n.spot&&"market"===t&&"buy"===i&&!this.options.marketBuyPrice?this.safeFloat(o,"cost"):a,l=this.createRequest(n,{type:c});if(n.future)l.match_price="market"===t?1:0,l.lever_rate=10,l.type="buy"===i?"1":"2";else if("market"===t)if("buy"===i){if(!h)throw this.options.marketBuyPrice?new r(this.id+" market buy orders require a price argument (the amount you want to spend or the cost of the order) when this.options['marketBuyPrice'] is true."):new r(this.id+" market buy orders require an additional cost parameter, cost = price * amount. If you want to pass the cost of the market order (the amount you want to spend) in the price argument (the default "+this.id+" behaviour), set this.options['marketBuyPrice'] = true. It will effectively suppress this warning exception as well.");l.price=h}else l.amount=s;"market"!==t&&(l.price=h,l.amount=s),o=this.omit(o,"cost");const u=await this[d](this.extend(l,o)),f=this.milliseconds();return{info:u,id:this.safeString(u,"order_id"),timestamp:f,datetime:this.iso8601(f),lastTradeTimestamp:void 0,status:void 0,symbol:e,type:t,side:i,price:a,amount:s,filled:void 0,remaining:void 0,cost:void 0,trades:void 0,fee:void 0}}async cancelOrder(e,t,i={}){if(void 0===t)throw new a(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const s=this.market(t),r=s.future?"privatePostFutureCancel":"privatePostCancelOrder",o=this.createRequest(s,{order_id:e});return await this[r](this.extend(o,i))}parseOrderStatus(e){return this.safeValue({"-1":"canceled",0:"open",1:"open",2:"closed",3:"open",4:"canceled"},e,e)}parseOrderSide(e){return 1===e?"buy":2===e?"sell":3===e?"sell":4===e?"buy":e}parseOrder(e,t){let i=void 0,s=void 0;"type"in e&&("buy"===e.type||"sell"===e.type?(i=e.type,s="limit"):"buy_market"===e.type?(i="buy",s="market"):"sell_market"===e.type?(i="sell",s="market"):(i=this.parseOrderSide(e.type),("contract_name"in e||"lever_rate"in e)&&(s="margin")));const r=this.parseOrderStatus(this.safeString(e,"status"));let a=void 0;if(void 0===t){const i=this.safeString(e,"symbol");i in this.markets_by_id&&(t=this.markets_by_id[i])}t&&(a=t.symbol);const o=this.getCreateDateField(),n=this.safeInteger(e,o);let d=this.safeFloat(e,"amount");const c=this.safeFloat(e,"deal_amount");d=Math.max(d,c);let h=Math.max(0,d-c);"market"===s&&(h=0);let l=this.safeFloat(e,"avg_price");const u=(l=this.safeFloat(e,"price_avg",l))*c;return{info:e,id:this.safeString(e,"order_id"),timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,symbol:a,type:s,side:i,price:this.safeFloat(e,"price"),average:l,cost:u,amount:d,filled:c,remaining:h,status:r,fee:void 0}}getCreateDateField(){return"create_date"}getOrdersField(){return"orders"}async fetchOrder(e,t,i={}){if(void 0===t)throw new r(this.id+" fetchOrder requires a symbol argument");await this.loadMarkets();const s=this.market(t),a=s.future?"privatePostFutureOrderInfo":"privatePostOrderInfo",o=this.createRequest(s,{order_id:e}),n=await this[a](this.extend(o,i)),d=this.getOrdersField();if(n[d].length>0)return this.parseOrder(n[d][0]);throw new c(this.id+" order "+e+" not found")}async fetchOrders(e,t,i,s={}){if(void 0===e)throw new r(this.id+" fetchOrders requires a symbol argument");await this.loadMarkets();const a=this.market(e);let o=a.future?"privatePostFutureOrdersInfo":"privatePost",n=this.createRequest(a);const d="order_id"in s;if(a.future){if(!d)throw new r(this.id+" fetchOrders() requires order_id param for futures market "+e+" (a string of one or more order ids, comma-separated)")}else{const t="type"in s?s.type:s.status;if(void 0===t){const t=d?"type":"status";throw new r(this.id+" fetchOrders() requires "+t+" param for spot market "+e+" (0 - for unfilled orders, 1 - for filled/canceled orders)")}d?(o+="OrdersInfo",n=this.extend(n,{type:t,order_id:s.order_id})):(o+="OrderHistory",n=this.extend(n,{status:t,current_page:1,page_length:200})),s=this.omit(s,["type","status"])}const c=await this[o](this.extend(n,s)),h=this.getOrdersField();return this.parseOrders(c[h],a,t,i)}async fetchOpenOrders(e,t,i,s={}){return await this.fetchOrders(e,t,i,this.extend({status:0},s))}async fetchClosedOrders(e,t,i,s={}){return await this.fetchOrders(e,t,i,this.extend({status:1},s))}async withdraw(e,t,i,s,a={}){this.checkAddress(i),await this.loadMarkets(),s&&(i=i+":"+s);const o={symbol:this.currency(e).id+"_usd",withdraw_address:i,withdraw_amount:t,target:"address"};let n=a;if(!("chargefee"in n))throw new r(this.id+" withdraw() requires a `chargefee` parameter");if(o.chargefee=n.chargefee,n=this.omit(n,"chargefee"),this.password?o.trade_pwd=this.password:"password"in n?(o.trade_pwd=n.password,n=this.omit(n,"password")):"trade_pwd"in n&&(o.trade_pwd=n.trade_pwd,n=this.omit(n,"trade_pwd")),!("trade_pwd"in o))throw new r(this.id+" withdraw() requires this.password set on the exchange instance or a password / trade_pwd parameter");const d=await this.privatePostWithdraw(this.extend(o,n));return{info:d,id:this.safeString(d,"withdraw_id")}}sign(e,t="public",i="GET",s={},r,a){let o="/";if("web"!==t&&(o+=this.version+"/"),o+=e,"web"!==t&&(o+=this.extension),"private"===t){this.checkRequiredCredentials();const e=this.keysort(this.extend({api_key:this.apiKey},s)),t=this.rawencode(e)+"&secret_key="+this.secret;e.sign=this.hash(this.encode(t)).toUpperCase(),a=this.urlencode(e),r={"Content-Type":"application/x-www-form-urlencoded"}}else Object.keys(s).length&&(o+="?"+this.urlencode(s));return{url:o=this.urls.api[t]+o,method:i,body:a,headers:r}}createRequest(e,t={}){return e.future?this.deepExtend({symbol:e.lowercaseId,contract_type:e.contractType},t):this.deepExtend({symbol:e.id},t)}handleErrors(e,t,i,s,a,o,n,d,c){if(void 0!==n){if("error_code"in n){const e=this.safeString(n,"error_code"),t=this.id+" "+this.json(n);if(e in this.exceptions){throw new(0,this.exceptions[e])(t)}throw new r(t)}if("result"in n&&!n.result)throw new r(this.id+" "+this.json(n))}}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"foxbit",name:"FoxBit",countries:["BR"],has:{CORS:!1,createMarketOrder:!1},rateLimit:1e3,version:"v1",urls:{logo:"https://user-images.githubusercontent.com/1294454/27991413-11b40d42-647f-11e7-91ee-78ced874dd09.jpg",api:{public:"https://api.blinktrade.com/api",private:"https://api.blinktrade.com/tapi"},www:"https://foxbit.com.br/exchange",doc:"https://foxbit.com.br/api/"},comment:"Blinktrade API",api:{public:{get:["{currency}/ticker","{currency}/orderbook","{currency}/trades"]},private:{post:["D","F","U2","U4","U6","U18","U24","U26","U30","U34","U70"]}},markets:{"BTC/VEF":{id:"BTCVEF",symbol:"BTC/VEF",base:"BTC",quote:"VEF",brokerId:1,broker:"SurBitcoin"},"BTC/VND":{id:"BTCVND",symbol:"BTC/VND",base:"BTC",quote:"VND",brokerId:3,broker:"VBTC"},"BTC/BRL":{id:"BTCBRL",symbol:"BTC/BRL",base:"BTC",quote:"BRL",brokerId:4,broker:"FoxBit"},"BTC/PKR":{id:"BTCPKR",symbol:"BTC/PKR",base:"BTC",quote:"PKR",brokerId:8,broker:"UrduBit"},"BTC/CLP":{id:"BTCCLP",symbol:"BTC/CLP",base:"BTC",quote:"CLP",brokerId:9,broker:"ChileBit"}},options:{brokerId:"4"}})}async fetchBalance(e={}){await this.loadMarkets();const t={BalanceReqID:this.nonce()},i=await this.privatePostU2(this.extend(t,e)),s=this.safeValue(i.Responses,this.options.brokerId),r={info:i};if(void 0!==s){const e=Object.keys(this.currencies_by_id);for(let t=0;t<e.length;t++){const i=e[t],a=this.safeCurrencyCode(i);if(i in s){const e=this.account();let t=this.safeFloat(s,i+"_locked");void 0!==t&&(t*=1e-8);let o=this.safeFloat(s,i);void 0!==o&&(o*=1e-8),e.used=t,e.total=o,r[a]=e}}}return this.parseBalance(r)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s=this.market(e),r={currency:s.quote,crypto_currency:s.base},a=await this.publicGetCurrencyOrderbook(this.extend(r,i));return this.parseOrderBook(a)}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={currency:i.quote,crypto_currency:i.base},r=await this.publicGetCurrencyTicker(this.extend(s,t)),a=this.milliseconds(),o="vol_"+i.quote.toLowerCase(),n=this.safeFloat(r,"last");return{symbol:e,timestamp:a,datetime:this.iso8601(a),high:this.safeFloat(r,"high"),low:this.safeFloat(r,"low"),bid:this.safeFloat(r,"buy"),bidVolume:void 0,ask:this.safeFloat(r,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeFloat(r,"vol"),quoteVolume:this.safeFloat(r,o),info:r}}parseTrade(e,t){const i=this.safeTimestamp(e,"date"),s=this.safeString(e,"tid");let r=void 0;void 0!==t&&(r=t.symbol);const a=this.safeString(e,"side"),o=this.safeFloat(e,"price"),n=this.safeFloat(e,"amount");let d=void 0;return void 0!==o&&void 0!==n&&(d=n*o),{id:s,info:e,timestamp:i,datetime:this.iso8601(i),symbol:r,type:void 0,side:a,order:void 0,takerOrMaker:void 0,price:o,amount:n,cost:d,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={currency:r.quote,crypto_currency:r.base},o=await this.publicGetCurrencyTrades(this.extend(a,s));return this.parseTrades(o,r,t,i)}async createOrder(e,t,i,s,a,o={}){if(await this.loadMarkets(),"market"===t)throw new r(this.id+" allows limit orders only");const n=this.market(e),d="buy"===i?"1":"2",c={ClOrdID:this.nonce(),Symbol:n.id,Side:d,OrdType:"2",Price:a,OrderQty:s,BrokerID:n.brokerId},h=await this.privatePostD(this.extend(c,o));return{info:h,id:this.indexBy(h.Responses,"MsgType")[8].OrderID}}async cancelOrder(e,t,i={}){return await this.loadMarkets(),await this.privatePostF(this.extend({ClOrdID:e},i))}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api[t]+"/"+this.version+"/"+this.implodeParams(e,s);const n=this.omit(s,this.extractParams(e));if("public"===t)Object.keys(n).length&&(o+="?"+this.urlencode(n));else{this.checkRequiredCredentials();const t=this.nonce().toString(),i=this.extend({MsgType:e},n);a=this.json(i),r={APIKey:this.apiKey,Nonce:t,Signature:this.hmac(this.encode(t),this.encode(this.secret)),"Content-Type":"application/json"}}return{url:o,method:i,body:a,headers:r}}async request(e,t="public",i="GET",s={},a,o){const n=await this.fetch2(e,t,i,s,a,o);if("Status"in n&&200!==n.Status)throw new r(this.id+" "+this.json(n));return n}}},function(e,t,i){"use strict";const s=e=>e?(e^16*Math.random()>>e/4).toString(16):([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,s);e.exports={uuid:s,unCamelCase:e=>e.match(/^[A-Z0-9_]+$/)?e:e.replace(/[a-z0-9][A-Z]/g,e=>e[0]+"_"+e[1]).replace(/[A-Z0-9][A-Z0-9][a-z]/g,e=>e[0]+"_"+e[1]+e[2]).toLowerCase(),capitalize:e=>e.length?e.charAt(0).toUpperCase()+e.slice(1):e,strip:e=>e.replace(/^\s+|\s+$/g,"")}},function(e,t){e.exports=require("stream")},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,ArgumentsRequired:a,ExchangeNotAvailable:o,InsufficientFunds:n,OrderNotFound:d,InvalidOrder:c,DDoSProtection:h,InvalidNonce:l,AuthenticationError:u,InvalidAddress:f}=i(0),{ROUND:p}=i(2);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"binance",name:"Binance",countries:["JP","MT"],rateLimit:500,certified:!0,has:{fetchDepositAddress:!0,CORS:!1,fetchBidsAsks:!0,fetchTickers:!0,fetchTime:!0,fetchOHLCV:!0,fetchMyTrades:!0,fetchOrder:!0,fetchOrders:!0,fetchOpenOrders:!0,fetchClosedOrders:!0,withdraw:!0,fetchFundingFees:!0,fetchDeposits:!0,fetchWithdrawals:!0,fetchTransactions:!1},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","8h":"8h","12h":"12h","1d":"1d","3d":"3d","1w":"1w","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/29604020-d5483cdc-87ee-11e7-94c7-d1a8d9169293.jpg",api:{web:"https://www.binance.com",wapi:"https://api.binance.com/wapi/v3",sapi:"https://api.binance.com/sapi/v1",fapiPrivate:"https://fapi.binance.com/fapi/v1",public:"https://api.binance.com/api/v1",private:"https://api.binance.com/api/v3",v3:"https://api.binance.com/api/v3",v1:"https://api.binance.com/api/v1"},www:"https://www.binance.com",referral:"https://www.binance.com/?ref=10205187",doc:["https://binance-docs.github.io/apidocs/spot/en"],api_management:"https://www.binance.com/en/usercenter/settings/api-management",fees:"https://www.binance.com/en/fee/schedule"},api:{web:{get:["exchange/public/product","assetWithdraw/getAllAsset.html"]},sapi:{get:["margin/asset","margin/pair","margin/allAssets","margin/allPairs","margin/priceIndex","asset/assetDividend","margin/loan","margin/repay","margin/account","margin/transfer","margin/interestHistory","margin/forceLiquidationRec","margin/order","margin/openOrders","margin/allOrders","margin/myTrades","margin/maxBorrowable","margin/maxTransferable"],post:["asset/dust","margin/transfer","margin/loan","margin/repay","margin/order","userDataStream"],put:["userDataStream"],delete:["margin/order","userDataStream"]},wapi:{post:["withdraw","sub-account/transfer"],get:["depositHistory","withdrawHistory","depositAddress","accountStatus","systemStatus","apiTradingStatus","userAssetDribbletLog","tradeFee","assetDetail","sub-account/list","sub-account/transfer/history","sub-account/assets"]},fapiPrivate:{get:["allOrders","openOrders","order","account","balance","positionRisk","userTrades"],post:["order"],delete:["order"]},v3:{get:["ticker/price","ticker/bookTicker"]},public:{get:["ping","time","depth","trades","aggTrades","historicalTrades","klines","ticker/24hr","ticker/allPrices","ticker/allBookTickers","ticker/price","ticker/bookTicker","exchangeInfo"],put:["userDataStream"],post:["userDataStream"],delete:["userDataStream"]},private:{get:["allOrderList","openOrderList","orderList","order","openOrders","allOrders","account","myTrades"],post:["order/oco","order","order/test"],delete:["orderList","order"]}},fees:{trading:{tierBased:!1,percentage:!0,taker:.001,maker:.001}},commonCurrencies:{BCC:"BCC",YOYO:"YOYOW"},options:{fetchTradesMethod:"publicGetAggTrades",fetchTickersMethod:"publicGetTicker24hr",defaultTimeInForce:"GTC",defaultLimitOrderType:"limit",hasAlreadyAuthenticatedSuccessfully:!1,warnOnFetchOpenOrdersWithoutSymbol:!0,recvWindow:5e3,timeDifference:0,adjustForTimeDifference:!1,parseOrderToPrecision:!1,newOrderRespType:{market:"FULL",limit:"RESULT"}},exceptions:{"API key does not exist":u,"Order would trigger immediately.":c,"Account has insufficient balance for requested action.":n,"Rest API trading is not enabled.":o,"-1000":o,"-1013":c,"-1021":l,"-1022":u,"-1100":c,"-1104":r,"-1128":r,"-2010":r,"-2011":d,"-2013":d,"-2014":u,"-2015":u}})}nonce(){return this.milliseconds()-this.options.timeDifference}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.safeFloat(t,"serverTime")}async loadTimeDifference(){const e=await this.fetchTime(),t=this.milliseconds();return this.options.timeDifference=parseInt(t-e),this.options.timeDifference}async fetchMarkets(e={}){const t=await this.publicGetExchangeInfo(e);this.options.adjustForTimeDifference&&await this.loadTimeDifference();const i=this.safeValue(t,"symbols"),s=[];for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"symbol");if("123456"===r)continue;const a=t.baseAsset,o=t.quoteAsset,n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o),c=n+"/"+d,h=this.indexBy(t.filters,"filterType"),l={base:t.baseAssetPrecision,quote:t.quotePrecision,amount:t.baseAssetPrecision,price:t.quotePrecision},u={id:r,symbol:c,base:n,quote:d,baseId:a,quoteId:o,info:t,active:"TRADING"===this.safeString(t,"status"),precision:l,limits:{amount:{min:Math.pow(10,-l.amount),max:void 0},price:{min:void 0,max:void 0},cost:{min:-1*Math.log10(l.amount),max:void 0}}};if("PRICE_FILTER"in h){const e=h.PRICE_FILTER;u.limits.price={min:this.safeFloat(e,"minPrice"),max:void 0};const t=this.safeFloat(e,"maxPrice");void 0!==t&&t>0&&(u.limits.price.max=t),u.precision.price=this.precisionFromString(e.tickSize)}if("LOT_SIZE"in h){const e=this.safeValue(h,"LOT_SIZE",{}),t=this.safeString(e,"stepSize");u.precision.amount=this.precisionFromString(t),u.limits.amount={min:this.safeFloat(e,"minQty"),max:this.safeFloat(e,"maxQty")}}"MIN_NOTIONAL"in h&&(u.limits.cost.min=this.safeFloat(h.MIN_NOTIONAL,"minNotional")),s.push(u)}return s}calculateFee(e,t,i,s,r,a="taker",o={}){const n=this.markets[e];let d="quote";const c=n[a];let h=s*c,l=n.precision.price;return"sell"===i?h*=r:(d="base",l=n.precision.amount),h=this.decimalToPrecision(h,p,l,this.precisionMode),{type:a,currency:n[d],rate:c,cost:parseFloat(h)}}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccount(e),i={info:t},s=this.safeValue(t,"balances",[]);for(let e=0;e<s.length;e++){const t=s[e],r=t.asset,a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeFloat(t,"free"),o.used=this.safeFloat(t,"locked"),i[a]=o}return this.parseBalance(i)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={symbol:this.market(e).id};void 0!==t&&(s.limit=t);const r=await this.publicGetDepth(this.extend(s,i)),a=this.parseOrderBook(r);return a.nonce=this.safeInteger(r,"lastUpdateId"),a}parseTicker(e,t){const i=this.safeInteger(e,"closeTime"),s=this.findSymbol(this.safeString(e,"symbol"),t),r=this.safeFloat(e,"lastPrice");return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"highPrice"),low:this.safeFloat(e,"lowPrice"),bid:this.safeFloat(e,"bidPrice"),bidVolume:this.safeFloat(e,"bidQty"),ask:this.safeFloat(e,"askPrice"),askVolume:this.safeFloat(e,"askQty"),vwap:this.safeFloat(e,"weightedAvgPrice"),open:this.safeFloat(e,"openPrice"),close:r,last:r,previousClose:this.safeFloat(e,"prevClosePrice"),change:this.safeFloat(e,"priceChange"),percentage:this.safeFloat(e,"priceChangePercent"),average:void 0,baseVolume:this.safeFloat(e,"volume"),quoteVolume:this.safeFloat(e,"quoteVolume"),info:e}}async fetchStatus(e={}){const t=await this.wapiGetSystemStatus();let i=this.safeValue(t,"status");return void 0!==i&&(i=0===i?"ok":"maintenance",this.status=this.extend(this.status,{status:i,updated:this.milliseconds()})),this.status}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={symbol:i.id},r=await this.publicGetTicker24hr(this.extend(s,t));return this.parseTicker(r,i)}parseTickers(e,t){const i=[];for(let t=0;t<e.length;t++)i.push(this.parseTicker(e[t]));return this.filterByArray(i,"symbol",t)}async fetchBidsAsks(e,t={}){await this.loadMarkets();const i=await this.publicGetTickerBookTicker(t);return this.parseTickers(i,e)}async fetchTickers(e,t={}){await this.loadMarkets();const i=this.options.fetchTickersMethod,s=await this[i](t);return this.parseTickers(s,e)}parseOHLCV(e,t,i="1m",s,r){return[e[0],parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3]),parseFloat(e[4]),parseFloat(e[5])]}async fetchOHLCV(e,t="1m",i,s,r={}){await this.loadMarkets();const a=this.market(e),o={symbol:a.id,interval:this.timeframes[t]};void 0!==i&&(o.startTime=i),void 0!==s&&(o.limit=s);const n=await this.publicGetKlines(this.extend(o,r));return this.parseOHLCVs(n,a,t,i,s)}parseTrade(e,t){if("isDustTrade"in e)return this.parseDustTrade(e,t);const i=this.safeInteger2(e,"T","time"),s=this.safeFloat2(e,"p","price"),r=this.safeFloat2(e,"q","qty"),a=this.safeString2(e,"a","id");let o=void 0;const n=this.safeString(e,"orderId");"m"in e?o=e.m?"sell":"buy":"isBuyerMaker"in e?o=e.isBuyerMaker?"sell":"buy":"isBuyer"in e&&(o=e.isBuyer?"buy":"sell");let d=void 0;"commission"in e&&(d={cost:this.safeFloat(e,"commission"),currency:this.safeCurrencyCode(this.safeString(e,"commissionAsset"))});let c=void 0;"isMaker"in e&&(c=e.isMaker?"maker":"taker");let h=void 0;if(void 0===t){const i=this.safeString(e,"symbol");t=this.safeValue(this.markets_by_id,i)}return void 0!==t&&(h=t.symbol),{info:e,timestamp:i,datetime:this.iso8601(i),symbol:h,id:a,order:n,type:void 0,takerOrMaker:c,side:o,price:s,amount:r,cost:s*r,fee:d}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id};"publicGetAggTrades"===this.options.fetchTradesMethod&&void 0!==t&&(a.startTime=t,a.endTime=this.sum(t,36e5)),void 0!==i&&(a.limit=i);const o=this.safeValue(this.options,"fetchTradesMethod","publicGetTrades"),n=await this[o](this.extend(a,s));return this.parseTrades(n,r,t,i)}parseOrderStatus(e){return this.safeString({NEW:"open",PARTIALLY_FILLED:"open",FILLED:"closed",CANCELED:"canceled",PENDING_CANCEL:"canceling",REJECTED:"rejected",EXPIRED:"expired"},e,e)}parseOrder(e,t){const i=this.parseOrderStatus(this.safeString(e,"status")),s=this.findSymbol(this.safeString(e,"symbol"),t);let r=void 0;"time"in e?r=this.safeInteger(e,"time"):"transactTime"in e&&(r=this.safeInteger(e,"transactTime"));let a=this.safeFloat(e,"price");const o=this.safeFloat(e,"origQty"),n=this.safeFloat(e,"executedQty");let d=void 0,c=this.safeFloat(e,"cummulativeQuoteQty");void 0!==n&&(void 0!==o&&(d=o-n,this.options.parseOrderToPrecision&&(d=parseFloat(this.amountToPrecision(s,d))),d=Math.max(d,0)),void 0!==a&&void 0===c&&(c=a*n));const h=this.safeString(e,"orderId"),l=this.safeStringLower(e,"type");"market"===l&&0===a&&void 0!==c&&void 0!==n&&c>0&&n>0&&(a=c/n,this.options.parseOrderToPrecision&&(a=parseFloat(this.priceToPrecision(s,a))));const u=this.safeStringLower(e,"side");let f=void 0,p=void 0;const m=this.safeValue(e,"fills");if(void 0!==m){if((p=this.parseTrades(m,t)).length>0){c=p[0].cost,f={cost:p[0].fee.cost,currency:p[0].fee.currency};for(let e=1;e<p.length;e++)c=this.sum(c,p[e].cost),f.cost=this.sum(f.cost,p[e].fee.cost)}}let y=void 0;return void 0!==c&&(n&&(y=c/n,this.options.parseOrderToPrecision&&(y=parseFloat(this.amountToPrecision(s,y)))),this.options.parseOrderToPrecision&&(c=parseFloat(this.costToPrecision(s,c)))),{info:e,id:h,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,symbol:s,type:l,side:u,price:a,amount:o,cost:c,average:y,filled:n,remaining:d,status:i,fee:f,trades:p}}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o=this.market(e);let n="privatePostOrder";this.safeValue(a,"test",!1)&&(n+="Test",a=this.omit(a,"test"));const d=t.toUpperCase(),h=this.safeValue(this.options.newOrderRespType,t,"RESULT"),l={symbol:o.id,quantity:this.amountToPrecision(e,s),type:d,side:i.toUpperCase(),newOrderRespType:h};let u=!1,f=!1,p=!1;if("LIMIT"===d?(f=!0,u=!0):"STOP_LOSS"===d||"TAKE_PROFIT"===d?p=!0:"STOP_LOSS_LIMIT"===d||"TAKE_PROFIT_LIMIT"===d?(p=!0,f=!0,u=!0):"LIMIT_MAKER"===d&&(f=!0),f){if(void 0===r)throw new c(this.id+" createOrder method requires a price argument for a "+t+" order");l.price=this.priceToPrecision(e,r)}if(u&&(l.timeInForce=this.options.defaultTimeInForce),p){const i=this.safeFloat(a,"stopPrice");if(void 0===i)throw new c(this.id+" createOrder method requires a stopPrice extra param for a "+t+" order");a=this.omit(a,"stopPrice"),l.stopPrice=this.priceToPrecision(e,i)}const m=await this[n](this.extend(l,a));return this.parseOrder(m,o)}async fetchOrder(e,t,i={}){if(void 0===t)throw new a(this.id+" fetchOrder requires a symbol argument");await this.loadMarkets();const s=this.market(t),r=this.safeValue(i,"origClientOrderId"),o={symbol:s.id};void 0!==r?o.origClientOrderId=r:o.orderId=parseInt(e);const n=await this.privateGetOrder(this.extend(o,i));return this.parseOrder(n,s)}async fetchOrders(e,t,i,s={}){if(void 0===e)throw new a(this.id+" fetchOrders requires a symbol argument");await this.loadMarkets();const r=this.market(e),o={symbol:r.id};void 0!==t&&(o.startTime=t),void 0!==i&&(o.limit=i);const n=await this.privateGetAllOrders(this.extend(o,s));return this.parseOrders(n,r,t,i)}async fetchOpenOrders(e,t,i,s={}){await this.loadMarkets();let a=void 0;const o={};if(void 0!==e)a=this.market(e),o.symbol=a.id;else if(this.options.warnOnFetchOpenOrdersWithoutSymbol){const e=this.symbols.length,t=parseInt(e/2);throw new r(this.id+" fetchOpenOrders WARNING: fetching open orders without specifying a symbol is rate-limited to one call per "+t.toString()+" seconds. Do not call this method frequently to avoid ban. Set "+this.id+'.options["warnOnFetchOpenOrdersWithoutSymbol"] = false to suppress this warning message.')}const n=await this.privateGetOpenOrders(this.extend(o,s));return this.parseOrders(n,a,t,i)}async fetchClosedOrders(e,t,i,s={}){const r=await this.fetchOrders(e,t,i,s);return this.filterBy(r,"status","closed")}async cancelOrder(e,t,i={}){if(void 0===t)throw new a(this.id+" cancelOrder requires a symbol argument");await this.loadMarkets();const s={symbol:this.market(t).id,orderId:parseInt(e)},r=await this.privateDeleteOrder(this.extend(s,i));return this.parseOrder(r)}async fetchMyTrades(e,t,i,s={}){if(void 0===e)throw new a(this.id+" fetchMyTrades requires a symbol argument");await this.loadMarkets();const r=this.market(e),o={symbol:r.id};void 0!==t&&(o.startTime=t),void 0!==i&&(o.limit=i);const n=await this.privateGetMyTrades(this.extend(o,s));return this.parseTrades(n,r,t,i)}async fetchMyDustTrades(e,t,i,s={}){await this.loadMarkets();const r=await this.wapiGetUserAssetDribbletLog(s),a=this.safeValue(r,"results",{}),o=this.safeValue(a,"rows",[]),n=[];for(let e=0;e<o.length;e++){const t=o[e].logs;for(let e=0;e<t.length;e++)t[e].isDustTrade=!0,n.push(t[e])}const d=this.parseTrades(n,void 0,t,i);return this.filterBySinceLimit(d,t,i)}parseDustTrade(e,t){const i=this.safeString(e,"tranId"),s=this.parse8601(this.safeString(e,"operateTime")),r=this.safeCurrencyCode(this.safeString(e,"fromAsset")),a=this.currency("BNB").code,o=a+"/"+r;let n=!1;o in this.markets&&(n=!0);const d={currency:a,cost:this.safeFloat(e,"serviceChargeAmount")};let c=void 0,h=void 0,l=void 0,u=void 0;n?(c=o,h=this.sum(this.safeFloat(e,"transferedAmount"),d.cost),l=this.safeFloat(e,"amount"),u="buy"):(c=r+"/"+a,h=this.safeFloat(e,"amount"),l=this.sum(this.safeFloat(e,"transferedAmount"),d.cost),u="sell");let f=void 0;void 0!==l&&h&&(f=l/h);return{id:void 0,timestamp:s,datetime:this.iso8601(s),symbol:c,order:i,type:void 0,takerOrMaker:void 0,side:u,amount:h,price:f,cost:l,fee:d,info:e}}async fetchDeposits(e,t,i,s={}){await this.loadMarkets();let r=void 0;const a={};void 0!==e&&(r=this.currency(e),a.asset=r.id),void 0!==t&&(a.startTime=t);const o=await this.wapiGetDepositHistory(this.extend(a,s));return this.parseTransactions(o.depositList,r,t,i)}async fetchWithdrawals(e,t,i,s={}){await this.loadMarkets();let r=void 0;const a={};void 0!==e&&(r=this.currency(e),a.asset=r.id),void 0!==t&&(a.startTime=t);const o=await this.wapiGetWithdrawHistory(this.extend(a,s));return this.parseTransactions(o.withdrawList,r,t,i)}parseTransactionStatusByType(e,t){if(void 0===t)return e;const i={deposit:{0:"pending",1:"ok"},withdrawal:{0:"pending",1:"canceled",2:"pending",3:"failed",4:"pending",5:"failed",6:"ok"}};return e in i[t]?i[t][e]:e}parseTransaction(e,t){const i=this.safeString(e,"id"),s=this.safeString(e,"address");let r=this.safeString(e,"addressTag");void 0!==r&&r.length<1&&(r=void 0);const a=this.safeValue(e,"txId"),o=this.safeString(e,"asset"),n=this.safeCurrencyCode(o,t);let d=void 0;const c=this.safeInteger(e,"insertTime"),h=this.safeInteger(e,"applyTime");let l=this.safeString(e,"type");void 0===l&&(void 0!==c&&void 0===h?(l="deposit",d=c):void 0===c&&void 0!==h&&(l="withdrawal",d=h));const u=this.parseTransactionStatusByType(this.safeString(e,"status"),l),f=this.safeFloat(e,"amount");return{info:e,id:i,txid:a,timestamp:d,datetime:this.iso8601(d),address:s,tag:r,type:l,amount:f,currency:n,status:u,updated:void 0,fee:void 0}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={asset:this.currency(e).id},s=await this.wapiGetDepositAddress(this.extend(i,t)),r=this.safeValue(s,"success");if(void 0===r||!r)throw new f(this.id+" fetchDepositAddress returned an empty response  create the deposit address in the user settings first.");const a=this.safeString(s,"address"),o=this.safeString(s,"addressTag");return this.checkAddress(a),{currency:e,address:this.checkAddress(a),tag:o,info:s}}async fetchFundingFees(e,t={}){const i=await this.wapiGetAssetDetail(t),s=this.safeValue(i,"assetDetail",{}),r=Object.keys(s),a={};for(let e=0;e<r.length;e++){const t=r[e];a[this.safeCurrencyCode(t)]=this.safeFloat(s[t],"withdrawFee")}return{withdraw:a,deposit:{},info:i}}async withdraw(e,t,i,s,r={}){this.checkAddress(i),await this.loadMarkets();const a=this.currency(e),o=i.slice(0,20),n={asset:a.id,address:i,amount:parseFloat(t),name:o};void 0!==s&&(n.addressTag=s);const d=await this.wapiPostWithdraw(this.extend(n,r));return{info:d,id:this.safeString(d,"id")}}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api[t];o+="/"+e,"wapi"===t&&(o+=".html");const n="userDataStream"===e;if("historicalTrades"===e?r={"X-MBX-APIKEY":this.apiKey}:n&&(a=this.urlencode(s),r={"X-MBX-APIKEY":this.apiKey,"Content-Type":"application/x-www-form-urlencoded"}),"private"===t||"sapi"===t||"wapi"===t&&"systemStatus"!==e||"fapiPrivate"===t){this.checkRequiredCredentials();let e=this.urlencode(this.extend({timestamp:this.nonce(),recvWindow:this.options.recvWindow},s));e+="&signature="+this.hmac(this.encode(e),this.encode(this.secret)),r={"X-MBX-APIKEY":this.apiKey},"GET"===i||"DELETE"===i||"wapi"===t?o+="?"+e:(a=e,r["Content-Type"]="application/x-www-form-urlencoded")}else n||Object.keys(s).length&&(o+="?"+this.urlencode(s));return{url:o,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,o,n,d,l){if(418===e||429===e)throw new h(this.id+" "+e.toString()+" "+t+" "+o);if(e>=400){if(o.indexOf("Price * QTY is zero or less")>=0)throw new c(this.id+" order cost = amount * price is zero or less "+o);if(o.indexOf("LOT_SIZE")>=0)throw new c(this.id+" order amount should be evenly divisible by lot size "+o);if(o.indexOf("PRICE_FILTER")>=0)throw new c(this.id+" order price is invalid, i.e. exceeds allowed price precision, exceeds min price or max price limits or is invalid float value in general, use this.priceToPrecision (symbol, amount) "+o)}if(o.length>0&&"{"===o[0]){const e=this.safeValue(n,"success",!0);if(!e){const e=this.safeString(n,"msg");let t=void 0;if(void 0!==e){try{t=JSON.parse(e)}catch(e){t=void 0}void 0!==t&&(n=t)}}const t=this.exceptions,i=this.safeString(n,"msg");if(i in t){throw new(0,t[i])(this.id+" "+i)}const s=this.safeString(n,"code");if(void 0!==s){if(s in t){if("-2015"===s&&this.options.hasAlreadyAuthenticatedSuccessfully)throw new h(this.id+" temporary banned: "+o);throw new t[s](this.id+" "+o)}throw new r(this.id+" "+o)}if(!e)throw new r(this.id+" "+o)}}async request(e,t="public",i="GET",s={},r,a){const o=await this.fetch2(e,t,i,s,r,a);return"private"!==t&&"wapi"!==t||(this.options.hasAlreadyAuthenticatedSuccessfully=!0),o}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,AuthenticationError:a,InvalidNonce:o,InsufficientFunds:n,InvalidOrder:d,OrderNotFound:c,DDoSProtection:h}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"coinegg",name:"CoinEgg",countries:["CN","UK"],has:{fetchOrder:!0,fetchOrders:!0,fetchOpenOrders:"emulated",fetchMyTrades:!1,fetchTickers:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/36770310-adfa764e-1c5a-11e8-8e09-449daac3d2fb.jpg",api:{web:"https://trade.coinegg.com/web",rest:"https://api.coinegg.com/api/v1"},www:"https://www.coinegg.com",doc:"https://www.coinegg.com/explain.api.html",fees:"https://www.coinegg.com/fee.html",referral:"https://www.coinegg.com/user/register?invite=523218"},api:{web:{get:["symbol/ticker?right_coin={quote}","{quote}/trends","{quote}/{base}/order","{quote}/{base}/trades","{quote}/{base}/depth.js"]},public:{get:["ticker/region/{quote}","depth/region/{quote}","orders/region/{quote}"]},private:{post:["balance","trade_add/region/{quote}","trade_cancel/region/{quote}","trade_view/region/{quote}","trade_list/region/{quote}"]}},fees:{trading:{maker:.001,taker:.001},funding:{withdraw:{BTC:.008,BCH:.002,LTC:.001,ETH:.01,ETC:.01,NEO:0,QTUM:"1%",XRP:"1%",DOGE:"1%",LSK:"1%",XAS:"1%",BTS:"1%",GAME:"1%",GOOC:"1%",NXT:"1%",IFC:"1%",DNC:"1%",BLK:"1%",VRC:"1%",XPM:"1%",VTC:"1%",TFC:"1%",PLC:"1%",EAC:"1%",PPC:"1%",FZ:"1%",ZET:"1%",RSS:"1%",PGC:"1%",SKT:"1%",JBC:"1%",RIO:"1%",LKC:"1%",ZCC:"1%",MCC:"1%",QEC:"1%",MET:"1%",YTC:"1%",HLB:"1%",MRYC:"1%",MTC:"1%",KTC:0}}},exceptions:{103:a,104:a,105:a,106:o,200:n,201:d,202:d,203:c,402:h},errorMessages:{100:"Required parameters can not be empty",101:"Illegal parameter",102:"coin does not exist",103:"Key does not exist",104:"Signature does not match",105:"Insufficient permissions",106:"Request expired(nonce error)",200:"Lack of balance",201:"Too small for the number of trading",202:"Price must be in 0 - 1000000",203:"Order does not exist",204:"Pending order amount must be above 0.001 BTC",205:"Restrict pending order prices",206:"Decimal place error",401:"System error",402:"Requests are too frequent",403:"Non-open API",404:"IP restriction does not request the resource",405:"Currency transactions are temporarily closed"},options:{quoteIds:["btc","eth","usc","usdt"]},commonCurrencies:{JBC:"JubaoCoin"}})}async fetchMarkets(e={}){const t=this.options.quoteIds,i=[];for(let e=0;e<t.length;e++){const s=t[e],r=await this.webGetSymbolTickerRightCoinQuote({quote:s}),a=this.safeValue(r,"data",[]);for(let e=0;e<a.length;e++){const t=a[e],r=t.symbol,o=r.split("_")[0];let n=o.toUpperCase(),d=s.toUpperCase();const c=(n=this.safeCurrencyCode(n))+"/"+(d=this.safeCurrencyCode(d)),h={amount:8,price:8};i.push({id:r,symbol:c,base:n,quote:d,baseId:o,quoteId:s,active:!0,precision:h,limits:{amount:{min:Math.pow(10,-h.amount),max:Math.pow(10,h.amount)},price:{min:Math.pow(10,-h.price),max:Math.pow(10,h.price)},cost:{min:void 0,max:void 0}},info:t})}}return i}parseTicker(e,t){const i=t.symbol,s=this.milliseconds(),r=this.safeFloat(e,"last"),a=this.safeFloat(e,"change");let o=void 0,n=void 0,d=void 0;if(void 0!==a){const e=a/100;n=r-(o=r/this.sum(1,e)),d=this.sum(r,o)/2}return{symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"buy"),bidVolume:void 0,ask:this.safeFloat(e,"sell"),askVolume:void 0,vwap:void 0,open:o,close:r,last:r,previousClose:void 0,change:n,percentage:a,average:d,baseVolume:this.safeFloat(e,"vol"),quoteVolume:this.safeFloat(e,"quoteVol"),info:e}}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={coin:i.baseId,quote:i.quoteId},r=await this.publicGetTickerRegionQuote(this.extend(s,t));return this.parseTicker(r,i)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s=this.market(e),r={coin:s.baseId,quote:s.quoteId},a=await this.publicGetDepthRegionQuote(this.extend(r,i));return this.parseOrderBook(a)}parseTrade(e,t){const i=this.safeTimestamp(e,"date"),s=this.safeFloat(e,"price"),r=this.safeFloat(e,"amount"),a=t.symbol;let o=void 0;void 0!==r&&void 0!==s&&(o=this.costToPrecision(a,s*r));const n=this.safeString(e,"type");return{id:this.safeString(e,"tid"),info:e,timestamp:i,datetime:this.iso8601(i),symbol:a,order:void 0,type:"limit",side:n,takerOrMaker:void 0,price:s,amount:r,cost:o,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={coin:r.baseId,quote:r.quoteId},o=await this.publicGetOrdersRegionQuote(this.extend(a,s));return this.parseTrades(o,r,t,i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostBalance(e),i={info:t},s=this.safeValue(t,"data",{}),r=this.omit(s,"uid"),a=Object.keys(r);for(let e=0;e<a.length;e++){const t=a[e],[s,o]=t.split("_"),n=this.safeCurrencyCode(s);n in i||(i[n]=this.account());const d="lock"===o?"used":"free";i[n][d]=this.safeFloat(r,t)}return this.parseBalance(i)}parseOrder(e,t){let i=void 0;void 0!==t&&(i=t.symbol);const s=this.parse8601(this.safeString(e,"datetime")),r=this.safeFloat(e,"price"),a=this.safeFloat(e,"amount_original"),o=this.safeFloat(e,"amount_outstanding");let n=void 0;void 0!==a&&void 0!==o&&(n=a-o);let d=this.safeString(e,"status");d="cancelled"===d?"canceled":o?"open":"closed";const c=this.safeValue(e,"info",e),h=this.safeString(e,"type");return{id:this.safeString(e,"id"),datetime:this.iso8601(s),timestamp:s,lastTradeTimestamp:void 0,status:d,symbol:i,type:"limit",side:h,price:r,cost:void 0,amount:a,filled:n,remaining:o,trades:void 0,fee:void 0,info:c}}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o=this.market(e),n={coin:o.baseId,quote:o.quoteId,type:i,amount:s,price:r},d=await this.privatePostTradeAddRegionQuote(this.extend(n,a)),c=this.safeString(d,"id"),h=this.parseOrder({id:c,datetime:this.ymdhms(this.milliseconds()),amount_original:s,amount_outstanding:s,price:r,type:i,info:d},o);return this.orders[c]=h,h}async cancelOrder(e,t,i={}){await this.loadMarkets();const s=this.market(t),r={id:e,coin:s.baseId,quote:s.quoteId};return await this.privatePostTradeCancelRegionQuote(this.extend(r,i))}async fetchOrder(e,t,i={}){await this.loadMarkets();const s=this.market(t),r={id:e,coin:s.baseId,quote:s.quoteId},a=await this.privatePostTradeViewRegionQuote(this.extend(r,i));return this.parseOrder(a.data,s)}async fetchOrders(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={coin:r.baseId,quote:r.quoteId};void 0!==t&&(a.since=t/1e3);const o=await this.privatePostTradeListRegionQuote(this.extend(a,s));return this.parseOrders(o.data,r,t,i)}async fetchOpenOrders(e,t,i,s={}){return await this.fetchOrders(e,t,i,this.extend({type:"open"},s))}nonce(){return this.milliseconds()}sign(e,t="public",i="GET",s={},r,a){let o="rest";"web"===t&&(o=t);let n=this.urls.api[o]+"/"+this.implodeParams(e,s),d=this.omit(s,this.extractParams(e));if("public"===t||"web"===t)Object.keys(d).length&&(n+="?"+this.urlencode(d));else{this.checkRequiredCredentials(),d=this.urlencode(this.extend({key:this.apiKey,nonce:this.nonce()},d));const e=this.hash(this.encode(this.secret));d+="&signature="+this.hmac(this.encode(d),this.encode(e)),"GET"===i?n+="?"+d:(r={"Content-type":"application/x-www-form-urlencoded"},a=d)}return{url:n,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,o,n,d,c){if(void 0===n)return;const h=this.safeValue(n,"result");if(void 0===h)return;if(!0===h)return;const l=this.safeString(n,"code"),u=this.errorMessages,f=this.safeString(u,l,"Unknown Error");throw l in this.exceptions?new this.exceptions[l](this.id+" "+f):new r(this.id+" "+f)}}},function(e,t,i){"use strict";const s=i(1),{AuthenticationError:r,ExchangeError:a,ExchangeNotAvailable:o,InvalidOrder:n,OrderNotFound:d,InsufficientFunds:c,ArgumentsRequired:h,BadSymbol:l}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"huobipro",name:"Huobi Pro",countries:["CN"],rateLimit:2e3,userAgent:this.userAgents.chrome39,version:"v1",accounts:void 0,accountsById:void 0,hostname:"api.huobi.pro",has:{CORS:!1,fetchTickers:!0,fetchDepositAddress:!1,fetchOHLCV:!0,fetchOrder:!0,fetchOrders:!0,fetchOpenOrders:!0,fetchClosedOrders:!0,fetchTradingLimits:!0,fetchMyTrades:!0,withdraw:!0,fetchCurrencies:!0,fetchDeposits:!0,fetchWithdrawals:!0},timeframes:{"1m":"1min","5m":"5min","15m":"15min","30m":"30min","1h":"60min","1d":"1day","1w":"1week","1M":"1mon","1y":"1year"},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766569-15aa7b9a-5edd-11e7-9e7f-44791f4ee49c.jpg",api:{market:"https://{hostname}",public:"https://{hostname}",private:"https://{hostname}",zendesk:"https://huobiglobal.zendesk.com/hc/en-us/articles"},www:"https://www.huobi.pro",referral:"https://www.huobi.co/en-us/topic/invited/?invite_code=rwrd3",doc:"https://huobiapi.github.io/docs/spot/v1/cn/",fees:"https://www.huobi.pro/about/fee/"},api:{zendesk:{get:["360000400491-Trade-Limits"]},market:{get:["history/kline","detail/merged","depth","trade","history/trade","detail","tickers"]},public:{get:["common/symbols","common/currencys","common/timestamp","common/exchange","settings/currencys"]},private:{get:["account/accounts","account/accounts/{id}/balance","order/openOrders","order/orders","order/orders/{id}","order/orders/{id}/matchresults","order/history","order/matchresults","dw/withdraw-virtual/addresses","query/deposit-withdraw","margin/loan-orders","margin/accounts/balance","points/actions","points/orders","subuser/aggregate-balance"],post:["order/orders/place","order/orders","order/orders/{id}/place","order/orders/{id}/submitcancel","order/orders/batchcancel","dw/balance/transfer","dw/withdraw/api/create","dw/withdraw-virtual/create","dw/withdraw-virtual/{id}/place","dw/withdraw-virtual/{id}/cancel","dw/transfer-in/margin","dw/transfer-out/margin","margin/orders","margin/orders/{id}/repay","subuser/transfer"]}},fees:{trading:{tierBased:!1,percentage:!0,maker:.002,taker:.002}},exceptions:{exact:{"gateway-internal-error":o,"account-frozen-balance-insufficient-error":c,"invalid-amount":n,"order-limitorder-amount-min-error":n,"order-marketorder-amount-min-error":n,"order-limitorder-price-min-error":n,"order-limitorder-price-max-error":n,"order-orderstate-error":d,"order-queryorder-invalid":d,"order-update-error":o,"api-signature-check-failed":r,"api-signature-not-valid":r,"base-record-invalid":d,"invalid symbol":l}},options:{fetchOrdersByStatesMethod:"private_get_order_orders",fetchOpenOrdersMethod:"fetch_open_orders_v1",createMarketBuyOrderRequiresPrice:!0,fetchMarketsMethod:"publicGetCommonSymbols",fetchBalanceMethod:"privateGetAccountAccountsIdBalance",createOrderMethod:"privatePostOrderOrdersPlace",language:"en-US"},commonCurrencies:{HOT:"Hydro Protocol"}})}async fetchTradingLimits(e,t={}){await this.loadMarkets(),void 0===e&&(e=this.symbols);const i={};for(let s=0;s<e.length;s++){const r=e[s];i[r]=await this.fetchTradingLimitsById(this.marketId(r),t)}return i}async fetchTradingLimitsById(e,t={}){const i={symbol:e},s=await this.publicGetCommonExchange(this.extend(i,t));return this.parseTradingLimits(this.safeValue(s,"data",{}))}parseTradingLimits(e,t,i={}){return{info:e,limits:{amount:{min:this.safeFloat(e,"limit-order-must-greater-than"),max:this.safeFloat(e,"limit-order-must-less-than")}}}}async fetchMarkets(e={}){const t=this.options.fetchMarketsMethod,i=await this[t](e),s=this.safeValue(i,"data");if(s.length<1)throw new a(this.id+" publicGetCommonSymbols returned empty response: "+this.json(s));const r=[];for(let e=0;e<s.length;e++){const t=s[e],i=this.safeString(t,"base-currency"),a=this.safeString(t,"quote-currency"),o=i+a,n=this.safeCurrencyCode(i),d=this.safeCurrencyCode(a),c=n+"/"+d,h={amount:t["amount-precision"],price:t["price-precision"]},l="OMG"===n?0:.002,u="OMG"===n?0:.002,f=this.safeFloat(t,"min-order-amt",Math.pow(10,-h.amount)),p=this.safeFloat(t,"min-order-value",0),m="online"===this.safeString(t,"state");r.push({id:o,symbol:c,base:n,quote:d,baseId:i,quoteId:a,active:m,precision:h,taker:u,maker:l,limits:{amount:{min:f,max:void 0},price:{min:Math.pow(10,-h.price),max:void 0},cost:{min:p,max:void 0}},info:t})}return r}parseTicker(e,t){let i=void 0;void 0!==t&&(i=t.symbol);const s=this.safeInteger(e,"ts");let r=void 0,a=void 0,o=void 0,n=void 0;"bid"in e&&Array.isArray(e.bid)&&(r=this.safeFloat(e.bid,0),o=this.safeFloat(e.bid,1)),"ask"in e&&Array.isArray(e.ask)&&(a=this.safeFloat(e.ask,0),n=this.safeFloat(e.ask,1));const d=this.safeFloat(e,"open"),c=this.safeFloat(e,"close");let h=void 0,l=void 0,u=void 0;void 0!==d&&void 0!==c&&(h=c-d,u=this.sum(d,c)/2,void 0!==c&&c>0&&(l=h/d*100));const f=this.safeFloat(e,"amount"),p=this.safeFloat(e,"vol");let m=void 0;return void 0!==f&&void 0!==p&&f>0&&(m=p/f),{symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:r,bidVolume:o,ask:a,askVolume:n,vwap:m,open:d,close:c,last:c,previousClose:void 0,change:h,percentage:l,average:u,baseVolume:f,quoteVolume:p,info:e}}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={symbol:this.market(e).id,type:"step0"},r=await this.marketGetDepth(this.extend(s,i));if("tick"in r){if(!r.tick)throw new a(this.id+" fetchOrderBook() returned empty response: "+this.json(r));const e=this.safeValue(r,"tick"),t=this.parseOrderBook(e,e.ts);return t.nonce=e.version,t}throw new a(this.id+" fetchOrderBook() returned unrecognized response: "+this.json(r))}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={symbol:i.id},r=await this.marketGetDetailMerged(this.extend(s,t));return this.parseTicker(r.tick,i)}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.marketGetTickers(t),s=this.safeValue(i,"data"),r=this.safeInteger(i,"ts"),a={};for(let e=0;e<s.length;e++){const t=this.safeString(s[e],"symbol"),i=this.safeValue(this.markets_by_id,t);let o=t;if(void 0!==i){o=i.symbol;const t=this.parseTicker(s[e],i);t.timestamp=r,t.datetime=this.iso8601(r),a[o]=t}}return a}parseTrade(e,t){let i=void 0;if(void 0===t){const i=this.safeString(e,"symbol");i in this.markets_by_id&&(t=this.markets_by_id[i])}void 0!==t&&(i=t.symbol);const s=this.safeInteger2(e,"ts","created-at"),r=this.safeString(e,"order-id");let a=this.safeString(e,"direction"),o=this.safeString(e,"type");if(void 0!==o){const e=o.split("-");a=e[0],o=e[1]}const n=this.safeString(e,"role"),d=this.safeFloat(e,"price"),c=this.safeFloat2(e,"filled-amount","amount");let h=void 0;void 0!==d&&void 0!==c&&(h=c*d);let l=void 0,u=this.safeFloat(e,"filled-fees"),f=void 0;void 0!==t&&(f="buy"===a?t.base:t.quote);const p=this.safeFloat(e,"filled-points");return void 0!==p&&(void 0!==u&&0!==u||(u=p,f=this.safeCurrencyCode(this.safeString(e,"fee-deduct-currency")))),void 0!==u&&(l={cost:u,currency:f}),{id:this.safeString(e,"id"),info:e,order:r,timestamp:s,datetime:this.iso8601(s),symbol:i,type:o,side:a,takerOrMaker:n,price:d,amount:c,cost:h,fee:l}}async fetchMyTrades(e,t,i,s={}){await this.loadMarkets();let r=void 0;const a={};void 0!==e&&(r=this.market(e),a.symbol=r.id),void 0!==i&&(a.size=i),void 0!==t&&(a["start-date"]=this.ymd(t));const o=await this.privateGetOrderMatchresults(this.extend(a,s));return this.parseTrades(o.data,r,t,i)}async fetchTrades(e,t,i=1e3,s={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id};void 0!==i&&(a.size=i);const o=await this.marketGetHistoryTrade(this.extend(a,s)),n=this.safeValue(o,"data");let d=[];for(let e=0;e<n.length;e++){const t=this.safeValue(n[e],"data",[]);for(let e=0;e<t.length;e++){const i=this.parseTrade(t[e],r);d.push(i)}}return d=this.sortBy(d,"timestamp"),this.filterBySymbolSinceLimit(d,e,t,i)}parseOHLCV(e,t,i="1m",s,r){return[this.safeTimestamp(e,"id"),this.safeFloat(e,"open"),this.safeFloat(e,"high"),this.safeFloat(e,"low"),this.safeFloat(e,"close"),this.safeFloat(e,"amount")]}async fetchOHLCV(e,t="1m",i,s=1e3,r={}){await this.loadMarkets();const a=this.market(e),o={symbol:a.id,period:this.timeframes[t]};void 0!==s&&(o.size=s);const n=await this.marketGetHistoryKline(this.extend(o,r));return this.parseOHLCVs(n.data,a,t,i,s)}async fetchAccounts(e={}){return await this.loadMarkets(),(await this.privateGetAccountAccounts(e)).data}async fetchCurrencies(e={}){const t={language:this.options.language},i=await this.publicGetSettingsCurrencys(this.extend(t,e)),s=this.safeValue(i,"data"),r={};for(let e=0;e<s.length;e++){const t=s[e],i=this.safeValue(t,"name"),a=this.safeInteger(t,"withdraw-precision"),o=this.safeCurrencyCode(i),n=t.visible&&t["deposit-enabled"]&&t["withdraw-enabled"],d=this.safeString(t,"display-name");r[o]={id:i,code:o,type:"crypto",name:d,active:n,fee:void 0,precision:a,limits:{amount:{min:Math.pow(10,-a),max:Math.pow(10,a)},price:{min:Math.pow(10,-a),max:Math.pow(10,a)},cost:{min:void 0,max:void 0},deposit:{min:this.safeFloat(t,"deposit-min-amount"),max:Math.pow(10,a)},withdraw:{min:this.safeFloat(t,"withdraw-min-amount"),max:Math.pow(10,a)}},info:t}}return r}async fetchBalance(e={}){await this.loadMarkets(),await this.loadAccounts();const t=this.options.fetchBalanceMethod,i={id:this.accounts[0].id},s=await this[t](this.extend(i,e)),r=this.safeValue(s.data,"list",[]),a={info:s};for(let e=0;e<r.length;e++){const t=r[e],i=this.safeString(t,"currency"),s=this.safeCurrencyCode(i);let o=void 0;o=s in a?a[s]:this.account(),"trade"===t.type&&(o.free=this.safeFloat(t,"balance")),"frozen"===t.type&&(o.used=this.safeFloat(t,"balance")),a[s]=o}return this.parseBalance(a)}async fetchOrdersByStates(e,t,i,s,r={}){await this.loadMarkets();const a={states:e};let o=void 0;void 0!==t&&(o=this.market(t),a.symbol=o.id);const n=this.safeString(this.options,"fetchOrdersByStatesMethod","private_get_order_orders"),d=await this[n](this.extend(a,r));return this.parseOrders(d.data,o,i,s)}async fetchOrder(e,t,i={}){await this.loadMarkets();const s={id:e},r=await this.privateGetOrderOrdersId(this.extend(s,i)),a=this.safeValue(r,"data");return this.parseOrder(a)}async fetchOrders(e,t,i,s={}){return await this.fetchOrdersByStates("pre-submitted,submitted,partial-filled,filled,partial-canceled,canceled",e,t,i,s)}async fetchOpenOrders(e,t,i,s={}){const r=this.safeString(this.options,"fetchOpenOrdersMethod","fetch_open_orders_v1");return await this[r](e,t,i,s)}async fetchOpenOrdersV1(e,t,i,s={}){return await this.fetchOrdersByStates("pre-submitted,submitted,partial-filled",e,t,i,s)}async fetchClosedOrders(e,t,i,s={}){return await this.fetchOrdersByStates("filled,partial-canceled,canceled",e,t,i,s)}async fetchOpenOrdersV2(e,t,i,s={}){if(await this.loadMarkets(),void 0===e)throw new h(this.id+" fetchOpenOrders requires a symbol argument");const r=this.market(e);let a=this.safeString(s,"account-id");if(void 0===a){await this.loadAccounts();for(let e=0;e<this.accounts.length;e++){const t=this.accounts[e];if("spot"===t.type&&void 0!==(a=this.safeString(t,"id")))break}}const o={symbol:r.id,"account-id":a};void 0!==i&&(o.size=i);const n=this.omit(s,"account-id"),d=await this.privateGetOrderOpenOrders(this.extend(o,n)),c=this.safeValue(d,"data",[]);return this.parseOrders(c,r,t,i)}parseOrderStatus(e){return this.safeString({"partial-filled":"open","partial-canceled":"canceled",filled:"closed",canceled:"canceled",submitted:"open"},e,e)}parseOrder(e,t){const i=this.safeString(e,"id");let s=void 0,r=void 0,a=void 0;if("type"in e){const t=e.type.split("-");s=t[0],r=t[1],a=this.parseOrderStatus(this.safeString(e,"state"))}let o=void 0;if(void 0===t&&"symbol"in e&&e.symbol in this.markets_by_id){const i=e.symbol;t=this.markets_by_id[i]}void 0!==t&&(o=t.symbol);const n=this.safeInteger(e,"created-at");let d=this.safeFloat(e,"amount");const c=this.safeFloat2(e,"filled-amount","field-amount");"market"===r&&"buy"===s&&(d="closed"===a?c:void 0);let h=this.safeFloat(e,"price");0===h&&(h=void 0);const l=this.safeFloat2(e,"filled-cash-amount","field-cash-amount");let u=void 0,f=void 0;void 0!==c&&(void 0!==d&&(u=d-c),void 0!==l&&c>0&&(f=l/c));const p=this.safeFloat2(e,"filled-fees","field-fees");let m=void 0;if(void 0!==p){let e=void 0;void 0!==t&&(e="sell"===s?t.quote:t.base),m={cost:p,currency:e}}return{info:e,id:i,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,symbol:o,type:r,side:s,price:h,average:f,cost:l,amount:d,filled:c,remaining:u,status:a,fee:m}}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets(),await this.loadAccounts();const o=this.market(e),d={"account-id":this.accounts[0].id,amount:this.amountToPrecision(e,s),symbol:o.id,type:i+"-"+t};if(this.options.createMarketBuyOrderRequiresPrice&&"market"===t&&"buy"===i){if(void 0===r)throw new n(this.id+" market buy order requires price argument to calculate cost (total amount of quote currency to spend for buying, amount * price). To switch off this warning exception and specify cost in the amount argument, set .options['createMarketBuyOrderRequiresPrice'] = false. Make sure you know what you're doing.");d.amount=this.priceToPrecision(e,parseFloat(s)*parseFloat(r))}"limit"!==t&&"ioc"!==t&&"limit-maker"!==t||(d.price=this.priceToPrecision(e,r));const c=this.options.createOrderMethod,h=await this[c](this.extend(d,a)),l=this.milliseconds();return{info:h,id:this.safeString(h,"data"),timestamp:l,datetime:this.iso8601(l),lastTradeTimestamp:void 0,status:void 0,symbol:e,type:t,side:i,price:r,amount:s,filled:void 0,remaining:void 0,cost:void 0,trades:void 0,fee:void 0}}async cancelOrder(e,t,i={}){const s=await this.privatePostOrderOrdersIdSubmitcancel({id:e});return this.extend(this.parseOrder(s),{id:e,status:"canceled"})}currencyToPrecision(e,t){return this.decimalToPrecision(t,0,this.currencies[e].precision)}calculateFee(e,t,i,s,r,a="taker",o={}){const n=this.markets[e],d=n[a];let c=s*d,h="quote";return"sell"===i?c*=r:h="base",{type:a,currency:n[h],rate:d,cost:parseFloat(this.currencyToPrecision(n[h],c))}}async withdraw(e,t,i,s,r={}){await this.loadMarkets(),this.checkAddress(i);const a={address:i,amount:t,currency:this.currency(e).id.toLowerCase()};void 0!==s&&(a["addr-tag"]=s);const o=await this.privatePostDwWithdrawApiCreate(this.extend(a,r));return{info:o,id:this.safeString(o,"data")}}sign(e,t="public",i="GET",s={},r,a){let o="/";"market"===t?o+=t:"public"!==t&&"private"!==t||(o+=this.version),o+="/"+this.implodeParams(e,s);const n=this.omit(s,this.extractParams(e));if("private"===t){this.checkRequiredCredentials();const e=this.ymdhms(this.milliseconds(),"T"),t=this.keysort(this.extend({SignatureMethod:"HmacSHA256",SignatureVersion:"2",AccessKeyId:this.apiKey,Timestamp:e},n));let s=this.urlencode(t);const d=[i,this.hostname,o,s].join("\n"),c=this.hmac(this.encode(d),this.encode(this.secret),"sha256","base64");o+="?"+(s+="&"+this.urlencode({Signature:c})),"POST"===i?(a=this.json(n),r={"Content-Type":"application/json"}):r={"Content-Type":"application/x-www-form-urlencoded"}}else Object.keys(s).length&&(o+="?"+this.urlencode(s));return{url:o=this.implodeParams(this.urls.api[t],{hostname:this.hostname})+o,method:i,body:a,headers:r}}handleErrors(e,t,i,s,r,o,n,d,c){if(void 0!==n&&"status"in n){if("error"===this.safeString(n,"status")){const e=this.safeString(n,"err-code"),t=this.id+" "+this.json(n),i=this.exceptions.exact;if(e in i)throw new i[e](t);const s=this.safeString(n,"err-msg");if(s in i)throw new i[s](t);throw new a(t)}}}async fetchDeposits(e,t,i,s={}){(void 0===i||i>100)&&(i=100),await this.loadMarkets();let r=void 0;void 0!==e&&(r=this.currency(e));const a={type:"deposit",from:0};void 0!==r&&(a.currency=r.id),void 0!==i&&(a.size=i);const o=await this.privateGetQueryDepositWithdraw(this.extend(a,s));return this.parseTransactions(o.data,r,t,i)}async fetchWithdrawals(e,t,i,s={}){(void 0===i||i>100)&&(i=100),await this.loadMarkets();let r=void 0;void 0!==e&&(r=this.currency(e));const a={type:"withdraw",from:0};void 0!==r&&(a.currency=r.id),void 0!==i&&(a.size=i);const o=await this.privateGetQueryDepositWithdraw(this.extend(a,s));return this.parseTransactions(o.data,r,t,i)}parseTransaction(e,t){const i=this.safeInteger(e,"created-at"),s=this.safeInteger(e,"updated-at"),r=this.safeCurrencyCode(this.safeString(e,"currency"));let a=this.safeString(e,"type");"withdraw"===a&&(a="withdrawal");const o=this.parseTransactionStatus(this.safeString(e,"state")),n=this.safeString(e,"address-tag");let d=this.safeFloat(e,"fee");return void 0!==d&&(d=Math.abs(d)),{info:e,id:this.safeString(e,"id"),txid:this.safeString(e,"tx-hash"),timestamp:i,datetime:this.iso8601(i),address:this.safeString(e,"address"),tag:n,type:a,amount:this.safeFloat(e,"amount"),currency:r,status:o,updated:s,fee:{currency:r,cost:d,rate:void 0}}}parseTransactionStatus(e){return this.safeString({unknown:"failed",confirming:"pending",confirmed:"ok",safe:"ok",orphan:"failed",submitted:"pending",canceled:"canceled",reexamine:"pending",reject:"failed",pass:"pending","wallet-reject":"failed","confirm-error":"failed",repealed:"failed","wallet-transfer":"pending","pre-transfer":"pending"},e,e)}}},function(e,t,i){"use strict";const{unCamelCase:s}=i(10);e.exports=(e=>{for(const t in e)e[s(t)]=e[t];return e})(Object.assign({},i(40),i(45),i(10),i(18),i(2),i(19),i(49),i(28),i(74),i(75)))},function(e,t){e.exports=require("http")},function(e,t){e.exports=require("url")},function(e,t,i){"use strict";const s=Number.isFinite,r=Array.isArray,a=e=>null!=e,o=e=>"string"==typeof e,n=e=>null!==e&&"object"==typeof e,d=e=>a(e)&&e.toString||s(e),c=(e,t)=>n(e)?e[t]:void 0,h=(e,t,i)=>n(e)?t in e?e[t]:e[i]:void 0,l=e=>s(e)||o(e)?parseFloat(e):NaN,u=e=>s(e)||o(e)?parseInt(e,10):NaN;e.exports={isNumber:s,isArray:r,isObject:n,isString:o,isStringCoercible:d,isDictionary:e=>n(e)&&!r(e),hasProps:a,prop:c,asFloat:l,asInteger:u,safeFloat:(e,t,i,r=l(c(e,t)))=>s(r)?r:i,safeInteger:(e,t,i,r=u(c(e,t)))=>s(r)?r:i,safeIntegerProduct:(e,t,i,r,a=u(c(e,t)))=>s(a)?parseInt(a*i):r,safeTimestamp:(e,t,i,r=u(c(e,t)))=>s(r)?parseInt(1e3*r):i,safeValue:(e,t,i,s=c(e,t))=>a(s)?s:i,safeString:(e,t,i,s=c(e,t))=>d(s)?String(s):i,safeStringLower:(e,t,i,s=c(e,t))=>d(s)?String(s).toLowerCase():i,safeStringUpper:(e,t,i,s=c(e,t))=>d(s)?String(s).toUpperCase():i,safeFloat2:(e,t,i,r,a=l(h(e,t,i)))=>s(a)?a:r,safeInteger2:(e,t,i,r,a=u(h(e,t,i)))=>s(a)?a:r,safeIntegerProduct2:(e,t,i,r,a,o=u(h(e,t,i)))=>s(o)?parseInt(o*r):a,safeTimestamp2:(e,t,i,r,a=u(h(e,t,i)))=>s(a)?parseInt(1e3*a):r,safeValue2:(e,t,i,s,r=h(e,t,i))=>a(r)?r:s,safeString2:(e,t,i,s,r=h(e,t,i))=>d(r)?String(r):s,safeStringLower2:(e,t,i,s,r=h(e,t,i))=>d(r)?String(r).toLowerCase():s,safeStringUpper2:(e,t,i,s,r=h(e,t,i))=>d(r)?String(r).toUpperCase():s}},function(e,t,i){"use strict";const s=i(6),r=i(46);e.exports={json:(e,t)=>JSON.stringify(e),unjson:JSON.parse,stringToBinary(e){const t=new Uint8Array(e.length);for(let i=0;i<e.length;i++)t[i]=e.charCodeAt(i);return s.lib.WordArray.create(t)},stringToBase64:e=>s.enc.Latin1.parse(e).toString(s.enc.Base64),utf16ToBase64:e=>s.enc.Utf16.parse(e).toString(s.enc.Base64),base64ToBinary:e=>s.enc.Base64.parse(e),base64ToString:e=>s.enc.Base64.parse(e).toString(s.enc.Utf8),binaryToBase64:e=>e.toString(s.enc.Base64),base16ToBinary:e=>s.enc.Hex.parse(e),binaryConcat:(...e)=>e.reduce((e,t)=>e.concat(t)),urlencode:e=>r.stringify(e),rawencode:e=>r.stringify(e,{encode:!1}),encode:e=>e,decode:e=>e,urlencodeBase64:e=>e.replace(/[=]+$/,"").replace(/\+/g,"-").replace(/\//g,"_")}},function(e,t,i){"use strict";var s=Object.prototype.hasOwnProperty,r=Array.isArray,a=function(){for(var e=[],t=0;t<256;++t)e.push("%"+((t<16?"0":"")+t.toString(16)).toUpperCase());return e}(),o=function(e,t){for(var i=t&&t.plainObjects?Object.create(null):{},s=0;s<e.length;++s)void 0!==e[s]&&(i[s]=e[s]);return i};e.exports={arrayToObject:o,assign:function(e,t){return Object.keys(t).reduce(function(e,i){return e[i]=t[i],e},e)},combine:function(e,t){return[].concat(e,t)},compact:function(e){for(var t=[{obj:{o:e},prop:"o"}],i=[],s=0;s<t.length;++s)for(var a=t[s],o=a.obj[a.prop],n=Object.keys(o),d=0;d<n.length;++d){var c=n[d],h=o[c];"object"==typeof h&&null!==h&&-1===i.indexOf(h)&&(t.push({obj:o,prop:c}),i.push(h))}return function(e){for(;e.length>1;){var t=e.pop(),i=t.obj[t.prop];if(r(i)){for(var s=[],a=0;a<i.length;++a)void 0!==i[a]&&s.push(i[a]);t.obj[t.prop]=s}}}(t),e},decode:function(e,t,i){var s=e.replace(/\+/g," ");if("iso-8859-1"===i)return s.replace(/%[0-9a-f]{2}/gi,unescape);try{return decodeURIComponent(s)}catch(e){return s}},encode:function(e,t,i){if(0===e.length)return e;var s="string"==typeof e?e:String(e);if("iso-8859-1"===i)return escape(s).replace(/%u[0-9a-f]{4}/gi,function(e){return"%26%23"+parseInt(e.slice(2),16)+"%3B"});for(var r="",o=0;o<s.length;++o){var n=s.charCodeAt(o);45===n||46===n||95===n||126===n||n>=48&&n<=57||n>=65&&n<=90||n>=97&&n<=122?r+=s.charAt(o):n<128?r+=a[n]:n<2048?r+=a[192|n>>6]+a[128|63&n]:n<55296||n>=57344?r+=a[224|n>>12]+a[128|n>>6&63]+a[128|63&n]:(o+=1,n=65536+((1023&n)<<10|1023&s.charCodeAt(o)),r+=a[240|n>>18]+a[128|n>>12&63]+a[128|n>>6&63]+a[128|63&n])}return r},isBuffer:function(e){return!(!e||"object"!=typeof e||!(e.constructor&&e.constructor.isBuffer&&e.constructor.isBuffer(e)))},isRegExp:function(e){return"[object RegExp]"===Object.prototype.toString.call(e)},merge:function e(t,i,a){if(!i)return t;if("object"!=typeof i){if(r(t))t.push(i);else{if(!t||"object"!=typeof t)return[t,i];(a&&(a.plainObjects||a.allowPrototypes)||!s.call(Object.prototype,i))&&(t[i]=!0)}return t}if(!t||"object"!=typeof t)return[t].concat(i);var n=t;return r(t)&&!r(i)&&(n=o(t,a)),r(t)&&r(i)?(i.forEach(function(i,r){if(s.call(t,r)){var o=t[r];o&&"object"==typeof o&&i&&"object"==typeof i?t[r]=e(o,i,a):t.push(i)}else t[r]=i}),t):Object.keys(i).reduce(function(t,r){var o=i[r];return s.call(t,r)?t[r]=e(t[r],o,a):t[r]=o,t},n)}}},function(e,t,i){"use strict";var s=String.prototype.replace,r=/%20/g;e.exports={default:"RFC3986",formatters:{RFC1738:function(e){return s.call(e,r,"+")},RFC3986:function(e){return e}},RFC1738:"RFC1738",RFC3986:"RFC3986"}},function(e,t,i){var s=i(3)._;function r(e,t){null!=e&&("number"==typeof e?this.fromNumber(e,t):Buffer.isBuffer(e)?this.fromBuffer(e):null==t&&"string"!=typeof e?this.fromByteArray(e):this.fromString(e,t))}function a(){return new r(null)}r.prototype.am=function(e,t,i,s,r,a){for(var o=16383&t,n=t>>14;--a>=0;){var d=16383&this[e],c=this[e++]>>14,h=n*d+c*o;r=((d=o*d+((16383&h)<<14)+i[s]+r)>>28)+(h>>14)+n*c,i[s++]=268435455&d}return r},r.prototype.DB=28,r.prototype.DM=268435455,r.prototype.DV=1<<28;r.prototype.FV=Math.pow(2,52),r.prototype.F1=24,r.prototype.F2=4;var o,n,d="0123456789abcdefghijklmnopqrstuvwxyz",c=new Array;for(o="0".charCodeAt(0),n=0;n<=9;++n)c[o++]=n;for(o="a".charCodeAt(0),n=10;n<36;++n)c[o++]=n;for(o="A".charCodeAt(0),n=10;n<36;++n)c[o++]=n;function h(e){return d.charAt(e)}function l(e,t){var i=c[e.charCodeAt(t)];return null==i?-1:i}function u(e){var t=a();return t.fromInt(e),t}function f(e){var t,i=1;return 0!=(t=e>>>16)&&(e=t,i+=16),0!=(t=e>>8)&&(e=t,i+=8),0!=(t=e>>4)&&(e=t,i+=4),0!=(t=e>>2)&&(e=t,i+=2),0!=(t=e>>1)&&(e=t,i+=1),i}function p(e){this.m=e}function m(e){this.m=e,this.mp=e.invDigit(),this.mpl=32767&this.mp,this.mph=this.mp>>15,this.um=(1<<e.DB-15)-1,this.mt2=2*e.t}function y(e,t){return e&t}function b(e,t){return e|t}function v(e,t){return e^t}function g(e){if(0===e)return-1;var t=0;return 0==(65535&e)&&(e>>=16,t+=16),0==(255&e)&&(e>>=8,t+=8),0==(15&e)&&(e>>=4,t+=4),0==(3&e)&&(e>>=2,t+=2),0==(1&e)&&++t,t}function w(){}function k(e){return e}function T(e){this.r2=a(),this.q3=a(),r.ONE.dlShiftTo(2*e.t,this.r2),this.mu=this.r2.divide(e),this.m=e}p.prototype.convert=function(e){return e.s<0||e.compareTo(this.m)>=0?e.mod(this.m):e},p.prototype.revert=function(e){return e},p.prototype.reduce=function(e){e.divRemTo(this.m,null,e)},p.prototype.mulTo=function(e,t,i){e.multiplyTo(t,i),this.reduce(i)},p.prototype.sqrTo=function(e,t){e.squareTo(t),this.reduce(t)},m.prototype.convert=function(e){var t=a();return e.abs().dlShiftTo(this.m.t,t),t.divRemTo(this.m,null,t),e.s<0&&t.compareTo(r.ZERO)>0&&this.m.subTo(t,t),t},m.prototype.revert=function(e){var t=a();return e.copyTo(t),this.reduce(t),t},m.prototype.reduce=function(e){for(;e.t<=this.mt2;)e[e.t++]=0;for(var t=0;t<this.m.t;++t){var i=32767&e[t],s=i*this.mpl+((i*this.mph+(e[t]>>15)*this.mpl&this.um)<<15)&e.DM;for(e[i=t+this.m.t]+=this.m.am(0,s,e,t,0,this.m.t);e[i]>=e.DV;)e[i]-=e.DV,e[++i]++}e.clamp(),e.drShiftTo(this.m.t,e),e.compareTo(this.m)>=0&&e.subTo(this.m,e)},m.prototype.mulTo=function(e,t,i){e.multiplyTo(t,i),this.reduce(i)},m.prototype.sqrTo=function(e,t){e.squareTo(t),this.reduce(t)},w.prototype.convert=k,w.prototype.revert=k,w.prototype.mulTo=function(e,t,i){e.multiplyTo(t,i)},w.prototype.sqrTo=function(e,t){e.squareTo(t)},T.prototype.convert=function(e){if(e.s<0||e.t>2*this.m.t)return e.mod(this.m);if(e.compareTo(this.m)<0)return e;var t=a();return e.copyTo(t),this.reduce(t),t},T.prototype.revert=function(e){return e},T.prototype.reduce=function(e){for(e.drShiftTo(this.m.t-1,this.r2),e.t>this.m.t+1&&(e.t=this.m.t+1,e.clamp()),this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3),this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);e.compareTo(this.r2)<0;)e.dAddOffset(1,this.m.t+1);for(e.subTo(this.r2,e);e.compareTo(this.m)>=0;)e.subTo(this.m,e)},T.prototype.mulTo=function(e,t,i){e.multiplyTo(t,i),this.reduce(i)},T.prototype.sqrTo=function(e,t){e.squareTo(t),this.reduce(t)},r.prototype.copyTo=function(e){for(var t=this.t-1;t>=0;--t)e[t]=this[t];e.t=this.t,e.s=this.s},r.prototype.fromInt=function(e){this.t=1,this.s=e<0?-1:0,e>0?this[0]=e:e<-1?this[0]=e+DV:this.t=0},r.prototype.fromString=function(e,t,i){var s;switch(t){case 2:s=1;break;case 4:s=2;break;case 8:s=3;break;case 16:s=4;break;case 32:s=5;break;case 256:s=8;break;default:return void this.fromRadix(e,t)}this.t=0,this.s=0;for(var a=e.length,o=!1,n=0;--a>=0;){var d=8==s?255&e[a]:l(e,a);d<0?"-"==e.charAt(a)&&(o=!0):(o=!1,0===n?this[this.t++]=d:n+s>this.DB?(this[this.t-1]|=(d&(1<<this.DB-n)-1)<<n,this[this.t++]=d>>this.DB-n):this[this.t-1]|=d<<n,(n+=s)>=this.DB&&(n-=this.DB))}i||8!=s||0==(128&e[0])||(this.s=-1,n>0&&(this[this.t-1]|=(1<<this.DB-n)-1<<n)),this.clamp(),o&&r.ZERO.subTo(this,this)},r.prototype.fromByteArray=function(e,t){this.fromString(e,256,t)},r.prototype.fromBuffer=function(e){this.fromString(e,256,!0)},r.prototype.clamp=function(){for(var e=this.s&this.DM;this.t>0&&this[this.t-1]==e;)--this.t},r.prototype.dlShiftTo=function(e,t){var i;for(i=this.t-1;i>=0;--i)t[i+e]=this[i];for(i=e-1;i>=0;--i)t[i]=0;t.t=this.t+e,t.s=this.s},r.prototype.drShiftTo=function(e,t){for(var i=e;i<this.t;++i)t[i-e]=this[i];t.t=Math.max(this.t-e,0),t.s=this.s},r.prototype.lShiftTo=function(e,t){var i,s=e%this.DB,r=this.DB-s,a=(1<<r)-1,o=Math.floor(e/this.DB),n=this.s<<s&this.DM;for(i=this.t-1;i>=0;--i)t[i+o+1]=this[i]>>r|n,n=(this[i]&a)<<s;for(i=o-1;i>=0;--i)t[i]=0;t[o]=n,t.t=this.t+o+1,t.s=this.s,t.clamp()},r.prototype.rShiftTo=function(e,t){t.s=this.s;var i=Math.floor(e/this.DB);if(i>=this.t)t.t=0;else{var s=e%this.DB,r=this.DB-s,a=(1<<s)-1;t[0]=this[i]>>s;for(var o=i+1;o<this.t;++o)t[o-i-1]|=(this[o]&a)<<r,t[o-i]=this[o]>>s;s>0&&(t[this.t-i-1]|=(this.s&a)<<r),t.t=this.t-i,t.clamp()}},r.prototype.subTo=function(e,t){for(var i=0,s=0,r=Math.min(e.t,this.t);i<r;)s+=this[i]-e[i],t[i++]=s&this.DM,s>>=this.DB;if(e.t<this.t){for(s-=e.s;i<this.t;)s+=this[i],t[i++]=s&this.DM,s>>=this.DB;s+=this.s}else{for(s+=this.s;i<e.t;)s-=e[i],t[i++]=s&this.DM,s>>=this.DB;s-=e.s}t.s=s<0?-1:0,s<-1?t[i++]=this.DV+s:s>0&&(t[i++]=s),t.t=i,t.clamp()},r.prototype.multiplyTo=function(e,t){var i=this.abs(),s=e.abs(),a=i.t;for(t.t=a+s.t;--a>=0;)t[a]=0;for(a=0;a<s.t;++a)t[a+i.t]=i.am(0,s[a],t,a,0,i.t);t.s=0,t.clamp(),this.s!=e.s&&r.ZERO.subTo(t,t)},r.prototype.squareTo=function(e){for(var t=this.abs(),i=e.t=2*t.t;--i>=0;)e[i]=0;for(i=0;i<t.t-1;++i){var s=t.am(i,t[i],e,2*i,0,1);(e[i+t.t]+=t.am(i+1,2*t[i],e,2*i+1,s,t.t-i-1))>=t.DV&&(e[i+t.t]-=t.DV,e[i+t.t+1]=1)}e.t>0&&(e[e.t-1]+=t.am(i,t[i],e,2*i,0,1)),e.s=0,e.clamp()},r.prototype.divRemTo=function(e,t,i){var s=e.abs();if(!(s.t<=0)){var o=this.abs();if(o.t<s.t)return null!=t&&t.fromInt(0),void(null!=i&&this.copyTo(i));null==i&&(i=a());var n=a(),d=this.s,c=e.s,h=this.DB-f(s[s.t-1]);h>0?(s.lShiftTo(h,n),o.lShiftTo(h,i)):(s.copyTo(n),o.copyTo(i));var l=n.t,u=n[l-1];if(0!==u){var p=u*(1<<this.F1)+(l>1?n[l-2]>>this.F2:0),m=this.FV/p,y=(1<<this.F1)/p,b=1<<this.F2,v=i.t,g=v-l,w=null==t?a():t;for(n.dlShiftTo(g,w),i.compareTo(w)>=0&&(i[i.t++]=1,i.subTo(w,i)),r.ONE.dlShiftTo(l,w),w.subTo(n,n);n.t<l;)n[n.t++]=0;for(;--g>=0;){var k=i[--v]==u?this.DM:Math.floor(i[v]*m+(i[v-1]+b)*y);if((i[v]+=n.am(0,k,i,g,0,l))<k)for(n.dlShiftTo(g,w),i.subTo(w,i);i[v]<--k;)i.subTo(w,i)}null!=t&&(i.drShiftTo(l,t),d!=c&&r.ZERO.subTo(t,t)),i.t=l,i.clamp(),h>0&&i.rShiftTo(h,i),d<0&&r.ZERO.subTo(i,i)}}},r.prototype.invDigit=function(){if(this.t<1)return 0;var e=this[0];if(0==(1&e))return 0;var t=3&e;return(t=(t=(t=(t=t*(2-(15&e)*t)&15)*(2-(255&e)*t)&255)*(2-((65535&e)*t&65535))&65535)*(2-e*t%this.DV)%this.DV)>0?this.DV-t:-t},r.prototype.isEven=function(){return 0===(this.t>0?1&this[0]:this.s)},r.prototype.exp=function(e,t){if(e>4294967295||e<1)return r.ONE;var i=a(),s=a(),o=t.convert(this),n=f(e)-1;for(o.copyTo(i);--n>=0;)if(t.sqrTo(i,s),(e&1<<n)>0)t.mulTo(s,o,i);else{var d=i;i=s,s=d}return t.revert(i)},r.prototype.chunkSize=function(e){return Math.floor(Math.LN2*this.DB/Math.log(e))},r.prototype.toRadix=function(e){if(null==e&&(e=10),0===this.signum()||e<2||e>36)return"0";var t=this.chunkSize(e),i=Math.pow(e,t),s=u(i),r=a(),o=a(),n="";for(this.divRemTo(s,r,o);r.signum()>0;)n=(i+o.intValue()).toString(e).substr(1)+n,r.divRemTo(s,r,o);return o.intValue().toString(e)+n},r.prototype.fromRadix=function(e,t){this.fromInt(0),null==t&&(t=10);for(var i=this.chunkSize(t),s=Math.pow(t,i),a=!1,o=0,n=0,d=0;d<e.length;++d){var c=l(e,d);c<0?"-"==e.charAt(d)&&0===this.signum()&&(a=!0):(n=t*n+c,++o>=i&&(this.dMultiply(s),this.dAddOffset(n,0),o=0,n=0))}o>0&&(this.dMultiply(Math.pow(t,o)),this.dAddOffset(n,0)),a&&r.ZERO.subTo(this,this)},r.prototype.bitwiseTo=function(e,t,i){var s,r,a=Math.min(e.t,this.t);for(s=0;s<a;++s)i[s]=t(this[s],e[s]);if(e.t<this.t){for(r=e.s&this.DM,s=a;s<this.t;++s)i[s]=t(this[s],r);i.t=this.t}else{for(r=this.s&this.DM,s=a;s<e.t;++s)i[s]=t(r,e[s]);i.t=e.t}i.s=t(this.s,e.s),i.clamp()},r.prototype.addTo=function(e,t){for(var i=0,s=0,r=Math.min(e.t,this.t);i<r;)s+=this[i]+e[i],t[i++]=s&this.DM,s>>=this.DB;if(e.t<this.t){for(s+=e.s;i<this.t;)s+=this[i],t[i++]=s&this.DM,s>>=this.DB;s+=this.s}else{for(s+=this.s;i<e.t;)s+=e[i],t[i++]=s&this.DM,s>>=this.DB;s+=e.s}t.s=s<0?-1:0,s>0?t[i++]=s:s<-1&&(t[i++]=this.DV+s),t.t=i,t.clamp()},r.prototype.dMultiply=function(e){this[this.t]=this.am(0,e-1,this,0,0,this.t),++this.t,this.clamp()},r.prototype.dAddOffset=function(e,t){if(0!==e){for(;this.t<=t;)this[this.t++]=0;for(this[t]+=e;this[t]>=this.DV;)this[t]-=this.DV,++t>=this.t&&(this[this.t++]=0),++this[t]}},r.prototype.multiplyLowerTo=function(e,t,i){var s,r=Math.min(this.t+e.t,t);for(i.s=0,i.t=r;r>0;)i[--r]=0;for(s=i.t-this.t;r<s;++r)i[r+this.t]=this.am(0,e[r],i,r,0,this.t);for(s=Math.min(e.t,t);r<s;++r)this.am(0,e[r],i,r,0,t-r);i.clamp()},r.prototype.multiplyUpperTo=function(e,t,i){--t;var s=i.t=this.t+e.t-t;for(i.s=0;--s>=0;)i[s]=0;for(s=Math.max(t-this.t,0);s<e.t;++s)i[this.t+s-t]=this.am(t-s,e[s],i,0,0,this.t+s-t);i.clamp(),i.drShiftTo(1,i)},r.prototype.toString=function(e){if(this.s<0)return"-"+this.negate().toString(e);var t;if(16==e)t=4;else if(8==e)t=3;else if(2==e)t=1;else if(32==e)t=5;else{if(4!=e)return this.toRadix(e);t=2}var i,s=(1<<t)-1,r=!1,a="",o=this.t,n=this.DB-o*this.DB%t;if(o-- >0)for(n<this.DB&&(i=this[o]>>n)>0&&(r=!0,a=h(i));o>=0;)n<t?(i=(this[o]&(1<<n)-1)<<t-n,i|=this[--o]>>(n+=this.DB-t)):(i=this[o]>>(n-=t)&s,n<=0&&(n+=this.DB,--o)),i>0&&(r=!0),r&&(a+=h(i));return r?a:"0"},r.prototype.negate=function(){var e=a();return r.ZERO.subTo(this,e),e},r.prototype.abs=function(){return this.s<0?this.negate():this},r.prototype.compareTo=function(e){var t=this.s-e.s;if(0!=t)return t;var i=this.t;if(0!=(t=i-e.t))return this.s<0?-t:t;for(;--i>=0;)if(0!=(t=this[i]-e[i]))return t;return 0},r.prototype.bitLength=function(){return this.t<=0?0:this.DB*(this.t-1)+f(this[this.t-1]^this.s&this.DM)},r.prototype.mod=function(e){var t=a();return this.abs().divRemTo(e,null,t),this.s<0&&t.compareTo(r.ZERO)>0&&e.subTo(t,t),t},r.prototype.clone=function(){var e=a();return this.copyTo(e),e},r.prototype.intValue=function(){if(this.s<0){if(1==this.t)return this[0]-this.DV;if(0===this.t)return-1}else{if(1==this.t)return this[0];if(0===this.t)return 0}return(this[1]&(1<<32-this.DB)-1)<<this.DB|this[0]},r.prototype.signum=function(){return this.s<0?-1:this.t<=0||1==this.t&&this[0]<=0?0:1},r.prototype.toByteArray=function(){var e=this.t,t=new Array;t[0]=this.s;var i,s=this.DB-e*this.DB%8,r=0;if(e-- >0)for(s<this.DB&&(i=this[e]>>s)!=(this.s&this.DM)>>s&&(t[r++]=i|this.s<<this.DB-s);e>=0;)s<8?(i=(this[e]&(1<<s)-1)<<8-s,i|=this[--e]>>(s+=this.DB-8)):(i=this[e]>>(s-=8)&255,s<=0&&(s+=this.DB,--e)),0!=(128&i)&&(i|=-256),0===r&&(128&this.s)!=(128&i)&&++r,(r>0||i!=this.s)&&(t[r++]=i);return t},r.prototype.toBuffer=function(e){var t=Buffer.from(this.toByteArray());if(!0===e&&0===t[0])t=t.slice(1);else if(s.isNumber(e)){if(t.length>e){for(var i=0;i<t.length-e;i++)if(0!==t[i])return null;return t.slice(t.length-e)}if(t.length<e){var r=Buffer.alloc(e);return r.fill(0,0,e-t.length),t.copy(r,e-t.length),r}}return t},r.prototype.equals=function(e){return 0==this.compareTo(e)},r.prototype.min=function(e){return this.compareTo(e)<0?this:e},r.prototype.max=function(e){return this.compareTo(e)>0?this:e},r.prototype.and=function(e){var t=a();return this.bitwiseTo(e,y,t),t},r.prototype.or=function(e){var t=a();return this.bitwiseTo(e,b,t),t},r.prototype.xor=function(e){var t=a();return this.bitwiseTo(e,v,t),t},r.prototype.not=function(){for(var e=a(),t=0;t<this.t;++t)e[t]=this.DM&~this[t];return e.t=this.t,e.s=~this.s,e},r.prototype.getLowestSetBit=function(){for(var e=0;e<this.t;++e)if(0!=this[e])return e*this.DB+g(this[e]);return this.s<0?this.t*this.DB:-1},r.prototype.add=function(e){var t=a();return this.addTo(e,t),t},r.prototype.subtract=function(e){var t=a();return this.subTo(e,t),t},r.prototype.multiply=function(e){var t=a();return this.multiplyTo(e,t),t},r.prototype.divide=function(e){var t=a();return this.divRemTo(e,t,null),t},r.prototype.remainder=function(e){var t=a();return this.divRemTo(e,null,t),t},r.prototype.modPow=function(e,t){var i,s,r=e.bitLength(),o=u(1);if(r<=0)return o;i=r<18?1:r<48?3:r<144?4:r<768?5:6,s=r<8?new p(t):t.isEven()?new T(t):new m(t);var n=new Array,d=3,c=i-1,h=(1<<i)-1;if(n[1]=s.convert(this),i>1){var l=a();for(s.sqrTo(n[1],l);d<=h;)n[d]=a(),s.mulTo(l,n[d-2],n[d]),d+=2}var y,b,v=e.t-1,g=!0,w=a();for(r=f(e[v])-1;v>=0;){for(r>=c?y=e[v]>>r-c&h:(y=(e[v]&(1<<r+1)-1)<<c-r,v>0&&(y|=e[v-1]>>this.DB+r-c)),d=i;0==(1&y);)y>>=1,--d;if((r-=d)<0&&(r+=this.DB,--v),g)n[y].copyTo(o),g=!1;else{for(;d>1;)s.sqrTo(o,w),s.sqrTo(w,o),d-=2;d>0?s.sqrTo(o,w):(b=o,o=w,w=b),s.mulTo(w,n[y],o)}for(;v>=0&&0==(e[v]&1<<r);)s.sqrTo(o,w),b=o,o=w,w=b,--r<0&&(r=this.DB-1,--v)}return s.revert(o)},r.prototype.pow=function(e){return this.exp(e,new w)},r.prototype.gcd=function(e){var t=this.s<0?this.negate():this.clone(),i=e.s<0?e.negate():e.clone();if(t.compareTo(i)<0){var s=t;t=i,i=s}var r=t.getLowestSetBit(),a=i.getLowestSetBit();if(a<0)return t;for(r<a&&(a=r),a>0&&(t.rShiftTo(a,t),i.rShiftTo(a,i));t.signum()>0;)(r=t.getLowestSetBit())>0&&t.rShiftTo(r,t),(r=i.getLowestSetBit())>0&&i.rShiftTo(r,i),t.compareTo(i)>=0?(t.subTo(i,t),t.rShiftTo(1,t)):(i.subTo(t,i),i.rShiftTo(1,i));return a>0&&i.lShiftTo(a,i),i},r.int2char=h,r.ZERO=u(0),r.ONE=u(1),r.prototype.square=function(){var e=a();return this.squareTo(e),e},e.exports=r},function(e,t,i){e.exports={pkcs1:i(52),isEncryption:function(t){return e.exports[t]&&e.exports[t].isEncryption},isSignature:function(t){return e.exports[t]&&e.exports[t].isSignature}}},function(e,t,i){var s=i(56);e.exports={Ber:s,BerReader:s.Reader}},function(e,t){e.exports={newInvalidAsn1Error:function(e){var t=new Error;return t.name="InvalidAsn1Error",t.message=e||"",t}}},function(e,t){e.exports={EOC:0,Boolean:1,Integer:2,BitString:3,OctetString:4,Null:5,OID:6,ObjectDescriptor:7,External:8,Real:9,Enumeration:10,PDV:11,Utf8String:12,RelativeOID:13,Sequence:16,Set:17,NumericString:18,PrintableString:19,T61String:20,VideotexString:21,IA5String:22,UTCTime:23,GeneralizedTime:24,GraphicString:25,VisibleString:26,GeneralString:28,UniversalString:29,CharacterString:30,BMPString:31,Constructor:32,Context:128}},function(e,t,i){"use strict";var s=t,r=i(5);s.assert=function(e,t){if(!e)throw new Error(t)},s.getNAF=function(e,t){for(var i=[],s=1<<t+1,r=e.clone();r.cmpn(1)>=0;){var a;if(r.isOdd()){var o=r.andln(s-1);a=o>(s>>1)-1?(s>>1)-o:o,r.isubn(a)}else a=0;i.push(a);for(var n=0!==r.cmpn(0)&&0===r.andln(s-1)?t+1:1,d=1;d<n;d++)i.push(0);r.iushrn(n)}return i},s.getJSF=function(e,t){var i=[[],[]];e=e.clone(),t=t.clone();for(var s=0,r=0;e.cmpn(-s)>0||t.cmpn(-r)>0;){var a,o,n,d=e.andln(3)+s&3,c=t.andln(3)+r&3;3===d&&(d=-1),3===c&&(c=-1),a=0==(1&d)?0:3!=(n=e.andln(7)+s&7)&&5!==n||2!==c?d:-d,i[0].push(a),o=0==(1&c)?0:3!=(n=t.andln(7)+r&7)&&5!==n||2!==d?c:-c,i[1].push(o),2*s===a+1&&(s=1-s),2*r===o+1&&(r=1-r),e.iushrn(1),t.iushrn(1)}return i},s.cachedProperty=function(e,t,i){var s="_"+t;e.prototype[t]=function(){return void 0!==this[s]?this[s]:this[s]=i.call(this)}},s.parseBytes=function(e){return"string"==typeof e?s.toArray(e,"hex"):e},s.intFromLE=function(e){return new r(e,"hex","le")}},function(e,t,i){"use strict";const s=Date.now,r=setTimeout,a=(e,t,i=r,o=s()+t)=>{let n=()=>{},d=!0,c=i(()=>{d=!0;const t=o-s();t>0?n=a(e,t,i,o):e()},t);return function(){d&&(d=!1,clearTimeout(c)),n()}};class o extends Error{constructor(){super("timed out"),this.constructor=o,this.__proto__=o.prototype,this.message="timed out"}}const n=e=>{if("string"==typeof e&&e&&!e.match(/^[0-9]+$/)&&!(e.indexOf("-")<0||e.indexOf(":")<0))try{const t=Date.parse(e.indexOf("+")>=0||"Z"===e.slice(-1)?e:(e+"Z").replace(/\s(\d\d):/,"T$1:"));if(Number.isNaN(t))return;return t}catch(e){return}};e.exports={now:s,microseconds:()=>1e3*s(),seconds:()=>Math.floor(s()/1e3),iso8601:e=>{let t;if(t="number"==typeof e?Math.floor(e):parseInt(e,10),!(Number.isNaN(t)||t<0))try{return new Date(t).toISOString()}catch(e){return}},parse8601:n,parseDate:e=>{if("string"==typeof e&&e){if(e.indexOf("GMT")>=0)try{return Date.parse(e)}catch(e){return}return n(e)}},mdy:(e,t="-")=>{t=t||"";const i=new Date(e),s=i.getUTCFullYear().toString();let r=i.getUTCMonth()+1,a=i.getUTCDate();return(r=r<10?"0"+r:r.toString())+t+(a=a<10?"0"+a:a.toString())+t+s},ymd:(e,t="-")=>{t=t||"";const i=new Date(e),s=i.getUTCFullYear().toString();let r=i.getUTCMonth()+1,a=i.getUTCDate();return s+t+(r=r<10?"0"+r:r.toString())+t+(a=a<10?"0"+a:a.toString())},ymdhms:(e,t=" ")=>{const i=new Date(e),s=i.getUTCFullYear();let r=i.getUTCMonth()+1,a=i.getUTCDate(),o=i.getUTCHours(),n=i.getUTCMinutes(),d=i.getUTCSeconds();return s+"-"+(r=r<10?"0"+r:r)+"-"+(a=a<10?"0"+a:a)+t+(o=o<10?"0"+o:o)+":"+(n=n<10?"0"+n:n)+":"+(d=d<10?"0"+d:d)},setTimeout_safe:a,sleep:e=>new Promise(t=>a(t,e)),TimedOut:o,timeout:async(e,t)=>{let i=()=>{};const s=new Promise(t=>i=a(t,e));try{return await Promise.race([t,s.then(()=>{throw new o})])}finally{i()}}}},function(e,t,i){"use strict";const s=i(1),{InsufficientFunds:r,OrderNotFound:a}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"acx",name:"ACX",countries:["AU"],rateLimit:1e3,version:"v2",has:{CORS:!0,fetchTickers:!0,fetchOHLCV:!0,withdraw:!0,fetchOrder:!0},timeframes:{"1m":"1","5m":"5","15m":"15","30m":"30","1h":"60","2h":"120","4h":"240","12h":"720","1d":"1440","3d":"4320","1w":"10080"},urls:{logo:"https://user-images.githubusercontent.com/1294454/30247614-1fe61c74-9621-11e7-9e8c-f1a627afa279.jpg",extension:".json",api:"https://acx.io/api",www:"https://acx.io",doc:"https://acx.io/documents/api_v2"},api:{public:{get:["depth","k_with_pending_trades","k","markets","order_book","order_book/{market}","tickers","tickers/{market}","timestamp","trades","trades/{market}"]},private:{get:["members/me","deposits","deposit","deposit_address","orders","order","trades/my","withdraws","withdraw"],post:["orders","orders/multi","orders/clear","order/delete","withdraw"]}},fees:{trading:{tierBased:!1,percentage:!0,maker:.002,taker:.002},funding:{tierBased:!1,percentage:!0,withdraw:{}}},exceptions:{2002:r,2003:a}})}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),i=[];for(let e=0;e<t.length;e++){const s=t[e],r=s.id,a=s.name;let o=this.safeString(s,"base_unit"),n=this.safeString(s,"quote_unit");if(void 0===o||void 0===n){const e=a.split("/");o=e[0].toLowerCase(),n=e[1].toLowerCase()}let d=o.toUpperCase(),c=n.toUpperCase();d=this.safeCurrencyCode(d),c=this.safeCurrencyCode(c);const h={amount:8,price:8};i.push({id:r,symbol:a,base:d,quote:c,baseId:o,quoteId:n,precision:h,info:s})}return i}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetMembersMe(e),i=this.safeValue(t,"accounts"),s={info:i};for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeFloat(t,"balance"),o.used=this.safeFloat(t,"locked"),s[a]=o}return this.parseBalance(s)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={market:this.market(e).id};void 0!==t&&(s.limit=t);const r=await this.publicGetDepth(this.extend(s,i)),a=this.safeTimestamp(r,"timestamp");return this.parseOrderBook(r,a)}parseTicker(e,t){const i=this.safeTimestamp(e,"at");e=e.ticker;let s=void 0;t&&(s=t.symbol);const r=this.safeFloat(e,"last");return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"buy"),bidVolume:void 0,ask:this.safeFloat(e,"sell"),askVolume:void 0,vwap:void 0,open:this.safeFloat(e,"open"),close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeFloat(e,"vol"),quoteVolume:void 0,info:e}}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetTickers(t),s=Object.keys(i),r={};for(let e=0;e<s.length;e++){const t=s[e];let a=void 0,o=t;if(t in this.markets_by_id)o=(a=this.markets_by_id[t]).symbol;else{let e=t.slice(0,3),i=t.slice(3,6);e=e.toUpperCase(),i=i.toUpperCase(),o=(e=this.safeCurrencyCode(e))+"/"+(i=this.safeCurrencyCode(i))}r[o]=this.parseTicker(i[t],a)}return r}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={market:i.id},r=await this.publicGetTickersMarket(this.extend(s,t));return this.parseTicker(r,i)}parseTrade(e,t){const i=this.parse8601(this.safeString(e,"created_at")),s=this.safeString(e,"tid");let r=void 0;return void 0!==t&&(r=t.symbol),{info:e,id:s,timestamp:i,datetime:this.iso8601(i),symbol:r,type:void 0,side:void 0,order:void 0,takerOrMaker:void 0,price:this.safeFloat(e,"price"),amount:this.safeFloat(e,"volume"),cost:this.safeFloat(e,"funds"),fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={market:r.id},o=await this.publicGetTrades(this.extend(a,s));return this.parseTrades(o,r,t,i)}parseOHLCV(e,t,i="1m",s,r){return[1e3*e[0],e[1],e[2],e[3],e[4],e[5]]}async fetchOHLCV(e,t="1m",i,s,r={}){await this.loadMarkets();const a=this.market(e);void 0===s&&(s=500);const o={market:a.id,period:this.timeframes[t],limit:s};void 0!==i&&(o.timestamp=parseInt(i/1e3));const n=await this.publicGetK(this.extend(o,r));return this.parseOHLCVs(n,a,t,i,s)}parseOrderStatus(e){return this.safeString({done:"closed",wait:"open",cancel:"canceled"},e,e)}parseOrder(e,t){let i=void 0;if(void 0!==t)i=t.symbol;else{const t=this.safeString(e,"market");i=this.markets_by_id[t].symbol}const s=this.parse8601(this.safeString(e,"created_at")),r=this.parseOrderStatus(this.safeString(e,"state")),a=this.safeString(e,"type"),o=this.safeString(e,"side");return{id:this.safeString(e,"id"),timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,status:r,symbol:i,type:a,side:o,price:this.safeFloat(e,"price"),amount:this.safeFloat(e,"volume"),filled:this.safeFloat(e,"executed_volume"),remaining:this.safeFloat(e,"remaining_volume"),trades:void 0,fee:void 0,info:e}}async fetchOrder(e,t,i={}){await this.loadMarkets();const s={id:parseInt(e)},r=await this.privateGetOrder(this.extend(s,i));return this.parseOrder(r)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o={market:this.marketId(e),side:i,volume:s.toString(),ord_type:t};"limit"===t&&(o.price=r.toString());const n=await this.privatePostOrders(this.extend(o,a)),d=this.safeValue(n,"market"),c=this.safeValue(this.markets_by_id,d);return this.parseOrder(n,c)}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={id:e},r=await this.privatePostOrderDelete(this.extend(s,i)),o=this.parseOrder(r),n=o.status;if("closed"===n||"canceled"===n)throw new a(this.id+" "+this.json(o));return o}async withdraw(e,t,i,s,r={}){this.checkAddress(i),await this.loadMarkets();const a={currency:this.currency(e).id,sum:t,address:i};return{info:await this.privatePostWithdraw(this.extend(a,r)),id:void 0}}nonce(){return this.milliseconds()}encodeParams(e){if("orders"in e){const t=e.orders;let i=this.urlencode(this.keysort(this.omit(e,"orders")));for(let e=0;e<t.length;e++){const s=t[e],r=Object.keys(s);for(let e=0;e<r.length;e++){const t=r[e];i+="&orders%5B%5D%5B"+t+"%5D="+s[t].toString()}}return i}return this.urlencode(this.keysort(e))}sign(e,t="public",i="GET",s={},r,a){let o="/api/"+this.version+"/"+this.implodeParams(e,s);"extension"in this.urls&&(o+=this.urls.extension);const n=this.omit(s,this.extractParams(e));let d=this.urls.api+o;if("public"===t)Object.keys(n).length&&(d+="?"+this.urlencode(n));else{this.checkRequiredCredentials();const e=this.nonce().toString(),t=this.encodeParams(this.extend({access_key:this.apiKey,tonce:e},s)),n=i+"|"+o+"|"+t,c=t+"&signature="+this.hmac(this.encode(n),this.encode(this.secret));"GET"===i?d+="?"+c:(a=c,r={"Content-Type":"application/x-www-form-urlencoded"})}return{url:d,method:i,body:a,headers:r}}handleErrors(e,t,i,s,r,a,o,n,d){if(void 0!==o&&400===e){const e=this.safeValue(o,"error"),t=this.safeString(e,"code"),i=this.id+" "+this.json(o),s=this.exceptions;if(t in s)throw new s[t](i)}}}},function(e,t,i){"use strict";const s=i(31),{PermissionDenied:r,ExchangeError:a,ExchangeNotAvailable:o,OrderNotFound:n,InsufficientFunds:d,InvalidOrder:c}=i(0),{TRUNCATE:h,DECIMAL_PLACES:l}=i(2);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"hitbtc2",name:"HitBTC",countries:["HK"],rateLimit:1500,version:"2",has:{createDepositAddress:!0,fetchDepositAddress:!0,CORS:!0,editOrder:!0,fetchCurrencies:!0,fetchOHLCV:!0,fetchTickers:!0,fetchOrder:!0,fetchOrders:!1,fetchOpenOrders:!0,fetchClosedOrders:!0,fetchMyTrades:!0,withdraw:!0,fetchOrderTrades:!1,fetchDeposits:!1,fetchWithdrawals:!1,fetchTransactions:!0,fetchTradingFee:!0},timeframes:{"1m":"M1","3m":"M3","5m":"M5","15m":"M15","30m":"M30","1h":"H1","4h":"H4","1d":"D1","1w":"D7","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766555-8eaec20e-5edc-11e7-9c5b-6dc69fc42f5e.jpg",api:"https://api.hitbtc.com",www:"https://hitbtc.com",referral:"https://hitbtc.com/?ref_id=5a5d39a65d466",doc:["https://api.hitbtc.com","https://github.com/hitbtc-com/hitbtc-api/blob/master/APIv2.md"],fees:["https://hitbtc.com/fees-and-limits","https://support.hitbtc.com/hc/en-us/articles/115005148605-Fees-and-limits"]},api:{public:{get:["symbol","symbol/{symbol}","currency","currency/{currency}","ticker","ticker/{symbol}","trades/{symbol}","orderbook/{symbol}","candles/{symbol}"]},private:{get:["order","order/{clientOrderId}","trading/balance","trading/fee/all","trading/fee/{symbol}","history/trades","history/order","history/order/{id}/trades","account/balance","account/transactions","account/transactions/{id}","account/crypto/address/{currency}"],post:["order","account/crypto/withdraw","account/crypto/address/{currency}","account/transfer"],put:["order/{clientOrderId}","account/crypto/withdraw/{id}"],delete:["order","order/{clientOrderId}","account/crypto/withdraw/{id}"],patch:["order/{clientOrderId}"]}},fees:{trading:{tierBased:!1,percentage:!0,maker:.001,taker:.002},funding:{tierBased:!1,percentage:!1,withdraw:{BTC:.001,BCC:.0018,ETH:.00958,BCH:.0018,USDT:100,DASH:.03,BTG:5e-4,XRP:.509,LTC:.003,ZEC:1e-4,XMR:.09,"1ST":.84,ADX:5.7,AE:6.7,AEON:.01006,AIR:565,AMM:14,AMP:342,ANT:6.7,ARDR:1,ARN:18.5,ART:26,ATB:4e-4,ATL:27,ATM:504,ATS:860,AVT:1.9,BAS:113,BCN:.1,BET:124,BKB:46,BMC:32,BMT:100,BNT:2.57,BQX:4.7,BTCA:351.21,BTM:40,BTX:.04,BUS:.004,CAPP:97,CCT:6,CDT:100,CDX:30,CFI:61,CL:13.85,CLD:.88,CND:574,CNX:.04,COSS:65,CPAY:5.487,CSNO:16,CTR:15,CTX:146,CVC:8.46,DATA:12.949,DBIX:.0168,DCN:1280,DCT:.02,DDF:342,DENT:1e3,DGB:.4,DGD:.01,DICE:.32,DLT:.26,DNT:.21,DOGE:2,DOV:34,DRPU:24,DRT:240,DSH:.017,EBET:84,EBTC:20,EBTCOLD:6.6,ECAT:14,EDG:2,EDO:2.9,EKO:1136.36,ELE:.00172,ELM:.004,EMC:.03,MGO:14,ENJ:163,EOS:1.5,ERO:34,ETBS:15,ETC:.002,ETP:.004,EVX:5.4,EXN:456,FCN:5e-6,FRD:65,FUEL:123.00105,FUN:202.9598309,FYN:1.849,FYP:66.13,GAME:.004,GNO:.0034,GUP:4,GVT:1.2,HSR:.04,HAC:144,HDG:7,HGT:1082,HPC:.4,HVN:120,ICN:.55,ICO:34,ICOS:.35,IND:76,INDI:790,ITS:15.0012,IXT:11,KBR:143,KICK:112,KMD:4,LA:41,LEND:388,LAT:1.44,LIFE:13e3,LRC:27,LSK:.3,LOC:11.076,LUN:.34,MAID:5,MANA:143,MCAP:5.44,MIPS:43,MNE:1.33,MSP:121,MCO:.357,MTH:92,MYB:3.9,NDC:165,NEBL:.04,NET:3.96,NTO:998,NGC:2.368,NXC:13.39,NXT:3,OAX:15,ODN:.004,OMG:2,OPT:335,ORME:2.8,OTN:.57,PAY:3.1,PIX:96,PLBT:.33,PLR:114,PLU:.87,POE:784,POLL:3.5,PPT:2,PRE:32,PRG:39,PRO:41,PRS:60,PTOY:.5,QAU:63,QCN:.03,QTUM:.04,QVT:64,REP:.02,RKC:15,RLC:1.21,RVT:14,SC:30,SAN:2.24,SBD:.03,SCL:2.6,SISA:1640,SKIN:407,SWFTC:352.94,SMART:.4,SMS:.0375,SNC:36,SNGLS:4,SNM:48,SNT:233,STAR:.144,STORM:153.19,STEEM:.01,STRAT:.01,SPF:14.4,STU:14,STX:11,SUB:17,SUR:3,SWT:.51,TAAS:.91,TBT:2.37,TFL:15,TIME:.03,TIX:7.1,TKN:1,TGT:173,TKR:84,TNT:90,TRST:1.6,TRX:270,UET:480,UGT:15,UTT:3,VEN:14,VERI:.037,VIB:50,VIBE:145,VOISE:618,WEALTH:.0168,WINGS:2.4,WTC:.75,WRC:48,XAUR:3.23,XDN:.01,XEM:15,XUC:.9,YOYOW:140,ZAP:24,ZRX:23,ZSC:191},deposit:{BTC:0,ETH:0,BCH:0,USDT:0,BTG:0,LTC:0,ZEC:0,XMR:0,"1ST":0,ADX:0,AE:0,AEON:0,AIR:0,AMP:0,ANT:0,ARDR:0,ARN:0,ART:0,ATB:0,ATL:0,ATM:0,ATS:0,AVT:0,BAS:0,BCN:0,BET:0,BKB:0,BMC:0,BMT:0,BNT:0,BQX:0,BTM:0,BTX:0,BUS:0,CCT:0,CDT:0,CDX:0,CFI:0,CLD:0,CND:0,CNX:0,COSS:0,CSNO:0,CTR:0,CTX:0,CVC:0,DBIX:0,DCN:0,DCT:0,DDF:0,DENT:0,DGB:0,DGD:0,DICE:0,DLT:0,DNT:0,DOGE:0,DOV:0,DRPU:0,DRT:0,DSH:0,EBET:0,EBTC:0,EBTCOLD:0,ECAT:0,EDG:0,EDO:0,ELE:0,ELM:0,EMC:0,EMGO:0,ENJ:0,EOS:0,ERO:0,ETBS:0,ETC:0,ETP:0,EVX:0,EXN:0,FRD:0,FUEL:0,FUN:0,FYN:0,FYP:0,GNO:0,GUP:0,GVT:0,HAC:0,HDG:0,HGT:0,HPC:0,HVN:0,ICN:0,ICO:0,ICOS:0,IND:0,INDI:0,ITS:0,IXT:0,KBR:0,KICK:0,LA:0,LAT:0,LIFE:0,LRC:0,LSK:0,LUN:0,MAID:0,MANA:0,MCAP:0,MIPS:0,MNE:0,MSP:0,MTH:0,MYB:0,NDC:0,NEBL:0,NET:0,NTO:0,NXC:0,NXT:0,OAX:0,ODN:0,OMG:0,OPT:0,ORME:0,OTN:0,PAY:0,PIX:0,PLBT:0,PLR:0,PLU:0,POE:0,POLL:0,PPT:0,PRE:0,PRG:0,PRO:0,PRS:0,PTOY:0,QAU:0,QCN:0,QTUM:0,QVT:0,REP:0,RKC:0,RVT:0,SAN:0,SBD:0,SCL:0,SISA:0,SKIN:0,SMART:0,SMS:0,SNC:0,SNGLS:0,SNM:0,SNT:0,STEEM:0,STRAT:0,STU:0,STX:0,SUB:0,SUR:0,SWT:0,TAAS:0,TBT:0,TFL:0,TIME:0,TIX:0,TKN:0,TKR:0,TNT:0,TRST:0,TRX:0,UET:0,UGT:0,VEN:0,VERI:0,VIB:0,VIBE:0,VOISE:0,WEALTH:0,WINGS:0,WTC:0,XAUR:0,XDN:0,XEM:0,XUC:0,YOYOW:0,ZAP:0,ZRX:0,ZSC:0}}},options:{defaultTimeInForce:"FOK"},exceptions:{1003:r,2010:c,2011:c,2020:c,20002:n,20001:d}})}feeToPrecision(e,t){return this.decimalToPrecision(t,h,8,l)}async fetchMarkets(e={}){const t=await this.publicGetSymbol(e),i=[];for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"id"),a=this.safeString(s,"baseCurrency"),o=this.safeString(s,"quoteCurrency"),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o),c=n+"/"+d,h=this.safeFloat(s,"quantityIncrement"),l=this.safeFloat(s,"tickSize"),u={price:this.precisionFromString(s.tickSize),amount:-1*parseInt(Math.log10(h))},f=this.safeFloat(s,"takeLiquidityRate"),p=this.safeFloat(s,"provideLiquidityRate");i.push(this.extend(this.fees.trading,{info:s,id:r,symbol:c,base:n,quote:d,baseId:a,quoteId:o,active:!0,taker:f,maker:p,precision:u,limits:{amount:{min:h,max:void 0},price:{min:l,max:void 0},cost:{min:h*l,max:void 0}}}))}return i}async fetchCurrencies(e={}){const t=await this.publicGetCurrency(e),i={};for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"id"),a=8,o=this.safeCurrencyCode(r),n=this.safeValue(s,"payinEnabled"),d=this.safeValue(s,"payoutEnabled"),c=this.safeValue(s,"transferEnabled");let h=n&&d&&c;"disabled"in s&&s.disabled&&(h=!1);let l="fiat";"crypto"in s&&s.crypto&&(l="crypto");const u=this.safeString(s,"fullName");i[o]={id:r,code:o,type:l,payin:n,payout:d,transfer:c,info:s,name:u,active:h,fee:this.safeFloat(s,"payoutFee"),precision:a,limits:{amount:{min:Math.pow(10,-a),max:Math.pow(10,a)},price:{min:Math.pow(10,-a),max:Math.pow(10,a)},cost:{min:void 0,max:void 0},withdraw:{min:void 0,max:Math.pow(10,a)}}}}return i}async fetchTradingFee(e,t={}){await this.loadMarkets();const i=this.market(e),s=this.extend({symbol:i.id},this.omit(t,"symbol")),r=await this.privateGetTradingFeeSymbol(s);return{info:r,maker:this.safeFloat(r,"provideLiquidityRate"),taker:this.safeFloat(r,"takeLiquidityRate")}}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString(e,"type","trading"),i="privateGet"+this.capitalize(t)+"Balance",s=this.omit(e,"type"),r=await this[i](s),a={info:r};for(let e=0;e<r.length;e++){const t=r[e],i=this.safeString(t,"currency"),s=this.safeCurrencyCode(i),o=this.account();o.free=this.safeFloat(t,"available"),o.used=this.safeFloat(t,"reserved"),a[s]=o}return this.parseBalance(a)}parseOHLCV(e,t,i="1d",s,r){return[this.parse8601(e.timestamp),parseFloat(e.open),parseFloat(e.max),parseFloat(e.min),parseFloat(e.close),parseFloat(e.volume)]}async fetchOHLCV(e,t="1m",i,s,r={}){await this.loadMarkets();const a=this.market(e),o={symbol:a.id,period:this.timeframes[t]};void 0!==i&&(o.from=this.iso8601(i)),void 0!==s&&(o.limit=s);const n=await this.publicGetCandlesSymbol(this.extend(o,r));return this.parseOHLCVs(n,a,t,i,s)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={symbol:this.marketId(e)};void 0!==t&&(s.limit=t);const r=await this.publicGetOrderbookSymbol(this.extend(s,i));return this.parseOrderBook(r,void 0,"bid","ask","price","size")}parseTicker(e,t){const i=this.parse8601(e.timestamp);let s=void 0;void 0!==t&&(s=t.symbol);const r=this.safeFloat(e,"volume"),a=this.safeFloat(e,"volumeQuote"),o=this.safeFloat(e,"open"),n=this.safeFloat(e,"last");let d=void 0,c=void 0,h=void 0;void 0!==n&&void 0!==o&&(d=n-o,h=this.sum(n,o)/2,o>0&&(c=d/o*100));let l=void 0;return void 0!==a&&void 0!==r&&r>0&&(l=a/r),{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"bid"),bidVolume:void 0,ask:this.safeFloat(e,"ask"),askVolume:void 0,vwap:l,open:o,close:n,last:n,previousClose:void 0,change:d,percentage:c,average:h,baseVolume:r,quoteVolume:a,info:e}}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetTicker(t),s={};for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"symbol");if(void 0!==r)if(r in this.markets_by_id){const e=this.markets_by_id[r];s[e.symbol]=this.parseTicker(t,e)}else s[r]=this.parseTicker(t)}return s}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={symbol:i.id},r=await this.publicGetTickerSymbol(this.extend(s,t));if("message"in r)throw new a(this.id+" "+r.message);return this.parseTicker(r,i)}parseTrade(e,t){const i=this.parse8601(e.timestamp);let s=void 0;const r=this.safeString(e,"symbol");void 0!==r&&(s=r in this.markets_by_id?(t=this.markets_by_id[r]).symbol:r),void 0===s&&void 0!==t&&(s=t.symbol);let a=void 0;const o=this.safeFloat(e,"fee");if(void 0!==o){a={cost:o,currency:t?t.quote:void 0}}const n=this.safeString(e,"clientOrderId"),d=this.safeFloat(e,"price"),c=this.safeFloat(e,"quantity"),h=d*c,l=this.safeString(e,"side");return{info:e,id:this.safeString(e,"id"),order:n,timestamp:i,datetime:this.iso8601(i),symbol:s,type:void 0,side:l,takerOrMaker:void 0,price:d,amount:c,cost:h,fee:a}}async fetchTransactions(e,t,i,s={}){await this.loadMarkets();let r=void 0;const a={};void 0!==e&&(r=this.currency(e),a.asset=r.id),void 0!==t&&(a.startTime=t);const o=await this.privateGetAccountTransactions(this.extend(a,s));return this.parseTransactions(o,r,t,i)}parseTransaction(e,t){const i=this.safeString(e,"id"),s=this.parse8601(this.safeString(e,"createdAt")),r=this.parse8601(this.safeString(e,"updatedAt")),a=this.safeString(e,"currency"),o=this.safeCurrencyCode(a,t),n=this.parseTransactionStatus(this.safeString(e,"status")),d=this.safeFloat(e,"amount"),c=this.safeString(e,"address"),h=this.safeString(e,"hash");let l=void 0;const u=this.safeFloat(e,"fee");void 0!==u&&(l={cost:u,currency:o});const f=this.parseTransactionType(this.safeString(e,"type"));return{info:e,id:i,txid:h,timestamp:s,datetime:this.iso8601(s),address:c,tag:void 0,type:f,amount:d,currency:o,status:n,updated:r,fee:l}}parseTransactionStatus(e){return this.safeString({pending:"pending",failed:"failed",success:"ok"},e,e)}parseTransactionType(e){return this.safeString({payin:"deposit",payout:"withdrawal",withdraw:"withdrawal"},e,e)}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id};void 0!==i&&(a.limit=i),void 0!==t&&(a.sort="ASC",a.from=this.iso8601(t));const o=await this.publicGetTradesSymbol(this.extend(a,s));return this.parseTrades(o,r,t,i)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o=this.market(e);let n=this.uuid().split("-").join("");n=n.slice(0,32),s=parseFloat(s);const d={clientOrderId:n,symbol:o.id,side:i,quantity:this.amountToPrecision(e,s),type:t};"limit"===t?d.price=this.priceToPrecision(e,r):d.timeInForce=this.options.defaultTimeInForce;const h=await this.privatePostOrder(this.extend(d,a)),l=this.parseOrder(h);if("rejected"===l.status)throw new c(this.id+" order was rejected by the exchange "+this.json(l));const u=l.id;return this.orders[u]=l,l}async editOrder(e,t,i,s,r,a,o={}){await this.loadMarkets();let n=this.uuid().split("-").join("");const d={clientOrderId:e,requestClientId:n=n.slice(0,32)};void 0!==r&&(d.quantity=this.amountToPrecision(t,r)),void 0!==a&&(d.price=this.priceToPrecision(t,a));const c=await this.privatePatchOrderClientOrderId(this.extend(d,o)),h=this.parseOrder(c);return this.orders[h.id]=h,h}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={clientOrderId:e},r=await this.privateDeleteOrderClientOrderId(this.extend(s,i));return this.parseOrder(r)}parseOrderStatus(e){return this.safeString({new:"open",suspended:"open",partiallyFilled:"open",filled:"closed",canceled:"canceled",expired:"failed"},e,e)}parseOrder(e,t){const i=this.parse8601(this.safeString(e,"createdAt")),s=this.parse8601(this.safeString(e,"updatedAt")),r=this.safeString(e,"symbol");let a=void 0;void 0!==r&&(a=r in this.markets_by_id?(t=this.markets_by_id[r]).symbol:r),void 0===a&&void 0!==t&&(a=t.id);const o=this.safeFloat(e,"quantity"),n=this.safeFloat(e,"cumQuantity"),d=this.parseOrderStatus(this.safeString(e,"status")),c=this.safeString(e,"clientOrderId");let h=this.safeFloat(e,"price");void 0===h&&c in this.orders&&(h=this.orders[c].price);let l=void 0,u=void 0;void 0!==o&&void 0!==n&&(l=o-n,void 0!==h&&(u=n*h));const f=this.safeString(e,"type"),p=this.safeString(e,"side");let m=this.safeValue(e,"tradesReport"),y=void 0,b=void 0;if(void 0!==m){let e=void 0;const i=(m=this.parseTrades(m,t)).length;let s=0;for(let t=0;t<i;t++){void 0===e&&(e=0),s=this.sum(s,m[t].cost);const i=this.safeValue(m[t],"fee",{}),r=this.safeFloat(i,"cost");void 0!==r&&(e=this.sum(e,r))}u=s,void 0!==n&&n>0&&(b=u/n,"market"===f&&void 0===h&&(h=b)),void 0!==e&&(y={cost:e,currency:t.quote})}return{id:c,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:s,status:d,symbol:a,type:f,side:p,price:h,average:b,amount:o,cost:u,filled:n,remaining:l,fee:y,trades:m,info:e}}async fetchOrder(e,t,i={}){await this.loadMarkets();const s={clientOrderId:e},r=await this.privateGetHistoryOrder(this.extend(s,i));if(r.length>0)return this.parseOrder(r[0]);throw new n(this.id+" order "+e+" not found")}async fetchOpenOrder(e,t,i={}){await this.loadMarkets();const s={clientOrderId:e},r=await this.privateGetOrderClientOrderId(this.extend(s,i));return this.parseOrder(r)}async fetchOpenOrders(e,t,i,s={}){await this.loadMarkets();let r=void 0;const a={};void 0!==e&&(r=this.market(e),a.symbol=r.id);const o=await this.privateGetOrder(this.extend(a,s));return this.parseOrders(o,r,t,i)}async fetchClosedOrders(e,t,i,s={}){await this.loadMarkets();let r=void 0;const a={};void 0!==e&&(r=this.market(e),a.symbol=r.id),void 0!==i&&(a.limit=i),void 0!==t&&(a.from=this.iso8601(t));const o=await this.privateGetHistoryOrder(this.extend(a,s)),n=this.parseOrders(o,r),d=[];for(let e=0;e<n.length;e++){const t=n[e],i=t.status;"closed"!==i&&"canceled"!==i||d.push(t)}return this.filterBySinceLimit(d,t,i)}async fetchMyTrades(e,t,i,s={}){await this.loadMarkets();const r={};let a=void 0;void 0!==e&&(a=this.market(e),r.symbol=a.id),void 0!==t&&(r.from=this.iso8601(t)),void 0!==i&&(r.limit=i);const o=await this.privateGetHistoryTrades(this.extend(r,s));return this.parseTrades(o,a,t,i)}async fetchOrderTrades(e,t,i,s,r={}){await this.loadMarkets();let a=void 0;void 0!==t&&(a=this.market(t));const o={id:e},d=await this.privateGetHistoryOrderIdTrades(this.extend(o,r));if(d.length>0)return this.parseTrades(d,a,i,s);throw new n(this.id+" order "+e+" not found, "+this.id+'.fetchOrderTrades() requires an exchange-specific order id, you need to grab it from order["info"]["id"]')}async createDepositAddress(e,t={}){await this.loadMarkets();const i=this.currency(e),s={currency:i.id},r=await this.privatePostAccountCryptoAddressCurrency(this.extend(s,t)),a=this.safeString(r,"address");return this.checkAddress(a),{currency:i,address:a,tag:this.safeString(r,"paymentId"),info:r}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i=this.currency(e),s={currency:i.id},r=await this.privateGetAccountCryptoAddressCurrency(this.extend(s,t)),a=this.safeString(r,"address");this.checkAddress(a);const o=this.safeString(r,"paymentId");return{currency:i.code,address:a,tag:o,info:r}}async withdraw(e,t,i,s,r={}){await this.loadMarkets(),this.checkAddress(i);const a={currency:this.currency(e).id,amount:parseFloat(t),address:i};s&&(a.paymentId=s);const o=await this.privatePostAccountCryptoWithdraw(this.extend(a,r));return{info:o,id:o.id}}sign(e,t="public",i="GET",s={},r,a){let o="/api/"+this.version+"/";const n=this.omit(s,this.extractParams(e));if("public"===t)o+=t+"/"+this.implodeParams(e,s),Object.keys(n).length&&(o+="?"+this.urlencode(n));else{this.checkRequiredCredentials(),o+=this.implodeParams(e,s),"GET"===i?Object.keys(n).length&&(o+="?"+this.urlencode(n)):Object.keys(n).length&&(a=this.json(n));const t=this.encode(this.apiKey+":"+this.secret),d=this.stringToBase64(t);r={Authorization:"Basic "+this.decode(d),"Content-Type":"application/json"}}return{url:o=this.urls.api+o,method:i,body:a,headers:r}}handleErrors(e,t,i,s,r,n,d,h,l){if(void 0!==d&&e>=400){const t=this.id+" "+n;if(503===e||504===e)throw new o(t);if(429===e)return;if("{"===n[0]&&"error"in d){const e=this.safeString(d.error,"code"),i=this.exceptions;if(e in i)throw new i[e](t);if("Duplicate clientOrderId"===this.safeString(d.error,"message"))throw new c(t)}throw new a(t)}}}},function(e,t,i){"use strict";const s=i(1),{BadSymbol:r,ExchangeError:a,InsufficientFunds:o,OrderNotFound:n,InvalidOrder:d}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"hitbtc",name:"HitBTC",countries:["HK"],rateLimit:1500,version:"1",has:{CORS:!1,fetchTrades:!0,fetchTickers:!0,fetchOrder:!0,fetchOpenOrders:!0,fetchClosedOrders:!0,fetchOrderTrades:!0,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766555-8eaec20e-5edc-11e7-9c5b-6dc69fc42f5e.jpg",api:"https://api.hitbtc.com",www:"https://hitbtc.com",referral:"https://hitbtc.com/?ref_id=5a5d39a65d466",doc:"https://github.com/hitbtc-com/hitbtc-api/blob/master/APIv1.md",fees:["https://hitbtc.com/fees-and-limits","https://support.hitbtc.com/hc/en-us/articles/115005148605-Fees-and-limits"]},api:{public:{get:["{symbol}/orderbook","{symbol}/ticker","{symbol}/trades","{symbol}/trades/recent","symbols","ticker","time"]},trading:{get:["balance","orders/active","orders/recent","order","trades/by/order","trades"],post:["new_order","cancel_order","cancel_orders"]},payment:{get:["balance","address/{currency}","transactions","transactions/{transaction}"],post:["transfer_to_trading","transfer_to_main","address/{currency}","payout"]}},fees:{trading:{tierBased:!1,percentage:!0,maker:.07/100,taker:.07/100},funding:{tierBased:!1,percentage:!1,withdraw:{BTC:.001,BCC:.0018,ETH:.00215,BCH:.0018,USDT:100,DASH:.03,BTG:5e-4,LTC:.003,ZEC:1e-4,XMR:.09,"1ST":.84,ADX:5.7,AE:6.7,AEON:.01006,AIR:565,AMP:9,ANT:6.7,ARDR:1,ARN:18.5,ART:26,ATB:4e-4,ATL:27,ATM:504,ATS:860,AVT:1.9,BAS:113,BCN:.1,"DAO.Casino":124,BKB:46,BMC:32,BMT:100,BNT:2.57,BQX:4.7,BTM:40,BTX:.04,BUS:.004,CCT:115,CDT:100,CDX:30,CFI:61,CLD:.88,CND:574,CNX:.04,COSS:65,CSNO:16,CTR:15,CTX:146,CVC:8.46,DBIX:.0168,DCN:12e4,DCT:.02,DDF:342,DENT:6240,DGB:.4,DGD:.01,DICE:.32,DLT:.26,DNT:.21,DOGE:2,DOV:34,DRPU:24,DRT:240,DSH:.017,EBET:84,EBTC:20,EBTCOLD:6.6,ECAT:14,EDG:2,EDO:2.9,ELE:.00172,ELM:.004,EMC:.03,EMGO:14,ENJ:163,EOS:1.5,ERO:34,ETBS:15,ETC:.002,ETP:.004,EVX:5.4,EXN:456,FRD:65,FUEL:123.00105,FUN:202.9598309,FYN:1.849,FYP:66.13,GNO:.0034,GUP:4,GVT:1.2,HAC:144,HDG:7,HGT:1082,HPC:.4,HVN:120,ICN:.55,ICO:34,ICOS:.35,IND:76,INDI:5913,ITS:15.0012,IXT:11,KBR:143,KICK:112,LA:41,LAT:1.44,LIFE:13e3,LRC:27,LSK:.3,LUN:.34,MAID:5,MANA:143,MCAP:5.44,MIPS:43,MNE:1.33,MSP:121,MTH:92,MYB:3.9,NDC:165,NEBL:.04,NET:3.96,NTO:998,NXC:13.39,NXT:3,OAX:15,ODN:.004,OMG:2,OPT:335,ORME:2.8,OTN:.57,PAY:3.1,PIX:96,PLBT:.33,PLR:114,PLU:.87,POE:784,POLL:3.5,PPT:2,PRE:32,PRG:39,PRO:41,PRS:60,PTOY:.5,QAU:63,QCN:.03,QTUM:.04,QVT:64,REP:.02,RKC:15,RVT:14,SAN:2.24,SBD:.03,SCL:2.6,SISA:1640,SKIN:407,SMART:.4,SMS:.0375,SNC:36,SNGLS:4,SNM:48,SNT:233,STEEM:.01,STRAT:.01,STU:14,STX:11,SUB:17,SUR:3,SWT:.51,TAAS:.91,TBT:2.37,TFL:15,TIME:.03,TIX:7.1,TKN:1,TKR:84,TNT:90,TRST:1.6,TRX:1395,UET:480,UGT:15,VEN:14,VERI:.037,VIB:50,VIBE:145,VOISE:618,WEALTH:.0168,WINGS:2.4,WTC:.75,XAUR:3.23,XDN:.01,XEM:15,XUC:.9,YOYOW:140,ZAP:24,ZRX:23,ZSC:191},deposit:{BTC:6e-4,ETH:.003,BCH:0,USDT:0,BTG:0,LTC:0,ZEC:0,XMR:0,"1ST":0,ADX:0,AE:0,AEON:0,AIR:0,AMP:0,ANT:0,ARDR:0,ARN:0,ART:0,ATB:0,ATL:0,ATM:0,ATS:0,AVT:0,BAS:0,BCN:0,"DAO.Casino":0,BKB:0,BMC:0,BMT:0,BNT:0,BQX:0,BTM:0,BTX:0,BUS:0,CCT:0,CDT:0,CDX:0,CFI:0,CLD:0,CND:0,CNX:0,COSS:0,CSNO:0,CTR:0,CTX:0,CVC:0,DBIX:0,DCN:0,DCT:0,DDF:0,DENT:0,DGB:0,DGD:0,DICE:0,DLT:0,DNT:0,DOGE:0,DOV:0,DRPU:0,DRT:0,DSH:0,EBET:0,EBTC:0,EBTCOLD:0,ECAT:0,EDG:0,EDO:0,ELE:0,ELM:0,EMC:0,EMGO:0,ENJ:0,EOS:0,ERO:0,ETBS:0,ETC:0,ETP:0,EVX:0,EXN:0,FRD:0,FUEL:0,FUN:0,FYN:0,FYP:0,GNO:0,GUP:0,GVT:0,HAC:0,HDG:0,HGT:0,HPC:0,HVN:0,ICN:0,ICO:0,ICOS:0,IND:0,INDI:0,ITS:0,IXT:0,KBR:0,KICK:0,LA:0,LAT:0,LIFE:0,LRC:0,LSK:0,LUN:0,MAID:0,MANA:0,MCAP:0,MIPS:0,MNE:0,MSP:0,MTH:0,MYB:0,NDC:0,NEBL:0,NET:0,NTO:0,NXC:0,NXT:0,OAX:0,ODN:0,OMG:0,OPT:0,ORME:0,OTN:0,PAY:0,PIX:0,PLBT:0,PLR:0,PLU:0,POE:0,POLL:0,PPT:0,PRE:0,PRG:0,PRO:0,PRS:0,PTOY:0,QAU:0,QCN:0,QTUM:0,QVT:0,REP:0,RKC:0,RVT:0,SAN:0,SBD:0,SCL:0,SISA:0,SKIN:0,SMART:0,SMS:0,SNC:0,SNGLS:0,SNM:0,SNT:0,STEEM:0,STRAT:0,STU:0,STX:0,SUB:0,SUR:0,SWT:0,TAAS:0,TBT:0,TFL:0,TIME:0,TIX:0,TKN:0,TKR:0,TNT:0,TRST:0,TRX:0,UET:0,UGT:0,VEN:0,VERI:0,VIB:0,VIBE:0,VOISE:0,WEALTH:0,WINGS:0,WTC:0,XAUR:0,XDN:0,XEM:0,XUC:0,YOYOW:0,ZAP:0,ZRX:0,ZSC:0}}},commonCurrencies:{BET:"DAO.Casino",CAT:"BitClave",DRK:"DASH",EMGO:"MGO",GET:"Themis",HSR:"HC",LNC:"LinkerCoin",UNC:"Unigame",USD:"USDT",XBT:"BTC"},exceptions:{exact:{2001:r},broad:{}},options:{defaultTimeInForce:"FOK"}})}async fetchMarkets(e={}){const t=await this.publicGetSymbols(e),i=this.safeValue(t,"symbols"),s=[];for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"symbol"),a=this.safeString(t,"commodity"),o=this.safeString(t,"currency"),n=this.safeFloat(t,"lot"),d=this.safeFloat(t,"step"),c=this.safeCurrencyCode(a),h=this.safeCurrencyCode(o),l=c+"/"+h;s.push({info:t,id:r,symbol:l,base:c,quote:h,baseId:a,quoteId:o,lot:n,step:d,active:!0,maker:this.safeFloat(t,"provideLiquidityRate"),taker:this.safeFloat(t,"takeLiquidityRate"),precision:{amount:this.precisionFromString(t.lot),price:this.precisionFromString(t.step)},limits:{amount:{min:n,max:void 0},price:{min:d,max:void 0},cost:{min:void 0,max:void 0}}})}return s}async fetchBalance(e={}){await this.loadMarkets();let t=this.safeString(e,"type","trading");t+="GetBalance";const i=this.omit(e,"type"),s=await this[t](i),r=this.safeValue(s,"balance",[]),a={info:s};for(let e=0;e<r.length;e++){const t=r[e],i=this.safeString(t,"currency_code"),s=this.safeCurrencyCode(i),o=this.account();o.free=this.safeFloat2(t,"cash","balance"),o.used=this.safeFloat(t,"reserved"),a[s]=o}return this.parseBalance(a)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s=await this.publicGetSymbolOrderbook(this.extend({symbol:this.marketId(e)},i));return this.parseOrderBook(s)}parseTicker(e,t){const i=this.safeInteger(e,"timestamp");let s=void 0;t&&(s=t.symbol);const r=this.safeFloat(e,"last");return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"bid"),bidVolume:void 0,ask:this.safeFloat(e,"ask"),askVolume:void 0,vwap:void 0,open:this.safeFloat(e,"open"),close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeFloat(e,"volume"),quoteVolume:this.safeFloat(e,"volume_quote"),info:e}}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetTicker(t),s=Object.keys(i),r={};for(let e=0;e<s.length;e++){const t=s[e],a=this.markets_by_id[t],o=a.symbol,n=i[t];r[o]=this.parseTicker(n,a)}return r}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={symbol:i.id},r=await this.publicGetSymbolTicker(this.extend(s,t));if("message"in r)throw new a(this.id+" "+r.message);return this.parseTicker(r,i)}parseTrade(e,t){return Array.isArray(e)?this.parsePublicTrade(e,t):this.parseOrderTrade(e,t)}parsePublicTrade(e,t){let i=void 0;void 0!==t&&(i=t.symbol);let s=void 0;e.length>4&&(s=e[4]);const r=parseFloat(e[1]),a=parseFloat(e[2]),o=r*a;return{info:e,id:e[0].toString(),timestamp:e[3],datetime:this.iso8601(e[3]),symbol:i,type:void 0,side:s,order:void 0,takerOrMaker:void 0,price:r,amount:a,cost:o,fee:void 0}}parseOrderTrade(e,t){let i=void 0;void 0!==t&&(i=t.symbol);let s=this.safeFloat(e,"execQuantity");t&&(s*=t.lot);const r=this.safeFloat(e,"execPrice"),a=r*s,o={cost:this.safeFloat(e,"fee"),currency:void 0,rate:void 0},n=this.safeInteger(e,"timestamp"),d=this.safeString(e,"tradeId"),c=this.safeString(e,"clientOrderId"),h=this.safeString(e,"side");return{info:e,id:d,order:c,timestamp:n,datetime:this.iso8601(n),symbol:i,type:void 0,side:h,price:r,amount:s,cost:a,fee:o}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id};void 0!==t&&(a.by="ts",a.from=t),void 0!==i&&(a.max_results=i);const o=await this.publicGetSymbolTrades(this.extend(a,s));return this.parseTrades(o.trades,r,t,i)}async createOrder(e,t,i,s,r,o={}){await this.loadMarkets();const n=this.market(e),c=parseFloat(s)/n.lot,h=Math.round(c),l=c-h;if(Math.abs(l)>n.step)throw new a(this.id+" order amount should be evenly divisible by lot unit size of "+n.lot.toString());const u={clientOrderId:this.milliseconds().toString(),symbol:n.id,side:i,quantity:h.toString(),type:t};"limit"===t?u.price=this.priceToPrecision(e,r):u.timeInForce=this.options.defaultTimeInForce;const f=await this.tradingPostNewOrder(this.extend(u,o)),p=this.parseOrder(f.ExecutionReport,n);if("rejected"===p.status)throw new d(this.id+" order was rejected by the exchange "+this.json(p));return p}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={clientOrderId:e};return await this.tradingPostCancelOrder(this.extend(s,i))}parseOrderStatus(e){return this.safeString({new:"open",partiallyFilled:"open",filled:"closed",canceled:"canceled",rejected:"rejected",expired:"expired"},e)}parseOrder(e,t){let i=this.safeInteger(e,"lastTimestamp");void 0===i&&(i=this.safeInteger(e,"timestamp"));let s=void 0;void 0===t&&(t=this.markets_by_id[e.symbol]);const r=this.parseOrderStatus(this.safeString(e,"orderStatus"));let a=this.safeFloat(e,"orderPrice");a=this.safeFloat(e,"price",a),a=this.safeFloat(e,"avgPrice",a);let o=this.safeFloat(e,"orderQuantity");o=this.safeFloat(e,"quantity",o);let n=this.safeFloat(e,"quantityLeaves"),d=void 0,c=void 0;const h=void 0!==o,l=void 0!==(n=this.safeFloat(e,"leavesQuantity",n));if(void 0!==t)s=t.symbol,h&&(o*=t.lot),l&&(n*=t.lot);else{const i=this.safeString(e,"symbol");i in this.markets_by_id&&(t=this.markets_by_id[i])}h&&l&&(d=o-n,void 0!==a&&(c=a*d));const u=this.safeFloat(e,"fee");let f=void 0;void 0!==t&&(s=t.symbol,f=t.quote);const p={cost:u,currency:f,rate:void 0},m=this.safeString(e,"clientOrderId"),y=this.safeString(e,"type"),b=this.safeString(e,"side");return{id:m,info:e,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,status:r,symbol:s,type:y,side:b,price:a,cost:c,amount:o,filled:d,remaining:n,fee:p}}async fetchOrder(e,t,i={}){await this.loadMarkets();const s={clientOrderId:e},r=await this.tradingGetOrder(this.extend(s,i));if(r.orders[0])return this.parseOrder(r.orders[0]);throw new n(this.id+" fetchOrder() error: "+this.response)}async fetchOpenOrders(e,t,i,s={}){await this.loadMarkets();let r=void 0;const a={sort:"desc",statuses:["new","partiallyFiiled"].join(",")};void 0!==e&&(r=this.market(e),a.symbols=r.id);const o=await this.tradingGetOrdersActive(this.extend(a,s));return this.parseOrders(o.orders,r,t,i)}async fetchClosedOrders(e,t,i,s={}){await this.loadMarkets();let r=void 0;const a={sort:"desc",statuses:["filled","canceled","rejected","expired"].join(","),max_results:1e3};void 0!==e&&(r=this.market(e),a.symbols=r.id);const o=await this.tradingGetOrdersRecent(this.extend(a,s));return this.parseOrders(o.orders,r,t,i)}async fetchOrderTrades(e,t,i,s,r={}){await this.loadMarkets();let a=void 0;void 0!==t&&(a=this.market(t));const o={clientOrderId:e},n=await this.tradingGetTradesByOrder(this.extend(o,r));return this.parseTrades(n.trades,a,i,s)}async withdraw(e,t,i,s,r={}){this.checkAddress(i),await this.loadMarkets();const a={currency_code:this.currency(e).id,amount:t,address:i};void 0!==s&&(a.extra_id=s);const o=await this.paymentPostPayout(this.extend(a,r));return{info:o,id:o.transaction}}nonce(){return this.milliseconds()}sign(e,t="public",i="GET",s={},r,a){let o="/api/"+this.version+"/"+t+"/"+this.implodeParams(e,s),n=this.omit(s,this.extractParams(e));if("public"===t)Object.keys(n).length&&(o+="?"+this.urlencode(n));else{this.checkRequiredCredentials();const e={nonce:this.nonce(),apikey:this.apiKey};n=this.extend(e,n);let t=o+="GET"===i?"?"+this.urlencode(n):"?"+this.urlencode(e);"POST"===i&&Object.keys(n).length&&(t+=a=this.urlencode(n)),r={"Content-Type":"application/x-www-form-urlencoded","X-Signature":this.hmac(this.encode(t),this.encode(this.secret),"sha512").toLowerCase()}}return{url:o=this.urls.api+o,method:i,body:a,headers:r}}async request(e,t="public",i="GET",s={},r,n){const d=await this.fetch2(e,t,i,s,r,n);if("code"in d){if("ExecutionReport"in d&&"orderExceedsLimit"===d.ExecutionReport.orderRejectReason)throw new o(this.id+" "+this.json(d));throw new a(this.id+" "+this.json(d))}return d}handleErrors(e,t,i,s,r,o,n,d,c){if(!n)return;const h=this.safeValue(n,"error");if(h){const e=this.safeValue(h,"code"),t=this.id+" "+this.json(n),i=this.exceptions.exact;if(e in i)throw new i[e](t);const s=this.exceptions.broad,r=this.findBroadlyMatchedKey(s,h);if(void 0!==r)throw new s[r](t);throw new a(t)}}}},function(e,t,i){"use strict";const s=i(1),{NotSupported:r,DDoSProtection:a,AuthenticationError:o,PermissionDenied:n,ArgumentsRequired:d,ExchangeError:c,ExchangeNotAvailable:h,InsufficientFunds:l,InvalidOrder:u,OrderNotFound:f,InvalidNonce:p}=i(0),{SIGNIFICANT_DIGITS:m}=i(2);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"bitfinex",name:"Bitfinex",countries:["VG"],version:"v1",rateLimit:1500,certified:!0,has:{CORS:!1,cancelAllOrders:!0,createDepositAddress:!0,deposit:!0,fetchClosedOrders:!0,fetchDepositAddress:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchFundingFees:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchTickers:!0,fetchTransactions:!0,fetchDeposits:!1,fetchWithdrawals:!1,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","3h":"3h","6h":"6h","12h":"12h","1d":"1D","1w":"7D","2w":"14D","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766244-e328a50c-5ed2-11e7-947b-041416579bb3.jpg",api:{v2:"https://api-pub.bitfinex.com",public:"https://api.bitfinex.com",private:"https://api.bitfinex.com"},www:"https://www.bitfinex.com",doc:["https://docs.bitfinex.com/v1/docs","https://github.com/bitfinexcom/bitfinex-api-node"]},api:{v2:{get:["platform/status","tickers","ticker/{symbol}","trades/{symbol}/hist","book/{symbol}/{precision}","book/{symbol}/P0","book/{symbol}/P1","book/{symbol}/P2","book/{symbol}/P3","book/{symbol}/R0","stats1/{key}:{size}:{symbol}:{side}/{section}","stats1/{key}:{size}:{symbol}/{section}","stats1/{key}:{size}:{symbol}:long/last","stats1/{key}:{size}:{symbol}:long/hist","stats1/{key}:{size}:{symbol}:short/last","stats1/{key}:{size}:{symbol}:short/hist","candles/trade:{timeframe}:{symbol}/{section}","candles/trade:{timeframe}:{symbol}/last","candles/trade:{timeframe}:{symbol}/hist"]},public:{get:["book/{symbol}","lendbook/{currency}","lends/{currency}","pubticker/{symbol}","stats/{symbol}","symbols","symbols_details","tickers","trades/{symbol}"]},private:{post:["account_fees","account_infos","balances","basket_manage","credits","deposit/new","funding/close","history","history/movements","key_info","margin_infos","mytrades","mytrades_funding","offer/cancel","offer/new","offer/status","offers","offers/hist","order/cancel","order/cancel/all","order/cancel/multi","order/cancel/replace","order/new","order/new/multi","order/status","orders","orders/hist","position/claim","position/close","positions","summary","taken_funds","total_taken_funds","transfer","unused_taken_funds","withdraw"]}},fees:{trading:{tierBased:!0,percentage:!0,maker:.001,taker:.002,tiers:{taker:[[0,.002],[5e5,.002],[1e6,.002],[25e5,.002],[5e6,.002],[75e5,.002],[1e7,.0018],[15e6,.0016],[2e7,.14/100],[25e6,.0012],[3e7,.001]],maker:[[0,.001],[5e5,8e-4],[1e6,6e-4],[25e5,4e-4],[5e6,2e-4],[75e5,0],[1e7,0],[15e6,0],[2e7,0],[25e6,0],[3e7,0]]}},funding:{tierBased:!1,percentage:!1,deposit:{BTC:4e-4,IOTA:.5,ETH:.0027,BCH:1e-4,LTC:.001,EOS:.24279,XMR:.04,SAN:.99269,DASH:.01,ETC:.01,XRP:.02,YYW:16.915,NEO:0,ZEC:.001,BTG:0,OMG:.14026,DATA:20.773,QASH:1.9858,ETP:.01,QTUM:.01,EDO:.95001,AVT:1.3045,USDT:0,TRX:28.184,ZRX:1.9947,RCN:10.793,TNB:31.915,SNT:14.976,RLC:1.414,GNT:5.8952,SPK:10.893,REP:.041168,BAT:6.1546,ELF:1.8753,FUN:32.336,SNG:18.622,AID:8.08,MNA:16.617,NEC:1.6504,XTZ:.2},withdraw:{BTC:4e-4,IOTA:.5,ETH:.0027,BCH:1e-4,LTC:.001,EOS:.24279,XMR:.04,SAN:.99269,DASH:.01,ETC:.01,XRP:.02,YYW:16.915,NEO:0,ZEC:.001,BTG:0,OMG:.14026,DATA:20.773,QASH:1.9858,ETP:.01,QTUM:.01,EDO:.95001,AVT:1.3045,USDT:20,TRX:28.184,ZRX:1.9947,RCN:10.793,TNB:31.915,SNT:14.976,RLC:1.414,GNT:5.8952,SPK:10.893,REP:.041168,BAT:6.1546,ELF:1.8753,FUN:32.336,SNG:18.622,AID:8.08,MNA:16.617,NEC:1.6504,XTZ:.2}}},commonCurrencies:{ABS:"ABYSS",AIO:"AION",AMP:"AMPL",ATM:"ATMI",ATO:"ATOM",BAB:"BCH",CTX:"CTXC",DAD:"DADI",DAT:"DATA",DSH:"DASH",DRK:"DRK",GSD:"GUSD",HOT:"Hydro Protocol",IOS:"IOST",IOT:"IOTA",IQX:"IQ",MIT:"MITH",MNA:"MANA",NCA:"NCASH",ORS:"ORS Group",POY:"POLY",QSH:"QASH",QTM:"QTUM",SEE:"SEER",SNG:"SNGLS",SPK:"SPANK",STJ:"STORJ",TSD:"TUSD",YYW:"YOYOW",UDC:"USDC",UST:"USDT",UTN:"UTNP",VSY:"VSYS",XCH:"XCHF"},exceptions:{exact:{temporarily_unavailable:h,"Order could not be cancelled.":f,"No such order found.":f,"Order price must be positive.":u,"Could not find a key matching the given X-BFX-APIKEY.":o,'Key price should be a decimal number, e.g. "123.456"':u,'Key amount should be a decimal number, e.g. "123.456"':u,ERR_RATE_LIMIT:a,Ratelimit:a,"Nonce is too small.":p,"No summary found.":c,"Cannot evaluate your available balance, please try again":h},broad:{"This API key does not have permission":n,"Invalid order: not enough exchange balance for ":l,"Invalid order: minimum size for ":u,"Invalid order":u,"The available balance is only":l}},precisionMode:m,options:{currencyNames:{AGI:"agi",AID:"aid",AIO:"aio",ANT:"ant",AVT:"aventus",BAT:"bat",BCH:"bab",BCI:"bci",BFT:"bft",BTC:"bitcoin",BTG:"bgold",CFI:"cfi",DAI:"dai",DADI:"dad",DASH:"dash",DATA:"datacoin",DTH:"dth",EDO:"eidoo",ELF:"elf",EOS:"eos",ETC:"ethereumc",ETH:"ethereum",ETP:"metaverse",FUN:"fun",GNT:"golem",IOST:"ios",IOTA:"iota",LEO:"let",LRC:"lrc",LTC:"litecoin",LYM:"lym",MANA:"mna",MIT:"mit",MKR:"mkr",MTN:"mtn",NEO:"neo",ODE:"ode",OMG:"omisego",OMNI:"mastercoin",QASH:"qash",QTUM:"qtum",RCN:"rcn",RDN:"rdn",REP:"rep",REQ:"req",RLC:"rlc",SAN:"santiment",SNGLS:"sng",SNT:"status",SPANK:"spk",STORJ:"stj",TNB:"tnb",TRX:"trx",USD:"wire",USDC:"udc",UTK:"utk",USDT:"tetheruso",VEE:"vee",WAX:"wax",XLM:"xlm",XMR:"monero",XRP:"ripple",XVG:"xvg",YOYOW:"yoyow",ZEC:"zcash",ZRX:"zrx",XTZ:"tezos"},orderTypes:{limit:"exchange limit",market:"exchange market"}}})}async fetchFundingFees(e={}){await this.loadMarkets();const t=await this.privatePostAccountFees(e),i=t.withdraw,s={},r=Object.keys(i);for(let e=0;e<r.length;e++){const t=r[e];s[this.safeCurrencyCode(t)]=this.safeFloat(i,t)}return{info:t,withdraw:s,deposit:s}}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privatePostSummary(e);return{info:t,maker:this.safeFloat(t,"maker_fee"),taker:this.safeFloat(t,"taker_fee")}}async fetchMarkets(e={}){const t=await this.publicGetSymbols(),i=await this.publicGetSymbolsDetails(),s=[];for(let e=0;e<i.length;e++){const r=i[e];let a=this.safeString(r,"pair");if(!this.inArray(a,t))continue;let o=void 0,n=void 0;if((a=a.toUpperCase()).indexOf(":")>=0){const e=a.split(":");o=e[0],n=e[1]}else o=a.slice(0,3),n=a.slice(3,6);const d=this.safeCurrencyCode(o),c=this.safeCurrencyCode(n),h=d+"/"+c,l={price:r.price_precision,amount:void 0},u={amount:{min:this.safeFloat(r,"minimum_order_size"),max:this.safeFloat(r,"maximum_order_size")},price:{min:Math.pow(10,-l.price),max:Math.pow(10,l.price)}};u.cost={min:u.amount.min*u.price.min,max:void 0},s.push({id:a,symbol:h,base:d,quote:c,baseId:o,quoteId:n,active:!0,precision:l,limits:u,info:r})}return s}amountToPrecision(e,t){return this.numberToString(t)}calculateFee(e,t,i,s,r,a="taker",o={}){const n=this.markets[e],d=n[a];let c=s*d,h="quote";return"sell"===i?c*=r:h="base",{type:a,currency:n[h],rate:d,cost:parseFloat(this.currencyToPrecision(n[h],c))}}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString(e,"type","exchange"),i=this.omit(e,"type"),s=await this.privatePostBalances(i),r={info:s};for(let e=0;e<s.length;e++){const i=s[e];if(i.type===t){const e=this.safeString(i,"currency"),t=this.safeCurrencyCode(e);if(!(t in r)){const e=this.account();e.free=this.safeFloat(i,"available"),e.total=this.safeFloat(i,"amount"),r[t]=e}}}return this.parseBalance(r)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={symbol:this.marketId(e)};void 0!==t&&(s.limit_bids=t,s.limit_asks=t);const r=await this.publicGetBookSymbol(this.extend(s,i));return this.parseOrderBook(r,void 0,"bids","asks","price","amount")}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetTickers(t),s={};for(let e=0;e<i.length;e++){const t=this.parseTicker(i[e]);s[t.symbol]=t}return s}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={symbol:i.id},r=await this.publicGetPubtickerSymbol(this.extend(s,t));return this.parseTicker(r,i)}parseTicker(e,t){let i=this.safeFloat(e,"timestamp");void 0!==i&&(i*=1e3);let s=void 0;if(void 0!==t)s=t.symbol;else if("pair"in e){const i=this.safeString(e,"pair");if(i in this.markets_by_id&&(t=this.markets_by_id[i]),void 0!==t)s=t.symbol;else{const e=i.slice(0,3),t=i.slice(3,6);s=this.safeCurrencyCode(e)+"/"+this.safeCurrencyCode(t)}}const r=this.safeFloat(e,"last_price");return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"bid"),bidVolume:void 0,ask:this.safeFloat(e,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:this.safeFloat(e,"mid"),baseVolume:this.safeFloat(e,"volume"),quoteVolume:void 0,info:e}}parseTrade(e,t){const i=this.safeString(e,"tid");let s=this.safeFloat(e,"timestamp");void 0!==s&&(s=1e3*parseInt(s));const r=this.safeStringLower(e,"type"),a=this.safeString(e,"order_id"),o=this.safeFloat(e,"price"),n=this.safeFloat(e,"amount");let d=void 0;void 0!==o&&void 0!==n&&(d=o*n);let c=void 0;if("fee_amount"in e){const t=-this.safeFloat(e,"fee_amount"),i=this.safeString(e,"fee_currency");c={cost:t,currency:this.safeCurrencyCode(i)}}return{id:i,info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,type:void 0,order:a,side:r,takerOrMaker:void 0,price:o,amount:n,cost:d,fee:c}}async fetchTrades(e,t,i=50,s={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,limit_trades:i};void 0!==t&&(a.timestamp=parseInt(t/1e3));const o=await this.publicGetTradesSymbol(this.extend(a,s));return this.parseTrades(o,r,t,i)}async fetchMyTrades(e,t,i,s={}){if(void 0===e)throw new d(this.id+" fetchMyTrades requires a `symbol` argument");await this.loadMarkets();const r=this.market(e),a={symbol:r.id};void 0!==i&&(a.limit_trades=i),void 0!==t&&(a.timestamp=parseInt(t/1e3));const o=await this.privatePostMytrades(this.extend(a,s));return this.parseTrades(o,r,t,i)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o={symbol:this.marketId(e),side:i,amount:this.amountToPrecision(e,s),type:this.safeString(this.options.orderTypes,t,t),ocoorder:!1,buy_price_oco:0,sell_price_oco:0};o.price="market"===t?this.nonce().toString():this.priceToPrecision(e,r);const n=await this.privatePostOrderNew(this.extend(o,a));return this.parseOrder(n)}async editOrder(e,t,i,s,r,a,o={}){await this.loadMarkets();const n={order_id:e};void 0!==a&&(n.price=this.priceToPrecision(t,a)),void 0!==r&&(n.amount=this.numberToString(r)),void 0!==t&&(n.symbol=this.marketId(t)),void 0!==s&&(n.side=s),void 0!==i&&(n.type=this.safeString(this.options.orderTypes,i,i));const d=await this.privatePostOrderCancelReplace(this.extend(n,o));return this.parseOrder(d)}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={order_id:parseInt(e)};return await this.privatePostOrderCancel(this.extend(s,i))}async cancelAllOrders(e,t={}){return await this.privatePostOrderCancelAll(t)}parseOrder(e,t){const i=this.safeString(e,"side"),s=this.safeValue(e,"is_live"),r=this.safeValue(e,"is_cancelled");let a=void 0;a=s?"open":r?"canceled":"closed";let o=void 0;if(void 0===t){let i=this.safeString(e,"symbol");void 0!==i&&(i=i.toUpperCase())in this.markets_by_id&&(t=this.markets_by_id[i])}void 0!==t&&(o=t.symbol);let n=e.type;if(n.indexOf("exchange ")>=0){n=e.type.split(" ")[1]}let d=this.safeFloat(e,"timestamp");return void 0!==d&&(d=1e3*parseInt(d)),{info:e,id:this.safeString(e,"id"),timestamp:d,datetime:this.iso8601(d),lastTradeTimestamp:void 0,symbol:o,type:n,side:i,price:this.safeFloat(e,"price"),average:this.safeFloat(e,"avg_execution_price"),amount:this.safeFloat(e,"original_amount"),remaining:this.safeFloat(e,"remaining_amount"),filled:this.safeFloat(e,"executed_amount"),status:a,fee:void 0}}async fetchOpenOrders(e,t,i,s={}){if(await this.loadMarkets(),void 0!==e&&!(e in this.markets))throw new c(this.id+" has no symbol "+e);const r=await this.privatePostOrders(s);let a=this.parseOrders(r,void 0,t,i);return void 0!==e&&(a=this.filterBy(a,"symbol",e)),a}async fetchClosedOrders(e,t,i,s={}){await this.loadMarkets();const r={};void 0!==i&&(r.limit=i);const a=await this.privatePostOrdersHist(this.extend(r,s));let o=this.parseOrders(a,void 0,t,i);return void 0!==e&&(o=this.filterBy(o,"symbol",e)),o=this.filterByArray(o,"status",["closed","canceled"],!1)}async fetchOrder(e,t,i={}){await this.loadMarkets();const s={order_id:parseInt(e)},r=await this.privatePostOrderStatus(this.extend(s,i));return this.parseOrder(r)}parseOHLCV(e,t,i="1m",s,r){return[e[0],e[1],e[3],e[4],e[2],e[5]]}async fetchOHLCV(e,t="1m",i,s,r={}){await this.loadMarkets(),void 0===s&&(s=100);const a=this.market(e),o={symbol:"t"+a.id,timeframe:this.timeframes[t],sort:1,limit:s};void 0!==i&&(o.start=i);const n=await this.v2GetCandlesTradeTimeframeSymbolHist(this.extend(o,r));return this.parseOHLCVs(n,a,t,i,s)}getCurrencyName(e){if(e in this.options.currencyNames)return this.options.currencyNames[e];throw new r(this.id+" "+e+" not supported for withdrawal")}async createDepositAddress(e,t={}){await this.loadMarkets();const i=await this.fetchDepositAddress(e,this.extend({renew:1},t)),s=this.safeString(i,"address");return this.checkAddress(s),{info:i.info,currency:e,address:s,tag:void 0}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={method:this.getCurrencyName(e),wallet_name:"exchange",renew:0},s=await this.privatePostDepositNew(this.extend(i,t));let r=this.safeValue(s,"address"),a=void 0;return"address_pool"in s&&(a=r,r=s.address_pool),this.checkAddress(r),{currency:e,address:r,tag:a,info:s}}async fetchTransactions(e,t,i,s={}){if(void 0===e)throw new d(this.id+" fetchTransactions() requires a currency `code` argument");await this.loadMarkets();const r=this.currency(e),a={currency:r.id};void 0!==t&&(a.since=parseInt(t/1e3));const o=await this.privatePostHistoryMovements(this.extend(a,s));return this.parseTransactions(o,r,t,i)}parseTransaction(e,t){let i=this.safeFloat(e,"timestamp_created");void 0!==i&&(i=parseInt(1e3*i));let s=this.safeFloat(e,"timestamp");void 0!==s&&(s=parseInt(1e3*s));const r=this.safeString(e,"currency"),a=this.safeCurrencyCode(r,t),o=this.safeStringLower(e,"type"),n=this.parseTransactionStatus(this.safeString(e,"status"));let d=this.safeFloat(e,"fee");return void 0!==d&&(d=Math.abs(d)),{info:e,id:this.safeString(e,"id"),txid:this.safeString(e,"txid"),timestamp:i,datetime:this.iso8601(i),address:this.safeString(e,"address"),tag:void 0,type:o,amount:this.safeFloat(e,"amount"),currency:a,status:n,updated:s,fee:{currency:a,cost:d,rate:void 0}}}parseTransactionStatus(e){return this.safeString({SENDING:"pending",CANCELED:"canceled",ZEROCONFIRMED:"failed",COMPLETED:"ok"},e,e)}async withdraw(e,t,i,s,r={}){this.checkAddress(i);const a={withdraw_type:this.getCurrencyName(e),walletselected:"exchange",amount:t.toString(),address:i};void 0!==s&&(a.payment_id=s);const o=(await this.privatePostWithdraw(this.extend(a,r)))[0],n=this.safeString(o,"withdrawal_id"),d=this.safeString(o,"message"),h=this.findBroadlyMatchedKey(this.exceptions.broad,d);if(0===n){if(void 0!==h){throw new(0,this.exceptions.broad[h])(this.id+" "+d)}throw new c(this.id+" withdraw returned an id of zero: "+this.json(o))}return{info:o,id:n}}nonce(){return this.milliseconds()}sign(e,t="public",i="GET",s={},r,a){let o="/"+this.implodeParams(e,s);o="v2"===t?"/"+t+o:"/"+this.version+o;let n=this.omit(s,this.extractParams(e)),d=this.urls.api[t]+o;if(("public"===t||e.indexOf("/hist")>=0)&&Object.keys(n).length){const e="?"+this.urlencode(n);d+=e,o+=e}if("private"===t){this.checkRequiredCredentials();const e=this.nonce();n=this.extend({nonce:e.toString(),request:o},n),a=this.json(n),n=this.encode(a);const t=this.stringToBase64(n),i=this.encode(this.secret),s=this.hmac(t,i,"sha384");r={"X-BFX-APIKEY":this.apiKey,"X-BFX-PAYLOAD":this.decode(t),"X-BFX-SIGNATURE":s}}return{url:d,method:i,body:a,headers:r}}handleErrors(e,t,i,s,r,a,o,n,d){if(void 0!==o&&e>=400&&"{"===a[0]){const e=this.id+" "+this.json(o);let t=void 0;if("message"in o)t=o.message;else{if(!("error"in o))throw new c(e);t=o.error}const i=this.exceptions.exact;if(t in i)throw new i[t](e);const s=this.exceptions.broad,r=this.findBroadlyMatchedKey(s,t);if(void 0!==r)throw new s[r](e);throw new c(e)}}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,ArgumentsRequired:a,AuthenticationError:o,InsufficientFunds:n,OrderNotFound:d,ExchangeNotAvailable:c,DDoSProtection:h,InvalidOrder:l}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"zb",name:"ZB",countries:["CN"],rateLimit:1e3,version:"v1",has:{CORS:!1,createMarketOrder:!1,fetchDepositAddress:!0,fetchOrder:!0,fetchOrders:!0,fetchOpenOrders:!0,fetchOHLCV:!0,fetchTickers:!0,withdraw:!0},timeframes:{"1m":"1min","3m":"3min","5m":"5min","15m":"15min","30m":"30min","1h":"1hour","2h":"2hour","4h":"4hour","6h":"6hour","12h":"12hour","1d":"1day","3d":"3day","1w":"1week"},exceptions:{1001:r,1002:r,1003:o,1004:o,1005:o,1006:o,1009:c,2001:n,2002:n,2003:n,2005:n,2006:n,2007:n,2009:n,3001:d,3002:l,3003:l,3004:o,3005:r,3006:o,3007:o,3008:d,4001:c,4002:h},urls:{logo:"https://user-images.githubusercontent.com/1294454/32859187-cd5214f0-ca5e-11e7-967d-96568e2e2bd1.jpg",api:{public:"http://api.zb.cn/data",private:"https://trade.zb.cn/api"},www:"https://www.zb.com",doc:"https://www.zb.com/i/developer",fees:"https://www.zb.com/i/rate"},api:{public:{get:["markets","ticker","allTicker","depth","trades","kline"]},private:{get:["order","cancelOrder","getOrder","getOrders","getOrdersNew","getOrdersIgnoreTradeType","getUnfinishedOrdersIgnoreTradeType","getAccountInfo","getUserAddress","getWithdrawAddress","getWithdrawRecord","getChargeRecord","getCnyWithdrawRecord","getCnyChargeRecord","withdraw","getLeverAssetsInfo","getLeverBills","transferInLever","transferOutLever","loan","cancelLoan","getLoans","getLoanRecords","borrow","repay","getRepayments"]}},fees:{funding:{withdraw:{BTC:1e-4,BCH:6e-4,LTC:.005,ETH:.01,ETC:.01,BTS:3,EOS:1,QTUM:.01,HSR:.001,XRP:.1,USDT:"0.1%",QCASH:5,DASH:.002,BCD:0,UBTC:0,SBTC:0,INK:20,TV:.1,BTH:0,BCX:0,LBTC:0,CHAT:20,bitCNY:20,HLC:20,BTP:0,BCW:0}},trading:{maker:.002,taker:.002}},commonCurrencies:{ENT:"ENTCash"}})}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),i=Object.keys(t),s=[];for(let e=0;e<i.length;e++){const r=i[e],a=t[r],[o,n]=r.split("_"),d=this.safeCurrencyCode(o),c=this.safeCurrencyCode(n),h=d+"/"+c,l={amount:this.safeInteger(a,"amountScale"),price:this.safeInteger(a,"priceScale")};s.push({id:r,symbol:h,baseId:o,quoteId:n,base:d,quote:c,active:!0,precision:l,limits:{amount:{min:Math.pow(10,-l.amount),max:void 0},price:{min:Math.pow(10,-l.price),max:void 0},cost:{min:0,max:void 0}},info:a})}return s}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetGetAccountInfo(e),i=this.safeValue(t.result,"coins"),s={info:t};for(let e=0;e<i.length;e++){const t=i[e],r=this.account(),a=this.safeString(t,"key"),o=this.safeCurrencyCode(a);r.free=this.safeFloat(t,"available"),r.used=this.safeFloat(t,"freez"),s[o]=r}return this.parseBalance(s)}getMarketFieldName(){return"market"}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},s=await this.privateGetGetUserAddress(this.extend(i,t));let r=s.message.datas.key,a=void 0;if(r.indexOf("_")>=0){const e=r.split("_");r=e[0],a=e[1]}return{currency:e,address:r,tag:a,info:s}}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s=this.market(e),r={};r[this.getMarketFieldName()]=s.id;const a=await this.publicGetDepth(this.extend(r,i));return this.parseOrderBook(a)}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetAllTicker(t),s={},r={},a=Object.keys(this.marketsById);for(let e=0;e<a.length;e++){r[a[e].replace("_","")]=this.marketsById[a[e]]}const o=Object.keys(i);for(let e=0;e<o.length;e++){const t=r[o[e]];s[t.symbol]=this.parseTicker(i[o[e]],t)}return s}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={};s[this.getMarketFieldName()]=i.id;const r=(await this.publicGetTicker(this.extend(s,t))).ticker;return this.parseTicker(r,i)}parseTicker(e,t){const i=this.milliseconds();let s=void 0;void 0!==t&&(s=t.symbol);const r=this.safeFloat(e,"last");return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"buy"),bidVolume:void 0,ask:this.safeFloat(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeFloat(e,"vol"),quoteVolume:void 0,info:e}}async fetchOHLCV(e,t="1m",i,s,r={}){await this.loadMarkets();const a=this.market(e);void 0===s&&(s=1e3);const o={market:a.id,type:this.timeframes[t],limit:s};void 0!==i&&(o.since=i);const n=await this.publicGetKline(this.extend(o,r)),d=this.safeValue(n,"data",[]);return this.parseOHLCVs(d,a,t,i,s)}parseTrade(e,t){const i=this.safeTimestamp(e,"date");let s=this.safeString(e,"trade_type");s="bid"===s?"buy":"sell";const r=this.safeString(e,"tid"),a=this.safeFloat(e,"price"),o=this.safeFloat(e,"amount");let n=void 0;void 0!==a&&void 0!==o&&(n=a*o);let d=void 0;return void 0!==t&&(d=t.symbol),{info:e,id:r,timestamp:i,datetime:this.iso8601(i),symbol:d,type:void 0,side:s,order:void 0,takerOrMaker:void 0,price:a,amount:o,cost:n,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={};a[this.getMarketFieldName()]=r.id;const o=await this.publicGetTrades(this.extend(a,s));return this.parseTrades(o,r,t,i)}async createOrder(e,t,i,s,r,a={}){if("limit"!==t)throw new l(this.id+" allows limit orders only");await this.loadMarkets();const o={price:this.priceToPrecision(e,r),amount:this.amountToPrecision(e,s),tradeType:"buy"===i?"1":"0",currency:this.marketId(e)},n=await this.privateGetOrder(this.extend(o,a));return{info:n,id:n.id}}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={id:e.toString(),currency:this.marketId(t)};return await this.privateGetCancelOrder(this.extend(s,i))}async fetchOrder(e,t,i={}){if(void 0===t)throw new a(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const s={id:e.toString(),currency:this.marketId(t)},r=await this.privateGetGetOrder(this.extend(s,i));return this.parseOrder(r,void 0)}async fetchOrders(e,t,i=50,s={}){if(void 0===e)throw new r(this.id+"fetchOrders requires a symbol parameter");await this.loadMarkets();const a=this.market(e),o={currency:a.id,pageIndex:1,pageSize:i};let n="privateGetGetOrdersIgnoreTradeType";"tradeType"in s&&(n="privateGetGetOrdersNew");let c=void 0;try{c=await this[n](this.extend(o,s))}catch(e){if(e instanceof d)return[];throw e}return this.parseOrders(c,a,t,i)}async fetchOpenOrders(e,t,i=10,s={}){if(void 0===e)throw new r(this.id+"fetchOpenOrders requires a symbol parameter");await this.loadMarkets();const a=this.market(e),o={currency:a.id,pageIndex:1,pageSize:i};let n="privateGetGetUnfinishedOrdersIgnoreTradeType";"tradeType"in s&&(n="privateGetGetOrdersNew");let c=void 0;try{c=await this[n](this.extend(o,s))}catch(e){if(e instanceof d)return[];throw e}return this.parseOrders(c,a,t,i)}parseOrder(e,t){let i=this.safeInteger(e,"type");i=1===i?"buy":"sell";let s=void 0;const r=this.getCreateDateField();r in e&&(s=e[r]);let a=void 0;const o=this.safeString(e,"currency");o in this.markets_by_id&&(t=this.marketsById[o]),void 0!==t&&(a=t.symbol);const n=this.safeFloat(e,"price"),d=this.safeFloat(e,"trade_amount"),c=this.safeFloat(e,"total_amount");let h=void 0;void 0!==c&&void 0!==d&&(h=c-d);const l=this.safeFloat(e,"trade_money");let u=void 0;const f=this.parseOrderStatus(this.safeString(e,"status"));return void 0!==l&&void 0!==d&&d>0&&(u=l/d),{info:e,id:this.safeString(e,"id"),timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,symbol:a,type:"limit",side:i,price:n,average:u,cost:l,amount:c,filled:d,remaining:h,status:f,fee:void 0}}parseOrderStatus(e){return this.safeString({0:"open",1:"canceled",2:"closed",3:"open"},e,e)}getCreateDateField(){return"trade_date"}nonce(){return this.milliseconds()}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api[t];if("public"===t)o+="/"+this.version+"/"+e,Object.keys(s).length&&(o+="?"+this.urlencode(s));else{let t=this.keysort(this.extend({method:e,accesskey:this.apiKey},s));const i=this.nonce();t=this.keysort(t);const r=this.rawencode(t),a=this.hash(this.encode(this.secret),"sha1");o+="/"+e+"?"+r+"&"+("sign="+this.hmac(this.encode(r),this.encode(a),"md5")+"&reqTime="+i.toString())}return{url:o,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,o,n,d,h){if(void 0!==n&&"{"===o[0]){const e=this.id+" "+o;if("code"in n){const t=this.safeString(n,"code");if(t in this.exceptions){throw new(0,this.exceptions[t])(e)}if("1000"!==t)throw new r(e)}const t=this.safeValue(n,"result");if(void 0!==t&&!t){throw""===this.safeString(n,"message")?new c(e):new r(e)}}}}},function(e,t,i){"use strict";const s=i(1),{BadSymbol:r,ExchangeError:a,ExchangeNotAvailable:o,AuthenticationError:n,InvalidOrder:d,InsufficientFunds:c,OrderNotFound:h,DDoSProtection:l,PermissionDenied:u,AddressPending:f,OnMaintenance:p}=i(0),{TRUNCATE:m,DECIMAL_PLACES:y}=i(2);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"bittrex",name:"Bittrex",countries:["US"],version:"v1.1",rateLimit:1500,certified:!0,has:{CORS:!0,createMarketOrder:!1,fetchDepositAddress:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchMyTrades:"emulated",fetchOHLCV:!0,fetchOrder:!0,fetchOpenOrders:!0,fetchTickers:!0,withdraw:!0,fetchDeposits:!0,fetchWithdrawals:!0,fetchTransactions:!1},timeframes:{"1m":"oneMin","5m":"fiveMin","30m":"thirtyMin","1h":"hour","1d":"day"},hostname:"bittrex.com",urls:{logo:"https://user-images.githubusercontent.com/1294454/27766352-cf0b3c26-5ed5-11e7-82b7-f3826b7a97d8.jpg",api:{public:"https://{hostname}/api",account:"https://{hostname}/api",market:"https://{hostname}/api",v2:"https://{hostname}/api/v2.0/pub",v3:"https://api.bittrex.com/v3",v3public:"https://api.bittrex.com/v3"},www:"https://bittrex.com",doc:["https://bittrex.github.io/api/","https://bittrex.github.io/api/v3","https://www.npmjs.com/package/bittrex-node"],fees:["https://bittrex.zendesk.com/hc/en-us/articles/115003684371-BITTREX-SERVICE-FEES-AND-WITHDRAWAL-LIMITATIONS","https://bittrex.zendesk.com/hc/en-us/articles/115000199651-What-fees-does-Bittrex-charge-"]},api:{v3:{get:["account","addresses","addresses/{currencySymbol}","balances","balances/{currencySymbol}","currencies","currencies/{symbol}","deposits/open","deposits/closed","deposits/ByTxId/{txId}","deposits/{depositId}","orders/closed","orders/open","orders/{orderId}","ping","subaccounts/{subaccountId}","subaccounts","withdrawals/open","withdrawals/closed","withdrawals/ByTxId/{txId}","withdrawals/{withdrawalId}"],post:["addresses","orders","subaccounts","withdrawals"],delete:["orders/{orderId}","withdrawals/{withdrawalId}"]},v3public:{get:["markets","markets/summaries","markets/{marketSymbol}","markets/{marketSymbol}/summary","markets/{marketSymbol}/orderbook","markets/{marketSymbol}/trades","markets/{marketSymbol}/ticker","markets/{marketSymbol}/candles"]},v2:{get:["currencies/GetBTCPrice","market/GetTicks","market/GetLatestTick","Markets/GetMarketSummaries","market/GetLatestTick"]},public:{get:["currencies","markethistory","markets","marketsummaries","marketsummary","orderbook","ticker"]},account:{get:["balance","balances","depositaddress","deposithistory","order","orders","orderhistory","withdrawalhistory","withdraw"]},market:{get:["buylimit","buymarket","cancel","openorders","selllimit","sellmarket"]}},fees:{trading:{tierBased:!1,percentage:!0,maker:.0025,taker:.0025},funding:{tierBased:!1,percentage:!1,withdraw:{BTC:5e-4,LTC:.01,DOGE:2,VTC:.02,PPC:.02,FTC:.2,RDD:2,NXT:2,DASH:.05,POT:.002,BLK:.02,EMC2:.2,XMY:.2,GLD:2e-4,SLR:.2,GRS:.2},deposit:{BTC:0,LTC:0,DOGE:0,VTC:0,PPC:0,FTC:0,RDD:0,NXT:0,DASH:0,POT:0,BLK:0,EMC2:0,XMY:0,GLD:0,SLR:0,GRS:0}}},exceptions:{APISIGN_NOT_PROVIDED:n,INVALID_SIGNATURE:n,INVALID_CURRENCY:a,INVALID_PERMISSION:n,INSUFFICIENT_FUNDS:c,QUANTITY_NOT_PROVIDED:d,MIN_TRADE_REQUIREMENT_NOT_MET:d,ORDER_NOT_OPEN:h,INVALID_ORDER:d,UUID_INVALID:h,RATE_NOT_PROVIDED:d,WHITELIST_VIOLATION_IP:u,DUST_TRADE_DISALLOWED_MIN_VALUE:d,RESTRICTED_MARKET:r,"We are down for scheduled maintenance, but well be back up shortly.":p},options:{parseOrderStatus:!1,hasAlreadyAuthenticatedSuccessfully:!1,symbolSeparator:"-",tag:{NXT:!0,CRYPTO_NOTE_PAYMENTID:!0,BITSHAREX:!0,RIPPLE:!0,NEM:!0,STELLAR:!0,STEEM:!0},subaccountId:void 0,fetchClosedOrdersMethod:"fetch_closed_orders_v3",fetchClosedOrdersFilterBySince:!0},commonCurrencies:{BITS:"SWIFT",CPC:"Capricoin"}})}costToPrecision(e,t){return this.decimalToPrecision(t,m,this.markets[e].precision.price,y)}feeToPrecision(e,t){return this.decimalToPrecision(t,m,this.markets[e].precision.price,y)}async fetchMarkets(e={}){const t=await this.v3publicGetMarkets(e),i=[];for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"baseCurrencySymbol"),a=this.safeString(s,"quoteCurrencySymbol"),o=a+this.options.symbolSeparator+r,n=this.safeCurrencyCode(r),d=this.safeCurrencyCode(a),c=n+"/"+d,h={amount:8,price:this.safeInteger(s,"precision",8)},l="ONLINE"===this.safeString(s,"status");i.push({id:o,symbol:c,base:n,quote:d,baseId:r,quoteId:a,active:l,info:s,precision:h,limits:{amount:{min:this.safeFloat(s,"minTradeSize"),max:void 0},price:{min:Math.pow(10,-h.price),max:void 0}}})}return i}async fetchBalance(e={}){await this.loadMarkets();const t=await this.accountGetBalances(e),i=this.safeValue(t,"result"),s={info:i},r=this.indexBy(i,"Currency"),a=Object.keys(r);for(let e=0;e<a.length;e++){const t=a[e],i=this.safeCurrencyCode(t),o=this.account(),n=r[t];o.free=this.safeFloat(n,"Available"),o.total=this.safeFloat(n,"Balance"),s[i]=o}return this.parseBalance(s)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={market:this.marketId(e),type:"both"},r=await this.publicGetOrderbook(this.extend(s,i));let a=r.result;return"type"in i&&("buy"===i.type?a={buy:r.result,sell:[]}:"sell"===i.type&&(a={buy:[],sell:r.result})),this.parseOrderBook(a,void 0,"buy","sell","Rate","Quantity")}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),i=this.safeValue(t,"result",[]),s={};for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"Currency"),a=this.safeCurrencyCode(r),o=8,n=this.safeValue(t,"BaseAddress"),d=this.safeFloat(t,"TxFee");s[a]={id:r,code:a,address:n,info:t,type:t.CoinType,name:t.CurrencyLong,active:t.IsActive,fee:d,precision:o,limits:{amount:{min:Math.pow(10,-o),max:void 0},price:{min:Math.pow(10,-o),max:void 0},cost:{min:void 0,max:void 0},withdraw:{min:d,max:void 0}}}}return s}parseTicker(e,t){const i=this.parse8601(this.safeString(e,"TimeStamp"));let s=void 0;const r=this.safeString(e,"MarketName");void 0!==r&&(r in this.markets_by_id?t=this.markets_by_id[r]:s=this.parseSymbol(r)),void 0===s&&void 0!==t&&(s=t.symbol);const a=this.safeFloat(e,"PrevDay"),o=this.safeFloat(e,"Last");let n=void 0,d=void 0;return void 0!==o&&void 0!==a&&(n=o-a,a>0&&(d=n/a*100)),{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"High"),low:this.safeFloat(e,"Low"),bid:this.safeFloat(e,"Bid"),bidVolume:void 0,ask:this.safeFloat(e,"Ask"),askVolume:void 0,vwap:void 0,open:a,close:o,last:o,previousClose:void 0,change:n,percentage:d,average:void 0,baseVolume:this.safeFloat(e,"Volume"),quoteVolume:this.safeFloat(e,"BaseVolume"),info:e}}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetMarketsummaries(t),s=this.safeValue(i,"result"),r=[];for(let e=0;e<s.length;e++){const t=this.parseTicker(s[e]);r.push(t)}return this.filterByArray(r,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={market:i.id},r=(await this.publicGetMarketsummary(this.extend(s,t))).result[0];return this.parseTicker(r,i)}parseTrade(e,t){const i=this.parse8601(e.TimeStamp+"+00:00");let s=void 0;"BUY"===e.OrderType?s="buy":"SELL"===e.OrderType&&(s="sell");const r=this.safeString2(e,"Id","ID");let a=void 0;void 0!==t&&(a=t.symbol);let o=void 0;const n=this.safeFloat(e,"Price"),d=this.safeFloat(e,"Quantity");return void 0!==d&&void 0!==n&&(o=n*d),{info:e,timestamp:i,datetime:this.iso8601(i),symbol:a,id:r,order:void 0,type:"limit",takerOrMaker:void 0,side:s,price:n,amount:d,cost:o,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),o={market:r.id},n=await this.publicGetMarkethistory(this.extend(o,s));if("result"in n&&void 0!==n.result)return this.parseTrades(n.result,r,t,i);throw new a(this.id+" fetchTrades() returned undefined response")}parseOHLCV(e,t,i="1d",s,r){return[this.parse8601(e.T+"+00:00"),e.O,e.H,e.L,e.C,e.V]}async fetchOHLCV(e,t="1m",i,s,r={}){await this.loadMarkets();const a=this.market(e),o={tickInterval:this.timeframes[t],marketName:a.id},n=await this.v2GetMarketGetTicks(this.extend(o,r));if("result"in n&&n.result)return this.parseOHLCVs(n.result,a,t,i,s)}async fetchOpenOrders(e,t,i,s={}){await this.loadMarkets();const r={};let a=void 0;void 0!==e&&(a=this.market(e),r.market=a.id);const o=await this.marketGetOpenorders(this.extend(r,s)),n=this.safeValue(o,"result",[]),d=this.parseOrders(n,a,t,i);return this.filterBySymbol(d,e)}async createOrder(e,t,i,s,r,o={}){if("limit"!==t)throw new a(this.id+" allows limit orders only");await this.loadMarkets();const n=this.market(e),d="marketGet"+this.capitalize(i)+t,c={market:n.id,quantity:this.amountToPrecision(e,s),rate:this.priceToPrecision(e,r)},h=await this[d](this.extend(c,o)),l=this.getOrderIdField();return{info:h,id:this.safeString(h.result,l),symbol:e,type:t,side:i,status:"open"}}getOrderIdField(){return"uuid"}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={};s[this.getOrderIdField()]=e;const r=await this.marketGetCancel(this.extend(s,i));return this.extend(this.parseOrder(r),{status:"canceled"})}async fetchDeposits(e,t,i,s={}){await this.loadMarkets();const r={};let a=void 0;void 0!==e&&(a=this.currency(e),r.currency=a.id);const o=await this.accountGetDeposithistory(this.extend(r,s));return this.parseTransactions(o.result,a,void 0,i)}async fetchWithdrawals(e,t,i,s={}){await this.loadMarkets();const r={};let a=void 0;void 0!==e&&(a=this.currency(e),r.currency=a.id);const o=await this.accountGetWithdrawalhistory(this.extend(r,s));return this.parseTransactions(o.result,a,t,i)}parseTransaction(e,t){const i=this.safeString2(e,"Id","PaymentUuid"),s=this.safeFloat(e,"Amount"),r=this.safeString2(e,"CryptoAddress","Address"),a=this.safeString(e,"TxId"),o=this.parse8601(this.safeString(e,"LastUpdated")),n=this.parse8601(this.safeString(e,"Opened")),d=n||o,c=void 0===n?"deposit":"withdrawal",h=this.safeString(e,"Currency"),l=this.safeCurrencyCode(h,t);let u="pending";if("deposit"===c)u="ok";else{const t=this.safeValue(e,"Authorized",!1),i=this.safeValue(e,"PendingPayment",!1),s=this.safeValue(e,"Canceled",!1);this.safeValue(e,"InvalidAddress",!1)?u="failed":s?u="canceled":i?u="pending":t&&void 0!==a&&(u="ok")}let f=this.safeFloat(e,"TxCost");return void 0===f&&"deposit"===c&&(f=0),{info:e,id:i,currency:l,amount:s,address:r,tag:void 0,status:u,type:c,updated:o,txid:a,timestamp:d,datetime:this.iso8601(d),fee:{currency:l,cost:f}}}parseSymbol(e){const[t,i]=e.split(this.options.symbolSeparator);return this.safeCurrencyCode(i)+"/"+this.safeCurrencyCode(t)}parseOrder(e,t){return"marketSymbol"in e?this.parseOrderV3(e,t):this.parseOrderV2(e,t)}parseOrders(e,t,i,s,r={}){return this.options.fetchClosedOrdersFilterBySince?super.parseOrders(e,t,i,s,r):super.parseOrders(e,t,void 0,s,r)}parseOrderStatus(e){return this.safeString({CLOSED:"closed",OPEN:"open",CANCELLED:"canceled",CANCELED:"canceled"},e,e)}parseOrderV3(e,t){const i=this.safeString(e,"marketSymbol");let s=void 0,r=void 0;if(void 0!==i){const[e,t]=i.split("-"),a=this.safeCurrencyCode(e),o=this.safeCurrencyCode(t);s=a+"/"+o,r=o}const a=this.safeStringLower(e,"direction"),o=this.safeString(e,"createdAt"),n=this.safeString(e,"updatedAt"),d=this.safeString(e,"closedAt");let c=void 0;void 0!==d?c=this.parse8601(d):n&&(c=this.parse8601(n));const h=this.parse8601(o),l=this.safeStringLower(e,"type"),u=this.safeFloat(e,"quantity"),f=this.safeFloat(e,"limit"),p=this.safeFloat(e,"fillQuantity"),m=this.safeFloat(e,"commission"),y=this.safeFloat(e,"proceeds"),b=this.safeStringLower(e,"status");let v=void 0,g=void 0;return void 0!==p&&(void 0!==y&&(p>0?v=y/p:0===y&&(v=0)),void 0!==u&&(g=u-p)),{id:this.safeString(e,"id"),timestamp:h,datetime:this.iso8601(h),lastTradeTimestamp:c,symbol:s,type:l,side:a,price:f,cost:y,average:v,amount:u,filled:p,remaining:g,status:b,fee:{cost:m,currency:r},info:e}}parseOrderV2(e,t){let i=this.safeString2(e,"OrderType","Type");const s="LIMIT_SELL"===i||"SELL"===i;("LIMIT_BUY"===i||"BUY"===i)&&(i="buy"),s&&(i="sell");let r=void 0;"Opened"in e&&e.Opened&&(r="open"),"Closed"in e&&e.Closed&&(r="closed"),"CancelInitiated"in e&&e.CancelInitiated&&(r="canceled"),"Status"in e&&this.options.parseOrderStatus&&(r=this.parseOrderStatus(this.safeString(e,"Status")));let a=void 0;if("Exchange"in e){const i=this.safeString(e,"Exchange");void 0!==i&&(a=i in this.markets_by_id?(t=this.markets_by_id[i]).symbol:this.parseSymbol(i))}else void 0!==t&&(a=t.symbol);let o=void 0;const n=this.safeString(e,"Opened");void 0!==n&&(o=this.parse8601(n+"+00:00"));const d=this.safeString(e,"Created");void 0!==d&&(o=this.parse8601(d+"+00:00"));let c=void 0;const h=this.safeString(e,"TimeStamp");void 0!==h&&(c=this.parse8601(h+"+00:00"));const l=this.safeString(e,"Closed");void 0!==l&&(c=this.parse8601(l+"+00:00")),void 0===o&&(o=c);let u=void 0;const f=this.safeFloat2(e,"Commission","CommissionPaid");if(void 0!==f)if(u={cost:f},void 0!==t)u.currency=t.quote;else if(void 0!==a){const e=a.split("/")[1];u.currency=this.safeCurrencyCode(e)}let p=this.safeFloat(e,"Limit"),m=this.safeFloat(e,"Price");const y=this.safeFloat(e,"Quantity"),b=this.safeFloat(e,"QuantityRemaining");let v=void 0;void 0!==y&&void 0!==b&&(v=y-b,"closed"===r&&b>0&&(r="canceled")),m||p&&v&&(m=p*v),p||m&&v&&(p=m/v);const g=this.safeFloat(e,"PricePerUnit");return{info:e,id:this.safeString2(e,"OrderUuid","OrderId"),timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:c,symbol:a,type:"limit",side:i,price:p,cost:m,average:g,amount:y,filled:v,remaining:b,status:r,fee:u}}async fetchOrder(e,t,i={}){await this.loadMarkets();let s=void 0;try{const t=this.getOrderIdField(),r={};r[t]=e,s=await this.accountGetOrder(this.extend(r,i))}catch(e){if(this.last_json_response){if("UUID_INVALID"===this.safeString(this.last_json_response,"message"))throw new h(this.id+" fetchOrder() error: "+this.last_http_response)}throw e}if(!s.result)throw new h(this.id+" order "+e+" not found");return this.parseOrder(s.result)}orderToTrade(e){const t=this.safeInteger2(e,"lastTradeTimestamp","timestamp");return{id:this.safeString(e,"id"),side:this.safeString(e,"side"),order:this.safeString(e,"id"),price:this.safeFloat(e,"average"),amount:this.safeFloat(e,"filled"),cost:this.safeFloat(e,"cost"),symbol:this.safeString(e,"symbol"),timestamp:t,datetime:this.iso8601(t),fee:this.safeValue(e,"fee"),info:e}}ordersToTrades(e){const t=[];for(let i=0;i<e.length;i++)t.push(this.orderToTrade(e[i]));return t}async fetchMyTrades(e,t,i,s={}){const r=await this.fetchClosedOrders(e,t,i,s);return this.ordersToTrades(r)}async fetchClosedOrders(e,t,i,s={}){const r=this.safeString(this.options,"fetchClosedOrdersMethod","fetch_closed_orders_v3");return await this[r](e,t,i,s)}async fetchClosedOrdersV2(e,t,i,s={}){await this.loadMarkets();const r={};let a=void 0;void 0!==e&&(a=this.market(e),r.market=a.id);const o=await this.accountGetOrderhistory(this.extend(r,s)),n=this.safeValue(o,"result",[]),d=this.parseOrders(n,a,t,i);return void 0!==e?this.filterBySymbol(d,e):d}async fetchClosedOrdersV3(e,t,i,s={}){await this.loadMarkets();const r={};void 0!==i&&(r.pageSize=i),void 0!==t&&(r.startDate=this.ymdhms(t,"T")+"Z");let a=void 0;void 0!==e&&(a=this.market(e),r.marketSymbol=a.base+"-"+a.quote);const o=await this.v3GetOrdersClosed(this.extend(r,s)),n=this.parseOrders(o,a,t,i);return void 0!==e?this.filterBySymbol(n,e):n}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i=this.currency(e),s={currency:i.id},r=await this.accountGetDepositaddress(this.extend(s,t));let a=this.safeString(r.result,"Address");const o=this.safeString(r,"message");if(!a||"ADDRESS_GENERATING"===o)throw new f(this.id+" the address for "+e+" is being generated (pending, not ready yet, retry again later)");let n=void 0;return i.type in this.options.tag&&(n=a,a=i.address),this.checkAddress(a),{currency:e,address:a,tag:n,info:r}}async withdraw(e,t,i,s,r={}){this.checkAddress(i),await this.loadMarkets();const a={currency:this.currency(e).id,quantity:t,address:i};void 0!==s&&(a.paymentid=s);const o=await this.accountGetWithdraw(this.extend(a,r)),n=this.safeValue(o,"result",{});return{info:o,id:this.safeString(n,"uuid")}}sign(e,t="public",i="GET",s={},r,a){let o=this.implodeParams(this.urls.api[t],{hostname:this.hostname})+"/";if("v2"!==t&&"v3"!==t&&"v3public"!==t&&(o+=this.version+"/"),"public"===t)o+=t+"/"+i.toLowerCase()+e,Object.keys(s).length&&(o+="?"+this.urlencode(s));else if("v3public"===t)o+=e,Object.keys(s).length&&(o+="?"+this.urlencode(s));else if("v2"===t)o+=e,Object.keys(s).length&&(o+="?"+this.urlencode(s));else if("v3"===t){o+=e,Object.keys(s).length&&(o+="?"+this.rawencode(s));const t=this.hash(this.encode(""),"sha512","hex"),a=this.milliseconds().toString();let n=a+o+i+t;const d=this.safeValue(this.options,"subaccountId");void 0!==d&&(n+=d);const c=this.hmac(this.encode(n),this.encode(this.secret),"sha512");r={"Api-Key":this.apiKey,"Api-Timestamp":a,"Api-Content-Hash":t,"Api-Signature":c},void 0!==d&&(r["Api-Subaccount-Id"]=d)}else{this.checkRequiredCredentials(),o+=t+"/",("account"===t&&"withdraw"!==e||"openorders"===e)&&(o+=i.toLowerCase());const a={apikey:this.apiKey},n=this.safeValue(this.options,"disableNonce");void 0!==n&&n||(a.nonce=this.nonce()),o+=e+"?"+this.urlencode(this.extend(a,s)),r={apisign:this.hmac(this.encode(o),this.encode(this.secret),"sha512")}}return{url:o,method:i,body:a,headers:r}}handleErrors(e,t,i,s,r,d,c,u,f){if(void 0!==c&&"{"===d[0]){let e=this.safeValue(c,"success");if(void 0===e)throw new a(this.id+": malformed response: "+this.json(c));if("string"==typeof e&&(e="true"===e),!e){const e=this.safeString(c,"message"),t=this.id+" "+this.json(c),s=this.exceptions;if("APIKEY_INVALID"===e)throw this.options.hasAlreadyAuthenticatedSuccessfully?new l(t):new n(t);if("INVALID_ORDER"===e){const e="cancel";if(i.indexOf(e)>=0){const e=i.split("?");if(e.length>1){const t=e[1].split("&"),i=t.length;let s=void 0;for(let e=0;e<i;e++){const i=t[e].split("=");if("uuid"===i[0]){s=i[1];break}}throw new h(void 0!==s?this.id+" cancelOrder "+s+" "+this.json(c):this.id+" cancelOrder "+this.json(c))}}}if(e in s)throw new s[e](t);if(void 0!==e){if(e.indexOf("throttled. Try again")>=0)throw new l(t);if(e.indexOf("problem")>=0)throw new o(t)}throw new a(t)}}}async request(e,t="public",i="GET",s={},r,a){const o=await this.fetch2(e,t,i,s,r,a);return"account"!==t&&"market"!==t||(this.options.hasAlreadyAuthenticatedSuccessfully=!0),o}}},function(e,t,i){"use strict";const s=i(1),{InsufficientFunds:r,ArgumentsRequired:a,ExchangeError:o,InvalidOrder:n,InvalidAddress:d,AuthenticationError:c,NotSupported:h,OrderNotFound:l}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"coinbasepro",name:"Coinbase Pro",countries:["US"],rateLimit:1e3,userAgent:this.userAgents.chrome,has:{cancelAllOrders:!0,CORS:!0,deposit:!0,fetchAccounts:!0,fetchClosedOrders:!0,fetchDepositAddress:!0,createDepositAddress:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderTrades:!0,fetchOrders:!0,fetchTime:!0,fetchTransactions:!0,withdraw:!0},timeframes:{"1m":60,"5m":300,"15m":900,"1h":3600,"6h":21600,"1d":86400},urls:{test:"https://api-public.sandbox.pro.coinbase.com",logo:"https://user-images.githubusercontent.com/1294454/41764625-63b7ffde-760a-11e8-996d-a6328fa9347a.jpg",api:"https://api.pro.coinbase.com",www:"https://pro.coinbase.com/",doc:"https://docs.pro.coinbase.com/",fees:["https://docs.pro.coinbase.com/#fees","https://support.pro.coinbase.com/customer/en/portal/articles/2945310-fees"]},requiredCredentials:{apiKey:!0,secret:!0,password:!0},api:{public:{get:["currencies","products","products/{id}/book","products/{id}/candles","products/{id}/stats","products/{id}/ticker","products/{id}/trades","time"]},private:{get:["accounts","accounts/{id}","accounts/{id}/holds","accounts/{id}/ledger","accounts/{id}/transfers","coinbase-accounts","coinbase-accounts/{id}/addresses","fills","funding","orders","orders/{id}","otc/orders","payment-methods","position","reports/{id}","users/self/trailing-volume"],post:["conversions","deposits/coinbase-account","deposits/payment-method","coinbase-accounts/{id}/addresses","funding/repay","orders","position/close","profiles/margin-transfer","reports","withdrawals/coinbase","withdrawals/crypto","withdrawals/payment-method"],delete:["orders","orders/{id}"]}},fees:{trading:{tierBased:!0,percentage:!0,maker:.005,taker:.005},funding:{tierBased:!1,percentage:!1,withdraw:{BCH:0,BTC:0,LTC:0,ETH:0,EUR:.15,USD:25},deposit:{BCH:0,BTC:0,LTC:0,ETH:0,EUR:.15,USD:10}}},exceptions:{exact:{"Insufficient funds":r,NotFound:l,"Invalid API Key":c,"invalid signature":c,"Invalid Passphrase":c,"Invalid order id":n},broad:{"Order already done":l,"order not found":l,"price too small":n,"price too precise":n}}})}async fetchMarkets(e={}){const t=await this.publicGetProducts(e),i=[];for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"id"),a=this.safeString(s,"base_currency"),o=this.safeString(s,"quote_currency"),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o),c=n+"/"+d,h={min:this.safeFloat(s,"quote_increment"),max:void 0},l={amount:this.precisionFromString(this.safeString(s,"base_increment")),price:this.precisionFromString(this.safeString(s,"quote_increment"))},u="online"===s.status;i.push(this.extend(this.fees.trading,{id:r,symbol:c,baseId:a,quoteId:o,base:n,quote:d,precision:l,limits:{amount:{min:this.safeFloat(s,"base_min_size"),max:this.safeFloat(s,"base_max_size")},price:h,cost:{min:this.safeFloat(s,"min_market_funds"),max:this.safeFloat(s,"max_market_funds")}},active:u,info:s}))}return i}async fetchAccounts(e={}){const t=await this.privateGetAccounts(e),i=[];for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"id"),a=this.safeString(s,"currency"),o=this.safeCurrencyCode(a);i.push({id:r,type:void 0,currency:o,info:s})}return i}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccounts(e),i={info:t};for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"currency"),a=this.safeCurrencyCode(r),o={free:this.safeFloat(s,"available"),used:this.safeFloat(s,"hold"),total:this.safeFloat(s,"balance")};i[a]=o}return this.parseBalance(i)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={id:this.marketId(e),level:2},r=await this.publicGetProductsIdBook(this.extend(s,i));return this.parseOrderBook(r)}async fetchTicker(e,t={}){await this.loadMarkets();const i={id:this.market(e).id},s=await this.publicGetProductsIdTicker(this.extend(i,t)),r=this.parse8601(this.safeValue(s,"time")),a=this.safeFloat(s,"bid"),o=this.safeFloat(s,"ask"),n=this.safeFloat(s,"price");return{symbol:e,timestamp:r,datetime:this.iso8601(r),high:void 0,low:void 0,bid:a,bidVolume:void 0,ask:o,askVolume:void 0,vwap:void 0,open:void 0,close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeFloat(s,"volume"),quoteVolume:void 0,info:s}}parseTrade(e,t){const i=this.parse8601(this.safeString2(e,"time","created_at"));let s=void 0;if(void 0===t){const i=this.safeString(e,"product_id");t=this.safeValue(this.markets_by_id,i)}t&&(s=t.symbol);let r=void 0,a=void 0,o=void 0;void 0!==t&&(a=t.quote,"liquidity"in e&&(r=t[o="T"===e.liquidity?"taker":"maker"]));const n={cost:this.safeFloat2(e,"fill_fees","fee"),currency:a,rate:r},d=this.safeString(e,"trade_id");let c="buy"===e.side?"sell":"buy";const h=this.safeString(e,"order_id");void 0!==h&&(c="buy"===e.side?"buy":"sell");const l=this.safeFloat(e,"price"),u=this.safeFloat(e,"size");return{id:d,order:h,info:e,timestamp:i,datetime:this.iso8601(i),symbol:s,type:void 0,takerOrMaker:o,side:c,price:l,amount:u,fee:n,cost:l*u}}async fetchMyTrades(e,t,i,s={}){if(void 0===e)throw new a(this.id+" fetchMyTrades requires a symbol argument");await this.loadMarkets();const r=this.market(e),o={product_id:r.id};void 0!==i&&(o.limit=i);const n=await this.privateGetFills(this.extend(o,s));return this.parseTrades(n,r,t,i)}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={id:r.id},o=await this.publicGetProductsIdTrades(this.extend(a,s));return this.parseTrades(o,r,t,i)}parseOHLCV(e,t,i="1m",s,r){return[1e3*e[0],e[3],e[2],e[1],e[4],e[5]]}async fetchOHLCV(e,t="1m",i,s,r={}){await this.loadMarkets();const a=this.market(e),o=this.timeframes[t],n={id:a.id,granularity:o};void 0!==i&&(n.start=this.iso8601(i),void 0===s&&(s=300),n.end=this.iso8601(this.sum((s-1)*o*1e3,i)));const d=await this.publicGetProductsIdCandles(this.extend(n,r));return this.parseOHLCVs(d,a,t,i,s)}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.parse8601(this.safeString(t,"iso"))}parseOrderStatus(e){return this.safeString({pending:"open",active:"open",open:"open",done:"closed",canceled:"canceled",canceling:"open"},e,e)}parseOrder(e,t){const i=this.parse8601(this.safeString(e,"created_at"));let s=void 0;const r=this.safeString(e,"product_id");let a=void 0;if(void 0!==r)if(r in this.markets_by_id)t=this.markets_by_id[r];else{const[e,t]=r.split("-");s=this.safeCurrencyCode(e)+"/"+(a=this.safeCurrencyCode(t))}const o=this.parseOrderStatus(this.safeString(e,"status")),n=this.safeFloat(e,"price"),d=this.safeFloat(e,"size"),c=this.safeFloat(e,"filled_size");let h=void 0;void 0!==d&&void 0!==c&&(h=d-c);const l=this.safeFloat(e,"executed_value"),u=this.safeFloat(e,"fill_fees");let f=void 0;if(void 0!==u){let e=void 0;void 0!==t?e=t.quote:void 0!==a&&(e=a),f={cost:u,currency:e,rate:void 0}}void 0===s&&void 0!==t&&(s=t.symbol);const p=this.safeString(e,"id"),m=this.safeString(e,"type"),y=this.safeString(e,"side");return{id:p,info:e,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,status:o,symbol:s,type:m,side:y,price:n,cost:l,amount:d,filled:c,remaining:h,fee:f}}async fetchOrder(e,t,i={}){await this.loadMarkets();const s={id:e},r=await this.privateGetOrdersId(this.extend(s,i));return this.parseOrder(r)}async fetchOrderTrades(e,t,i,s,r={}){await this.loadMarkets();let a=void 0;void 0!==t&&(a=this.market(t));const o={order_id:e},n=await this.privateGetFills(this.extend(o,r));return this.parseTrades(n,a,i,s)}async fetchOrders(e,t,i,s={}){await this.loadMarkets();const r={status:"all"};let a=void 0;void 0!==e&&(a=this.market(e),r.product_id=a.id);const o=await this.privateGetOrders(this.extend(r,s));return this.parseOrders(o,a,t,i)}async fetchOpenOrders(e,t,i,s={}){await this.loadMarkets();const r={};let a=void 0;void 0!==e&&(a=this.market(e),r.product_id=a.id);const o=await this.privateGetOrders(this.extend(r,s));return this.parseOrders(o,a,t,i)}async fetchClosedOrders(e,t,i,s={}){await this.loadMarkets();const r={status:"done"};let a=void 0;void 0!==e&&(a=this.market(e),r.product_id=a.id);const o=await this.privateGetOrders(this.extend(r,s));return this.parseOrders(o,a,t,i)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o={product_id:this.marketId(e),side:i,size:this.amountToPrecision(e,s),type:t};"limit"===t&&(o.price=this.priceToPrecision(e,r));const n=await this.privatePostOrders(this.extend(o,a));return this.parseOrder(n)}async cancelOrder(e,t,i={}){return await this.loadMarkets(),await this.privateDeleteOrdersId({id:e})}async cancelAllOrders(e,t={}){return await this.privateDeleteOrders(t)}calculateFee(e,t,i,s,r,a="taker",o={}){const n=this.markets[e],d=n[a],c=s*r,h=n.quote;return{type:a,currency:h,rate:d,cost:parseFloat(this.currencyToPrecision(h,d*c))}}async fetchPaymentMethods(e={}){return await this.privateGetPaymentMethods(e)}async deposit(e,t,i,s={}){await this.loadMarkets();const r={currency:this.currency(e).id,amount:t};let a="privatePostDeposits";if("payment_method_id"in s)a+="PaymentMethod";else{if(!("coinbase_account_id"in s))throw new h(this.id+" deposit() requires one of `coinbase_account_id` or `payment_method_id` extra params");a+="CoinbaseAccount"}const n=await this[a](this.extend(r,s));if(!n)throw new o(this.id+" deposit() error: "+this.json(n));return{info:n,id:n.id}}async withdraw(e,t,i,s,r={}){this.checkAddress(i),await this.loadMarkets();const a={currency:this.currency(e).id,amount:t};let n="privatePostWithdrawals";"payment_method_id"in r?n+="PaymentMethod":"coinbase_account_id"in r?n+="CoinbaseAccount":(n+="Crypto",a.crypto_address=i);const d=await this[n](this.extend(a,r));if(!d)throw new o(this.id+" withdraw() error: "+this.json(d));return{info:d,id:d.id}}async fetchTransactions(e,t,i,s={}){await this.loadMarkets(),await this.loadAccounts();let r=void 0,n=this.safeString(s,"id");if(void 0===n){if(void 0===e)throw new a(this.id+" fetchTransactions() requires a currency code argument if no account id specified in params");r=this.currency(e);const t=this.indexBy(this.accounts,"currency"),i=this.safeValue(t,e);if(void 0===i)throw new o(this.id+" fetchTransactions() could not find account id for "+e);n=i.id}const d={id:n};void 0!==i&&(d.limit=i);const c=await this.privateGetAccountsIdTransfers(this.extend(d,s));for(let t=0;t<c.length;t++)c[t].currency=e;return this.parseTransactions(c,r,t,i)}parseTransactionStatus(e){if(this.safeValue(e,"canceled_at"))return"canceled";const t=this.safeValue(e,"processed_at"),i=this.safeValue(e,"completed_at");return i?"ok":t&&!i?"failed":"pending"}parseTransaction(e,t){const i=this.safeValue(e,"details",{}),s=this.safeString(e,"id"),r=this.safeString(i,"crypto_transaction_hash"),a=this.parse8601(this.safeString(e,"created_at")),o=this.parse8601(this.safeString(e,"processed_at")),n=this.safeString(e,"currency"),d=this.safeCurrencyCode(n,t),c=this.parseTransactionStatus(e),h=this.safeFloat(e,"amount");let l=this.safeString(e,"type"),u=this.safeString(i,"crypto_address");const f=this.safeString(i,"destination_tag");return u=this.safeString(e,"crypto_address",u),"withdraw"===l&&(l="withdrawal",u=this.safeString(i,"sent_to_address",u)),{info:e,id:s,txid:r,timestamp:a,datetime:this.iso8601(a),address:u,tag:f,type:l,amount:h,currency:d,status:c,updated:o,fee:void 0}}sign(e,t="public",i="GET",s={},r,a){let o="/"+this.implodeParams(e,s);const n=this.omit(s,this.extractParams(e));"GET"===i&&Object.keys(n).length&&(o+="?"+this.urlencode(n));const d=this.urls.api+o;if("private"===t){this.checkRequiredCredentials();const e=this.nonce().toString();let t="";"GET"!==i&&Object.keys(n).length&&(t=a=this.json(n));const s=e+i+o+t,d=this.base64ToBinary(this.secret),c=this.hmac(this.encode(s),d,"sha256","base64");r={"CB-ACCESS-KEY":this.apiKey,"CB-ACCESS-SIGN":this.decode(c),"CB-ACCESS-TIMESTAMP":e,"CB-ACCESS-PASSPHRASE":this.password,"Content-Type":"application/json"}}return{url:d,method:i,body:a,headers:r}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i=this.currency(e);let s=this.safeValue(this.options,"coinbaseAccounts");void 0===s&&(s=await this.privateGetCoinbaseAccounts(),this.options.coinbaseAccounts=s,this.options.coinbaseAccountsByCurrencyId=this.indexBy(s,"currency"));const r=i.id,a=this.safeValue(this.options.coinbaseAccountsByCurrencyId,r);if(void 0===a)throw new d(this.id+" fetchDepositAddress() could not find currency code "+e+" with id = "+r+" in this.options['coinbaseAccountsByCurrencyId']");const o={id:a.id},n=await this.privateGetCoinbaseAccountsIdAddresses(this.extend(o,t)),c=this.safeString(n,"address"),h=this.safeString(n,"destination_tag");return{currency:e,address:this.checkAddress(c),tag:h,info:n}}async createDepositAddress(e,t={}){await this.loadMarkets();const i=this.currency(e);let s=this.safeValue(this.options,"coinbaseAccounts");void 0===s&&(s=await this.privateGetCoinbaseAccounts(),this.options.coinbaseAccounts=s,this.options.coinbaseAccountsByCurrencyId=this.indexBy(s,"currency"));const r=i.id,a=this.safeValue(this.options.coinbaseAccountsByCurrencyId,r);if(void 0===a)throw new d(this.id+" fetchDepositAddress() could not find currency code "+e+" with id = "+r+" in this.options['coinbaseAccountsByCurrencyId']");const o={id:a.id},n=await this.privatePostCoinbaseAccountsIdAddresses(this.extend(o,t)),c=this.safeString(n,"address"),h=this.safeString(n,"destination_tag");return{currency:e,address:this.checkAddress(c),tag:h,info:n}}handleErrors(e,t,i,s,r,a,n,d,c){if(400===e||404===e){if("{"===a[0]){const e=n.message,t=this.id+" "+e,i=this.exceptions.exact;if(e in i)throw new i[e](t);const s=this.exceptions.broad,r=this.findBroadlyMatchedKey(s,e);if(void 0!==r)throw new s[r](t);throw new o(t)}throw new o(this.id+" "+a)}}async request(e,t="public",i="GET",s={},r,a){const n=await this.fetch2(e,t,i,s,r,a);if("string"!=typeof n&&"message"in n)throw new o(this.id+" "+this.json(n));return n}}},function(e,t,i){"use strict";const s=i(1),{BadSymbol:r,ExchangeError:a,ExchangeNotAvailable:o,ArgumentsRequired:n,InsufficientFunds:d,InvalidOrder:c,DDoSProtection:h,InvalidNonce:l,AuthenticationError:u,NotSupported:f}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"fcoin",name:"FCoin",countries:["CN"],rateLimit:2e3,userAgent:this.userAgents.chrome39,version:"v2",accounts:void 0,accountsById:void 0,hostname:"fcoin.com",has:{CORS:!1,fetchDepositAddress:!1,fetchOHLCV:!0,fetchOpenOrders:!0,fetchClosedOrders:!0,fetchOrder:!0,fetchOrders:!0,fetchOrderBook:!0,fetchOrderBooks:!1,fetchTradingLimits:!1,withdraw:!1,fetchCurrencies:!1},timeframes:{"1m":"M1","3m":"M3","5m":"M5","15m":"M15","30m":"M30","1h":"H1","1d":"D1","1w":"W1","1M":"MN"},urls:{logo:"https://user-images.githubusercontent.com/1294454/42244210-c8c42e1e-7f1c-11e8-8710-a5fb63b165c4.jpg",api:{public:"https://api.{hostname}",private:"https://api.{hostname}",market:"https://api.{hostname}",openapi:"https://www.{hostname}"},www:"https://www.fcoin.com",referral:"https://www.fcoin.com/i/Z5P7V",doc:"https://developer.fcoin.com",fees:"https://fcoinjp.zendesk.com/hc/en-us/articles/360018727371"},api:{openapi:{get:["symbols"]},market:{get:["ticker/{symbol}","depth/{level}/{symbol}","trades/{symbol}","candles/{timeframe}/{symbol}"]},public:{get:["symbols","currencies","server-time"]},private:{get:["accounts/balance","assets/accounts/balance","broker/otc/suborders","broker/otc/suborders/{id}","broker/otc/suborders/{id}/payments","broker/otc/users","broker/otc/users/me/balances","broker/otc/users/me/balance","broker/leveraged_accounts/account","broker/leveraged_accounts","orders","orders/{order_id}","orders/{order_id}/match-results"],post:["assets/accounts/assets-to-spot","accounts/spot-to-assets","broker/otc/assets/transfer/in","broker/otc/assets/transfer/out","broker/otc/suborders","broker/otc/suborders/{id}/pay_confirm","broker/otc/suborders/{id}/cancel","broker/leveraged/assets/transfer/in","broker/leveraged/assets/transfer/out","orders","orders/{order_id}/submit-cancel"]}},fees:{trading:{tierBased:!1,percentage:!0,maker:-2e-4,taker:3e-4}},limits:{amount:{min:.01,max:1e5}},options:{createMarketBuyOrderRequiresPrice:!0,fetchMarketsMethod:"fetch_markets_from_open_api",limits:{"BTM/USDT":{amount:{min:.1,max:1e7}},"ETC/USDT":{amount:{min:.001,max:4e5}},"ETH/USDT":{amount:{min:.001,max:1e4}},"LTC/USDT":{amount:{min:.001,max:4e4}},"BCH/USDT":{amount:{min:.001,max:5e3}},"BTC/USDT":{amount:{min:.001,max:1e3}},"ICX/ETH":{amount:{min:.01,max:3e6}},"OMG/ETH":{amount:{min:.01,max:5e5}},"FT/USDT":{amount:{min:1,max:1e7}},"ZIL/ETH":{amount:{min:1,max:1e7}},"ZIP/ETH":{amount:{min:1,max:1e7}},"FT/BTC":{amount:{min:1,max:1e7}},"FT/ETH":{amount:{min:1,max:1e7}}}},exceptions:{400:f,401:u,405:f,429:h,1002:o,1016:d,2136:u,3008:c,6004:l,6005:u,40003:r},commonCurrencies:{DAG:"DAGX",PAI:"PCHAIN",MT:"Mariana Token"}})}async fetchMarkets(e={}){const t=this.safeString(this.options,"fetchMarketsMethod","fetch_markets_from_open_api");return await this[t](e)}async fetchMarketsFromOpenAPI(e={}){const t=await this.openapiGetSymbols(e),i=this.safeValue(t,"data",{}),s=this.safeValue(i,"symbols",{}),r=Object.keys(s),a=[];for(let e=0;e<r.length;e++){const t=s[r[e]],i=this.safeString(t,"symbol"),o=this.safeString(t,"base_currency"),n=this.safeString(t,"quote_currency"),d=this.safeCurrencyCode(o),c=this.safeCurrencyCode(n),h=d+"/"+c,l={price:this.safeInteger(t,"price_decimal"),amount:this.safeInteger(t,"amount_decimal")},u={amount:{min:this.safeFloat(t,"limit_amount_min"),max:this.safeFloat(t,"limit_amount_max")},price:{min:Math.pow(10,-l.price),max:Math.pow(10,l.price)},cost:{min:void 0,max:void 0}},f=this.safeValue(t,"tradeable",!1);a.push({id:i,symbol:h,base:d,quote:c,baseId:o,quoteId:n,active:f,precision:l,limits:u,info:t})}return a}async fetchMarketsFromAPI(e={}){const t=await this.publicGetSymbols(e),i=[],s=this.safeValue(t,"data");for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"name"),a=this.safeString(t,"base_currency"),o=this.safeString(t,"quote_currency"),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o),c=n+"/"+d,h={price:t.price_decimal,amount:t.amount_decimal};let l={price:{min:Math.pow(10,-h.price),max:Math.pow(10,h.price)}};const u=this.safeValue(t,"tradable",!1);c in this.options.limits&&(l=this.extend(this.options.limits[c],l)),i.push({id:r,symbol:c,base:n,quote:d,baseId:a,quoteId:o,active:u,precision:h,limits:l,info:t})}return i}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccountsBalance(e),i={info:t},s=this.safeValue(t,"data");for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeFloat(t,"available"),o.total=this.safeFloat(t,"balance"),o.used=this.safeFloat(t,"frozen"),i[a]=o}return this.parseBalance(i)}parseBidsAsks(e,t=0,i=1){const s=[],r=e.length,a=parseInt(r/2);for(let r=0;r<a;r++){const a=2*r,o=this.sum(a,t),n=this.sum(a,i);s.push([this.safeFloat(e,o),this.safeFloat(e,n)])}return s}async fetchOrderBook(e,t,i={}){if(await this.loadMarkets(),void 0!==t){if(20!==t&&150!==t)throw new a(this.id+" fetchOrderBook supports limit of 20 or 150. Other values are not accepted");t="L"+t.toString()}else t="L20";const s={symbol:this.marketId(e),level:t},r=await this.marketGetDepthLevelSymbol(this.extend(s,i)),o=this.safeValue(r,"data");return this.parseOrderBook(o,o.ts,"bids","asks",0,1)}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={symbol:i.id},r=await this.marketGetTickerSymbol(this.extend(s,t));return this.parseTicker(r.data,i)}parseTicker(e,t){let i=void 0;if(void 0===t){const i=this.safeString(e,"type");if(void 0!==i){const e=i.split(".")[1];e in this.markets_by_id&&(t=this.markets_by_id[e])}}const s=e.ticker,r=parseFloat(s[0]);return void 0!==t&&(i=t.symbol),{symbol:i,timestamp:void 0,datetime:this.iso8601(void 0),high:parseFloat(s[7]),low:parseFloat(s[8]),bid:parseFloat(s[2]),bidVolume:parseFloat(s[3]),ask:parseFloat(s[4]),askVolume:parseFloat(s[5]),vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:parseFloat(s[9]),quoteVolume:parseFloat(s[10]),info:e}}parseTrade(e,t){let i=void 0;void 0!==t&&(i=t.symbol);const s=this.safeInteger(e,"ts"),r=this.safeStringLower(e,"side"),a=this.safeString(e,"id"),o=this.safeFloat(e,"price"),n=this.safeFloat(e,"amount");let d=void 0;void 0!==o&&void 0!==n&&(d=n*o);return{id:a,info:e,timestamp:s,datetime:this.iso8601(s),symbol:i,type:void 0,order:void 0,side:r,takerOrMaker:void 0,price:o,amount:n,cost:d,fee:void 0}}async fetchTrades(e,t,i=50,s={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,limit:i};void 0!==t&&(a.timestamp=parseInt(t/1e3));const o=await this.marketGetTradesSymbol(this.extend(a,s));return this.parseTrades(o.data,r,t,i)}async createOrder(e,t,i,s,r,a={}){if("market"===t&&"buy"===i&&this.options.createMarketBuyOrderRequiresPrice){if(void 0===r)throw new c(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the cost in the amount argument (the exchange-specific behaviour)");s*=r}await this.loadMarkets();const o=t,n={symbol:this.marketId(e),amount:this.amountToPrecision(e,s),side:i,type:o};"limit"!==t&&"ioc"!==t&&"fok"!==t||(n.price=this.priceToPrecision(e,r));const d=await this.privatePostOrders(this.extend(n,a));return{info:d,id:d.data}}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={order_id:e},r=await this.privatePostOrdersOrderIdSubmitCancel(this.extend(s,i)),a=this.parseOrder(r);return this.extend(a,{id:e,status:"canceled"})}parseOrderStatus(e){return this.safeString({submitted:"open",canceled:"canceled",partial_filled:"open",partial_canceled:"canceled",filled:"closed",pending_cancel:"canceled"},e,e)}parseOrder(e,t){const i=this.safeString(e,"id"),s=this.safeString(e,"side"),r=this.parseOrderStatus(this.safeString(e,"state"));let a=void 0;if(void 0===t){const i=this.safeString(e,"symbol");i in this.markets_by_id&&(t=this.markets_by_id[i])}const o=this.safeString(e,"type"),n=this.safeInteger(e,"created_at"),d=this.safeFloat(e,"amount"),c=this.safeFloat(e,"filled_amount");let h=void 0,l=this.safeFloat(e,"price"),u=this.safeFloat(e,"executed_value");void 0!==c&&(void 0!==d&&(h=d-c),void 0===u?void 0!==l&&(u=l*c):u>0&&c>0&&(l=u/c));let f=void 0;void 0!==t&&(a=t.symbol,f="buy"===s?t.base:t.quote);const p=this.safeFloat(e,"fill_fees");return{info:e,id:i,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,symbol:a,type:o,side:s,price:l,cost:u,amount:d,remaining:h,filled:c,average:void 0,status:r,fee:{cost:p,currency:f},trades:void 0}}async fetchOrder(e,t,i={}){await this.loadMarkets();const s={order_id:e},r=await this.privateGetOrdersOrderId(this.extend(s,i));return this.parseOrder(r.data)}async fetchOpenOrders(e,t,i,s={}){return await this.fetchOrders(e,t,i,this.extend({states:"submitted,partial_filled"},s))}async fetchClosedOrders(e,t,i,s={}){return await this.fetchOrders(e,t,i,this.extend({states:"partial_canceled,filled"},s))}async fetchOrders(e,t,i,s={}){if(void 0===e)throw new n(this.id+" fetchOrders() requires a `symbol` argument");await this.loadMarkets();const r=this.market(e),a={symbol:r.id,states:"submitted,partial_filled,partial_canceled,filled,canceled"};void 0!==i&&(a.limit=i);const o=await this.privateGetOrders(this.extend(a,s));return this.parseOrders(o.data,r,t,i)}parseOHLCV(e,t,i="1m",s,r){return[this.safeTimestamp(e,"id"),this.safeFloat(e,"open"),this.safeFloat(e,"high"),this.safeFloat(e,"low"),this.safeFloat(e,"close"),this.safeFloat(e,"base_vol")]}async fetchOHLCV(e,t="1m",i,s=100,r={}){if(await this.loadMarkets(),void 0===s)throw new a(this.id+" fetchOHLCV requires a limit argument");const o=this.market(e),n={symbol:o.id,timeframe:this.timeframes[t],limit:s},d=await this.marketGetCandlesTimeframeSymbol(this.extend(n,r));return this.parseOHLCVs(d.data,o,t,i,s)}nonce(){return this.milliseconds()}sign(e,t="public",i="GET",s={},r,a){let o="/";const n="openapi"===t,d="private"===t;o+=n?t+"/":"",o+=this.version+"/",o+=d||n?"":t+"/",o+=this.implodeParams(e,s);let c=this.omit(s,this.extractParams(e)),h=this.implodeParams(this.urls.api[t],{hostname:this.hostname});if(h+=o,d){this.checkRequiredCredentials();const e=this.nonce().toString();c=this.keysort(c),"GET"===i&&Object.keys(c).length&&(h+="?"+this.rawencode(c));let t=i+h+e;"POST"===i&&Object.keys(c).length&&(a=this.json(c),t+=this.urlencode(c));const s=this.stringToBase64(this.encode(t));let o=this.hmac(s,this.encode(this.secret),"sha1","binary");o=this.decode(this.stringToBase64(o)),r={"FC-ACCESS-KEY":this.apiKey,"FC-ACCESS-SIGNATURE":o,"FC-ACCESS-TIMESTAMP":e,"Content-Type":"application/json"}}else Object.keys(c).length&&(h+="?"+this.urlencode(c));return{url:h,method:i,body:a,headers:r}}handleErrors(e,t,i,s,r,o,n,d,c){if(void 0===n)return;const h=this.safeString(n,"status");if("0"!==h&&"ok"!==h){const e=this.id+" "+o;if(h in this.exceptions){throw new this.exceptions[h](e)}throw new a(e)}}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,ArgumentsRequired:a,ExchangeNotAvailable:o,InsufficientFunds:n,OrderNotFound:d,InvalidOrder:c,AccountSuspended:h,InvalidNonce:l,DDoSProtection:u,NotSupported:f,BadRequest:p,AuthenticationError:m,BadSymbol:y}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"kucoin",name:"KuCoin",countries:["SC"],rateLimit:334,version:"v2",certified:!0,comment:"Platform 2.0",has:{fetchMarkets:!0,fetchCurrencies:!0,fetchTicker:!0,fetchTickers:!0,fetchOrderBook:!0,fetchOrder:!0,fetchClosedOrders:!0,fetchOpenOrders:!0,fetchDepositAddress:!0,createDepositAddress:!0,withdraw:!0,fetchDeposits:!0,fetchWithdrawals:!0,fetchBalance:!0,fetchTrades:!0,fetchMyTrades:!0,createOrder:!0,cancelOrder:!0,fetchAccounts:!0,fetchFundingFee:!0,fetchOHLCV:!0,fetchLedger:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/57369448-3cc3aa80-7196-11e9-883e-5ebeb35e4f57.jpg",referral:"https://www.kucoin.com/?rcode=E5wkqe",api:{public:"https://openapi-v2.kucoin.com",private:"https://openapi-v2.kucoin.com"},test:{public:"https://openapi-sandbox.kucoin.com",private:"https://openapi-sandbox.kucoin.com"},www:"https://www.kucoin.com",doc:["https://docs.kucoin.com"]},requiredCredentials:{apiKey:!0,secret:!0,password:!0},api:{public:{get:["timestamp","symbols","market/allTickers","market/orderbook/level{level}","market/histories","market/candles","market/stats","currencies","currencies/{currency}"],post:["bullet-public"]},private:{get:["accounts","accounts/{accountId}","accounts/{accountId}/ledgers","accounts/{accountId}/holds","deposit-addresses","deposits","hist-deposits","hist-orders","hist-withdrawals","withdrawals","withdrawals/quotas","orders","orders/{orderId}","fills","limit/fills"],post:["accounts","accounts/inner-transfer","deposit-addresses","withdrawals","orders","bullet-private"],delete:["withdrawals/{withdrawalId}","orders/{orderId}"]}},timeframes:{"1m":"1min","3m":"3min","5m":"5min","15m":"15min","30m":"30min","1h":"1hour","2h":"2hour","4h":"4hour","6h":"6hour","8h":"8hour","12h":"12hour","1d":"1day","1w":"1week"},exceptions:{order_not_exist:d,order_not_exist_or_not_allow_to_cancel:c,"Order size below the minimum requirement.":c,"The withdrawal amount is below the minimum requirement.":r,400:p,401:m,403:f,404:f,405:f,429:u,500:r,503:o,200004:n,230003:n,260100:n,300000:c,400000:y,400001:m,400002:l,400003:m,400004:m,400005:m,400006:m,400007:m,400008:f,400100:p,411100:h,415000:p,500000:r},fees:{trading:{tierBased:!1,percentage:!0,taker:.001,maker:.001},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{}}},commonCurrencies:{HOT:"HOTNOW",EDGE:"DADI"},options:{version:"v1",symbolSeparator:"-",fetchMyTradesMethod:"private_get_fills",fetchBalance:{type:"trade"}}})}nonce(){return this.milliseconds()}async loadTimeDifference(){const e=await this.publicGetTimestamp(),t=this.milliseconds(),i=this.safeInteger(e,"data");return this.options.timeDifference=parseInt(t-i),this.options.timeDifference}async fetchMarkets(e={}){const t=(await this.publicGetSymbols(e)).data,i=[];for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"symbol"),a=this.safeString(s,"baseCurrency"),o=this.safeString(s,"quoteCurrency"),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o),c=n+"/"+d,h=this.safeValue(s,"enableTrading"),l=this.safeFloat(s,"baseMaxSize"),u=this.safeFloat(s,"baseMinSize"),f=this.safeFloat(s,"quoteMaxSize"),p=this.safeFloat(s,"quoteMinSize"),m={amount:this.precisionFromString(this.safeString(s,"baseIncrement")),price:this.precisionFromString(this.safeString(s,"priceIncrement"))},y={amount:{min:u,max:l},price:{min:this.safeFloat(s,"priceIncrement"),max:f/u},cost:{min:p,max:f}};i.push({id:r,symbol:c,baseId:a,quoteId:o,base:n,quote:d,active:h,precision:m,limits:y,info:s})}return i}async fetchCurrencies(e={}){const t=(await this.publicGetCurrencies(e)).data,i={};for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"currency"),a=this.safeString(s,"fullName"),o=this.safeCurrencyCode(r),n=this.safeInteger(s,"precision");i[o]={id:r,name:a,code:o,precision:n,info:s}}return i}async fetchAccounts(e={}){const t=await this.privateGetAccounts(e),i=this.safeValue(t,"data"),s=[];for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"id"),a=this.safeString(t,"currency"),o=this.safeCurrencyCode(a),n=this.safeString(t,"type");s.push({id:r,type:n,currency:o,info:t})}return s}async fetchFundingFee(e,t={}){const i={currency:this.currencyId(e)},s=await this.privateGetWithdrawalsQuotas(this.extend(i,t)),r=s.data,a={};return a[e]=this.safeFloat(r,"withdrawMinFee"),{info:s,withdraw:a,deposit:{}}}parseTicker(e,t){let i=this.safeFloat(e,"changeRate");void 0!==i&&(i*=100);const s=this.safeFloat(e,"last");let r=void 0;const a=this.safeString(e,"symbol");if(void 0!==a)if(a in this.markets_by_id)r=(t=this.markets_by_id[a]).symbol;else{const[e,t]=a.split("-");r=this.safeCurrencyCode(e)+"/"+this.safeCurrencyCode(t)}return void 0===r&&void 0!==t&&(r=t.symbol),{symbol:r,timestamp:void 0,datetime:void 0,high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"buy"),bidVolume:void 0,ask:this.safeFloat(e,"sell"),askVolume:void 0,vwap:void 0,open:this.safeFloat(e,"open"),close:s,last:s,previousClose:void 0,change:this.safeFloat(e,"changePrice"),percentage:i,average:void 0,baseVolume:this.safeFloat(e,"vol"),quoteVolume:this.safeFloat(e,"volValue"),info:e}}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetMarketAllTickers(t),s=this.safeValue(i,"data",{}),r=this.safeValue(s,"ticker",[]),a={};for(let e=0;e<r.length;e++){const t=this.parseTicker(r[e]),i=this.safeString(t,"symbol");void 0!==i&&(a[i]=t)}return a}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={symbol:i.id},r=await this.publicGetMarketStats(this.extend(s,t));return this.parseTicker(r.data,i)}parseOHLCV(e,t,i="1m",s,r){return[1e3*parseInt(e[0]),parseFloat(e[1]),parseFloat(e[3]),parseFloat(e[4]),parseFloat(e[2]),parseFloat(e[5])]}async fetchOHLCV(e,t="15m",i,s,r={}){await this.loadMarkets();const a=this.market(e),o={symbol:a.id,type:this.timeframes[t]},n=1e3*this.parseTimeframe(t);let d=this.milliseconds();void 0!==i?(o.startAt=parseInt(Math.floor(i/1e3)),void 0===s&&(s=this.safeInteger(this.options,"fetchOHLCVLimit",1500)),d=this.sum(i,s*n)):void 0!==s&&(i=d-s*n,o.startAt=parseInt(Math.floor(i/1e3))),o.endAt=parseInt(Math.floor(d/1e3));const c=await this.publicGetMarketCandles(this.extend(o,r)),h=this.safeValue(c,"data",[]);return this.parseOHLCVs(h,a,t,i,s)}async createDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currencyId(e)},s=await this.privatePostDepositAddresses(this.extend(i,t)),r=this.safeValue(s,"data",{});let a=this.safeString(r,"address");void 0!==a&&(a=a.replace("bitcoincash:",""));const o=this.safeString(r,"memo");return this.checkAddress(a),{info:s,currency:e,address:a,tag:o}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currencyId(e)},s=await this.privateGetDepositAddresses(this.extend(i,t)),r=this.safeValue(s,"data",{});let a=this.safeString(r,"address");void 0!==a&&(a=a.replace("bitcoincash:",""));const o=this.safeString(r,"memo");return this.checkAddress(a),{info:s,currency:e,address:a,tag:o}}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s=this.marketId(e),r=this.extend({symbol:s,level:2},i),a=(await this.publicGetMarketOrderbookLevelLevel(r)).data,o=this.safeInteger(a,"sequence"),n=this.safeString(r,"level").split("_"),d=parseInt(n[0]);return this.parseOrderBook(a,o,"bids","asks",d-2,d-1)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o=this.marketId(e),n=this.uuid(),d={clientOid:n,side:i,size:this.amountToPrecision(e,s),symbol:o,type:t};"market"!==t&&(d.price=this.priceToPrecision(e,r));const c=await this.privatePostOrders(this.extend(d,a)),h=this.safeValue(c,"data",{}),l=this.milliseconds();return{id:this.safeString(h,"orderId"),symbol:e,type:t,side:i,amount:s,price:r,cost:void 0,filled:void 0,remaining:void 0,timestamp:l,datetime:this.iso8601(l),fee:void 0,status:"open",clientOid:n,info:h}}async cancelOrder(e,t,i={}){const s={orderId:e};return await this.privateDeleteOrdersOrderId(this.extend(s,i))}async fetchOrdersByStatus(e,t,i,s,r={}){await this.loadMarkets();const a={status:e};let o=void 0;void 0!==t&&(o=this.market(t),a.symbol=o.id),void 0!==i&&(a.startAt=i),void 0!==s&&(a.pageSize=s);const n=await this.privateGetOrders(this.extend(a,r)),d=this.safeValue(n,"data",{}),c=this.safeValue(d,"items",[]);return this.parseOrders(c,o,i,s)}async fetchClosedOrders(e,t,i,s={}){return await this.fetchOrdersByStatus("done",e,t,i,s)}async fetchOpenOrders(e,t,i,s={}){return await this.fetchOrdersByStatus("active",e,t,i,s)}async fetchOrder(e,t,i={}){await this.loadMarkets();const s={orderId:e};let r=void 0;void 0!==t&&(r=this.market(t));const a=(await this.privateGetOrdersOrderId(this.extend(s,i))).data;return this.parseOrder(a,r)}parseOrder(e,t){let i=void 0;const s=this.safeString(e,"symbol");if(void 0!==s){if(s in this.markets_by_id)i=(t=this.markets_by_id[s]).symbol;else{const[e,t]=s.split("-");i=this.safeCurrencyCode(e)+"/"+this.safeCurrencyCode(t)}t=this.safeValue(this.markets_by_id,s)}void 0===i&&void 0!==t&&(i=t.symbol);const r=this.safeString(e,"id"),a=this.safeString(e,"type"),o=this.safeInteger(e,"createdAt"),n=this.iso8601(o);let d=this.safeFloat(e,"price");const c=this.safeString(e,"side"),h=this.safeString(e,"feeCurrency"),l=this.safeCurrencyCode(h),u=this.safeFloat(e,"fee"),f=this.safeFloat(e,"size"),p=this.safeFloat(e,"dealSize"),m=this.safeFloat(e,"dealFunds");return"market"===a&&0===d&&void 0!==m&&void 0!==p&&m>0&&p>0&&(d=m/p),{id:r,symbol:i,type:a,side:c,amount:f,price:d,cost:m,filled:p,remaining:f-p,timestamp:o,datetime:n,fee:{currency:l,cost:u},status:e.isActive?"open":"closed",info:e}}async fetchMyTrades(e,t,i,s={}){await this.loadMarkets();const a={};let o=void 0;void 0!==e&&(o=this.market(e),a.symbol=o.id),void 0!==i&&(a.pageSize=i);const n=this.options.fetchMyTradesMethod;let d=!1;if("private_get_fills"===n)void 0!==t&&(a.startAt=t);else if("private_get_limit_fills"===n)d=!0;else{if("private_get_hist_orders"!==n)throw new r(this.id+" invalid fetchClosedOrder method");void 0!==t&&(a.startAt=parseInt(t/1e3))}const c=await this[n](this.extend(a,s)),h=this.safeValue(c,"data",{});let l=void 0;return l=d?h:this.safeValue(h,"items",[]),this.parseTrades(l,o,t,i)}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id};void 0!==t&&(a.startAt=Math.floor(t/1e3)),void 0!==i&&(a.pageSize=i);const o=await this.publicGetMarketHistories(this.extend(a,s)),n=this.safeValue(o,"data",[]);return this.parseTrades(n,r,t,i)}parseTrade(e,t){let i=void 0;const s=this.safeString(e,"symbol");if(void 0!==s)if(s in this.markets_by_id)i=(t=this.markets_by_id[s]).symbol;else{const[e,t]=s.split("-");i=this.safeCurrencyCode(e)+"/"+this.safeCurrencyCode(t)}void 0===i&&void 0!==t&&(i=t.symbol);let r=this.safeString2(e,"tradeId","id");void 0!==r&&(r=r.toString());const a=this.safeString(e,"orderId"),o=this.safeString(e,"liquidity"),n=this.safeFloat2(e,"size","amount");let d=this.safeInteger(e,"time");void 0!==d?d=parseInt(d/1e6):(d=this.safeInteger(e,"createdAt"),"dealValue"in e&&void 0!==d&&(d*=1e3));const c=this.safeFloat2(e,"price","dealPrice"),h=this.safeString(e,"side");let l=void 0;const u=this.safeFloat(e,"fee");if(void 0!==u){const i=this.safeString(e,"feeCurrency");let s=this.safeCurrencyCode(i);void 0===s&&void 0!==t&&(s="sell"===h?t.quote:t.base),l={cost:u,currency:s,rate:this.safeFloat(e,"feeRate")}}const f=this.safeString(e,"type");let p=this.safeFloat2(e,"funds","dealValue");return void 0===p&&void 0!==n&&void 0!==c&&(p=n*c),{info:e,id:r,order:a,timestamp:d,datetime:this.iso8601(d),symbol:i,type:f,takerOrMaker:o,side:h,price:c,amount:n,cost:p,fee:l}}async withdraw(e,t,i,s,r={}){await this.loadMarkets(),this.checkAddress(i);const a={currency:this.currencyId(e),address:i,amount:t};void 0!==s&&(a.memo=s);const o=await this.privatePostWithdrawals(this.extend(a,r)),n=this.safeValue(o,"data",{});return{id:this.safeString(n,"withdrawalId"),info:o}}parseTransactionStatus(e){return this.safeString({SUCCESS:"ok",PROCESSING:"ok",FAILURE:"failed"},e)}parseTransaction(e,t){const i=this.safeString(e,"currency"),s=this.safeCurrencyCode(i,t);let r=this.safeString(e,"address");const a=this.safeFloat(e,"amount");let o=this.safeString(e,"walletTxId");if(void 0!==o){const e=o.split("@");e.length>1&&void 0===r&&e[1].length>1&&(r=e[1]),o=e[0]}let n=void 0===o?"withdrawal":"deposit";const d=this.safeString(e,"status"),c=this.parseTransactionStatus(d);let h=void 0;const l=this.safeFloat(e,"fee");if(void 0!==l){let e=void 0;void 0!==a&&(e=l/a),h={cost:l,rate:e,currency:s}}const u=this.safeString(e,"memo");let f=this.safeInteger2(e,"createdAt","createAt");const p=this.safeString(e,"id");let m=this.safeInteger(e,"updatedAt");return!("createdAt"in e)&&(n="address"in e?"withdrawal":"deposit",void 0!==f&&(f*=1e3),void 0!==m&&(m*=1e3)),{id:p,address:r,tag:u,currency:s,amount:a,txid:o,type:n,status:c,fee:h,timestamp:f,datetime:this.iso8601(f),updated:m,info:e}}async fetchDeposits(e,t,i,s={}){await this.loadMarkets();const r={};let a=void 0;void 0!==e&&(a=this.currency(e),r.currency=a.id),void 0!==i&&(r.pageSize=i);let o="privateGetDeposits";void 0!==t&&(t<1550448e6?(r.startAt=parseInt(t/1e3),o="privateGetHistDeposits"):r.startAt=t);const n=(await this[o](this.extend(r,s))).data.items;return this.parseTransactions(n,a,t,i,{type:"deposit"})}async fetchWithdrawals(e,t,i,s={}){await this.loadMarkets();const r={};let a=void 0;void 0!==e&&(a=this.currency(e),r.currency=a.id),void 0!==i&&(r.pageSize=i);let o="privateGetWithdrawals";void 0!==t&&(t<1550448e6?(r.startAt=parseInt(t/1e3),o="privateGetHistWithdrawals"):r.startAt=t);const n=(await this[o](this.extend(r,s))).data.items;return this.parseTransactions(n,a,t,i,{type:"withdrawal"})}async fetchBalance(e={}){await this.loadMarkets();let t=void 0;const i={};if("type"in e)void 0!==(t=e.type)&&(i.type=t),e=this.omit(e,"type");else{const e=this.safeValue(this.options,"fetchBalance",{});t=this.safeString(e,"type","trade")}const s=await this.privateGetAccounts(this.extend(i,e)),r=this.safeValue(s,"data",[]),a={info:s};for(let e=0;e<r.length;e++){const i=r[e];if(this.safeString(i,"type")===t){const e=this.safeString(i,"currency"),t=this.safeCurrencyCode(e),s=this.account();s.total=this.safeFloat(i,"balance"),s.free=this.safeFloat(i,"available"),s.used=this.safeFloat(i,"holds"),a[t]=s}}return this.parseBalance(a)}async fetchLedger(e,t,i,s={}){if(void 0===e)throw new a(this.id+" fetchLedger requires a code param");await this.loadMarkets(),await this.loadAccounts();const o=this.currency(e);let n=this.safeString(s,"accountId");if(void 0===n)for(let t=0;t<this.accounts.length;t++){const i=this.accounts[t];if(i.currency===e&&"main"===i.type){n=i.id;break}}if(void 0===n)throw new r(this.id+" "+e+"main account is not loaded in loadAccounts");const d={accountId:n};void 0!==t&&(d.startAt=Math.floor(t/1e3));const c=(await this.privateGetAccountsAccountIdLedgers(this.extend(d,s))).data.items;return this.parseLedger(c,o,t,i)}parseLedgerEntry(e,t){const i=this.safeString(e,"currency"),s=this.safeCurrencyCode(i,t),r={cost:this.safeFloat(e,"fee"),code:s},a=this.safeFloat(e,"amount"),o=this.safeFloat(e,"balance"),n=this.safeString(e,"direction");let d=void 0;if(void 0!==o&&void 0!==a){const e="out"===n?a:-a;d=this.sum(o,e)}const c=this.safeInteger(e,"createdAt"),h=this.parseLedgerEntryType(this.safeString(e,"bizType")),l=this.safeString(e,"context");let u=void 0,f=void 0;if(this.isJsonEncodedObject(l)){const e=this.parseJson(l);u=this.safeString(e,"orderId"),"trade"===h?f=this.safeString(e,"tradeId"):"transaction"===h&&(f=this.safeString(e,"txId"))}return{id:u,currency:s,account:void 0,referenceAccount:void 0,referenceId:f,status:void 0,amount:a,before:d,after:o,fee:r,direction:n,timestamp:c,datetime:this.iso8601(c),type:h,info:e}}parseLedgerEntryType(e){return this.safeString({Exchange:"trade",Withdrawal:"transaction",Deposit:"transaction",Transfer:"transfer"},e,e)}sign(e,t="public",i="GET",s={},r,a){const o=this.safeString(s,"version",this.options.version);s=this.omit(s,"version");let n="/api/"+o+"/"+this.implodeParams(e,s);const d=this.omit(s,this.extractParams(e));let c="";r=void 0!==r?r:{},Object.keys(d).length&&("GET"!==i?(c=a=this.json(d),r["Content-Type"]="application/json"):n+="?"+this.urlencode(d));const h=this.urls.api[t]+n;if("private"===t){this.checkRequiredCredentials();const e=this.nonce().toString();r=this.extend({"KC-API-KEY":this.apiKey,"KC-API-TIMESTAMP":e,"KC-API-PASSPHRASE":this.password},r);const t=e+i+n+c,s=this.hmac(this.encode(t),this.encode(this.secret),"sha256","base64");r["KC-API-SIGN"]=this.decode(s)}return{url:h,method:i,body:a,headers:r}}handleErrors(e,t,i,s,r,a,o,n,d){if(!o)return;const c=this.safeString(o,"code"),h=this.safeString(o,"msg"),l=this.safeValue2(this.exceptions,h,c);if(void 0!==l)throw new l(this.id+" "+h)}}},function(e,t,i){const s=i(39);e.exports={fetchTrades:async function({exchange:e,base:t,quote:i,since:r}){const a=`${t}/${i}`,o=new Date(r).getTime();return await new s[e].fetchTrades(a,o)},exchanges:async()=>s.exchanges,fetchMarketsForExchange:async function(e){const t=new s[e];return await t.loadMarkets()},fetchOhlcvs:async function({exchange:e,base:t,quote:i,timeframe:r,since:a,limit:o}){const n=`${t}/${i}`,d=new s[e];return await d.fetchOHLCV(n,r,a,o)},fetchTicker:async function({exchange:e,symbol:t}){const i=new s[e];return await i.fetchTicker(t)},fetchTickers:async function(e,t,i){const r=new s[e];return await r.fetchTickers(t,i)},fetchTickersAll:async function(e){const t=new s[e];return await t.fetchTickers()},fetchMarkets:async function(e){const t=new s[e];return await t.fetchMarkets()}}},function(e,t,i){"use strict";const s=i(1),r=i(15),a=i(0);s.ccxtVersion="1.18.1281";const o={_1btcxe:i(76),acx:i(29),adara:i(77),allcoin:i(78),anxpro:i(79),bcex:i(80),bequant:i(81),bibox:i(82),bigone:i(83),binance:i(12),binanceje:i(84),binanceus:i(85),bit2c:i(86),bitbank:i(87),bitbay:i(88),bitfinex:i(32),bitfinex2:i(89),bitflyer:i(90),bitforex:i(91),bithumb:i(92),bitkk:i(93),bitlish:i(94),bitmart:i(95),bitmax:i(96),bitmex:i(97),bitso:i(98),bitstamp:i(99),bitstamp1:i(100),bittrex:i(34),bitz:i(101),bl3p:i(102),bleutrade:i(103),braziliex:i(104),btcalpha:i(105),btcbox:i(106),btcchina:i(107),btcmarkets:i(108),btctradeim:i(109),btctradeua:i(110),btcturk:i(111),buda:i(112),cex:i(113),chilebit:i(114),cobinhood:i(115),coinbase:i(116),coinbaseprime:i(117),coinbasepro:i(35),coincheck:i(118),coinegg:i(13),coinex:i(119),coinexchange:i(120),coinfalcon:i(121),coinfloor:i(122),coingi:i(123),coinmarketcap:i(124),coinmate:i(125),coinone:i(126),coinspot:i(127),cointiger:i(128),coolcoin:i(129),coss:i(130),crex24:i(131),deribit:i(132),digifinex:i(133),dsx:i(134),dx:i(135),exmo:i(136),exx:i(137),fcoin:i(36),fcoinjp:i(138),flowbtc:i(139),foxbit:i(9),fybse:i(140),gateio:i(141),gemini:i(142),hitbtc:i(31),hitbtc2:i(30),huobipro:i(14),huobiru:i(143),ice3x:i(144),idex:i(145),independentreserve:i(146),indodax:i(147),itbit:i(148),kkex:i(149),kraken:i(150),kucoin:i(37),kucoin2:i(151),kuna:i(152),lakebtc:i(153),latoken:i(154),lbank:i(155),liquid:i(156),livecoin:i(157),luno:i(158),lykke:i(159),mandala:i(160),mercado:i(161),mixcoins:i(162),negociecoins:i(163),oceanex:i(164),okcoincny:i(165),okcoinusd:i(8),okex:i(166),okex3:i(167),paymium:i(168),poloniex:i(169),rightbtc:i(170),southxchange:i(171),stronghold:i(172),surbitcoin:i(173),theocean:i(174),therock:i(175),tidebit:i(176),tidex:i(177),upbit:i(178),vaultoro:i(179),vbtc:i(180),virwox:i(181),whitebit:i(182),xbtce:i(183),yobit:i(184),zaif:i(185),zb:i(33)};e.exports=Object.assign({version:"1.18.1281",Exchange:s,exchanges:Object.keys(o)},o,r,a)},function(e,t,i){"use strict";const s="undefined"!=typeof window,r="undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.electron,a="undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope,o="undefined"!=typeof process&&"win32"===process.platform,n=!(s||a),d="undefined"==typeof fetch?i(41)().fetch:fetch;e.exports={isBrowser:s,isElectron:r,isWebWorker:a,isNode:n,isWindows:o,defaultFetch:d}},function(e,t,i){"use strict";var s=i(42);function r(e){return function(t,i){return"string"==typeof t&&"//"===t.slice(0,2)?e("https:"+t,i):e(t,i)}}e.exports=function(e){return e&&e.Promise&&(s.Promise=e.Promise),{fetch:r(s),Headers:s.Headers,Request:s.Request,Response:s.Response}}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const s=Symbol("buffer"),r=Symbol("type");class a{constructor(){this[r]="";const e=arguments[0],t=arguments[1],i=[];if(e){const t=e,r=Number(t.length);for(let e=0;e<r;e++){const r=t[e];let o;o=r instanceof Buffer?r:ArrayBuffer.isView(r)?Buffer.from(r.buffer,r.byteOffset,r.byteLength):r instanceof ArrayBuffer?Buffer.from(r):r instanceof a?r[s]:Buffer.from("string"==typeof r?r:String(r)),i.push(o)}}this[s]=Buffer.concat(i);let o=t&&void 0!==t.type&&String(t.type).toLowerCase();o&&!/[^\u0020-\u007E]/.test(o)&&(this[r]=o)}get size(){return this[s].length}get type(){return this[r]}slice(){const e=this.size,t=arguments[0],i=arguments[1];let r,o;r=void 0===t?0:t<0?Math.max(e+t,0):Math.min(t,e),o=void 0===i?e:i<0?Math.max(e+i,0):Math.min(i,e);const n=Math.max(o-r,0),d=this[s].slice(r,r+n),c=new a([],{type:arguments[2]});return c[s]=d,c}}function o(e,t,i){Error.call(this,e),this.message=e,this.type=t,i&&(this.code=this.errno=i.code),Error.captureStackTrace(this,this.constructor)}Object.defineProperties(a.prototype,{size:{enumerable:!0},type:{enumerable:!0},slice:{enumerable:!0}}),Object.defineProperty(a.prototype,Symbol.toStringTag,{value:"Blob",writable:!1,enumerable:!1,configurable:!0}),o.prototype=Object.create(Error.prototype),o.prototype.constructor=o,o.prototype.name="FetchError";const n=i(11);const d=i(11).PassThrough,c=Symbol("Body internals");function h(e){var t=this,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},s=i.size;let r=void 0===s?0:s;var d=i.timeout;let h=void 0===d?0:d;null==e?e=null:"string"==typeof e||u(e)||e instanceof a||Buffer.isBuffer(e)||"[object ArrayBuffer]"===Object.prototype.toString.call(e)||e instanceof n||(e=String(e)),this[c]={body:e,disturbed:!1,error:null},this.size=r,this.timeout=h,e instanceof n&&e.on("error",function(e){t[c].error=new o(`Invalid response body while trying to fetch ${t.url}: ${e.message}`,"system",e)})}function l(){var e=this;if(this[c].disturbed)return h.Promise.reject(new TypeError(`body used already for: ${this.url}`));if(this[c].disturbed=!0,this[c].error)return h.Promise.reject(this[c].error);if(null===this.body)return h.Promise.resolve(Buffer.alloc(0));if("string"==typeof this.body)return h.Promise.resolve(Buffer.from(this.body));if(this.body instanceof a)return h.Promise.resolve(this.body[s]);if(Buffer.isBuffer(this.body))return h.Promise.resolve(this.body);if("[object ArrayBuffer]"===Object.prototype.toString.call(this.body))return h.Promise.resolve(Buffer.from(this.body));if(!(this.body instanceof n))return h.Promise.resolve(Buffer.alloc(0));let t=[],i=0,r=!1;return new h.Promise(function(s,a){let n;e.timeout&&(n=setTimeout(function(){r=!0,a(new o(`Response timeout while trying to fetch ${e.url} (over ${e.timeout}ms)`,"body-timeout"))},e.timeout)),e.body.on("error",function(t){a(new o(`Invalid response body while trying to fetch ${e.url}: ${t.message}`,"system",t))}),e.body.on("data",function(s){if(!r&&null!==s){if(e.size&&i+s.length>e.size)return r=!0,void a(new o(`content size at ${e.url} over limit: ${e.size}`,"max-size"));i+=s.length,t.push(s)}}),e.body.on("end",function(){if(!r){clearTimeout(n);try{s(Buffer.concat(t))}catch(t){a(new o(`Could not create Buffer from response body for ${e.url}: ${t.message}`,"system",t))}}})})}function u(e){return"object"==typeof e&&"function"==typeof e.append&&"function"==typeof e.delete&&"function"==typeof e.get&&"function"==typeof e.getAll&&"function"==typeof e.has&&"function"==typeof e.set&&("URLSearchParams"===e.constructor.name||"[object URLSearchParams]"===Object.prototype.toString.call(e)||"function"==typeof e.sort)}function f(e){let t,i,s=e.body;if(e.bodyUsed)throw new Error("cannot clone body after it is used");return s instanceof n&&"function"!=typeof s.getBoundary&&(t=new d,i=new d,s.pipe(t),s.pipe(i),e[c].body=t,s=i),s}function p(e){const t=e.body;return null===t?0:"string"==typeof t?Buffer.byteLength(t):u(t)?Buffer.byteLength(String(t)):t instanceof a?t.size:Buffer.isBuffer(t)?t.length:"[object ArrayBuffer]"===Object.prototype.toString.call(t)?t.byteLength:t&&"function"==typeof t.getLengthSync&&(t._lengthRetrievers&&0==t._lengthRetrievers.length||t.hasKnownLength&&t.hasKnownLength())?t.getLengthSync():null}h.prototype={get body(){return this[c].body},get bodyUsed(){return this[c].disturbed},arrayBuffer(){return l.call(this).then(function(e){return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)})},blob(){let e=this.headers&&this.headers.get("content-type")||"";return l.call(this).then(function(t){return Object.assign(new a([],{type:e.toLowerCase()}),{[s]:t})})},json(){var e=this;return l.call(this).then(function(t){try{return JSON.parse(t.toString())}catch(t){return h.Promise.reject(new o(`invalid json response body at ${e.url} reason: ${t.message}`,"invalid-json"))}})},text(){return l.call(this).then(function(e){return e.toString()})},buffer(){return l.call(this)},textConverted(){var e=this;return l.call(this).then(function(t){return function(e,t){if("function"!=typeof convert)throw new Error("The package `encoding` must be installed to use the textConverted() function");const i=t.get("content-type");let s,r,a="utf-8";i&&(s=/charset=([^;]*)/i.exec(i));r=e.slice(0,1024).toString(),!s&&r&&(s=/<meta.+?charset=(['"])(.+?)\1/i.exec(r));!s&&r&&(s=/<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(r))&&(s=/charset=(.*)/i.exec(s.pop()));!s&&r&&(s=/<\?xml.+?encoding=(['"])(.+?)\1/i.exec(r));s&&("gb2312"!==(a=s.pop())&&"gbk"!==a||(a="gb18030"));return convert(e,"UTF-8",a).toString()}(t,e.headers)})}},Object.defineProperties(h.prototype,{body:{enumerable:!0},bodyUsed:{enumerable:!0},arrayBuffer:{enumerable:!0},blob:{enumerable:!0},json:{enumerable:!0},text:{enumerable:!0}}),h.mixIn=function(e){for(const t of Object.getOwnPropertyNames(h.prototype))if(!(t in e)){const i=Object.getOwnPropertyDescriptor(h.prototype,t);Object.defineProperty(e,t,i)}},h.Promise=global.Promise;const m=/[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/,y=/[^\t\x20-\x7e\x80-\xff]/;function b(e){if(e=`${e}`,m.test(e))throw new TypeError(`${e} is not a legal HTTP header name`)}function v(e){if(e=`${e}`,y.test(e))throw new TypeError(`${e} is not a legal HTTP header value`)}function g(e,t){t=t.toLowerCase();for(const i in e)if(i.toLowerCase()===t)return i}const w=Symbol("map");class k{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:void 0;if(this[w]=Object.create(null),e instanceof k){const t=e.raw(),i=Object.keys(t);for(const e of i)for(const i of t[e])this.append(e,i)}else if(null==e);else{if("object"!=typeof e)throw new TypeError("Provided initializer must be an object");{const t=e[Symbol.iterator];if(null!=t){if("function"!=typeof t)throw new TypeError("Header pairs must be iterable");const i=[];for(const t of e){if("object"!=typeof t||"function"!=typeof t[Symbol.iterator])throw new TypeError("Each header pair must be iterable");i.push(Array.from(t))}for(const e of i){if(2!==e.length)throw new TypeError("Each header pair must be a name/value tuple");this.append(e[0],e[1])}}else for(const t of Object.keys(e)){const i=e[t];this.append(t,i)}}}}get(e){b(e=`${e}`);const t=g(this[w],e);return void 0===t?null:this[w][t].join(", ")}forEach(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,i=T(this),s=0;for(;s<i.length;){var r=i[s];const a=r[0],o=r[1];e.call(t,o,a,this),i=T(this),s++}}set(e,t){t=`${t}`,b(e=`${e}`),v(t);const i=g(this[w],e);this[w][void 0!==i?i:e]=[t]}append(e,t){t=`${t}`,b(e=`${e}`),v(t);const i=g(this[w],e);void 0!==i?this[w][i].push(t):this[w][e]=[t]}has(e){return b(e=`${e}`),void 0!==g(this[w],e)}delete(e){b(e=`${e}`);const t=g(this[w],e);void 0!==t&&delete this[w][t]}raw(){return this[w]}keys(){return _(this,"key")}values(){return _(this,"value")}[Symbol.iterator](){return _(this,"key+value")}}function T(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"key+value";return Object.keys(e[w]).sort().map("key"===t?function(e){return e.toLowerCase()}:"value"===t?function(t){return e[w][t].join(", ")}:function(t){return[t.toLowerCase(),e[w][t].join(", ")]})}k.prototype.entries=k.prototype[Symbol.iterator],Object.defineProperty(k.prototype,Symbol.toStringTag,{value:"Headers",writable:!1,enumerable:!1,configurable:!0}),Object.defineProperties(k.prototype,{get:{enumerable:!0},forEach:{enumerable:!0},set:{enumerable:!0},append:{enumerable:!0},has:{enumerable:!0},delete:{enumerable:!0},keys:{enumerable:!0},values:{enumerable:!0},entries:{enumerable:!0}});const O=Symbol("internal");function _(e,t){const i=Object.create(C);return i[O]={target:e,kind:t,index:0},i}const C=Object.setPrototypeOf({next(){if(!this||Object.getPrototypeOf(this)!==C)throw new TypeError("Value of `this` is not a HeadersIterator");var e=this[O];const t=e.target,i=e.kind,s=e.index,r=T(t,i);return s>=r.length?{value:void 0,done:!0}:(this[O].index=s+1,{value:r[s],done:!1})}},Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));function S(e){const t=Object.assign({__proto__:null},e[w]),i=g(e[w],"Host");return void 0!==i&&(t[i]=t[i][0]),t}Object.defineProperty(C,Symbol.toStringTag,{value:"HeadersIterator",writable:!1,enumerable:!1,configurable:!0});const x=i(16).STATUS_CODES,M=Symbol("Response internals");class I{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};h.call(this,e,t);const i=t.status||200;this[M]={url:t.url,status:i,statusText:t.statusText||x[i],headers:new k(t.headers)}}get url(){return this[M].url}get status(){return this[M].status}get ok(){return this[M].status>=200&&this[M].status<300}get statusText(){return this[M].statusText}get headers(){return this[M].headers}clone(){return new I(f(this),{url:this.url,status:this.status,statusText:this.statusText,headers:this.headers,ok:this.ok})}}h.mixIn(I.prototype),Object.defineProperties(I.prototype,{url:{enumerable:!0},status:{enumerable:!0},ok:{enumerable:!0},statusText:{enumerable:!0},headers:{enumerable:!0},clone:{enumerable:!0}}),Object.defineProperty(I.prototype,Symbol.toStringTag,{value:"Response",writable:!1,enumerable:!1,configurable:!0});var F=i(17);const B=F.format,A=F.parse,E=Symbol("Request internals");function P(e){return"object"==typeof e&&"object"==typeof e[E]}class q{constructor(e){let t,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};P(e)?t=A(e.url):(t=e&&e.href?A(e.href):A(`${e}`),e={});let s=i.method||e.method||"GET";if(s=s.toUpperCase(),(null!=i.body||P(e)&&null!==e.body)&&("GET"===s||"HEAD"===s))throw new TypeError("Request with GET/HEAD method cannot have body");let r=null!=i.body?i.body:P(e)&&null!==e.body?f(e):null;h.call(this,r,{timeout:i.timeout||e.timeout||0,size:i.size||e.size||0});const o=new k(i.headers||e.headers||{});if(null!=i.body){const e=function(e){const t=e.body;return null===t?null:"string"==typeof t?"text/plain;charset=UTF-8":u(t)?"application/x-www-form-urlencoded;charset=UTF-8":t instanceof a?t.type||null:Buffer.isBuffer(t)?null:"[object ArrayBuffer]"===Object.prototype.toString.call(t)?null:"function"==typeof t.getBoundary?`multipart/form-data;boundary=${t.getBoundary()}`:null}(this);null===e||o.has("Content-Type")||o.append("Content-Type",e)}this[E]={method:s,redirect:i.redirect||e.redirect||"follow",headers:o,parsedURL:t},this.follow=void 0!==i.follow?i.follow:void 0!==e.follow?e.follow:20,this.compress=void 0!==i.compress?i.compress:void 0===e.compress||e.compress,this.counter=i.counter||e.counter||0,this.agent=i.agent||e.agent}get method(){return this[E].method}get url(){return B(this[E].parsedURL)}get headers(){return this[E].headers}get redirect(){return this[E].redirect}clone(){return new q(this)}}h.mixIn(q.prototype),Object.defineProperty(q.prototype,Symbol.toStringTag,{value:"Request",writable:!1,enumerable:!1,configurable:!0}),Object.defineProperties(q.prototype,{method:{enumerable:!0},url:{enumerable:!0},headers:{enumerable:!0},redirect:{enumerable:!0},clone:{enumerable:!0}});const D=i(16),V=i(43);const R=i(11).PassThrough;const G=i(17).resolve,L=i(44);function N(e,t){if(!N.Promise)throw new Error("native promise missing, set fetch.Promise to your favorite alternative");return h.Promise=N.Promise,new N.Promise(function(i,r){const n=new q(e,t),d=function(e){const t=e[E].parsedURL,i=new k(e[E].headers);if(i.has("Accept")||i.set("Accept","*/*"),!t.protocol||!t.hostname)throw new TypeError("Only absolute URLs are supported");if(!/^https?:$/.test(t.protocol))throw new TypeError("Only HTTP(S) protocols are supported");let s=null;if(null==e.body&&/^(POST|PUT)$/i.test(e.method)&&(s="0"),null!=e.body){const t=p(e);"number"==typeof t&&(s=String(t))}return s&&i.set("Content-Length",s),i.has("User-Agent")||i.set("User-Agent","node-fetch/1.0 (+https://github.com/bitinn/node-fetch)"),e.compress&&i.set("Accept-Encoding","gzip,deflate"),i.has("Connection")||e.agent||i.set("Connection","close"),Object.assign({},t,{method:e.method,headers:S(i),agent:e.agent})}(n),c=(0,("https:"===d.protocol?V:D).request)(d);let h;function l(){c.abort(),clearTimeout(h)}n.timeout&&c.once("socket",function(e){h=setTimeout(function(){r(new o(`network timeout at: ${n.url}`,"request-timeout")),l()},n.timeout)}),c.on("error",function(e){r(new o(`request to ${n.url} failed, reason: ${e.message}`,"system",e)),l()}),c.on("response",function(e){clearTimeout(h);const t=function(e){const t=new k;for(const i of Object.keys(e))if(!m.test(i))if(Array.isArray(e[i]))for(const s of e[i])y.test(s)||(void 0===t[w][i]?t[w][i]=[s]:t[w][i].push(s));else y.test(e[i])||(t[w][i]=[e[i]]);return t}(e.headers);if(N.isRedirect(e.statusCode)){const s=t.get("Location"),a=null===s?null:G(n.url,s);switch(n.redirect){case"error":return r(new o(`redirect mode is set to error: ${n.url}`,"no-redirect")),void l();case"manual":null!==a&&t.set("Location",a);break;case"follow":if(null===a)break;if(n.counter>=n.follow)return r(new o(`maximum redirect reached at: ${n.url}`,"max-redirect")),void l();const s={headers:new k(n.headers),follow:n.follow,counter:n.counter+1,agent:n.agent,compress:n.compress,method:n.method,body:n.body};return 303!==e.statusCode&&n.body&&null===p(n)?(r(new o("Cannot follow redirect with body being a readable stream","unsupported-redirect")),void l()):(303!==e.statusCode&&(301!==e.statusCode&&302!==e.statusCode||"POST"!==n.method)||(s.method="GET",s.body=void 0,s.headers.delete("content-length")),i(N(new q(a,s))),void l())}}let s=e.pipe(new R);const a={url:n.url,status:e.statusCode,statusText:e.statusMessage,headers:t,size:n.size,timeout:n.timeout},d=t.get("Content-Encoding");if(!n.compress||"HEAD"===n.method||null===d||204===e.statusCode||304===e.statusCode)return void i(new I(s,a));const c={flush:L.Z_SYNC_FLUSH,finishFlush:L.Z_SYNC_FLUSH};if("gzip"==d||"x-gzip"==d)return s=s.pipe(L.createGunzip(c)),void i(new I(s,a));if("deflate"!=d&&"x-deflate"!=d)i(new I(s,a));else{e.pipe(new R).once("data",function(e){s=8==(15&e[0])?s.pipe(L.createInflate()):s.pipe(L.createInflateRaw()),i(new I(s,a))})}}),function(e,t){const i=t.body;null===i?e.end():"string"==typeof i?(e.write(i),e.end()):u(i)?(e.write(Buffer.from(String(i))),e.end()):i instanceof a?(e.write(i[s]),e.end()):Buffer.isBuffer(i)?(e.write(i),e.end()):"[object ArrayBuffer]"===Object.prototype.toString.call(i)?(e.write(Buffer.from(i)),e.end()):i.pipe(e)}(c,n)})}N.isRedirect=function(e){return 301===e||302===e||303===e||307===e||308===e},N.default=N,N.Promise=global.Promise,e.exports=t=N,t.Headers=k,t.Request=q,t.Response=I,t.FetchError=o},function(e,t){e.exports=require("https")},function(e,t){e.exports=require("zlib")},function(e,t,i){"use strict";const{isObject:s,isNumber:r,isDictionary:a,isArray:o}=i(18),n=Object.keys,d=e=>o(e)?e:Object.values(e),c=e=>new Set(d(e)),h=(...e)=>Object.assign({},...e),l=e=>o(e)?Array.from(e):h(e);e.exports={keys:n,values:d,extend:h,clone:l,index:c,ordered:e=>e,unique:e=>Array.from(c(e)),inArray:(e,t)=>t.includes(e),toArray:e=>Object.values(e),isEmpty:e=>!e||(Array.isArray(e)?e:Object.keys(e)).length<1,keysort(e,t={}){for(const i of n(e).sort())t[i]=e[i];return t},indexBy(e,t,i={}){for(const s of d(e))t in s&&(i[s[t]]=s);return i},groupBy(e,t,i={}){for(const s of d(e))if(t in s){const e=s[t];i[e]=i[e]||[],i[e].push(s)}return i},filterBy(e,t,i,s=[]){for(const r of d(e))r[t]===i&&s.push(r);return s},sortBy:(e,t,i=!1,s=(i?-1:1))=>e.sort((e,i)=>e[t]<i[t]?-s:e[t]>i[t]?s:0),flatten:function e(t,i=[]){for(const s of t)o(s)?e(s,i):i.push(s);return i},pluck:(e,t)=>d(e).filter(e=>t in e).map(e=>e[t]),omit(e,...t){if(!Array.isArray(e)){const i=l(e);for(const e of t)if(o(e))for(const t of e)delete i[t];else delete i[e];return i}return e},sum(...e){const t=e.filter(r);return t.length>0?t.reduce((e,t)=>e+t,0):void 0},deepExtend:function e(...t){let i=void 0;for(const r of t)if(a(r)){s(i)||(i={});for(const t in r)i[t]=e(i[t],r[t])}else i=r;return i}}},function(e,t,i){"use strict";var s=i(47),r=i(48),a=i(21);e.exports={formats:a,parse:r,stringify:s}},function(e,t,i){"use strict";var s=i(20),r=i(21),a=Object.prototype.hasOwnProperty,o={brackets:function(e){return e+"[]"},comma:"comma",indices:function(e,t){return e+"["+t+"]"},repeat:function(e){return e}},n=Array.isArray,d=Array.prototype.push,c=function(e,t){d.apply(e,n(t)?t:[t])},h=Date.prototype.toISOString,l={addQueryPrefix:!1,allowDots:!1,charset:"utf-8",charsetSentinel:!1,delimiter:"&",encode:!0,encoder:s.encode,encodeValuesOnly:!1,formatter:r.formatters[r.default],indices:!1,serializeDate:function(e){return h.call(e)},skipNulls:!1,strictNullHandling:!1},u=function e(t,i,r,a,o,d,h,u,f,p,m,y,b){var v=t;if("function"==typeof h?v=h(i,v):v instanceof Date?v=p(v):"comma"===r&&n(v)&&(v=v.join(",")),null===v){if(a)return d&&!y?d(i,l.encoder,b):i;v=""}if("string"==typeof v||"number"==typeof v||"boolean"==typeof v||s.isBuffer(v))return d?[m(y?i:d(i,l.encoder,b))+"="+m(d(v,l.encoder,b))]:[m(i)+"="+m(String(v))];var g,w=[];if(void 0===v)return w;if(n(h))g=h;else{var k=Object.keys(v);g=u?k.sort(u):k}for(var T=0;T<g.length;++T){var O=g[T];o&&null===v[O]||(n(v)?c(w,e(v[O],"function"==typeof r?r(i,O):i,r,a,o,d,h,u,f,p,m,y,b)):c(w,e(v[O],i+(f?"."+O:"["+O+"]"),r,a,o,d,h,u,f,p,m,y,b)))}return w};e.exports=function(e,t){var i,s=e,d=function(e){if(!e)return l;if(null!==e.encoder&&void 0!==e.encoder&&"function"!=typeof e.encoder)throw new TypeError("Encoder has to be a function.");var t=e.charset||l.charset;if(void 0!==e.charset&&"utf-8"!==e.charset&&"iso-8859-1"!==e.charset)throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");var i=r.default;if(void 0!==e.format){if(!a.call(r.formatters,e.format))throw new TypeError("Unknown format option provided.");i=e.format}var s=r.formatters[i],o=l.filter;return("function"==typeof e.filter||n(e.filter))&&(o=e.filter),{addQueryPrefix:"boolean"==typeof e.addQueryPrefix?e.addQueryPrefix:l.addQueryPrefix,allowDots:void 0===e.allowDots?l.allowDots:!!e.allowDots,charset:t,charsetSentinel:"boolean"==typeof e.charsetSentinel?e.charsetSentinel:l.charsetSentinel,delimiter:void 0===e.delimiter?l.delimiter:e.delimiter,encode:"boolean"==typeof e.encode?e.encode:l.encode,encoder:"function"==typeof e.encoder?e.encoder:l.encoder,encodeValuesOnly:"boolean"==typeof e.encodeValuesOnly?e.encodeValuesOnly:l.encodeValuesOnly,filter:o,formatter:s,serializeDate:"function"==typeof e.serializeDate?e.serializeDate:l.serializeDate,skipNulls:"boolean"==typeof e.skipNulls?e.skipNulls:l.skipNulls,sort:"function"==typeof e.sort?e.sort:null,strictNullHandling:"boolean"==typeof e.strictNullHandling?e.strictNullHandling:l.strictNullHandling}}(t);"function"==typeof d.filter?s=(0,d.filter)("",s):n(d.filter)&&(i=d.filter);var h,f=[];if("object"!=typeof s||null===s)return"";h=t&&t.arrayFormat in o?t.arrayFormat:t&&"indices"in t?t.indices?"indices":"repeat":"indices";var p=o[h];i||(i=Object.keys(s)),d.sort&&i.sort(d.sort);for(var m=0;m<i.length;++m){var y=i[m];d.skipNulls&&null===s[y]||c(f,u(s[y],y,p,d.strictNullHandling,d.skipNulls,d.encode?d.encoder:null,d.filter,d.sort,d.allowDots,d.serializeDate,d.formatter,d.encodeValuesOnly,d.charset))}var b=f.join(d.delimiter),v=!0===d.addQueryPrefix?"?":"";return d.charsetSentinel&&("iso-8859-1"===d.charset?v+="utf8=%26%2310003%3B&":v+="utf8=%E2%9C%93&"),b.length>0?v+b:""}},function(e,t,i){"use strict";var s=i(20),r=Object.prototype.hasOwnProperty,a={allowDots:!1,allowPrototypes:!1,arrayLimit:20,charset:"utf-8",charsetSentinel:!1,comma:!1,decoder:s.decode,delimiter:"&",depth:5,ignoreQueryPrefix:!1,interpretNumericEntities:!1,parameterLimit:1e3,parseArrays:!0,plainObjects:!1,strictNullHandling:!1},o=function(e){return e.replace(/&#(\d+);/g,function(e,t){return String.fromCharCode(parseInt(t,10))})},n=function(e,t,i){if(e){var s=i.allowDots?e.replace(/\.([^.[]+)/g,"[$1]"):e,a=/(\[[^[\]]*])/g,o=/(\[[^[\]]*])/.exec(s),n=o?s.slice(0,o.index):s,d=[];if(n){if(!i.plainObjects&&r.call(Object.prototype,n)&&!i.allowPrototypes)return;d.push(n)}for(var c=0;null!==(o=a.exec(s))&&c<i.depth;){if(c+=1,!i.plainObjects&&r.call(Object.prototype,o[1].slice(1,-1))&&!i.allowPrototypes)return;d.push(o[1])}return o&&d.push("["+s.slice(o.index)+"]"),function(e,t,i){for(var s=t,r=e.length-1;r>=0;--r){var a,o=e[r];if("[]"===o&&i.parseArrays)a=[].concat(s);else{a=i.plainObjects?Object.create(null):{};var n="["===o.charAt(0)&&"]"===o.charAt(o.length-1)?o.slice(1,-1):o,d=parseInt(n,10);i.parseArrays||""!==n?!isNaN(d)&&o!==n&&String(d)===n&&d>=0&&i.parseArrays&&d<=i.arrayLimit?(a=[])[d]=s:a[n]=s:a={0:s}}s=a}return s}(d,t,i)}};e.exports=function(e,t){var i=function(e){if(!e)return a;if(null!==e.decoder&&void 0!==e.decoder&&"function"!=typeof e.decoder)throw new TypeError("Decoder has to be a function.");if(void 0!==e.charset&&"utf-8"!==e.charset&&"iso-8859-1"!==e.charset)throw new Error("The charset option must be either utf-8, iso-8859-1, or undefined");var t=void 0===e.charset?a.charset:e.charset;return{allowDots:void 0===e.allowDots?a.allowDots:!!e.allowDots,allowPrototypes:"boolean"==typeof e.allowPrototypes?e.allowPrototypes:a.allowPrototypes,arrayLimit:"number"==typeof e.arrayLimit?e.arrayLimit:a.arrayLimit,charset:t,charsetSentinel:"boolean"==typeof e.charsetSentinel?e.charsetSentinel:a.charsetSentinel,comma:"boolean"==typeof e.comma?e.comma:a.comma,decoder:"function"==typeof e.decoder?e.decoder:a.decoder,delimiter:"string"==typeof e.delimiter||s.isRegExp(e.delimiter)?e.delimiter:a.delimiter,depth:"number"==typeof e.depth?e.depth:a.depth,ignoreQueryPrefix:!0===e.ignoreQueryPrefix,interpretNumericEntities:"boolean"==typeof e.interpretNumericEntities?e.interpretNumericEntities:a.interpretNumericEntities,parameterLimit:"number"==typeof e.parameterLimit?e.parameterLimit:a.parameterLimit,parseArrays:!1!==e.parseArrays,plainObjects:"boolean"==typeof e.plainObjects?e.plainObjects:a.plainObjects,strictNullHandling:"boolean"==typeof e.strictNullHandling?e.strictNullHandling:a.strictNullHandling}}(t);if(""===e||null==e)return i.plainObjects?Object.create(null):{};for(var d="string"==typeof e?function(e,t){var i,n={},d=t.ignoreQueryPrefix?e.replace(/^\?/,""):e,c=t.parameterLimit===1/0?void 0:t.parameterLimit,h=d.split(t.delimiter,c),l=-1,u=t.charset;if(t.charsetSentinel)for(i=0;i<h.length;++i)0===h[i].indexOf("utf8=")&&("utf8=%E2%9C%93"===h[i]?u="utf-8":"utf8=%26%2310003%3B"===h[i]&&(u="iso-8859-1"),l=i,i=h.length);for(i=0;i<h.length;++i)if(i!==l){var f,p,m=h[i],y=m.indexOf("]="),b=-1===y?m.indexOf("="):y+1;-1===b?(f=t.decoder(m,a.decoder,u),p=t.strictNullHandling?null:""):(f=t.decoder(m.slice(0,b),a.decoder,u),p=t.decoder(m.slice(b+1),a.decoder,u)),p&&t.interpretNumericEntities&&"iso-8859-1"===u&&(p=o(p)),p&&t.comma&&p.indexOf(",")>-1&&(p=p.split(",")),r.call(n,f)?n[f]=s.combine(n[f],p):n[f]=p}return n}(e,i):e,c=i.plainObjects?Object.create(null):{},h=Object.keys(d),l=0;l<h.length;++l){var u=h[l],f=n(u,d[u],i);c=s.merge(c,f,i)}return s.compact(c)}},function(e,t,i){"use strict";const s=i(6),{capitalize:r}=i(10),{stringToBase64:a,utf16ToBase64:o,urlencodeBase64:n}=i(19),d=i(50),c=i(4).ec,{ArgumentsRequired:h}=i(0),l=(e,t="md5",i="hex")=>{const a={};"keccak"===t&&(t="SHA3",a.outputLength=256);const o=s[t.toUpperCase()](e,a);return"binary"===i?o:o.toString(s.enc[r(i)])},u=(e,t,i="sha256",a="hex")=>{const o=s["Hmac"+i.toUpperCase()](e,t);if(a){const e="binary"===a?"Latin1":r(a);return o.toString(s.enc[r(e)])}return o};function f(e,t,i="RS256"){const s={RS256:"pkcs1-sha256",RS512:"pkcs1-sha512"};if(!(i in s))throw new ExchangeError(i+" is not a supported rsa signing algorithm.");return new d(t,{environment:"browser",signingScheme:s[i]}).sign(e,"base64","binary")}e.exports={hash:l,hmac:u,jwt:function(e,t,i="HS256"){const s=[n(a(JSON.stringify({alg:i,typ:"JWT"}))),n(a(JSON.stringify(e)))].join("."),r=i.slice(0,2);let o=void 0;return"HS"===r?o=n(u(s,t,{HS256:"sha256",HS384:"sha384",HS512:"sha512"}[i],"base64")):"RS"===r&&(o=n(f(s,t,i))),[s,o].join(".")},totp:e=>{const t=e=>parseInt(e,16),i=(e,t)=>(t+e).slice(-t.length);return(e=>{e=e.replace(" ","");let r=Math.round((new Date).getTime()/1e3),a=i((e=>(e<15.5?"0":"")+Math.round(e).toString(16))(Math.floor(r/30)),"0000000000000000"),o=u(s.enc.Hex.parse(a),s.enc.Hex.parse((e=>{let t="",s="";for(let s=0;s<e.length;s++){let r="ABCDEFGHIJKLMNOPQRSTUVWXYZ234567".indexOf(e.charAt(s).toUpperCase());t+=i(r.toString(2),"00000")}for(let e=0;e+4<=t.length;e+=4){let i=t.substr(e,4);s+=parseInt(i,2).toString(16)}return s})(e)),"sha1","hex"),n=t(o.substring(o.length-1)),d=(t(o.substr(2*n,8))&t("7fffffff"))+"";return d=d.substr(d.length-6,6)})(e)},rsa:f,ecdsa:function(e,t,i="p256",s){let r=e;void 0!==s&&(r=l(e,s,"hex"));const a=new c(i).sign(r,t,"hex",{canonical:!0});return{r:a.r.toString(16).padStart(64,"0"),s:a.s.toString(16).padStart(64,"0"),v:a.recoveryParam}}}},function(e,t,i){
/*!
 * RSA library for Node.js
 *
 * Author: rzcoder
 * License MIT
 */
var s=i(51),r=i(3)._,a=i(23),o=i(54);e.exports=function(){var e={browser:["md5","ripemd160","sha1","sha256","sha512"]},t="pkcs1",i="pkcs1",n={private:"pkcs1-private-pem","private-der":"pkcs1-private-der",public:"pkcs8-public-pem","public-der":"pkcs8-public-der"};function d(e,a,o){if(!(this instanceof d))return new d(e,a,o);r.isObject(a)&&(o=a,a=void 0),this.$options={signingScheme:i,signingSchemeOptions:{hash:"sha256",saltLength:null},encryptionScheme:t,encryptionSchemeOptions:{hash:"sha1",label:null},environment:"browser",rsaUtils:this},this.keyPair=new s.Key,this.$cache={},Buffer.isBuffer(e)||r.isString(e)?this.importKey(e,a):r.isObject(e)&&this.generateKeyPair(e.b,e.e),this.setOptions(o)}return d.prototype.setOptions=function(s){if((s=s||{}).environment&&(this.$options.environment=s.environment),s.signingScheme){if(r.isString(s.signingScheme)){var o=s.signingScheme.toLowerCase().split("-");1==o.length?e.node.indexOf(o[0])>-1?(this.$options.signingSchemeOptions={hash:o[0]},this.$options.signingScheme=i):(this.$options.signingScheme=o[0],this.$options.signingSchemeOptions={hash:null}):(this.$options.signingSchemeOptions={hash:o[1]},this.$options.signingScheme=o[0])}else r.isObject(s.signingScheme)&&(this.$options.signingScheme=s.signingScheme.scheme||i,this.$options.signingSchemeOptions=r.omit(s.signingScheme,"scheme"));if(!a.isSignature(this.$options.signingScheme))throw Error("Unsupported signing scheme");if(this.$options.signingSchemeOptions.hash&&-1===e[this.$options.environment].indexOf(this.$options.signingSchemeOptions.hash))throw Error("Unsupported hashing algorithm for "+this.$options.environment+" environment")}if(s.encryptionScheme){if(r.isString(s.encryptionScheme)?(this.$options.encryptionScheme=s.encryptionScheme.toLowerCase(),this.$options.encryptionSchemeOptions={}):r.isObject(s.encryptionScheme)&&(this.$options.encryptionScheme=s.encryptionScheme.scheme||t,this.$options.encryptionSchemeOptions=r.omit(s.encryptionScheme,"scheme")),!a.isEncryption(this.$options.encryptionScheme))throw Error("Unsupported encryption scheme");if(this.$options.encryptionSchemeOptions.hash&&-1===e[this.$options.environment].indexOf(this.$options.encryptionSchemeOptions.hash))throw Error("Unsupported hashing algorithm for "+this.$options.environment+" environment")}this.keyPair.setOptions(this.$options)},d.prototype.importKey=function(e,t){if(!e)throw Error("Empty key given");if(t&&(t=n[t]||t),!o.detectAndImport(this.keyPair,e,t)&&void 0===t)throw Error("Key format must be specified");return this.$cache={},this},d.prototype.isPrivate=function(){return this.keyPair.isPrivate()},d.prototype.isPublic=function(e){return this.keyPair.isPublic(e)},d.prototype.isEmpty=function(e){return!(this.keyPair.n||this.keyPair.e||this.keyPair.d)},d.prototype.sign=function(e,t,i){if(!this.isPrivate())throw Error("This is not private key");var s=this.keyPair.sign(this.$getDataForEncrypt(e,i));return t&&"buffer"!=t&&(s=s.toString(t)),s},d.prototype.$getDataForEncrypt=function(e,t){if(r.isString(e)||r.isNumber(e))return Buffer.from(""+e,t||"utf8");if(Buffer.isBuffer(e))return e;if(r.isObject(e))return Buffer.from(JSON.stringify(e));throw Error("Unexpected data type")},d}()},function(e,t,i){var s=i(3)._,r=i(22),a=i(3),o=i(23);e.exports.Key=function(){function e(){this.n=null,this.e=0,this.d=null,this.p=null,this.q=null,this.dmp1=null,this.dmq1=null,this.coeff=null}return e.prototype.setOptions=function(e){var t=o[e.signingScheme],i=o[e.encryptionScheme];t===i?this.signingScheme=this.encryptionScheme=i.makeScheme(this,e):(this.encryptionScheme=i.makeScheme(this,e),this.signingScheme=t.makeScheme(this,e))},e.prototype.setPrivate=function(e,t,i,o,n,d,c,h){if(!(e&&t&&i&&e.length>0&&(s.isNumber(t)||t.length>0)&&i.length>0))throw Error("Invalid RSA private key");this.n=new r(e),this.e=s.isNumber(t)?t:a.get32IntFromBuffer(t,0),this.d=new r(i),o&&n&&d&&c&&h&&(this.p=new r(o),this.q=new r(n),this.dmp1=new r(d),this.dmq1=new r(c),this.coeff=new r(h)),this.$$recalculateCache()},e.prototype.$doPrivate=function(e){if(this.p||this.q)return e.modPow(this.d,this.n);for(var t=e.mod(this.p).modPow(this.dmp1,this.p),i=e.mod(this.q).modPow(this.dmq1,this.q);t.compareTo(i)<0;)t=t.add(this.p);return t.subtract(i).multiply(this.coeff).mod(this.p).multiply(this.q).add(i)},e.prototype.sign=function(e){return this.signingScheme.sign.apply(this.signingScheme,arguments)},e.prototype.isPrivate=function(){return this.n&&this.e&&this.d||!1},Object.defineProperty(e.prototype,"keySize",{get:function(){return this.cache.keyBitLength}}),Object.defineProperty(e.prototype,"encryptedDataLength",{get:function(){return this.cache.keyByteLength}}),Object.defineProperty(e.prototype,"maxMessageLength",{get:function(){return this.encryptionScheme.maxMessageLength()}}),e.prototype.$$recalculateCache=function(){this.cache=this.cache||{},this.cache.keyBitLength=this.n.bitLength(),this.cache.keyByteLength=this.cache.keyBitLength+6>>3},e}()},function(e,t,i){var s=i(22),r=i(6),a=3;i(53);var o={md2:Buffer.from("3020300c06082a864886f70d020205000410","hex"),md5:Buffer.from("3020300c06082a864886f70d020505000410","hex"),sha1:Buffer.from("3021300906052b0e03021a05000414","hex"),sha224:Buffer.from("302d300d06096086480165030402040500041c","hex"),sha256:Buffer.from("3031300d060960864801650304020105000420","hex"),sha384:Buffer.from("3041300d060960864801650304020205000430","hex"),sha512:Buffer.from("3051300d060960864801650304020305000440","hex"),ripemd160:Buffer.from("3021300906052b2403020105000414","hex"),rmd160:Buffer.from("3021300906052b2403020105000414","hex")},n={ripemd160:"rmd160"};function d(e,t){var i=[];return t>0&&i.push(e>>>24),t>1&&i.push(e>>>16&255),t>2&&i.push(e>>>8&255),t>3&&i.push(255&e),i}e.exports={isEncryption:!0,isSignature:!0},e.exports.makeScheme=function(e,t){function i(e,t){this.key=e,this.options=t}return i.prototype.maxMessageLength=function(){return this.options.encryptionSchemeOptions&&this.options.encryptionSchemeOptions.padding==a?this.key.encryptedDataLength:this.key.encryptedDataLength-11},i.prototype.encUnPad=function(e,t){t=t||{};var i=0;if(this.options.encryptionSchemeOptions&&this.options.encryptionSchemeOptions.padding==a)return"function"==typeof e.lastIndexOf?e.slice(e.lastIndexOf("\0")+1,e.length):e.slice(String.prototype.lastIndexOf.call(e,"\0")+1,e.length);if(e.length<4)return null;if(1===t.type){if(0!==e[0]&&1!==e[1])return null;for(i=3;0!==e[i];)if(255!=e[i]||++i>=e.length)return null}else{if(0!==e[0]&&2!==e[1])return null;for(i=3;0!==e[i];)if(++i>=e.length)return null}return e.slice(i+1,e.length)},i.prototype.sign=function(e){var t=this.options.signingSchemeOptions.hash||"sha256";if("browser"===this.options.environment){var i=function(e){let t=void 0;if(!e.hasOwnProperty("sigBytes")||!e.hasOwnProperty("words"))throw Error("Argument not a wordArray");t=e.sigBytes,e=e.words;const i=[];let s=[],r=0;for(;t>0;)s=d(e[r],Math.min(4,t)),t-=s.length,i.push(s),r++;return new Buffer.from([].concat.apply([],i),"hex")}(r[(t=n[t]||t).toUpperCase()](e.toString())),a=this.pkcs1pad(i,t);return this.key.$doPrivate(new s(a)).toBuffer(this.key.encryptedDataLength)}throw new Error("CCXT only supports browser mode :P")},i.prototype.pkcs1pad=function(e,t){var i=o[t];if(!i)throw Error("Unsupported hash algorithm");var s=Buffer.concat([i,e]);if(s.length+10>this.key.encryptedDataLength)throw Error("Key is too short for signing algorithm ("+t+")");var r=Buffer.alloc(this.key.encryptedDataLength-s.length-1);return r.fill(255,0,r.length-1),r[0]=1,r[r.length-1]=0,Buffer.concat([r,s])},new i(e,t)}},function(e,t){e.exports=require("constants")},function(e,t,i){i(3)._;e.exports={pkcs1:i(55),pkcs8:i(59),components:i(60),detectAndImport:function(t,i,s){if(void 0===s){for(var r in e.exports)if("function"==typeof e.exports[r].autoImport&&e.exports[r].autoImport(t,i))return!0}else if(s){var a=formatParse(s);if(!e.exports[a.scheme])throw Error("Unsupported key format");"private"===a.keyType?e.exports[a.scheme].privateImport(t,i,a.keyOpt):e.exports[a.scheme].publicImport(t,i,a.keyOpt)}return!1}}},function(e,t,i){var s=i(24).Ber,r=i(3)._,a=i(3);e.exports={privateExport:function(e,t){t=t||{};var i=e.n.toBuffer(),r=e.d.toBuffer(),o=e.p.toBuffer(),n=e.q.toBuffer(),d=e.dmp1.toBuffer(),c=e.dmq1.toBuffer(),h=e.coeff.toBuffer(),l=i.length+r.length+o.length+n.length+d.length+c.length+h.length+512,u=new s.Writer({size:l});return u.startSequence(),u.writeInt(0),u.writeBuffer(i,2),u.writeInt(e.e),u.writeBuffer(r,2),u.writeBuffer(o,2),u.writeBuffer(n,2),u.writeBuffer(d,2),u.writeBuffer(c,2),u.writeBuffer(h,2),u.endSequence(),"der"===t.type?u.buffer:"-----BEGIN RSA PRIVATE KEY-----\n"+a.linebrk(u.buffer.toString("base64"),64)+"\n-----END RSA PRIVATE KEY-----"},privateImport:function(e,t,i){var o;if("der"!==(i=i||{}).type){if(Buffer.isBuffer(t)&&(t=t.toString("utf8")),!r.isString(t))throw Error("Unsupported key format");var n=a.trimSurroundingText(t,"-----BEGIN RSA PRIVATE KEY-----","-----END RSA PRIVATE KEY-----").replace(/\s+|\n\r|\n|\r$/gm,"");o=Buffer.from(n,"base64")}else{if(!Buffer.isBuffer(t))throw Error("Unsupported key format");o=t}var d=new s.Reader(o);d.readSequence(),d.readString(2,!0),e.setPrivate(d.readString(2,!0),d.readString(2,!0),d.readString(2,!0),d.readString(2,!0),d.readString(2,!0),d.readString(2,!0),d.readString(2,!0),d.readString(2,!0))},publicExport:function(e,t){t=t||{};var i=e.n.toBuffer(),r=i.length+512,o=new s.Writer({size:r});return o.startSequence(),o.writeBuffer(i,2),o.writeInt(e.e),o.endSequence(),"der"===t.type?o.buffer:"-----BEGIN RSA PUBLIC KEY-----\n"+a.linebrk(o.buffer.toString("base64"),64)+"\n-----END RSA PUBLIC KEY-----"},publicImport:function(e,t,i){var o;if("der"!==(i=i||{}).type){if(Buffer.isBuffer(t)&&(t=t.toString("utf8")),r.isString(t)){var n=a.trimSurroundingText(t,"-----BEGIN RSA PUBLIC KEY-----","-----END RSA PUBLIC KEY-----").replace(/\s+|\n\r|\n|\r$/gm,"");o=Buffer.from(n,"base64")}}else{if(!Buffer.isBuffer(t))throw Error("Unsupported key format");o=t}var d=new s.Reader(o);d.readSequence(),e.setPublic(d.readString(2,!0),d.readString(2,!0))},autoImport:function(t,i){return/^[\S\s]*-----BEGIN RSA PRIVATE KEY-----\s*(?=(([A-Za-z0-9+\/=]+\s*)+))\1-----END RSA PRIVATE KEY-----[\S\s]*$/g.test(i)?(e.exports.privateImport(t,i),!0):!!/^[\S\s]*-----BEGIN RSA PUBLIC KEY-----\s*(?=(([A-Za-z0-9+\/=]+\s*)+))\1-----END RSA PUBLIC KEY-----[\S\s]*$/g.test(i)&&(e.exports.publicImport(t,i),!0)}}},function(e,t,i){var s=i(25),r=i(26),a=i(57);for(var o in e.exports={Reader:a},r)r.hasOwnProperty(o)&&(e.exports[o]=r[o]);for(var n in s)s.hasOwnProperty(n)&&(e.exports[n]=s[n])},function(e,t,i){var s=i(58),r=i(26),a=i(25).newInvalidAsn1Error;function o(e){if(!e||!Buffer.isBuffer(e))throw new TypeError("data must be a node Buffer");this._buf=e,this._size=e.length,this._len=0,this._offset=0}Object.defineProperty(o.prototype,"length",{enumerable:!0,get:function(){return this._len}}),Object.defineProperty(o.prototype,"offset",{enumerable:!0,get:function(){return this._offset}}),Object.defineProperty(o.prototype,"remain",{get:function(){return this._size-this._offset}}),Object.defineProperty(o.prototype,"buffer",{get:function(){return this._buf.slice(this._offset)}}),o.prototype.readByte=function(e){if(this._size-this._offset<1)return null;var t=255&this._buf[this._offset];return e||(this._offset+=1),t},o.prototype.peek=function(){return this.readByte(!0)},o.prototype.readLength=function(e){if(void 0===e&&(e=this._offset),e>=this._size)return null;var t=255&this._buf[e++];if(null===t)return null;if(128==(128&t)){if(0===(t&=127))throw a("Indefinite length not supported");if(t>4)throw a("encoding too long");if(this._size-e<t)return null;this._len=0;for(var i=0;i<t;i++)this._len=(this._len<<8)+(255&this._buf[e++])}else this._len=t;return e},o.prototype.readSequence=function(e){var t=this.peek();if(null===t)return null;if(void 0!==e&&e!==t)throw a("Expected 0x"+e.toString(16)+": got 0x"+t.toString(16));var i=this.readLength(this._offset+1);return null===i?null:(this._offset=i,t)},o.prototype.readInt=function(){return this._readTag(r.Integer)},o.prototype.readBoolean=function(){return 0!==this._readTag(r.Boolean)},o.prototype.readEnumeration=function(){return this._readTag(r.Enumeration)},o.prototype.readString=function(e,t){e||(e=r.OctetString);var i=this.peek();if(null===i)return null;if(i!==e)throw a("Expected 0x"+e.toString(16)+": got 0x"+i.toString(16));var s=this.readLength(this._offset+1);if(null===s)return null;if(this.length>this._size-s)return null;if(this._offset=s,0===this.length)return t?Buffer.alloc(0):"";var o=this._buf.slice(this._offset,this._offset+this.length);return this._offset+=this.length,t?o:o.toString("utf8")},o.prototype.readOID=function(e){e||(e=r.OID);var t=this.readString(e,!0);if(null===t)return null;for(var i=[],s=0,a=0;a<t.length;a++){var o=255&t[a];s<<=7,s+=127&o,0==(128&o)&&(i.push(s),s=0)}return s=i.shift(),i.unshift(s%40),i.unshift(s/40>>0),i.join(".")},o.prototype._readTag=function(e){s.ok(void 0!==e);var t=this.peek();if(null===t)return null;if(t!==e)throw a("Expected 0x"+e.toString(16)+": got 0x"+t.toString(16));var i=this.readLength(this._offset+1);if(null===i)return null;if(this.length>4)throw a("Integer too long: "+this.length);if(this.length>this._size-i)return null;this._offset=i;for(var r=this._buf[this._offset],o=0,n=0;n<this.length;n++)o<<=8,o|=255&this._buf[this._offset++];return 128==(128&r)&&4!==n&&(o-=1<<8*n),o>>0},e.exports=o},function(e,t){e.exports=require("assert")},function(e,t,i){var s=i(24).Ber,r=i(3)._,a=i(3);e.exports={privateExport:function(e,t){t=t||{};var i=e.n.toBuffer(),r=e.d.toBuffer(),o=e.p.toBuffer(),n=e.q.toBuffer(),d=e.dmp1.toBuffer(),c=e.dmq1.toBuffer(),h=e.coeff.toBuffer(),l=i.length+r.length+o.length+n.length+d.length+c.length+h.length+512,u=new s.Writer({size:l});u.startSequence(),u.writeInt(0),u.writeBuffer(i,2),u.writeInt(e.e),u.writeBuffer(r,2),u.writeBuffer(o,2),u.writeBuffer(n,2),u.writeBuffer(d,2),u.writeBuffer(c,2),u.writeBuffer(h,2),u.endSequence();var f=new s.Writer({size:l});return f.startSequence(),f.writeInt(0),f.startSequence(),f.writeOID("1.2.840.113549.1.1.1"),f.writeNull(),f.endSequence(),f.writeBuffer(u.buffer,4),f.endSequence(),"der"===t.type?f.buffer:"-----BEGIN PRIVATE KEY-----\n"+a.linebrk(f.buffer.toString("base64"),64)+"\n-----END PRIVATE KEY-----"},privateImport:function(e,t,i){var o;if("der"!==(i=i||{}).type){if(Buffer.isBuffer(t)&&(t=t.toString("utf8")),!r.isString(t))throw Error("Unsupported key format");var n=a.trimSurroundingText(t,"-----BEGIN PRIVATE KEY-----","-----END PRIVATE KEY-----").replace("-----END PRIVATE KEY-----","").replace(/\s+|\n\r|\n|\r$/gm,"");o=Buffer.from(n,"base64")}else{if(!Buffer.isBuffer(t))throw Error("Unsupported key format");o=t}var d=new s.Reader(o);if(d.readSequence(),d.readInt(0),"1.2.840.113549.1.1.1"!==new s.Reader(d.readString(48,!0)).readOID(6,!0))throw Error("Invalid Public key format");var c=new s.Reader(d.readString(4,!0));c.readSequence(),c.readString(2,!0),e.setPrivate(c.readString(2,!0),c.readString(2,!0),c.readString(2,!0),c.readString(2,!0),c.readString(2,!0),c.readString(2,!0),c.readString(2,!0),c.readString(2,!0))},publicExport:function(e,t){t=t||{};var i=e.n.toBuffer(),r=i.length+512,o=new s.Writer({size:r});o.writeByte(0),o.startSequence(),o.writeBuffer(i,2),o.writeInt(e.e),o.endSequence();var n=new s.Writer({size:r});return n.startSequence(),n.startSequence(),n.writeOID("1.2.840.113549.1.1.1"),n.writeNull(),n.endSequence(),n.writeBuffer(o.buffer,3),n.endSequence(),"der"===t.type?n.buffer:"-----BEGIN PUBLIC KEY-----\n"+a.linebrk(n.buffer.toString("base64"),64)+"\n-----END PUBLIC KEY-----"},publicImport:function(e,t,i){var o;if("der"!==(i=i||{}).type){if(Buffer.isBuffer(t)&&(t=t.toString("utf8")),r.isString(t)){var n=a.trimSurroundingText(t,"-----BEGIN PUBLIC KEY-----","-----END PUBLIC KEY-----").replace(/\s+|\n\r|\n|\r$/gm,"");o=Buffer.from(n,"base64")}}else{if(!Buffer.isBuffer(t))throw Error("Unsupported key format");o=t}var d=new s.Reader(o);if(d.readSequence(),"1.2.840.113549.1.1.1"!==new s.Reader(d.readString(48,!0)).readOID(6,!0))throw Error("Invalid Public key format");var c=new s.Reader(d.readString(3,!0));c.readByte(),c.readSequence(),e.setPublic(c.readString(2,!0),c.readString(2,!0))},autoImport:function(t,i){return/^[\S\s]*-----BEGIN PRIVATE KEY-----\s*(?=(([A-Za-z0-9+\/=]+\s*)+))\1-----END PRIVATE KEY-----[\S\s]*$/g.test(i)?(e.exports.privateImport(t,i),!0):!!/^[\S\s]*-----BEGIN PUBLIC KEY-----\s*(?=(([A-Za-z0-9+\/=]+\s*)+))\1-----END PUBLIC KEY-----[\S\s]*$/g.test(i)&&(e.exports.publicImport(t,i),!0)}}},function(e,t,i){i(3)._,i(3);e.exports={privateExport:function(e,t){return{n:e.n.toBuffer(),e:e.e,d:e.d.toBuffer(),p:e.p.toBuffer(),q:e.q.toBuffer(),dmp1:e.dmp1.toBuffer(),dmq1:e.dmq1.toBuffer(),coeff:e.coeff.toBuffer()}},privateImport:function(e,t,i){if(!(t.n&&t.e&&t.d&&t.p&&t.q&&t.dmp1&&t.dmq1&&t.coeff))throw Error("Invalid key data");e.setPrivate(t.n,t.e,t.d,t.p,t.q,t.dmp1,t.dmq1,t.coeff)},publicExport:function(e,t){return{n:e.n.toBuffer(),e:e.e}},publicImport:function(e,t,i){if(!t.n||!t.e)throw Error("Invalid key data");e.setPublic(t.n,t.e)},autoImport:function(t,i){return!(!i.n||!i.e)&&(i.d&&i.p&&i.q&&i.dmp1&&i.dmq1&&i.coeff?(e.exports.privateImport(t,i),!0):(e.exports.publicImport(t,i),!0))}}},function(e,t){e.exports=function(e){return e.webpackPolyfill||(e.deprecate=function(){},e.paths=[],e.children||(e.children=[]),Object.defineProperty(e,"loaded",{enumerable:!0,get:function(){return e.l}}),Object.defineProperty(e,"id",{enumerable:!0,get:function(){return e.i}}),e.webpackPolyfill=1),e}},function(e,t){e.exports=require("buffer")},function(e,t,i){"use strict";var s=i(5),r=i(4).utils,a=r.getNAF,o=r.getJSF,n=r.assert;function d(e,t){this.type=e,this.p=new s(t.p,16),this.red=t.prime?s.red(t.prime):s.mont(this.p),this.zero=new s(0).toRed(this.red),this.one=new s(1).toRed(this.red),this.two=new s(2).toRed(this.red),this.n=t.n&&new s(t.n,16),this.g=t.g&&this.pointFromJSON(t.g,t.gRed),this._wnafT1=new Array(4),this._wnafT2=new Array(4),this._wnafT3=new Array(4),this._wnafT4=new Array(4);var i=this.n&&this.p.div(this.n);!i||i.cmpn(100)>0?this.redN=null:(this._maxwellTrick=!0,this.redN=this.n.toRed(this.red))}function c(e,t){this.curve=e,this.type=t,this.precomputed=null}e.exports=d,d.prototype.point=function(){throw new Error("Not implemented")},d.prototype.validate=function(){throw new Error("Not implemented")},d.prototype._fixedNafMul=function(e,t){n(e.precomputed);var i=e._getDoubles(),s=a(t,1),r=(1<<i.step+1)-(i.step%2==0?2:1);r/=3;for(var o=[],d=0;d<s.length;d+=i.step){var c=0;for(t=d+i.step-1;t>=d;t--)c=(c<<1)+s[t];o.push(c)}for(var h=this.jpoint(null,null,null),l=this.jpoint(null,null,null),u=r;u>0;u--){for(d=0;d<o.length;d++){(c=o[d])===u?l=l.mixedAdd(i.points[d]):c===-u&&(l=l.mixedAdd(i.points[d].neg()))}h=h.add(l)}return h.toP()},d.prototype._wnafMul=function(e,t){var i=4,s=e._getNAFPoints(i);i=s.wnd;for(var r=s.points,o=a(t,i),d=this.jpoint(null,null,null),c=o.length-1;c>=0;c--){for(t=0;c>=0&&0===o[c];c--)t++;if(c>=0&&t++,d=d.dblp(t),c<0)break;var h=o[c];n(0!==h),d="affine"===e.type?h>0?d.mixedAdd(r[h-1>>1]):d.mixedAdd(r[-h-1>>1].neg()):h>0?d.add(r[h-1>>1]):d.add(r[-h-1>>1].neg())}return"affine"===e.type?d.toP():d},d.prototype._wnafMulAdd=function(e,t,i,s,r){for(var n=this._wnafT1,d=this._wnafT2,c=this._wnafT3,h=0,l=0;l<s;l++){var u=(C=t[l])._getNAFPoints(e);n[l]=u.wnd,d[l]=u.points}for(l=s-1;l>=1;l-=2){var f=l-1,p=l;if(1===n[f]&&1===n[p]){var m=[t[f],null,null,t[p]];0===t[f].y.cmp(t[p].y)?(m[1]=t[f].add(t[p]),m[2]=t[f].toJ().mixedAdd(t[p].neg())):0===t[f].y.cmp(t[p].y.redNeg())?(m[1]=t[f].toJ().mixedAdd(t[p]),m[2]=t[f].add(t[p].neg())):(m[1]=t[f].toJ().mixedAdd(t[p]),m[2]=t[f].toJ().mixedAdd(t[p].neg()));var y=[-3,-1,-5,-7,0,7,5,1,3],b=o(i[f],i[p]);h=Math.max(b[0].length,h),c[f]=new Array(h),c[p]=new Array(h);for(var v=0;v<h;v++){var g=0|b[0][v],w=0|b[1][v];c[f][v]=y[3*(g+1)+(w+1)],c[p][v]=0,d[f]=m}}else c[f]=a(i[f],n[f]),c[p]=a(i[p],n[p]),h=Math.max(c[f].length,h),h=Math.max(c[p].length,h)}var k=this.jpoint(null,null,null),T=this._wnafT4;for(l=h;l>=0;l--){for(var O=0;l>=0;){var _=!0;for(v=0;v<s;v++)T[v]=0|c[v][l],0!==T[v]&&(_=!1);if(!_)break;O++,l--}if(l>=0&&O++,k=k.dblp(O),l<0)break;for(v=0;v<s;v++){var C,S=T[v];0!==S&&(S>0?C=d[v][S-1>>1]:S<0&&(C=d[v][-S-1>>1].neg()),k="affine"===C.type?k.mixedAdd(C):k.add(C))}}for(l=0;l<s;l++)d[l]=null;return r?k:k.toP()},d.BasePoint=c,c.prototype.eq=function(){throw new Error("Not implemented")},c.prototype.validate=function(){return this.curve.validate(this)},d.prototype.decodePoint=function(e,t){e=r.toArray(e,t);var i=this.p.byteLength();if((4===e[0]||6===e[0]||7===e[0])&&e.length-1==2*i)return 6===e[0]?n(e[e.length-1]%2==0):7===e[0]&&n(e[e.length-1]%2==1),this.point(e.slice(1,1+i),e.slice(1+i,1+2*i));if((2===e[0]||3===e[0])&&e.length-1===i)return this.pointFromX(e.slice(1,1+i),3===e[0]);throw new Error("Unknown point format")},c.prototype.encodeCompressed=function(e){return this.encode(e,!0)},c.prototype._encode=function(e){var t=this.curve.p.byteLength(),i=this.getX().toArray("be",t);return e?[this.getY().isEven()?2:3].concat(i):[4].concat(i,this.getY().toArray("be",t))},c.prototype.encode=function(e,t){return r.encode(this._encode(t),e)},c.prototype.precompute=function(e){if(this.precomputed)return this;var t={doubles:null,naf:null,beta:null};return t.naf=this._getNAFPoints(8),t.doubles=this._getDoubles(4,e),t.beta=this._getBeta(),this.precomputed=t,this},c.prototype._hasDoubles=function(e){if(!this.precomputed)return!1;var t=this.precomputed.doubles;return!!t&&t.points.length>=Math.ceil((e.bitLength()+1)/t.step)},c.prototype._getDoubles=function(e,t){if(this.precomputed&&this.precomputed.doubles)return this.precomputed.doubles;for(var i=[this],s=this,r=0;r<t;r+=e){for(var a=0;a<e;a++)s=s.dbl();i.push(s)}return{step:e,points:i}},c.prototype._getNAFPoints=function(e){if(this.precomputed&&this.precomputed.naf)return this.precomputed.naf;for(var t=[this],i=(1<<e)-1,s=1===i?null:this.dbl(),r=1;r<i;r++)t[r]=t[r-1].add(s);return{wnd:e,points:t}},c.prototype._getBeta=function(){return null},c.prototype.dblp=function(e){for(var t=this,i=0;i<e;i++)t=t.dbl();return t}},function(e,t,i){"use strict";var s=i(7),r=i(4),a=i(5),o=r.inherits,n=s.base,d=r.utils.assert;function c(e){n.call(this,"short",e),this.a=new a(e.a,16).toRed(this.red),this.b=new a(e.b,16).toRed(this.red),this.tinv=this.two.redInvm(),this.zeroA=0===this.a.fromRed().cmpn(0),this.threeA=0===this.a.fromRed().sub(this.p).cmpn(-3),this.endo=this._getEndomorphism(e),this._endoWnafT1=new Array(4),this._endoWnafT2=new Array(4)}function h(e,t,i,s){n.BasePoint.call(this,e,"affine"),null===t&&null===i?(this.x=null,this.y=null,this.inf=!0):(this.x=new a(t,16),this.y=new a(i,16),s&&(this.x.forceRed(this.curve.red),this.y.forceRed(this.curve.red)),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.inf=!1)}function l(e,t,i,s){n.BasePoint.call(this,e,"jacobian"),null===t&&null===i&&null===s?(this.x=this.curve.one,this.y=this.curve.one,this.z=new a(0)):(this.x=new a(t,16),this.y=new a(i,16),this.z=new a(s,16)),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red)),this.zOne=this.z===this.curve.one}o(c,n),e.exports=c,c.prototype._getEndomorphism=function(e){if(this.zeroA&&this.g&&this.n&&1===this.p.modn(3)){var t,i;if(e.beta)t=new a(e.beta,16).toRed(this.red);else{var s=this._getEndoRoots(this.p);t=(t=s[0].cmp(s[1])<0?s[0]:s[1]).toRed(this.red)}if(e.lambda)i=new a(e.lambda,16);else{var r=this._getEndoRoots(this.n);0===this.g.mul(r[0]).x.cmp(this.g.x.redMul(t))?i=r[0]:(i=r[1],d(0===this.g.mul(i).x.cmp(this.g.x.redMul(t))))}return{beta:t,lambda:i,basis:e.basis?e.basis.map(function(e){return{a:new a(e.a,16),b:new a(e.b,16)}}):this._getEndoBasis(i)}}},c.prototype._getEndoRoots=function(e){var t=e===this.p?this.red:a.mont(e),i=new a(2).toRed(t).redInvm(),s=i.redNeg(),r=new a(3).toRed(t).redNeg().redSqrt().redMul(i);return[s.redAdd(r).fromRed(),s.redSub(r).fromRed()]},c.prototype._getEndoBasis=function(e){for(var t,i,s,r,o,n,d,c,h,l=this.n.ushrn(Math.floor(this.n.bitLength()/2)),u=e,f=this.n.clone(),p=new a(1),m=new a(0),y=new a(0),b=new a(1),v=0;0!==u.cmpn(0);){var g=f.div(u);c=f.sub(g.mul(u)),h=y.sub(g.mul(p));var w=b.sub(g.mul(m));if(!s&&c.cmp(l)<0)t=d.neg(),i=p,s=c.neg(),r=h;else if(s&&2==++v)break;d=c,f=u,u=c,y=p,p=h,b=m,m=w}o=c.neg(),n=h;var k=s.sqr().add(r.sqr());return o.sqr().add(n.sqr()).cmp(k)>=0&&(o=t,n=i),s.negative&&(s=s.neg(),r=r.neg()),o.negative&&(o=o.neg(),n=n.neg()),[{a:s,b:r},{a:o,b:n}]},c.prototype._endoSplit=function(e){var t=this.endo.basis,i=t[0],s=t[1],r=s.b.mul(e).divRound(this.n),a=i.b.neg().mul(e).divRound(this.n),o=r.mul(i.a),n=a.mul(s.a),d=r.mul(i.b),c=a.mul(s.b);return{k1:e.sub(o).sub(n),k2:d.add(c).neg()}},c.prototype.pointFromX=function(e,t){(e=new a(e,16)).red||(e=e.toRed(this.red));var i=e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b),s=i.redSqrt();if(0!==s.redSqr().redSub(i).cmp(this.zero))throw new Error("invalid point");var r=s.fromRed().isOdd();return(t&&!r||!t&&r)&&(s=s.redNeg()),this.point(e,s)},c.prototype.validate=function(e){if(e.inf)return!0;var t=e.x,i=e.y,s=this.a.redMul(t),r=t.redSqr().redMul(t).redIAdd(s).redIAdd(this.b);return 0===i.redSqr().redISub(r).cmpn(0)},c.prototype._endoWnafMulAdd=function(e,t,i){for(var s=this._endoWnafT1,r=this._endoWnafT2,a=0;a<e.length;a++){var o=this._endoSplit(t[a]),n=e[a],d=n._getBeta();o.k1.negative&&(o.k1.ineg(),n=n.neg(!0)),o.k2.negative&&(o.k2.ineg(),d=d.neg(!0)),s[2*a]=n,s[2*a+1]=d,r[2*a]=o.k1,r[2*a+1]=o.k2}for(var c=this._wnafMulAdd(1,s,r,2*a,i),h=0;h<2*a;h++)s[h]=null,r[h]=null;return c},o(h,n.BasePoint),c.prototype.point=function(e,t,i){return new h(this,e,t,i)},c.prototype.pointFromJSON=function(e,t){return h.fromJSON(this,e,t)},h.prototype._getBeta=function(){if(this.curve.endo){var e=this.precomputed;if(e&&e.beta)return e.beta;var t=this.curve.point(this.x.redMul(this.curve.endo.beta),this.y);if(e){var i=this.curve,s=function(e){return i.point(e.x.redMul(i.endo.beta),e.y)};e.beta=t,t.precomputed={beta:null,naf:e.naf&&{wnd:e.naf.wnd,points:e.naf.points.map(s)},doubles:e.doubles&&{step:e.doubles.step,points:e.doubles.points.map(s)}}}return t}},h.prototype.toJSON=function(){return this.precomputed?[this.x,this.y,this.precomputed&&{doubles:this.precomputed.doubles&&{step:this.precomputed.doubles.step,points:this.precomputed.doubles.points.slice(1)},naf:this.precomputed.naf&&{wnd:this.precomputed.naf.wnd,points:this.precomputed.naf.points.slice(1)}}]:[this.x,this.y]},h.fromJSON=function(e,t,i){"string"==typeof t&&(t=JSON.parse(t));var s=e.point(t[0],t[1],i);if(!t[2])return s;function r(t){return e.point(t[0],t[1],i)}var a=t[2];return s.precomputed={beta:null,doubles:a.doubles&&{step:a.doubles.step,points:[s].concat(a.doubles.points.map(r))},naf:a.naf&&{wnd:a.naf.wnd,points:[s].concat(a.naf.points.map(r))}},s},h.prototype.inspect=function(){return this.isInfinity()?"<EC Point Infinity>":"<EC Point x: "+this.x.fromRed().toString(16,2)+" y: "+this.y.fromRed().toString(16,2)+">"},h.prototype.isInfinity=function(){return this.inf},h.prototype.add=function(e){if(this.inf)return e;if(e.inf)return this;if(this.eq(e))return this.dbl();if(this.neg().eq(e))return this.curve.point(null,null);if(0===this.x.cmp(e.x))return this.curve.point(null,null);var t=this.y.redSub(e.y);0!==t.cmpn(0)&&(t=t.redMul(this.x.redSub(e.x).redInvm()));var i=t.redSqr().redISub(this.x).redISub(e.x),s=t.redMul(this.x.redSub(i)).redISub(this.y);return this.curve.point(i,s)},h.prototype.dbl=function(){if(this.inf)return this;var e=this.y.redAdd(this.y);if(0===e.cmpn(0))return this.curve.point(null,null);var t=this.curve.a,i=this.x.redSqr(),s=e.redInvm(),r=i.redAdd(i).redIAdd(i).redIAdd(t).redMul(s),a=r.redSqr().redISub(this.x.redAdd(this.x)),o=r.redMul(this.x.redSub(a)).redISub(this.y);return this.curve.point(a,o)},h.prototype.getX=function(){return this.x.fromRed()},h.prototype.getY=function(){return this.y.fromRed()},h.prototype.mul=function(e){return e=new a(e,16),this._hasDoubles(e)?this.curve._fixedNafMul(this,e):this.curve.endo?this.curve._endoWnafMulAdd([this],[e]):this.curve._wnafMul(this,e)},h.prototype.mulAdd=function(e,t,i){var s=[this,t],r=[e,i];return this.curve.endo?this.curve._endoWnafMulAdd(s,r):this.curve._wnafMulAdd(1,s,r,2)},h.prototype.jmulAdd=function(e,t,i){var s=[this,t],r=[e,i];return this.curve.endo?this.curve._endoWnafMulAdd(s,r,!0):this.curve._wnafMulAdd(1,s,r,2,!0)},h.prototype.eq=function(e){return this===e||this.inf===e.inf&&(this.inf||0===this.x.cmp(e.x)&&0===this.y.cmp(e.y))},h.prototype.neg=function(e){if(this.inf)return this;var t=this.curve.point(this.x,this.y.redNeg());if(e&&this.precomputed){var i=this.precomputed,s=function(e){return e.neg()};t.precomputed={naf:i.naf&&{wnd:i.naf.wnd,points:i.naf.points.map(s)},doubles:i.doubles&&{step:i.doubles.step,points:i.doubles.points.map(s)}}}return t},h.prototype.toJ=function(){return this.inf?this.curve.jpoint(null,null,null):this.curve.jpoint(this.x,this.y,this.curve.one)},o(l,n.BasePoint),c.prototype.jpoint=function(e,t,i){return new l(this,e,t,i)},l.prototype.toP=function(){if(this.isInfinity())return this.curve.point(null,null);var e=this.z.redInvm(),t=e.redSqr(),i=this.x.redMul(t),s=this.y.redMul(t).redMul(e);return this.curve.point(i,s)},l.prototype.neg=function(){return this.curve.jpoint(this.x,this.y.redNeg(),this.z)},l.prototype.add=function(e){if(this.isInfinity())return e;if(e.isInfinity())return this;var t=e.z.redSqr(),i=this.z.redSqr(),s=this.x.redMul(t),r=e.x.redMul(i),a=this.y.redMul(t.redMul(e.z)),o=e.y.redMul(i.redMul(this.z)),n=s.redSub(r),d=a.redSub(o);if(0===n.cmpn(0))return 0!==d.cmpn(0)?this.curve.jpoint(null,null,null):this.dbl();var c=n.redSqr(),h=c.redMul(n),l=s.redMul(c),u=d.redSqr().redIAdd(h).redISub(l).redISub(l),f=d.redMul(l.redISub(u)).redISub(a.redMul(h)),p=this.z.redMul(e.z).redMul(n);return this.curve.jpoint(u,f,p)},l.prototype.mixedAdd=function(e){if(this.isInfinity())return e.toJ();if(e.isInfinity())return this;var t=this.z.redSqr(),i=this.x,s=e.x.redMul(t),r=this.y,a=e.y.redMul(t).redMul(this.z),o=i.redSub(s),n=r.redSub(a);if(0===o.cmpn(0))return 0!==n.cmpn(0)?this.curve.jpoint(null,null,null):this.dbl();var d=o.redSqr(),c=d.redMul(o),h=i.redMul(d),l=n.redSqr().redIAdd(c).redISub(h).redISub(h),u=n.redMul(h.redISub(l)).redISub(r.redMul(c)),f=this.z.redMul(o);return this.curve.jpoint(l,u,f)},l.prototype.dblp=function(e){if(0===e)return this;if(this.isInfinity())return this;if(!e)return this.dbl();if(this.curve.zeroA||this.curve.threeA){for(var t=this,i=0;i<e;i++)t=t.dbl();return t}var s=this.curve.a,r=this.curve.tinv,a=this.x,o=this.y,n=this.z,d=n.redSqr().redSqr(),c=o.redAdd(o);for(i=0;i<e;i++){var h=a.redSqr(),l=c.redSqr(),u=l.redSqr(),f=h.redAdd(h).redIAdd(h).redIAdd(s.redMul(d)),p=a.redMul(l),m=f.redSqr().redISub(p.redAdd(p)),y=p.redISub(m),b=f.redMul(y);b=b.redIAdd(b).redISub(u);var v=c.redMul(n);i+1<e&&(d=d.redMul(u)),a=m,n=v,c=b}return this.curve.jpoint(a,c.redMul(r),n)},l.prototype.dbl=function(){return this.isInfinity()?this:this.curve.zeroA?this._zeroDbl():this.curve.threeA?this._threeDbl():this._dbl()},l.prototype._zeroDbl=function(){var e,t,i;if(this.zOne){var s=this.x.redSqr(),r=this.y.redSqr(),a=r.redSqr(),o=this.x.redAdd(r).redSqr().redISub(s).redISub(a);o=o.redIAdd(o);var n=s.redAdd(s).redIAdd(s),d=n.redSqr().redISub(o).redISub(o),c=a.redIAdd(a);c=(c=c.redIAdd(c)).redIAdd(c),e=d,t=n.redMul(o.redISub(d)).redISub(c),i=this.y.redAdd(this.y)}else{var h=this.x.redSqr(),l=this.y.redSqr(),u=l.redSqr(),f=this.x.redAdd(l).redSqr().redISub(h).redISub(u);f=f.redIAdd(f);var p=h.redAdd(h).redIAdd(h),m=p.redSqr(),y=u.redIAdd(u);y=(y=y.redIAdd(y)).redIAdd(y),e=m.redISub(f).redISub(f),t=p.redMul(f.redISub(e)).redISub(y),i=(i=this.y.redMul(this.z)).redIAdd(i)}return this.curve.jpoint(e,t,i)},l.prototype._threeDbl=function(){var e,t,i;if(this.zOne){var s=this.x.redSqr(),r=this.y.redSqr(),a=r.redSqr(),o=this.x.redAdd(r).redSqr().redISub(s).redISub(a);o=o.redIAdd(o);var n=s.redAdd(s).redIAdd(s).redIAdd(this.curve.a),d=n.redSqr().redISub(o).redISub(o);e=d;var c=a.redIAdd(a);c=(c=c.redIAdd(c)).redIAdd(c),t=n.redMul(o.redISub(d)).redISub(c),i=this.y.redAdd(this.y)}else{var h=this.z.redSqr(),l=this.y.redSqr(),u=this.x.redMul(l),f=this.x.redSub(h).redMul(this.x.redAdd(h));f=f.redAdd(f).redIAdd(f);var p=u.redIAdd(u),m=(p=p.redIAdd(p)).redAdd(p);e=f.redSqr().redISub(m),i=this.y.redAdd(this.z).redSqr().redISub(l).redISub(h);var y=l.redSqr();y=(y=(y=y.redIAdd(y)).redIAdd(y)).redIAdd(y),t=f.redMul(p.redISub(e)).redISub(y)}return this.curve.jpoint(e,t,i)},l.prototype._dbl=function(){var e=this.curve.a,t=this.x,i=this.y,s=this.z,r=s.redSqr().redSqr(),a=t.redSqr(),o=i.redSqr(),n=a.redAdd(a).redIAdd(a).redIAdd(e.redMul(r)),d=t.redAdd(t),c=(d=d.redIAdd(d)).redMul(o),h=n.redSqr().redISub(c.redAdd(c)),l=c.redISub(h),u=o.redSqr();u=(u=(u=u.redIAdd(u)).redIAdd(u)).redIAdd(u);var f=n.redMul(l).redISub(u),p=i.redAdd(i).redMul(s);return this.curve.jpoint(h,f,p)},l.prototype.trpl=function(){if(!this.curve.zeroA)return this.dbl().add(this);var e=this.x.redSqr(),t=this.y.redSqr(),i=this.z.redSqr(),s=t.redSqr(),r=e.redAdd(e).redIAdd(e),a=r.redSqr(),o=this.x.redAdd(t).redSqr().redISub(e).redISub(s),n=(o=(o=(o=o.redIAdd(o)).redAdd(o).redIAdd(o)).redISub(a)).redSqr(),d=s.redIAdd(s);d=(d=(d=d.redIAdd(d)).redIAdd(d)).redIAdd(d);var c=r.redIAdd(o).redSqr().redISub(a).redISub(n).redISub(d),h=t.redMul(c);h=(h=h.redIAdd(h)).redIAdd(h);var l=this.x.redMul(n).redISub(h);l=(l=l.redIAdd(l)).redIAdd(l);var u=this.y.redMul(c.redMul(d.redISub(c)).redISub(o.redMul(n)));u=(u=(u=u.redIAdd(u)).redIAdd(u)).redIAdd(u);var f=this.z.redAdd(o).redSqr().redISub(i).redISub(n);return this.curve.jpoint(l,u,f)},l.prototype.mul=function(e,t){return e=new a(e,t),this.curve._wnafMul(this,e)},l.prototype.eq=function(e){if("affine"===e.type)return this.eq(e.toJ());if(this===e)return!0;var t=this.z.redSqr(),i=e.z.redSqr();if(0!==this.x.redMul(i).redISub(e.x.redMul(t)).cmpn(0))return!1;var s=t.redMul(this.z),r=i.redMul(e.z);return 0===this.y.redMul(r).redISub(e.y.redMul(s)).cmpn(0)},l.prototype.eqXToP=function(e){var t=this.z.redSqr(),i=e.toRed(this.curve.red).redMul(t);if(0===this.x.cmp(i))return!0;for(var s=e.clone(),r=this.curve.redN.redMul(t);;){if(s.iadd(this.curve.n),s.cmp(this.curve.p)>=0)return!1;if(i.redIAdd(r),0===this.x.cmp(i))return!0}return!1},l.prototype.inspect=function(){return this.isInfinity()?"<EC JPoint Infinity>":"<EC JPoint x: "+this.x.toString(16,2)+" y: "+this.y.toString(16,2)+" z: "+this.z.toString(16,2)+">"},l.prototype.isInfinity=function(){return 0===this.z.cmpn(0)}},function(e,t,i){"use strict";var s=i(7),r=i(5),a=i(4).inherits,o=s.base,n=i(4).utils;function d(e){o.call(this,"mont",e),this.a=new r(e.a,16).toRed(this.red),this.b=new r(e.b,16).toRed(this.red),this.i4=new r(4).toRed(this.red).redInvm(),this.two=new r(2).toRed(this.red),this.a24=this.i4.redMul(this.a.redAdd(this.two))}function c(e,t,i){o.BasePoint.call(this,e,"projective"),null===t&&null===i?(this.x=this.curve.one,this.z=this.curve.zero):(this.x=new r(t,16),this.z=new r(i,16),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red)))}a(d,o),e.exports=d,d.prototype.validate=function(e){var t=e.normalize().x,i=t.redSqr(),s=i.redMul(t).redAdd(i.redMul(this.a)).redAdd(t);return 0===s.redSqrt().redSqr().cmp(s)},a(c,o.BasePoint),d.prototype.decodePoint=function(e,t){return this.point(n.toArray(e,t),1)},d.prototype.point=function(e,t){return new c(this,e,t)},d.prototype.pointFromJSON=function(e){return c.fromJSON(this,e)},c.prototype.precompute=function(){},c.prototype._encode=function(){return this.getX().toArray("be",this.curve.p.byteLength())},c.fromJSON=function(e,t){return new c(e,t[0],t[1]||e.one)},c.prototype.inspect=function(){return this.isInfinity()?"<EC Point Infinity>":"<EC Point x: "+this.x.fromRed().toString(16,2)+" z: "+this.z.fromRed().toString(16,2)+">"},c.prototype.isInfinity=function(){return 0===this.z.cmpn(0)},c.prototype.dbl=function(){var e=this.x.redAdd(this.z).redSqr(),t=this.x.redSub(this.z).redSqr(),i=e.redSub(t),s=e.redMul(t),r=i.redMul(t.redAdd(this.curve.a24.redMul(i)));return this.curve.point(s,r)},c.prototype.add=function(){throw new Error("Not supported on Montgomery curve")},c.prototype.diffAdd=function(e,t){var i=this.x.redAdd(this.z),s=this.x.redSub(this.z),r=e.x.redAdd(e.z),a=e.x.redSub(e.z).redMul(i),o=r.redMul(s),n=t.z.redMul(a.redAdd(o).redSqr()),d=t.x.redMul(a.redISub(o).redSqr());return this.curve.point(n,d)},c.prototype.mul=function(e){for(var t=e.clone(),i=this,s=this.curve.point(null,null),r=[];0!==t.cmpn(0);t.iushrn(1))r.push(t.andln(1));for(var a=r.length-1;a>=0;a--)0===r[a]?(i=i.diffAdd(s,this),s=s.dbl()):(s=i.diffAdd(s,this),i=i.dbl());return s},c.prototype.mulAdd=function(){throw new Error("Not supported on Montgomery curve")},c.prototype.jumlAdd=function(){throw new Error("Not supported on Montgomery curve")},c.prototype.eq=function(e){return 0===this.getX().cmp(e.getX())},c.prototype.normalize=function(){return this.x=this.x.redMul(this.z.redInvm()),this.z=this.curve.one,this},c.prototype.getX=function(){return this.normalize(),this.x.fromRed()}},function(e,t,i){"use strict";var s=i(7),r=i(4),a=i(5),o=r.inherits,n=s.base,d=r.utils.assert;function c(e){this.twisted=1!=(0|e.a),this.mOneA=this.twisted&&-1==(0|e.a),this.extended=this.mOneA,n.call(this,"edwards",e),this.a=new a(e.a,16).umod(this.red.m),this.a=this.a.toRed(this.red),this.c=new a(e.c,16).toRed(this.red),this.c2=this.c.redSqr(),this.d=new a(e.d,16).toRed(this.red),this.dd=this.d.redAdd(this.d),d(!this.twisted||0===this.c.fromRed().cmpn(1)),this.oneC=1==(0|e.c)}function h(e,t,i,s,r){n.BasePoint.call(this,e,"projective"),null===t&&null===i&&null===s?(this.x=this.curve.zero,this.y=this.curve.one,this.z=this.curve.one,this.t=this.curve.zero,this.zOne=!0):(this.x=new a(t,16),this.y=new a(i,16),this.z=s?new a(s,16):this.curve.one,this.t=r&&new a(r,16),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red)),this.t&&!this.t.red&&(this.t=this.t.toRed(this.curve.red)),this.zOne=this.z===this.curve.one,this.curve.extended&&!this.t&&(this.t=this.x.redMul(this.y),this.zOne||(this.t=this.t.redMul(this.z.redInvm()))))}o(c,n),e.exports=c,c.prototype._mulA=function(e){return this.mOneA?e.redNeg():this.a.redMul(e)},c.prototype._mulC=function(e){return this.oneC?e:this.c.redMul(e)},c.prototype.jpoint=function(e,t,i,s){return this.point(e,t,i,s)},c.prototype.pointFromX=function(e,t){(e=new a(e,16)).red||(e=e.toRed(this.red));var i=e.redSqr(),s=this.c2.redSub(this.a.redMul(i)),r=this.one.redSub(this.c2.redMul(this.d).redMul(i)),o=s.redMul(r.redInvm()),n=o.redSqrt();if(0!==n.redSqr().redSub(o).cmp(this.zero))throw new Error("invalid point");var d=n.fromRed().isOdd();return(t&&!d||!t&&d)&&(n=n.redNeg()),this.point(e,n)},c.prototype.pointFromY=function(e,t){(e=new a(e,16)).red||(e=e.toRed(this.red));var i=e.redSqr(),s=i.redSub(this.one),r=i.redMul(this.d).redAdd(this.one),o=s.redMul(r.redInvm());if(0===o.cmp(this.zero)){if(t)throw new Error("invalid point");return this.point(this.zero,e)}var n=o.redSqrt();if(0!==n.redSqr().redSub(o).cmp(this.zero))throw new Error("invalid point");return n.isOdd()!==t&&(n=n.redNeg()),this.point(n,e)},c.prototype.validate=function(e){if(e.isInfinity())return!0;e.normalize();var t=e.x.redSqr(),i=e.y.redSqr(),s=t.redMul(this.a).redAdd(i),r=this.c2.redMul(this.one.redAdd(this.d.redMul(t).redMul(i)));return 0===s.cmp(r)},o(h,n.BasePoint),c.prototype.pointFromJSON=function(e){return h.fromJSON(this,e)},c.prototype.point=function(e,t,i,s){return new h(this,e,t,i,s)},h.fromJSON=function(e,t){return new h(e,t[0],t[1],t[2])},h.prototype.inspect=function(){return this.isInfinity()?"<EC Point Infinity>":"<EC Point x: "+this.x.fromRed().toString(16,2)+" y: "+this.y.fromRed().toString(16,2)+" z: "+this.z.fromRed().toString(16,2)+">"},h.prototype.isInfinity=function(){return 0===this.x.cmpn(0)&&0===this.y.cmp(this.z)},h.prototype._extDbl=function(){var e=this.x.redSqr(),t=this.y.redSqr(),i=this.z.redSqr();i=i.redIAdd(i);var s=this.curve._mulA(e),r=this.x.redAdd(this.y).redSqr().redISub(e).redISub(t),a=s.redAdd(t),o=a.redSub(i),n=s.redSub(t),d=r.redMul(o),c=a.redMul(n),h=r.redMul(n),l=o.redMul(a);return this.curve.point(d,c,l,h)},h.prototype._projDbl=function(){var e,t,i,s=this.x.redAdd(this.y).redSqr(),r=this.x.redSqr(),a=this.y.redSqr();if(this.curve.twisted){var o=(c=this.curve._mulA(r)).redAdd(a);if(this.zOne)e=s.redSub(r).redSub(a).redMul(o.redSub(this.curve.two)),t=o.redMul(c.redSub(a)),i=o.redSqr().redSub(o).redSub(o);else{var n=this.z.redSqr(),d=o.redSub(n).redISub(n);e=s.redSub(r).redISub(a).redMul(d),t=o.redMul(c.redSub(a)),i=o.redMul(d)}}else{var c=r.redAdd(a);n=this.curve._mulC(this.c.redMul(this.z)).redSqr(),d=c.redSub(n).redSub(n);e=this.curve._mulC(s.redISub(c)).redMul(d),t=this.curve._mulC(c).redMul(r.redISub(a)),i=c.redMul(d)}return this.curve.point(e,t,i)},h.prototype.dbl=function(){return this.isInfinity()?this:this.curve.extended?this._extDbl():this._projDbl()},h.prototype._extAdd=function(e){var t=this.y.redSub(this.x).redMul(e.y.redSub(e.x)),i=this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)),s=this.t.redMul(this.curve.dd).redMul(e.t),r=this.z.redMul(e.z.redAdd(e.z)),a=i.redSub(t),o=r.redSub(s),n=r.redAdd(s),d=i.redAdd(t),c=a.redMul(o),h=n.redMul(d),l=a.redMul(d),u=o.redMul(n);return this.curve.point(c,h,u,l)},h.prototype._projAdd=function(e){var t,i,s=this.z.redMul(e.z),r=s.redSqr(),a=this.x.redMul(e.x),o=this.y.redMul(e.y),n=this.curve.d.redMul(a).redMul(o),d=r.redSub(n),c=r.redAdd(n),h=this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(a).redISub(o),l=s.redMul(d).redMul(h);return this.curve.twisted?(t=s.redMul(c).redMul(o.redSub(this.curve._mulA(a))),i=d.redMul(c)):(t=s.redMul(c).redMul(o.redSub(a)),i=this.curve._mulC(d).redMul(c)),this.curve.point(l,t,i)},h.prototype.add=function(e){return this.isInfinity()?e:e.isInfinity()?this:this.curve.extended?this._extAdd(e):this._projAdd(e)},h.prototype.mul=function(e){return this._hasDoubles(e)?this.curve._fixedNafMul(this,e):this.curve._wnafMul(this,e)},h.prototype.mulAdd=function(e,t,i){return this.curve._wnafMulAdd(1,[this,t],[e,i],2,!1)},h.prototype.jmulAdd=function(e,t,i){return this.curve._wnafMulAdd(1,[this,t],[e,i],2,!0)},h.prototype.normalize=function(){if(this.zOne)return this;var e=this.z.redInvm();return this.x=this.x.redMul(e),this.y=this.y.redMul(e),this.t&&(this.t=this.t.redMul(e)),this.z=this.curve.one,this.zOne=!0,this},h.prototype.neg=function(){return this.curve.point(this.x.redNeg(),this.y,this.z,this.t&&this.t.redNeg())},h.prototype.getX=function(){return this.normalize(),this.x.fromRed()},h.prototype.getY=function(){return this.normalize(),this.y.fromRed()},h.prototype.eq=function(e){return this===e||0===this.getX().cmp(e.getX())&&0===this.getY().cmp(e.getY())},h.prototype.eqXToP=function(e){var t=e.toRed(this.curve.red).redMul(this.z);if(0===this.x.cmp(t))return!0;for(var i=e.clone(),s=this.curve.redN.redMul(this.z);;){if(i.iadd(this.curve.n),i.cmp(this.curve.p)>=0)return!1;if(t.redIAdd(s),0===this.x.cmp(t))return!0}return!1},h.prototype.toP=h.prototype.normalize,h.prototype.mixedAdd=h.prototype.add},function(e,t,i){"use strict";var s,r=t,a=i(4),o=a.utils.assert;function n(e){"short"===e.type?this.curve=new a.curve.short(e):"edwards"===e.type?this.curve=new a.curve.edwards(e):this.curve=new a.curve.mont(e),this.g=this.curve.g,this.n=this.curve.n,this.hash=e.hash,o(this.g.validate(),"Invalid curve"),o(this.g.mul(this.n).isInfinity(),"Invalid curve, G*N != O")}function d(e,t){Object.defineProperty(r,e,{configurable:!0,enumerable:!0,get:function(){var i=new n(t);return Object.defineProperty(r,e,{configurable:!0,enumerable:!0,value:i}),i}})}r.PresetCurve=n,d("p192",{type:"short",prime:"p192",p:"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",a:"ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",b:"64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",n:"ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",hash:"SHA256",gRed:!1,g:["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012","07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]}),d("p224",{type:"short",prime:"p224",p:"ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",a:"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",b:"b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",n:"ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",hash:"SHA256",gRed:!1,g:["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21","bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]}),d("p256",{type:"short",prime:null,p:"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",a:"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",b:"5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",n:"ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",hash:"SHA256",gRed:!1,g:["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296","4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]}),d("p384",{type:"short",prime:null,p:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",a:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",b:"b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",n:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",hash:"SHA384",gRed:!1,g:["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7","3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]}),d("p521",{type:"short",prime:null,p:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",a:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",b:"00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",n:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",hash:"SHA512",gRed:!1,g:["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66","00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]}),d("curve25519",{type:"mont",prime:"p25519",p:"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",a:"76d06",b:"1",n:"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",hash:"SHA256",gRed:!1,g:["9"]}),d("ed25519",{type:"edwards",prime:"p25519",p:"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",a:"-1",c:"1",d:"52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",n:"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",hash:"SHA256",gRed:!1,g:["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a","6666666666666666666666666666666666666666666666666666666666666658"]});try{s=i(68)}catch(e){s=void 0}d("secp256k1",{type:"short",prime:"k256",p:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",a:"0",b:"7",n:"ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",h:"1",hash:"SHA256",beta:"7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",lambda:"5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",basis:[{a:"3086d221a7d46bcde86c90e49284eb15",b:"-e4437ed6010e88286f547fa90abfe4c3"},{a:"114ca50f7a8e2f3f657c1108d9d44cfd8",b:"3086d221a7d46bcde86c90e49284eb15"}],gRed:!1,g:["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798","483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",s]})},function(e,t){e.exports={doubles:{step:4,points:[["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a","f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"],["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508","11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"],["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739","d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"],["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640","4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"],["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c","4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"],["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda","96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"],["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa","5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"],["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0","cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"],["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d","9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"],["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d","e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"],["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1","9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"],["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0","5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"],["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047","10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"],["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862","283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"],["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7","7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"],["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd","56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"],["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83","7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"],["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a","53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"],["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8","bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"],["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d","4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"],["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725","7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"],["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754","4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"],["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c","17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"],["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6","6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"],["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39","c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"],["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891","893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"],["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b","febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"],["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03","2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"],["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d","eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"],["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070","7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"],["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4","e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"],["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da","662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"],["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11","1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"],["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e","efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"],["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41","2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"],["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef","67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"],["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8","db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"],["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d","648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"],["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96","35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"],["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd","ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"],["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5","9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"],["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266","40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"],["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71","34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"],["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac","c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"],["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751","1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"],["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e","493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"],["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241","c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"],["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3","be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"],["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f","4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"],["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19","aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"],["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be","b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"],["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9","6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"],["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2","8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"],["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13","7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"],["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c","ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"],["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba","2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"],["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151","e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"],["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073","d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"],["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458","38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"],["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b","69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"],["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366","d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"],["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa","40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"],["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0","620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"],["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787","7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"],["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e","ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]]},naf:{wnd:7,points:[["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9","388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"],["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4","d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"],["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc","6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"],["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe","cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"],["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb","d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"],["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8","ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"],["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e","581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"],["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34","4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"],["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c","85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"],["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5","321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"],["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f","2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"],["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714","73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"],["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729","a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"],["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db","2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"],["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4","e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"],["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5","b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"],["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479","2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"],["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d","80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"],["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f","1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"],["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb","d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"],["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9","eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"],["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963","758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"],["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74","958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"],["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530","e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"],["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b","5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"],["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247","cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"],["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1","cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"],["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120","4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"],["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435","91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"],["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18","673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"],["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8","59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"],["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb","3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"],["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f","55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"],["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143","efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"],["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba","e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"],["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45","f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"],["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a","744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"],["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e","c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"],["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8","e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"],["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c","30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"],["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519","e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"],["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab","100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"],["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca","ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"],["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf","8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"],["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610","68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"],["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4","f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"],["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c","d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"],["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940","edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"],["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980","a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"],["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3","66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"],["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf","9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"],["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63","4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"],["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448","fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"],["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf","5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"],["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5","8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"],["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6","8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"],["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5","5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"],["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99","f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"],["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51","f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"],["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5","42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"],["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5","204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"],["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997","4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"],["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881","73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"],["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5","39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"],["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66","d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"],["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726","ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"],["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede","6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"],["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94","60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"],["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31","3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"],["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51","b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"],["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252","ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"],["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5","cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"],["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b","6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"],["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4","322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"],["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f","6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"],["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889","2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"],["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246","b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"],["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984","998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"],["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a","b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"],["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030","bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"],["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197","6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"],["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593","c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"],["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef","21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"],["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38","60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"],["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a","49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"],["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111","5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"],["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502","7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"],["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea","be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"],["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26","8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"],["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986","39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"],["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e","62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"],["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4","25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"],["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda","ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"],["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859","cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"],["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f","f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"],["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c","6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"],["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942","fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"],["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a","1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"],["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80","5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"],["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d","438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"],["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1","cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"],["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63","c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"],["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352","6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"],["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193","ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"],["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00","9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"],["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58","ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"],["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7","d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"],["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8","c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"],["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e","67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"],["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d","cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"],["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b","299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"],["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f","f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"],["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6","462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"],["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297","62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"],["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a","7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"],["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c","ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"],["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52","4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"],["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb","bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"],["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065","bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"],["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917","603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"],["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9","cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"],["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3","553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"],["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57","712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"],["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66","ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"],["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8","9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"],["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721","9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"],["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180","4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]]}}},function(e,t,i){"use strict";var s=i(5),r=i(70),a=i(4),o=a.utils.assert,n=i(71),d=i(72);function c(e){if(!(this instanceof c))return new c(e);"string"==typeof e&&(o(a.curves.hasOwnProperty(e),"Unknown curve "+e),e=a.curves[e]),e instanceof a.curves.PresetCurve&&(e={curve:e}),this.curve=e.curve.curve,this.n=this.curve.n,this.nh=this.n.ushrn(1),this.g=this.curve.g,this.g=e.curve.g,this.g.precompute(e.curve.n.bitLength()+1),this.hash=e.hash||e.curve.hash}e.exports=c,c.prototype.keyPair=function(e){return new n(this,e)},c.prototype.keyFromPrivate=function(e,t){return n.fromPrivate(this,e,t)},c.prototype.keyFromPublic=function(e,t){return n.fromPublic(this,e,t)},c.prototype.genKeyPair=function(e){e||(e={});for(var t=new r({hash:this.hash,pers:e.pers,persEnc:e.persEnc||"utf8",entropy:e.entropy||null,entropyEnc:e.entropy&&e.entropyEnc||"utf8",nonce:this.n.toArray()}),i=this.n.byteLength(),a=this.n.sub(new s(2));;){var o=new s(t.generate(i));if(!(o.cmp(a)>0))return o.iaddn(1),this.keyFromPrivate(o)}},c.prototype._truncateToN=function(e,t){var i=8*e.byteLength()-this.n.bitLength();return i>0&&(e=e.ushrn(i)),!t&&e.cmp(this.n)>=0?e.sub(this.n):e},c.prototype.sign=function(e,t,i,a){"object"==typeof i&&(a=i,i=null),a||(a={}),t=this.keyFromPrivate(t,i),e=this._truncateToN(new s(e,16));for(var o=this.n.byteLength(),n=t.getPrivate().toArray("be",o),c=e.toArray("be",o),h=new r({hash:this.hash,entropy:n,nonce:c,pers:a.pers,persEnc:a.persEnc||"utf8"}),l=this.n.sub(new s(1)),u=0;;u++){var f=a.k?a.k(u):new s(h.generate(this.n.byteLength()));if(!((f=this._truncateToN(f,!0)).cmpn(1)<=0||f.cmp(l)>=0)){var p=this.g.mul(f);if(!p.isInfinity()){var m=p.getX(),y=m.umod(this.n);if(0!==y.cmpn(0)){var b=f.invm(this.n).mul(y.mul(t.getPrivate()).iadd(e));if(0!==(b=b.umod(this.n)).cmpn(0)){var v=(p.getY().isOdd()?1:0)|(0!==m.cmp(y)?2:0);return a.canonical&&b.cmp(this.nh)>0&&(b=this.n.sub(b),v^=1),new d({r:y,s:b,recoveryParam:v})}}}}}},c.prototype.verify=function(e,t,i,r){e=this._truncateToN(new s(e,16)),i=this.keyFromPublic(i,r);var a=(t=new d(t,"hex")).r,o=t.s;if(a.cmpn(1)<0||a.cmp(this.n)>=0)return!1;if(o.cmpn(1)<0||o.cmp(this.n)>=0)return!1;var n,c=o.invm(this.n),h=c.mul(e).umod(this.n),l=c.mul(a).umod(this.n);return this.curve._maxwellTrick?!(n=this.g.jmulAdd(h,i.getPublic(),l)).isInfinity()&&n.eqXToP(a):!(n=this.g.mulAdd(h,i.getPublic(),l)).isInfinity()&&0===n.getX().umod(this.n).cmp(a)},c.prototype.recoverPubKey=function(e,t,i,r){o((3&i)===i,"The recovery param is more than two bits"),t=new d(t,r);var a=this.n,n=new s(e),c=t.r,h=t.s,l=1&i,u=i>>1;if(c.cmp(this.curve.p.umod(this.curve.n))>=0&&u)throw new Error("Unable to find sencond key candinate");c=u?this.curve.pointFromX(c.add(this.curve.n),l):this.curve.pointFromX(c,l);var f=t.r.invm(a),p=a.sub(n).mul(f).umod(a),m=h.mul(f).umod(a);return this.g.mulAdd(p,c,m)},c.prototype.getKeyRecoveryParam=function(e,t,i,s){if(null!==(t=new d(t,s)).recoveryParam)return t.recoveryParam;for(var r=0;r<4;r++){var a;try{a=this.recoverPubKey(e,t,r)}catch(e){continue}if(a.eq(i))return r}throw new Error("Unable to find valid recovery factor")}},function(e,t,i){"use strict";var s=i(6),r=i(27).assert;const a=s.enc.Utf8.parse(""),o=s.enc.Utf8.parse("\0");function n(e){if(!(this instanceof n))return new n(e);this.hash=e.hash,this.predResist=!!e.predResist,this.outLen=this.hash.slice(3,6),this.minEntropy=e.minEntropy||192,this._reseed=null,this.reseedInterval=null,this.K=null,this.V=null;var t=e.entropy,i=e.nonce;r(t.length>=this.minEntropy/8,"Not enough entropy. Minimum is: "+this.minEntropy+" bits"),this._init(t,i,[])}function d(e){var t,i=[];for(t=0;t<e.length;t++)i[t/4|0]|=e[t]<<24-8*t;return s.lib.WordArray.create(i,e.length)}function c(e,t){var i=[];return t>0&&i.push(e>>>24),t>1&&i.push(e>>>16&255),t>2&&i.push(e>>>8&255),t>3&&i.push(255&e),i}e.exports=n,n.prototype._init=function(e,t,i){var r=e.concat(t).concat(i);this.K=new s.lib.WordArray.init,this.V=new s.lib.WordArray.init;this.V.words=Array(this.outLen/32).fill(16843009),this.V.sigBytes=32,this._update(r),this._reseed=1,this.reseedInterval=281474976710656},n.prototype._hmac=function(){return new s.lib.WordArray.init},n.prototype._update=function(e){var t=this._hmac();t.concat(this.V),t.concat(o),e&&t.concat(d(e)),this.K=s["Hmac"+this.hash](t,this.K),this.V=s["Hmac"+this.hash](this.V,this.K),e&&((t=this._hmac()).concat(this.V),t.concat(a),t.concat(d(e)),this.K=s["Hmac"+this.hash](t,this.K),this.V=s["Hmac"+this.hash](this.V,this.K))},n.prototype.reseed=function(e,t,i,s){"string"!=typeof t&&(i,i=t,t=null),r(e.length>=this.minEntropy/8,"Not enough entropy. Minimum is: "+this.minEntropy+" bits"),this._update(e.concat(i||[])),this._reseed=1},n.prototype.generate=function(e,t,i,r){if(this._reseed>this.reseedInterval)throw new Error("Reseed is required");"string"!=typeof t&&(i,i=t,t=null),i&&(i=s.enc.Utf8.parse(i),this._update(i));for(var a=new s.lib.WordArray.init;a.sigBytes<e;)this.V=s["Hmac"+this.hash](this.V,this.K),a.concat(this.V);return this._update(i),this._reseed++,function(e){let t=void 0;if(!e.hasOwnProperty("sigBytes")||!e.hasOwnProperty("words"))throw Error("Argument not a wordArray");t=e.sigBytes,e=e.words;const i=[];let s=[],r=0;for(;t>0;)s=c(e[r],Math.min(4,t)),t-=s.length,i.push(s),r++;return[].concat.apply([],i)}(a)}},function(e,t,i){"use strict";var s=i(5),r=i(4).utils.assert;function a(e,t){this.ec=e,this.priv=null,this.pub=null,t.priv&&this._importPrivate(t.priv,t.privEnc),t.pub&&this._importPublic(t.pub,t.pubEnc)}e.exports=a,a.fromPublic=function(e,t,i){return t instanceof a?t:new a(e,{pub:t,pubEnc:i})},a.fromPrivate=function(e,t,i){return t instanceof a?t:new a(e,{priv:t,privEnc:i})},a.prototype.validate=function(){var e=this.getPublic();return e.isInfinity()?{result:!1,reason:"Invalid public key"}:e.validate()?e.mul(this.ec.curve.n).isInfinity()?{result:!0,reason:null}:{result:!1,reason:"Public key * N != O"}:{result:!1,reason:"Public key is not a point"}},a.prototype.getPublic=function(e,t){return"string"==typeof e&&(t=e,e=null),this.pub||(this.pub=this.ec.g.mul(this.priv)),t?this.pub.encode(t,e):this.pub},a.prototype.getPrivate=function(e){return"hex"===e?this.priv.toString(16,2):this.priv},a.prototype._importPrivate=function(e,t){this.priv=new s(e,t||16),this.priv=this.priv.umod(this.ec.curve.n)},a.prototype._importPublic=function(e,t){if(e.x||e.y)return"mont"===this.ec.curve.type?r(e.x,"Need x coordinate"):"short"!==this.ec.curve.type&&"edwards"!==this.ec.curve.type||r(e.x&&e.y,"Need both x and y coordinate"),void(this.pub=this.ec.curve.point(e.x,e.y));this.pub=this.ec.curve.decodePoint(e,t)},a.prototype.derive=function(e){return e.mul(this.priv).getX()},a.prototype.sign=function(e,t,i){return this.ec.sign(e,this,t,i)},a.prototype.verify=function(e,t){return this.ec.verify(e,t,this)},a.prototype.inspect=function(){return"<Key priv: "+(this.priv&&this.priv.toString(16,2))+" pub: "+(this.pub&&this.pub.inspect())+" >"}},function(e,t,i){"use strict";var s=i(5),r=i(4).utils.assert;e.exports=function e(t,i){if(t instanceof e)return t;r(t.r&&t.s,"Signature without r or s"),this.r=new s(t.r,16),this.s=new s(t.s,16),void 0===t.recoveryParam?this.recoveryParam=null:this.recoveryParam=t.recoveryParam}},function(e,t,i){"use strict";e.exports={BaseError:{ExchangeError:{AuthenticationError:{PermissionDenied:{},AccountSuspended:{}},ArgumentsRequired:{},BadRequest:{BadSymbol:{}},BadResponse:{NullResponse:{}},InsufficientFunds:{},InvalidAddress:{AddressPending:{}},InvalidOrder:{OrderNotFound:{},OrderNotCached:{},CancelPending:{},OrderImmediatelyFillable:{},OrderNotFillable:{},DuplicateOrderId:{}},NotSupported:{}},NetworkError:{DDoSProtection:{},ExchangeNotAvailable:{OnMaintenance:{}},InvalidNonce:{},RequestTimeout:{}}}}},function(e,t,i){"use strict";const{sleep:s,now:r}=i(28);e.exports={throttle:function e(t){let i=r(),a=void 0!==t.numTokens?t.numTokens:t.capacity,o=!1;const n=[];return Object.assign(e=>{if(n.length>t.maxCapacity)throw new Error("Backlog is over max capacity of "+t.maxCapacity);return new Promise(async(d,c)=>{try{if(n.push({cost:e,resolve:d,reject:c}),!o){for(o=!0;n.length>0;){if((t.capacity?a>0:a>=0)&&n.length>0){let{cost:e,resolve:i,reject:s}=n[0];e=e||t.defaultCost,a>=Math.min(e,t.capacity)&&(a-=e,n.shift(),i())}const e=r(),o=e-i;i=e,a=Math.min(t.capacity,a+o*t.refillRate),await s(t.delay)}o=!1}}catch(e){c(e)}})},t,{configure:i=>e(Object.assign({},t,i))})}}},function(e,t,i){"use strict";const{ROUND_UP:s,ROUND_DOWN:r}=i(2),a=e=>{const t=e.slice(0,-1),i=e.slice(-1);let s=60;return"y"===i?s=31536e3:"M"===i?s=2592e3:"w"===i?s=604800:"d"===i?s=86400:"h"===i&&(s=3600),t*s};e.exports={aggregate(e){const t={};for(let i=0;i<e.length;i++){const[s,r]=e[i];r>0&&(t[s]=(t[s]||0)+r)}return Object.keys(t).map(e=>[parseFloat(e),parseFloat(t[e])])},parseTimeframe:a,roundTimeframe:(e,t,i=r)=>{const o=1e3*a(e);return t-t%o+(i===s?o:0)},buildOHLCVC:(e,t="1m",i=-1/0,s=1/0)=>{const r=1e3*a(t),o=[],[n,,d,c,h,l,u]=[0,1,2,3,4,5,6],f=Math.min(e.length-1,s);for(let t=0;t<=f;t++){const s=e[t];if(s.timestamp<i)continue;const a=Math.floor(s.timestamp/r)*r,f=o.length-1;-1===f||a>=o[f][n]+r?o.push([a,s.price,s.price,s.price,s.price,s.amount,1]):(o[f][d]=Math.max(o[f][d],s.price),o[f][c]=Math.min(o[f][c],s.price),o[f][h]=s.price,o[f][l]+=s.amount,o[f][u]++)}return o},ROUND_UP:s,ROUND_DOWN:r,implodeParams:(e,t)=>{if(!Array.isArray(t)){const i=Object.keys(t);for(let s=0;s<i.length;s++){const r=i[s];Array.isArray(t[r])||(e=e.replace("{"+r+"}",t[r]))}}return e},extractParams:e=>{const t=/{([\w-]+)}/g,i=[];let s=t.exec(e);for(;s;)i.push(s[1]),s=t.exec(e);return i}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,ExchangeNotAvailable:a}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"_1btcxe",name:"1BTCXE",countries:["PA"],comment:"Crypto Capital API",has:{CORS:!0,withdraw:!0},timeframes:{"1d":"1year"},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766049-2b294408-5ecc-11e7-85cc-adaff013dc1a.jpg",api:"https://1btcxe.com/api",www:"https://1btcxe.com",doc:"https://1btcxe.com/api-docs.php"},api:{public:{get:["stats","historical-prices","order-book","transactions"]},private:{post:["balances-and-info","open-orders","user-transactions","btc-deposit-address/get","btc-deposit-address/new","deposits/get","withdrawals/get","orders/new","orders/edit","orders/cancel","orders/status","withdrawals/new"]}}})}async fetchMarkets(e={}){return[{id:"USD",symbol:"BTC/USD",base:"BTC",quote:"USD",baseId:"BTC",quoteId:"USD"},{id:"EUR",symbol:"BTC/EUR",base:"BTC",quote:"EUR",baseId:"BTC",quoteId:"EUR"},{id:"CNY",symbol:"BTC/CNY",base:"BTC",quote:"CNY",baseId:"BTC",quoteId:"CNY"},{id:"RUB",symbol:"BTC/RUB",base:"BTC",quote:"RUB",baseId:"BTC",quoteId:"RUB"},{id:"CHF",symbol:"BTC/CHF",base:"BTC",quote:"CHF",baseId:"BTC",quoteId:"CHF"},{id:"JPY",symbol:"BTC/JPY",base:"BTC",quote:"JPY",baseId:"BTC",quoteId:"JPY"},{id:"GBP",symbol:"BTC/GBP",base:"BTC",quote:"GBP",baseId:"BTC",quoteId:"GBP"},{id:"CAD",symbol:"BTC/CAD",base:"BTC",quote:"CAD",baseId:"BTC",quoteId:"CAD"},{id:"AUD",symbol:"BTC/AUD",base:"BTC",quote:"AUD",baseId:"BTC",quoteId:"AUD"},{id:"AED",symbol:"BTC/AED",base:"BTC",quote:"AED",baseId:"BTC",quoteId:"AED"},{id:"BGN",symbol:"BTC/BGN",base:"BTC",quote:"BGN",baseId:"BTC",quoteId:"BGN"},{id:"CZK",symbol:"BTC/CZK",base:"BTC",quote:"CZK",baseId:"BTC",quoteId:"CZK"},{id:"DKK",symbol:"BTC/DKK",base:"BTC",quote:"DKK",baseId:"BTC",quoteId:"DKK"},{id:"HKD",symbol:"BTC/HKD",base:"BTC",quote:"HKD",baseId:"BTC",quoteId:"HKD"},{id:"HRK",symbol:"BTC/HRK",base:"BTC",quote:"HRK",baseId:"BTC",quoteId:"HRK"},{id:"HUF",symbol:"BTC/HUF",base:"BTC",quote:"HUF",baseId:"BTC",quoteId:"HUF"},{id:"ILS",symbol:"BTC/ILS",base:"BTC",quote:"ILS",baseId:"BTC",quoteId:"ILS"},{id:"INR",symbol:"BTC/INR",base:"BTC",quote:"INR",baseId:"BTC",quoteId:"INR"},{id:"MUR",symbol:"BTC/MUR",base:"BTC",quote:"MUR",baseId:"BTC",quoteId:"MUR"},{id:"MXN",symbol:"BTC/MXN",base:"BTC",quote:"MXN",baseId:"BTC",quoteId:"MXN"},{id:"NOK",symbol:"BTC/NOK",base:"BTC",quote:"NOK",baseId:"BTC",quoteId:"NOK"},{id:"NZD",symbol:"BTC/NZD",base:"BTC",quote:"NZD",baseId:"BTC",quoteId:"NZD"},{id:"PLN",symbol:"BTC/PLN",base:"BTC",quote:"PLN",baseId:"BTC",quoteId:"PLN"},{id:"RON",symbol:"BTC/RON",base:"BTC",quote:"RON",baseId:"BTC",quoteId:"RON"},{id:"SEK",symbol:"BTC/SEK",base:"BTC",quote:"SEK",baseId:"BTC",quoteId:"SEK"},{id:"SGD",symbol:"BTC/SGD",base:"BTC",quote:"SGD",baseId:"BTC",quoteId:"SGD"},{id:"THB",symbol:"BTC/THB",base:"BTC",quote:"THB",baseId:"BTC",quoteId:"THB"},{id:"TRY",symbol:"BTC/TRY",base:"BTC",quote:"TRY",baseId:"BTC",quoteId:"TRY"},{id:"ZAR",symbol:"BTC/ZAR",base:"BTC",quote:"ZAR",baseId:"BTC",quoteId:"ZAR"}]}async fetchBalance(e={}){const t=(await this.privatePostBalancesAndInfo(e))["balances-and-info"],i={info:t},s=Object.keys(this.currencies);for(let e=0;e<s.length;e++){const r=s[e],a=this.currency(r).id,o=this.account();o.free=this.safeFloat(t.available,a),o.used=this.safeFloat(t.on_hold,a),i[r]=o}return this.parseBalance(i)}async fetchOrderBook(e,t,i={}){const s={currency:this.marketId(e)},r=await this.publicGetOrderBook(this.extend(s,i));return this.parseOrderBook(r["order-book"],void 0,"bid","ask","price","order_amount")}async fetchTicker(e,t={}){const i={currency:this.marketId(e)},s=await this.publicGetStats(this.extend(i,t)),r=this.safeValue(s,"stats",{}),a=this.safeFloat(r,"last_price");return{symbol:e,timestamp:void 0,datetime:void 0,high:this.safeFloat(r,"max"),low:this.safeFloat(r,"min"),bid:this.safeFloat(r,"bid"),bidVolume:void 0,ask:this.safeFloat(r,"ask"),askVolume:void 0,vwap:void 0,open:this.safeFloat(r,"open"),close:a,last:a,previousClose:void 0,change:this.safeFloat(r,"daily_change"),percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:this.safeFloat(r,"total_btc_traded"),info:r}}parseOHLCV(e,t,i="1d",s,r){return[this.parse8601(e.date+" 00:00:00"),void 0,void 0,void 0,this.safeFloat(e,"price"),void 0]}async fetchOHLCV(e,t="1d",i,s,r={}){const a=this.market(e),o=await this.publicGetHistoricalPrices(this.extend({currency:a.id,timeframe:this.timeframes[t]},r)),n=this.toArray(this.omit(o["historical-prices"],"request_currency"));return this.parseOHLCVs(n,a,t,i,s)}parseTrade(e,t){const i=this.safeTimestamp(e,"timestamp"),s=this.safeString(e,"id");let r=void 0;void 0!==t&&(r=t.symbol);const a=this.safeString(e,"maker_type"),o=this.safeFloat(e,"price"),n=this.safeFloat(e,"amount");let d=void 0;return void 0!==n&&void 0!==o&&(d=n*o),{id:s,info:e,timestamp:i,datetime:this.iso8601(i),symbol:r,order:void 0,type:void 0,side:a,takerOrMaker:void 0,price:o,amount:n,cost:d,fee:void 0}}async fetchTrades(e,t,i,s={}){const r=this.market(e),a={currency:r.id};void 0!==i&&(a.limit=i);const o=await this.publicGetTransactions(this.extend(a,s)),n=this.toArray(this.omit(o.transactions,"request_currency"));return this.parseTrades(n,r,t,i)}async createOrder(e,t,i,s,r,a={}){const o={side:i,type:t,currency:this.marketId(e),amount:s};"limit"===t&&(o.limit_price=r);const n=await this.privatePostOrdersNew(this.extend(o,a));return{info:n,id:n}}async cancelOrder(e,t,i={}){const s={id:e};return await this.privatePostOrdersCancel(this.extend(s,i))}async withdraw(e,t,i,s,r={}){this.checkAddress(i),await this.loadMarkets();const a={currency:this.currency(e).id,amount:parseFloat(t),address:i},o=await this.privatePostWithdrawalsNew(this.extend(a,r));return{info:o,id:o.result.uuid}}sign(e,t="public",i="GET",s={},a,o){if("cryptocapital"===this.id)throw new r(this.id+" is an abstract base API for _1btcxe");let n=this.urls.api+"/"+e;if("public"===t)Object.keys(s).length&&(n+="?"+this.urlencode(s));else{this.checkRequiredCredentials();const e=this.extend({api_key:this.apiKey,nonce:this.nonce()},s),t=this.json(e);e.signature=this.hmac(this.encode(t),this.encode(this.secret)),o=this.json(e),a={"Content-Type":"application/json"}}return{url:n,method:i,body:o,headers:a}}async request(e,t="public",i="GET",s={},o,n){const d=await this.fetch2(e,t,i,s,o,n);if("string"==typeof d&&d.indexOf("Maintenance")>=0)throw new a(this.id+" on maintenance");if("errors"in d){let e=[];for(let t=0;t<d.errors.length;t++){const i=d.errors[t];e.push(i.code+": "+i.message)}throw e=e.join(" "),new r(this.id+" "+e)}return d}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,BadRequest:a,AuthenticationError:o,InvalidOrder:n,InsufficientFunds:d,OrderNotFound:c}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"adara",name:"Adara",countries:["MT"],version:"v1",rateLimit:1e3,certified:!1,has:{CORS:!0,fetchCurrencies:!0,fetchOrderBooks:!1,createMarketOrder:!1,fetchDepositAddress:!1,fetchClosedOrders:!0,fetchMyTrades:!1,fetchOHLCV:!1,fetchOrder:!0,fetchOpenOrders:!0,fetchTickers:!0,withdraw:!1,fetchDeposits:!1,fetchWithdrawals:!1,fetchTransactions:!1},requiredCredentials:{apiKey:!0,secret:!0,token:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/49189583-0466a780-f380-11e8-9248-57a631aad2d6.jpg",api:"https://api.adara.io",www:"https://adara.io",doc:"https://api.adara.io/v1",fees:"https://adara.io/fees"},api:{public:{get:["currencies","limits","market","marketDepth","marketInfo","orderBook","quote/","quote/{id}","symbols","trade"],post:["confirmContactEmail","restorePassword","user"]},private:{get:["balance","order","order/{id}","currencyBalance","apiKey","user/{id}"],post:["order","recovery","user","apiKey","contact"],patch:["order/{id}","user/{id}","customer"],delete:["apiKey"]}},fees:{trading:{tierBased:!1,percentage:!0,maker:.001,taker:.001},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{}}},exceptions:{exact:{"Insufficient funds":d,"Amount is too small":n,"operation has invalid value":n,"closed order can't be changed":n,"Order is not found":c,AUTH:o,"You are not authorized":o,"Bad Request":a,500:r},broad:{}}})}async fetchMarkets(e={}){const t=await this.publicGetSymbols(this.extend({include:"from,to"},e)),i=this.safeValue(t,"included",[]),s=this.groupBy(i,"type"),r=this.safeValue(s,"currency",[]),a=this.indexBy(r,"id"),o=[],n=t.data;for(let e=0;e<n.length;e++){const t=n[e],i=this.safeString(t,"id"),s=this.safeValue(t,"attributes",{}),r=this.safeValue(t,"relationships",{}),d=this.safeValue(r,"from",{}),c=this.safeValue(r,"to",{}),h=this.safeValue(d,"data",{}),l=this.safeValue(c,"data",{}),u=this.safeString(h,"id"),f=this.safeString(l,"id"),p=this.commonCurrencyCode(u),m=this.commonCurrencyCode(f),y=this.safeValue(a,u,{}),b=this.safeValue(y,"attributes",{}),v=p+"/"+m,g={amount:this.safeInteger(b,"accuracy",8),price:this.safeInteger(s,"digits",8)},w=this.safeValue(s,"allowTrade"),k=this.safeFloat(s,"makerFee"),T=this.safeFloat(s,"takerFee");o.push({info:t,id:i,symbol:v,base:p,quote:m,baseId:u,quoteId:f,active:w,maker:k,taker:T,precision:g,limits:{amount:{min:Math.pow(10,-g.amount),max:void 0},price:{min:Math.pow(10,-g.price),max:void 0},cost:{min:void 0,max:void 0}}})}return o}async fetchCurrencies(e={}){const t=(await this.publicGetCurrencies(e)).data,i={};for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"id"),a=this.safeValue(s,"attributes",{}),o=this.commonCurrencyCode(r),n=this.safeInteger(a,"accuracy"),d=this.safeFloat(a,"withdrawFee"),c=this.safeValue(a,"active"),h=this.safeValue(a,"allowDeposit"),l=this.safeValue(a,"allowWithdraw");i[o]={id:r,code:o,info:s,name:this.safeString(a,"name"),active:c&&h&&l,fee:d,precision:n,limits:{amount:{min:Math.pow(10,-n),max:Math.pow(10,n)},price:{min:Math.pow(10,-n),max:Math.pow(10,n)},cost:{min:void 0,max:void 0},withdraw:{min:this.safeFloat(a,"withdrawMinAmount"),max:Math.pow(10,n)}}}}return i}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalance(e),i={info:t},s=this.safeValue(t,"data");if(void 0!==s)for(let e=0;e<s.length;e++){const t=s[e],r=this.safeValue(t,"attributes",{}),a=this.safeValue(t,"relationships",{}),o=this.safeValue(a,"currency",{}),n=this.safeValue(o,"data"),d=this.safeString(n,"id"),c=this.commonCurrencyCode(d),h=this.account();h.total=this.safeFloat(r,"totalBalance"),h.used=this.safeFloat(r,"onOrders"),i[c]=h}return this.parseBalance(i)}getSymbolFromMarketId(e,t){if(void 0===e)return;if(void 0!==(t=this.safeValue(this.markets_by_id,e,t)))return t.symbol;const[i,s]=e.split("-");return this.commonCurrencyCode(i)+"/"+this.commonCurrencyCode(s)}parseOrderBook(e,t,i="bids",s="asks",a="price",o="amount"){const n=[],d=[];e.length>0&&(t=this.safeInteger(e[0].attributes,"serializedAt"));for(let i=0;i<e.length;i++){const s=e[i],c=this.safeValue(s,"attributes",{}),h=this.safeInteger(c,"serializedAt");t=Math.max(t,h);const l=this.safeString(s,"id");if(l.indexOf("OBID")>=0)n.push(this.parseBidAsk(s.attributes,a,o));else{if(!(l.indexOf("OSID")>=0))throw r(this.id+" parseOrderBook encountered an unrecognized bidask format: "+this.json(s));d.push(this.parseBidAsk(s.attributes,a,o))}}return{bids:this.sortBy(n,0,!0),asks:this.sortBy(d,0),timestamp:t,datetime:this.iso8601(t),nonce:void 0}}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s=this.market(e),r={};r["filters[symbol]"]=s.id;const a=await this.publicGetOrderBook(this.extend(r,i));return this.parseOrderBook(a.data,void 0,"bids","asks","price","amount")}parseTicker(e,t){const i=this.getSymbolFromMarketId(this.safeString(e,"id"),t),s=this.safeValue(e,"attributes",{}),r=this.safeInteger(s,"serializedAt"),a=this.safeFloat(s,"currentPrice"),o=this.safeFloat(s,"change");let n=void 0;void 0!==o&&void 0!==a&&(n=a-o);const d=this.safeFloat(s,"percentChange");return{symbol:i,timestamp:r,datetime:this.iso8601(r),high:this.safeFloat(s,"high"),low:this.safeFloat(s,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:n,close:a,last:a,previousClose:void 0,change:o,percentage:d,average:void 0,baseVolume:this.safeFloat(e,"baseVolume"),quoteVolume:this.safeFloat(e,"quoteVolume"),info:e}}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetQuote(t),s=this.safeValue(i,"data",[]),r={};for(let e=0;e<s.length;e++){const t=this.parseTicker(s[e]);r[t.symbol]=t}return r}async fetchTicker(e,t={}){await this.loadMarkets();const i={id:this.market(e).id},s=await this.publicGetQuoteId(this.extend(i,t));return this.parseTicker(s.data)}parseTrade(e,t){const i=this.safeString(e,"id","uuid"),s=this.safeValue(e,"attributes",{}),r=this.safeValue(e,"relationships",{}),a=this.safeValue(r,"symbol",{}),o=this.safeValue(a,"data",{}),n=this.safeString(o,"id");let d=void 0,c=void 0;if(void 0!==(t=this.safeValue(this.markets_by_id,n,t)))d=t.symbol,c=t.quote;else if(void 0!==n){const e=n.length-3,t=n.slice(0,e),i=n.slice(e),s=this.commonCurrencyCode(t),r=this.commonCurrencyCode(i);d=s+"/"+r,c=r}const h=this.parse8601(this.safeString(s,"createdAt")),l=this.safeString(s,"operation"),u=this.safeFloat(s,"price"),f=this.safeFloat(s,"amount");let p=this.safeFloat(s,"total");void 0===p&&void 0!==f&&void 0!==u&&(p=parseFloat(this.costToPrecision(d,u*f)));const m=this.safeFloat(s,"fee");let y=void 0;return void 0!==m&&(y={cost:m,currency:c}),{id:i,info:e,order:void 0,timestamp:h,datetime:this.iso8601(h),symbol:d,type:void 0,side:l,takerOrMaker:void 0,price:u,amount:f,cost:p,fee:y}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();let r=void 0;void 0!==e&&(r=this.market(e));const a=await this.publicGetTrade(this.extend({},s));return this.parseTrades(a.data,r,t,i)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o=this.market(e),n={data:{type:"order",attributes:{amount:parseFloat(this.amountToPrecision(e,s)),operation:i,orderType:t,price:parseFloat(this.priceToPrecision(e,r))},relationships:{symbol:{data:{id:o.id,type:"symbol"}}}},included:[{id:o.id,type:"symbol"}]},d=await this.privatePostOrder(this.extend(n,a));return this.parseOrder(d.data)}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={id:e,data:{attributes:{status:"canceled"}}},r=await this.privatePatchOrderId(this.extend(s,i));return this.parseOrder(r.data)}parseOrderStatus(e){return this.safeString({open:"open",closed:"closed",canceled:"canceled"},e,e)}parseOrder(e,t){const i=this.safeString(e,"id"),s=this.safeValue(e,"attributes",{}),r=this.safeValue(e,"relationships",{}),a=this.safeValue(r,"symbol",{}),o=this.safeValue(a,"data",{}),n=this.safeValue(r,"trades",{}),d=this.safeValue(n,"data"),c=this.safeString(o,"id");let h=void 0,l=void 0;if(void 0!==(t=this.safeValue(this.markets_by_id,c,t)))l=t.symbol,h=t.quote;else if(void 0!==c){const e=c.length-3,t=c.slice(0,e),i=c.slice(e),s=this.commonCurrencyCode(t),r=this.commonCurrencyCode(i);l=s+"/"+r,h=r}const u=this.parse8601(this.safeString(s,"timeOpen")),f=this.safeString(s,"operation"),p=this.safeString(s,"orderType"),m=this.parseOrderStatus(this.safeString(s,"status")),y=this.parse8601(this.safeString(s,"timeClose")),b=this.safeFloat(s,"price"),v=this.safeFloat(s,"amount"),g=this.safeFloat(s,"filled");let w=void 0;void 0!==v&&void 0!==g&&(w=Math.max(0,v-g));let k=void 0;const T=this.safeFloat(s,"averagePrice");void 0===k&&void 0!==T&&void 0!==g&&(k=parseFloat(this.costToPrecision(l,T*g)));let O=void 0;const _=this.safeFloat(s,"fee");void 0!==_&&(O={currency:h,cost:_});let C=void 0;if(void 0!==d){d.length>0&&(C=this.parseTrades(d,t))}return{info:e,id:i,timestamp:u,datetime:this.iso8601(u),lastTradeTimestamp:y,symbol:l,type:p,side:f,price:b,cost:k,average:T,amount:v,filled:g,remaining:w,status:m,fee:O,trades:C}}async fetchOrders(e,t,i,s={}){await this.loadMarkets();const r={include:"trades"};let a=void 0;if(void 0!==e){a=this.market(e),r["filters[symbol]"]=a.id}const o=await this.privateGetOrder(this.extend(r,s));return this.parseOrdersResponse(o,a,t,i)}async fetchOpenOrders(e,t,i,s={}){const r={"filters[status][]":"open"};return await this.fetchOrders(e,t,i,this.extend(r,s))}async fetchClosedOrders(e,t,i,s={}){const r={"filters[status][]":"closed"};return await this.fetchOrders(e,t,i,this.extend(r,s))}parseOrdersResponse(e,t,i,s){const r=this.safeValue(e,"included",[]),a=this.groupBy(r,"type"),o=this.safeValue(a,"trade",[]),n=this.parseTrades(o,t),d=this.indexBy(n,"id"),c=this.parseOrders(this.safeValue(e,"data",[]),t,i,s),h=[];for(let e=0;e<c.length;e++){const t=c[e],i=[],s=this.safeValue(t,"fee",{}),r=this.safeString(s,"currency");if(void 0!==t.trades)for(let e=0;e<t.trades.length;e++){const s=t.trades[e].id;s in d&&i.push(this.deepExtend(d[s],{order:t.id,type:t.type,symbol:t.symbol,fee:{currency:r}}))}i.length>0&&(t.trades=i),h.push(t)}return h}async fetchOrder(e,t,i={}){await this.loadMarkets();const s={id:e,include:"trades"},r=await this.privateGetOrderId(this.extend(s,i)),a=this.safeValue(r,"data");r.data=[],r.data.push(a);const o=this.parseOrdersResponse(r),n=this.indexBy(o,"id");if(e in n)return n[e];throw c(this.id+" fetchOrder could not find order id "+e.toString())}nonce(){return this.milliseconds()}sign(e,t="public",i="GET",s={},r,a){let o="/"+this.implodeParams(e,s),n=this.urls.api+"/"+this.version+o;const d=this.omit(s,this.extractParams(e));if("GET"===i&&Object.keys(d).length&&(n+="?"+this.urlencode(d)),"private"===t){const e=this.nonce();let t=this.sum(e,this.safeInteger(this.options,"expiredAt",1e4));if(t=t.toString(),"POST"!==i&&"PATCH"!==i||(o=a=this.json(d)),this.token)r={Cookie:"token="+this.token};else{this.checkRequiredCredentials();const e=i+o+"expiredAt="+t,s=this.hmac(this.encode(e),this.encode(this.secret),"sha512","base64");r={"X-ADX-EXPIRE":t,"X-ADX-APIKEY":this.apiKey,"X-ADX-SIGNATURE":s}}"GET"!==i&&(r["Content-Type"]="application/json")}return{url:n,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,o,n,d,c){if(void 0===n)return;const h=this.safeValue(n,"errors",[]);if(h.length>0){const e=h[0],t=this.safeString(e,"code"),i=this.safeString(e,"status"),s=this.safeString(e,"title"),a=this.safeString(e,"detail"),d=this.id+" "+this.json(n),c=this.exceptions.exact;if(t in c)throw new c[t](d);if(i in c)throw new c[i](d);if(s in c)throw new c[s](d);if(a in c)throw new c[a](d);const l=this.exceptions.broad,u=this.findBroadlyMatchedKey(l,o);if(void 0!==u)throw new l[u](d);throw new r(d)}}}},function(e,t,i){"use strict";const s=i(8);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"allcoin",name:"Allcoin",countries:["CA"],has:{CORS:!1},extension:"",urls:{logo:"https://user-images.githubusercontent.com/1294454/31561809-c316b37c-b061-11e7-8d5a-b547b4d730eb.jpg",api:{web:"https://www.allcoin.com",public:"https://api.allcoin.com/api",private:"https://api.allcoin.com/api"},www:"https://www.allcoin.com",doc:"https://www.allcoin.com/api_market/market",referral:"https://www.allcoin.com"},status:{status:"error",updated:void 0,eta:void 0,url:void 0},api:{web:{get:["Home/MarketOverViewDetail/"]},public:{get:["depth","kline","ticker","trades"]},private:{post:["batch_trade","cancel_order","order_history","order_info","orders_info","repayment","trade","trade_history","userinfo"]}}})}async fetchMarkets(e={}){const t=[],i=(await this.webGetHomeMarketOverViewDetail(e)).marketCoins;for(let e=0;e<i.length;e++){const s=i[e].Markets;for(let e=0;e<s.length;e++){const i=s[e].Market;let r=this.safeString(i,"Primary"),a=this.safeString(i,"Secondary");const o=r.toLowerCase(),n=a.toLowerCase(),d=o+"_"+n,c=(r=this.safeCurrencyCode(r))+"/"+(a=this.safeCurrencyCode(a)),h=i.TradeEnabled&&i.BuyEnabled&&i.SellEnabled;t.push({id:d,symbol:c,base:r,quote:a,baseId:o,quoteId:n,active:h,type:"spot",spot:!0,future:!1,maker:this.safeFloat(i,"AskFeeRate"),taker:this.safeFloat(i,"AskFeeRate"),precision:{amount:this.safeInteger(i,"PrimaryDigits"),price:this.safeInteger(i,"SecondaryDigits")},limits:{amount:{min:this.safeFloat(i,"MinTradeAmount"),max:this.safeFloat(i,"MaxTradeAmount")},price:{min:this.safeFloat(i,"MinOrderPrice"),max:this.safeFloat(i,"MaxOrderPrice")},cost:{min:void 0,max:void 0}},info:i})}}return t}parseOrderStatus(e){return this.safeString({"-1":"canceled",0:"open",1:"open",2:"closed",10:"canceled"},e,e)}getCreateDateField(){return"create_data"}getOrdersField(){return"order"}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,AuthenticationError:a,InsufficientFunds:o,ExchangeNotAvailable:n,InvalidOrder:d,BadRequest:c,OrderNotFound:h,NotSupported:l}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"anxpro",name:"ANXPro",countries:["JP","SG","HK","NZ"],rateLimit:1500,userAgent:this.userAgents.chrome,has:{CORS:!1,fetchCurrencies:!0,fetchOHLCV:!1,fetchTrades:!1,fetchOpenOrders:!0,fetchDepositAddress:!0,fetchTransactions:!0,fetchMyTrades:!0,createDepositAddress:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27765983-fd8595da-5ec9-11e7-82e3-adb3ab8c2612.jpg",api:{public:"https://anxpro.com/api/2",private:"https://anxpro.com/api/2",v3public:"https://anxpro.com/api/3",v3private:"https://anxpro.com/api/3"},www:"https://anxpro.com",doc:["https://anxv2.docs.apiary.io","https://anxv3.docs.apiary.io","https://anxpro.com/pages/api"]},api:{v3public:{get:["currencyStatic"]},v3private:{post:["register/register","register/verifyRegistration","register/resendVerification","register/autoRegister","account","subaccount/new","transaction/list","order/list","trade/list","send","receive","receive/create","batch/new","batch/add","batch/list","batch/info","batch/closeForSend","order/new","order/info","order/cancel","retail/quote","retail/trade","validateAddress","address/check","alert/create","alert/delete","alert/list","kyc/personal","kyc/document","kyc/status","kyc/verifyCode","news/list","press/list","announcements/list","apiDoc/list"]},public:{get:["{currency_pair}/money/ticker","{currency_pair}/money/depth/full","{currency_pair}/money/trade/fetch"]},private:{post:["{currency_pair}/money/order/add","{currency_pair}/money/order/cancel","{currency_pair}/money/order/quote","{currency_pair}/money/order/result","{currency_pair}/money/orders","money/{currency}/address","money/{currency}/send_simple","money/info","money/trade/list","money/wallet/history"]}},httpExceptions:{403:a},exceptions:{exact:{"Insufficient Funds":o,"Trade value too small":d,"The currency pair is not supported":c,"Order amount is too low":d,"Order amount is too high":d,"order rate is too low":d,"order rate is too high":d,"Too many open orders":d,"Unexpected error":r,"Order Engine is offline":n,"No executed order with that identifer found":h,"Unknown server error, please contact support.":r}},fees:{trading:{tierBased:!1,percentage:!0,maker:.001,taker:.002}},options:{fetchMyTradesMethod:"private_post_money_trade_list"}})}async fetchTransactions(e,t,i,s={}){await this.loadMarkets();const r={};void 0!==t&&(r.from=t),void 0!==i&&(r.max=i);const a=void 0===e?void 0:this.currency(e);void 0!==a&&(r.ccy=a.id);const o=await this.v3privatePostTransactionList(this.extend(r,s)),n=this.safeValue(o,"transactions",[]),d=this.groupBy(n,"transactionType",[]),c=this.arrayConcat(this.safeValue(d,"DEPOSIT",[]),this.safeValue(d,"WITHDRAWAL",[]));return this.parseTransactions(c,a,t,i)}parseTransaction(e,t){const i=this.safeInteger(e,"received"),s=this.safeInteger(e,"processed"),r=this.safeString(e,"transactionType");let a=void 0,o=this.safeFloat(e,"amount"),n=this.safeString(e,"coinAddress"),d=void 0;if("WITHDRAWAL"===r){if(a="withdrawal",o=-o,n&&n.indexOf("?dt=")>=0){const e=n.split("?dt=");n=e[0],d=e[1]}}else if("DEPOSIT"===r){if(!n){const t=this.safeString(e,"displayDescription").replace("Deposit to: ","");if(t.length>0)if(t.indexOf("?dt=")>=0){const e=t.split("?dt=");n=e[0],d=e[1]}else n=t}a="deposit"}const c=this.safeString(e,"ccy"),h=this.safeCurrencyCode(c),l=this.safeString(e,"transactionState"),u=this.parseTransactionStatus(l),f=this.safeFloat(e,"fee"),p=o-f;return{timestamp:i,datetime:this.iso8601(i),id:this.safeString(e,"uuid"),currency:h,amount:p,address:n,tag:d,status:u,type:a,updated:s,txid:this.safeString(e,"coinTransactionId"),fee:{cost:f,currency:h},info:e}}parseTransactionStatus(e){return this.safeString({PROCESSED:"ok",REVERSED:"canceled",CANCELLED_INSUFFICIENT_FUNDS:"canceled",CANCELLED_LIMIT_BREACH:"canceled"},e,e)}async fetchMyTrades(e,t,i,s={}){await this.loadMarkets();const r={};void 0!==i&&(r.max=i);const a=this.safeString(this.options,"fetchMyTradesMethod","private_post_money_trade_list"),o=await this[a](this.extend(r,s)),n=this.safeValue2(o,"trades","data",[]),d=void 0===e?void 0:this.market(e);return this.parseTrades(n,d,t,i)}parseTrade(e,t){const i=this.safeString(e,"tradeId"),s=this.safeString(e,"orderId"),r=this.safeInteger(e,"timestamp"),a=this.safeFloat(e,"price"),o=this.safeFloat(e,"tradedCurrencyFillAmount"),n=this.safeFloat(e,"settlementCurrencyFillAmount"),d=this.safeStringLower(e,"side");return{id:i,order:s,timestamp:r,datetime:this.iso8601(r),symbol:this.findSymbol(this.safeString(e,"ccyPair")),type:void 0,side:d,price:a,amount:o,cost:n,fee:void 0,info:e}}async fetchCurrencies(e={}){const t=await this.v3publicGetCurrencyStatic(e),i=this.safeValue(t,"currencyStatic",{}),s=this.safeValue(i,"currencies",{}),r={},a=Object.keys(s);for(let e=0;e<a.length;e++){const t=a[e],i=s[t],o=this.safeCurrencyCode(t),n=this.safeValue(i,"engineSettings"),d=this.safeValue(n,"depositsEnabled"),c=this.safeValue(n,"withdrawalsEnabled"),h=this.safeValue(n,"displayEnabled"),l=d&&c&&h,u=this.safeInteger(i,"decimals"),f=this.safeFloat(i,"networkFee"),p=this.safeStringLower(i,"type");r[o]={id:t,code:o,info:i,name:o,type:p,active:l,precision:u,fee:f,limits:{amount:{min:this.safeFloat(i,"minOrderSize"),max:this.safeFloat(i,"maxOrderSize")},price:{min:void 0,max:void 0},cost:{min:this.safeFloat(i,"minOrderValue"),max:this.safeFloat(i,"maxOrderValue")},withdraw:{min:void 0,max:void 0}}}}return r}async fetchMarkets(e={}){const t=await this.v3publicGetCurrencyStatic(e),i=this.safeValue(t,"currencyStatic",{}),s=this.safeValue(i,"currencies",{}),r=this.safeValue(i,"currencyPairs",{}),a=[],o=Object.keys(r);for(let e=0;e<o.length;e++){const t=o[e],i=r[t],n=this.safeString(i,"tradedCcy"),d=this.safeString(i,"settlementCcy"),c=this.safeCurrencyCode(n),h=this.safeCurrencyCode(d),l=c+"/"+h,u=this.safeValue(s,n,{}),f=this.safeValue(s,d,{}),p={price:this.safeInteger(i,"priceDecimals"),amount:this.safeInteger(u,"decimals")},m=this.safeValue(i,"engineSettings"),y=this.safeValue(m,"displayEnabled"),b=this.safeValue(m,"tradingEnabled"),v=y&&b;a.push({id:t,symbol:l,base:c,quote:h,baseId:n,quoteId:d,precision:p,active:v,limits:{price:{min:this.safeFloat(i,"minOrderRate"),max:this.safeFloat(i,"maxOrderRate")},amount:{min:this.safeFloat(u,"minOrderSize"),max:this.safeFloat(u,"maxOrderSize")},cost:{min:this.safeFloat(f,"minOrderValue"),max:this.safeFloat(f,"maxOrderValue")}},info:i})}return a}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostMoneyInfo(e),i=this.safeValue(t,"data",{}),s=this.safeValue(i,"Wallets",{}),r=Object.keys(s),a={info:i};for(let e=0;e<r.length;e++){const t=r[e],i=this.safeCurrencyCode(t),o=this.account(),n=this.safeValue(s,t);o.free=this.safeFloat(n.Available_Balance,"value"),o.total=this.safeFloat(n.Balance,"value"),a[i]=o}return this.parseBalance(a)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={currency_pair:this.marketId(e)},r=await this.publicGetCurrencyPairMoneyDepthFull(this.extend(s,i)),a=this.safeValue(r,"data",{}),o=this.safeIntegerProduct(a,"dataUpdateTime",.001);return this.parseOrderBook(a,o,"bids","asks","price","amount")}async fetchTicker(e,t={}){await this.loadMarkets();const i={currency_pair:this.marketId(e)},s=await this.publicGetCurrencyPairMoneyTicker(this.extend(i,t)),r=this.safeValue(s,"data",{}),a=this.safeIntegerProduct(r,"dataUpdateTime",.001),o=this.safeFloat(r.buy,"value"),n=this.safeFloat(r.sell,"value"),d=this.safeFloat(r.vol,"value"),c=this.safeFloat(r.last,"value");return{symbol:e,timestamp:a,datetime:this.iso8601(a),high:this.safeFloat(r.high,"value"),low:this.safeFloat(r.low,"value"),bid:o,bidVolume:void 0,ask:n,askVolume:void 0,vwap:void 0,open:void 0,close:c,last:c,previousClose:void 0,change:void 0,percentage:void 0,average:this.safeFloat(r.avg,"value"),baseVolume:d,quoteVolume:void 0,info:r}}async fetchTrades(e,t,i,s={}){throw new l(this.id+" switched off the trades endpoint, see their docs at https://docs.anxv2.apiary.io")}async fetchOrders(e,t,i,s={}){await this.loadMarkets();const r={};void 0!==i&&(r.max=i);const a=await this.v3privatePostOrderList(this.extend(r,s)),o=this.safeValue(a,"orders",[]),n=void 0===e?void 0:this.market(e);return this.parseOrders(o,n,t,i)}async fetchOpenOrders(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={currency_pair:r.id},o=await this.privatePostCurrencyPairMoneyOrders(this.extend(a,s));return this.parseOrders(this.safeValue(o,"data",{}),r,t,i)}parseOrder(e,t){return"orderId"in e?this.parseOrderV3(e,t):this.parseOrderV2(e,t)}parseOrderStatus(e){return this.safeString({ACTIVE:"open",FULL_FILL:"closed",CANCEL:"canceled"},e,e)}parseOrderV3(e,t){const i=this.safeString(e,"tradedCurrency"),s=this.safeString(e,"orderStatus"),r=this.parseOrderStatus(s),a=this.safeString(e,"settlementCurrency"),o=this.findSymbol(i+"/"+a),n="true"===this.safeString(e,"buyTradedCurrency")?"buy":"sell",d=this.safeInteger(e,"timestamp");let c=void 0;const h=[];let l=0;const u=this.safeStringLower(e,"orderType");for(let t=0;t<e.trades.length;t++){const i=e.trades[t],s=this.safeInteger(i,"timestamp");(!c||c<s)&&(c=s);const r=this.extend(this.parseTrade(i),{side:n,type:u});h.push(r),l=this.sum(l,r.amount)}const f=this.safeFloat(e,"limitPriceInSettlementCurrency"),p=this.safeFloat(e,"executedAverageRate"),m="market"===u?0:this.safeFloat(e,"tradedCurrencyAmountOutstanding");let y=this.safeFloat(e,"tradedCurrencyAmount");if(!y){y=this.safeFloat(e,"settlementCurrencyAmount")/p}const b=p*l;return{id:this.safeString(e,"orderId"),symbol:o,timestamp:d,datetime:this.iso8601(d),lastTradeTimestamp:c,type:u,side:n,price:f,cost:b,amount:y,remaining:m,filled:l,status:r,fee:void 0,trades:h,info:e}}parseOrderV2(e,t){const i=this.safeString(e,"oid"),s=this.safeString(e,"status"),r=this.safeInteger(e,"date"),a=this.safeString(e,"item")+"/"+this.safeString(e,"currency");let o=void 0;void 0!==(t=this.safeValue(this.markets_by_id,a))&&(o=t.symbol);const n=this.safeValue(e,"amount",{}),d=this.safeValue(e,"effective_amount",{}),c=this.safeValue(e,"price",{}),h=this.safeFloat(d,"value"),l=this.safeFloat(n,"volume"),u=this.safeFloat(c,"value");let f=void 0,p=void 0;void 0!==l&&void 0!==h&&(p=u*(f=l-h));let m=this.safeString(e,"type");m="offer"===m?"sell":"buy";return{info:e,id:i,symbol:o,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,type:"limit",side:m,price:u,cost:p,amount:l,remaining:h,filled:f,status:s,fee:void 0,trades:void 0}}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o=this.market(e),n=Math.pow(10,o.precision.amount),d={currency_pair:o.id,amount_int:parseInt(s*n)};if("limit"===t){const e=Math.pow(10,o.precision.price);d.price_int=parseInt(r*e)}d.type="buy"===i?"bid":"ask";const c=await this.privatePostCurrencyPairMoneyOrderAdd(this.extend(d,a));return{info:c,id:c.data}}async cancelOrder(e,t,i={}){return await this.privatePostCurrencyPairMoneyOrderCancel({oid:e})}getAmountMultiplier(e){return this.safeInteger({BTC:1e8,LTC:1e8,STR:1e8,XRP:1e8,DOGE:1e8},e,100)}async withdraw(e,t,i,s,r={}){this.checkAddress(i),await this.loadMarkets();const a=this.currency(e),o=this.getAmountMultiplier(e),n={currency:a,amount_int:parseInt(t*o),address:i};void 0!==s&&(n.destinationTag=s);const d=await this.privatePostMoneyCurrencySendSimple(this.extend(n,r));return{info:d,id:d.data.transactionId}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},s=await this.privatePostMoneyCurrencyAddress(this.extend(i,t)),r=this.safeValue(s,"data",{}),a=this.safeString(r,"addr");return this.checkAddress(a),{currency:e,address:a,tag:void 0,info:s}}nonce(){return this.milliseconds()}sign(e,t="public",i="GET",s={},r,a){const o=this.implodeParams(e,s),n=this.omit(s,this.extractParams(e));let d=this.urls.api[t]+"/"+o;if("public"===t||"v3public"===t)Object.keys(n).length&&(d+="?"+this.urlencode(n));else{this.checkRequiredCredentials();const e=this.nonce();let i=void 0,s=void 0;if("v3private"===t){a=this.json(this.extend({tonce:1e3*e},n)),i=d.replace("https://anxpro.com/","")+"\0"+a,s="application/json"}else i=o+"\0"+(a=this.urlencode(this.extend({nonce:e},n))),s="application/x-www-form-urlencoded";const c=this.base64ToBinary(this.secret),h=this.hmac(this.encode(i),c,"sha512","base64");r={"Content-Type":s,"Rest-Key":this.apiKey,"Rest-Sign":this.decode(h)}}return{url:d,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,o,n,d,c){if(void 0===n||""===n)return;const h=this.safeString(n,"result"),l=this.safeString(n,"resultCode");if(void 0!==h&&"success"!==h||void 0!==l&&"OK"!==l){const e=this.safeString(n,"error"),t=this.id+" "+o,i=this.exceptions.exact;if(l in i)throw new i[l](t);if(e in i)throw new i[e](t);const s=this.safeValue(this.exceptions,"broad",{}),a=this.findBroadlyMatchedKey(s,e);if(void 0!==a)throw new s[a](t);throw new r(t)}}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,ArgumentsRequired:a,AuthenticationError:o,InsufficientFunds:n,InvalidOrder:d,OrderNotFound:c}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"bcex",name:"BCEX",countries:["CN","CA"],version:"1",has:{fetchBalance:!0,fetchMarkets:!0,createOrder:!0,cancelOrder:!0,fetchTicker:!0,fetchTickers:!1,fetchTrades:!0,fetchOrder:!0,fetchOrders:!0,fetchClosedOrders:"emulated",fetchOpenOrders:!0,fetchTradingLimits:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/43362240-21c26622-92ee-11e8-9464-5801ec526d77.jpg",api:"https://www.bcex.top",www:"https://www.bcex.top",doc:"https://github.com/BCEX-TECHNOLOGY-LIMITED/API_Docs/wiki/Interface",fees:"https://bcex.udesk.cn/hc/articles/57085",referral:"https://www.bcex.top/register?invite_code=758978&lang=en"},status:{status:"error",updated:void 0,eta:void 0,url:void 0},api:{public:{get:["Api_Market/getPriceList","Api_Order/ticker","Api_Order/depth","Api_Market/getCoinTrade","Api_Order/marketOrder"],post:["Api_Market/getPriceList","Api_Order/ticker","Api_Order/depth","Api_Market/getCoinTrade","Api_Order/marketOrder"]},private:{post:["Api_Order/cancel","Api_Order/coinTrust","Api_Order/orderList","Api_Order/orderInfo","Api_Order/tradeList","Api_Order/trustList","Api_User/userBalance"]}},fees:{trading:{tierBased:!1,percentage:!0,buy:0,sell:.002},funding:{tierBased:!1,percentage:!1,withdraw:{ckusd:0,other:5e-4},deposit:{}}},exceptions:{",":r,"":o,"":n,"btc":n,"":d,"":c},options:{limits:{"AFC/CKUSD":{precision:{amount:2,price:4},limits:{amount:{min:6,max:12e4}}},"AFC/ETH":{precision:{amount:2,price:8},limits:{amount:{min:6,max:12e4}}},"AFT/ETH":{precision:{amount:2,price:8},limits:{amount:{min:15,max:3e5}}},"AICC/CNET":{precision:{amount:2,price:2},limits:{amount:{min:5,max:5e4}}},"AIDOC/CKUSD":{precision:{amount:2,price:4},limits:{amount:{min:5,max:1e5}}},"AISI/ETH":{precision:{amount:4,price:2},limits:{amount:{min:.001,max:500}}},"AIT/ETH":{precision:{amount:2,price:8},limits:{amount:{min:20,max:4e5}}},"ANS/BTC":{precision:{amount:4,price:8},limits:{amount:{min:.1,max:500}}},"ANS/CKUSD":{precision:{amount:2,price:2},limits:{amount:{min:.1,max:1e3}}},"ARC/CNET":{precision:{amount:2,price:4},limits:{amount:{min:60,max:6e5}}},"AXF/CNET":{precision:{amount:2,price:4},limits:{amount:{min:100,max:1e6}}},"BASH/CKUSD":{precision:{amount:2,price:4},limits:{amount:{min:250,max:3e6}}},"BATT/ETH":{precision:{amount:2,price:8},limits:{amount:{min:60,max:15e5}}},"BCD/BTC":{precision:{amount:2,price:8},limits:{amount:{min:.3,max:7e3}}},"BHPC/BTC":{precision:{amount:2,price:8},limits:{amount:{min:2,max:7e4}}},"BHPC/ETH":{precision:{amount:2,price:8},limits:{amount:{min:2,max:6e4}}},"BOPO/BTC":{precision:{amount:2,price:8},limits:{amount:{min:100,max:2e6}}},"BOPO/CKUSD":{precision:{amount:2,price:4},limits:{amount:{min:100,max:1e7}}},"BTC/CKUSD":{precision:{amount:4,price:2},limits:{amount:{min:.001,max:10}}},"BTC/CNET":{precision:{amount:4,price:2},limits:{amount:{min:5e-4,max:5}}},"BTC/USDT":{precision:{amount:4,price:2},limits:{amount:{min:2e-4,max:4}}},"BTE/CNET":{precision:{amount:2,price:4},limits:{amount:{min:25,max:25e4}}},"BU/ETH":{precision:{amount:2,price:8},limits:{amount:{min:20,max:4e5}}},"CIC/CNET":{precision:{amount:2,price:4},limits:{amount:{min:3e3,max:3e7}}},"CIT/CKUSD":{precision:{amount:2,price:4},limits:{amount:{min:4,max:4e4}}},"CIT/ETH":{precision:{amount:2,price:8},limits:{amount:{min:4,max:4e4}}},"CMT/CKUSD":{precision:{amount:2,price:4},limits:{amount:{min:5,max:25e5}}},"CNET/CKUSD":{precision:{amount:2,price:4},limits:{amount:{min:12,max:12e4}}},"CNMC/BTC":{precision:{amount:2,price:8},limits:{amount:{min:4,max:5e4}}},"CTC/ETH":{precision:{amount:2,price:8},limits:{amount:{min:5,max:55e4}}},"CZR/ETH":{precision:{amount:2,price:8},limits:{amount:{min:12,max:5e5}}},"DCON/ETH":{precision:{amount:2,price:8},limits:{amount:{min:8,max:3e5}}},"DCT/BTC":{precision:{amount:4,price:8},limits:{amount:{min:2,max:4e4}}},"DCT/CKUSD":{precision:{amount:2,price:3},limits:{amount:{min:2,max:2e3}}},"DOGE/BTC":{precision:{amount:4,price:8},limits:{amount:{min:3e3,max:14e6}}},"DOGE/CKUSD":{precision:{amount:2,price:6},limits:{amount:{min:500,max:2e6}}},"DRCT/ETH":{precision:{amount:2,price:8},limits:{amount:{min:16,max:19e4}}},"ELA/BTC":{precision:{amount:2,price:8},limits:{amount:{min:.02,max:500}}},"ELF/BTC":{precision:{amount:2,price:8},limits:{amount:{min:.1,max:1e5}}},"ELF/CKUSD":{precision:{amount:2,price:3},limits:{amount:{min:.01,max:1e5}}},"EOS/CKUSD":{precision:{amount:2,price:2},limits:{amount:{min:.5,max:5e3}}},"EOS/CNET":{precision:{amount:2,price:2},limits:{amount:{min:2.5,max:3e4}}},"EOS/ETH":{precision:{amount:2,price:8},limits:{amount:{min:.18,max:1800}}},"ETC/BTC":{precision:{amount:4,price:8},limits:{amount:{min:.2,max:2500}}},"ETC/CKUSD":{precision:{amount:2,price:2},limits:{amount:{min:.2,max:2500}}},"ETF/ETH":{precision:{amount:2,price:8},limits:{amount:{min:7,max:15e4}}},"ETH/BTC":{precision:{amount:4,price:8},limits:{amount:{min:.015,max:100}}},"ETH/CKUSD":{precision:{amount:4,price:4},limits:{amount:{min:.005,max:100}}},"ETH/USDT":{precision:{amount:4,price:2},limits:{amount:{min:.005,max:100}}},"FCT/BTC":{precision:{amount:4,price:8},limits:{amount:{min:.24,max:1e3}}},"FCT/CKUSD":{precision:{amount:2,price:2},limits:{amount:{min:.24,max:1e3}}},"GAME/CNET":{precision:{amount:2,price:2},limits:{amount:{min:1,max:1e4}}},"GOOC/CKUSD":{precision:{amount:2,price:4},limits:{amount:{min:200,max:2e6}}},"GP/CNET":{precision:{amount:2,price:4},limits:{amount:{min:600,max:6e6}}},"HSC/ETH":{precision:{amount:2,price:8},limits:{amount:{min:1e3,max:2e7}}},"IFISH/ETH":{precision:{amount:2,price:8},limits:{amount:{min:300,max:8e6}}},"IIC/ETH":{precision:{amount:2,price:8},limits:{amount:{min:50,max:4e6}}},"IMOS/ETH":{precision:{amount:2,price:8},limits:{amount:{min:15,max:3e5}}},"JC/CNET":{precision:{amount:2,price:4},limits:{amount:{min:300,max:3e6}}},"LBTC/BTC":{precision:{amount:2,price:8},limits:{amount:{min:.1,max:3e3}}},"LEC/CNET":{precision:{amount:2,price:4},limits:{amount:{min:500,max:5e6}}},"LKY/CKUSD":{precision:{amount:2,price:4},limits:{amount:{min:10,max:7e4}}},"LKY/ETH":{precision:{amount:2,price:8},limits:{amount:{min:10,max:1e5}}},"LMC/CNET":{precision:{amount:2,price:4},limits:{amount:{min:25,max:25e4}}},"LSK/CNET":{precision:{amount:2,price:2},limits:{amount:{min:.3,max:3e3}}},"LTC/BTC":{precision:{amount:4,price:8},limits:{amount:{min:.01,max:500}}},"LTC/CKUSD":{precision:{amount:2,price:2},limits:{amount:{min:.01,max:500}}},"LTC/USDT":{precision:{amount:4,price:2},limits:{amount:{min:.02,max:450}}},"MC/CNET":{precision:{amount:2,price:6},limits:{amount:{min:1e4,max:1e8}}},"MCC/CKUSD":{precision:{amount:2,price:4},limits:{amount:{min:30,max:35e4}}},"MOC/ETH":{precision:{amount:2,price:8},limits:{amount:{min:25,max:6e5}}},"MRYC/CNET":{precision:{amount:2,price:4},limits:{amount:{min:300,max:3e6}}},"MT/ETH":{precision:{amount:2,price:8},limits:{amount:{min:200,max:6e6}}},"MXI/CNET":{precision:{amount:2,price:6},limits:{amount:{min:5e3,max:6e7}}},"NAI/ETH":{precision:{amount:2,price:8},limits:{amount:{min:10,max:1e5}}},"NAS/BTC":{precision:{amount:4,price:8},limits:{amount:{min:.2,max:15e3}}},"NAS/CKUSD":{precision:{amount:2,price:2},limits:{amount:{min:.5,max:5e3}}},"NEWOS/ETH":{precision:{amount:2,price:8},limits:{amount:{min:65,max:7e5}}},"NKN/ETH":{precision:{amount:2,price:8},limits:{amount:{min:3,max:35e4}}},"NTK/ETH":{precision:{amount:2,price:8},limits:{amount:{min:2,max:3e4}}},"ONT/CKUSD":{precision:{amount:2,price:3},limits:{amount:{min:.2,max:2e3}}},"ONT/ETH":{precision:{amount:3,price:8},limits:{amount:{min:.01,max:1e3}}},"PNT/ETH":{precision:{amount:2,price:8},limits:{amount:{min:80,max:8e5}}},"PST/ETH":{precision:{amount:2,price:8},limits:{amount:{min:5,max:1e5}}},"PTT/ETH":{precision:{amount:2,price:8},limits:{amount:{min:450,max:1e7}}},"QTUM/BTC":{precision:{amount:4,price:8},limits:{amount:{min:.4,max:2800}}},"QTUM/CKUSD":{precision:{amount:2,price:2},limits:{amount:{min:.1,max:1e3}}},"RATING/ETH":{precision:{amount:2,price:8},limits:{amount:{min:500,max:1e7}}},"RHC/CNET":{precision:{amount:2,price:4},limits:{amount:{min:1e3,max:1e7}}},"SDA/ETH":{precision:{amount:2,price:8},limits:{amount:{min:20,max:5e5}}},"SDD/CKUSD":{precision:{amount:2,price:3},limits:{amount:{min:10,max:1e5}}},"SHC/CNET":{precision:{amount:2,price:4},limits:{amount:{min:250,max:25e5}}},"SHE/ETH":{precision:{amount:2,price:8},limits:{amount:{min:100,max:5e6}}},"SMC/CNET":{precision:{amount:2,price:6},limits:{amount:{min:1e3,max:1e7}}},"SOP/ETH":{precision:{amount:2,price:8},limits:{amount:{min:50,max:1e6}}},"TAC/ETH":{precision:{amount:2,price:8},limits:{amount:{min:35,max:8e5}}},"TIP/ETH":{precision:{amount:2,price:8},limits:{amount:{min:7,max:2e5}}},"TKT/ETH":{precision:{amount:2,price:8},limits:{amount:{min:40,max:4e5}}},"TLC/ETH":{precision:{amount:2,price:8},limits:{amount:{min:500,max:1e7}}},"TNC/ETH":{precision:{amount:2,price:8},limits:{amount:{min:10,max:11e4}}},"TUB/ETH":{precision:{amount:2,price:8},limits:{amount:{min:200,max:8e6}}},"UC/ETH":{precision:{amount:2,price:8},limits:{amount:{min:100,max:3e6}}},"UDB/CNET":{precision:{amount:2,price:6},limits:{amount:{min:2e3,max:4e7}}},"UIC/CKUSD":{precision:{amount:2,price:4},limits:{amount:{min:5,max:15e4}}},"VAAC/ETH":{precision:{amount:2,price:8},limits:{amount:{min:10,max:25e4}}},"VPN/CNET":{precision:{amount:2,price:4},limits:{amount:{min:200,max:2e6}}},"VSC/ETH":{precision:{amount:2,price:8},limits:{amount:{min:30,max:65e4}}},"WAVES/CKUSD":{precision:{amount:2,price:3},limits:{amount:{min:.15,max:1500}}},"WDNA/ETH":{precision:{amount:2,price:8},limits:{amount:{min:100,max:25e4}}},"WIC/CKUSD":{precision:{amount:2,price:4},limits:{amount:{min:3,max:3e4}}},"XAS/CNET":{precision:{amount:2,price:2},limits:{amount:{min:2.5,max:25e3}}},"XLM/BTC":{precision:{amount:4,price:8},limits:{amount:{min:10,max:3e5}}},"XLM/CKUSD":{precision:{amount:2,price:4},limits:{amount:{min:1,max:3e5}}},"XLM/USDT":{precision:{amount:2,price:4},limits:{amount:{min:5,max:15e4}}},"XRP/BTC":{precision:{amount:4,price:8},limits:{amount:{min:24,max:1e5}}},"XRP/CKUSD":{precision:{amount:2,price:3},limits:{amount:{min:5,max:5e4}}},"YBCT/BTC":{precision:{amount:4,price:8},limits:{amount:{min:15,max:2e5}}},"YBCT/CKUSD":{precision:{amount:2,price:4},limits:{amount:{min:10,max:2e5}}},"YBY/CNET":{precision:{amount:2,price:6},limits:{amount:{min:25e3,max:25e7}}},"ZEC/BTC":{precision:{amount:4,price:8},limits:{amount:{min:.02,max:100}}},"ZEC/CKUSD":{precision:{amount:4,price:2},limits:{amount:{min:.02,max:100}}}}}})}async fetchTradingLimits(e,t={}){await this.loadMarkets(),void 0===e&&(e=this.symbols);const i={};for(let s=0;s<e.length;s++){const r=e[s];i[r]=await this.fetchTradingLimitsById(this.marketId(r),t)}return i}async fetchTradingLimitsById(e,t={}){const i={symbol:e},s=await this.publicPostApiOrderTicker(this.extend(i,t));return this.parseTradingLimits(this.safeValue(s,"data",{}))}parseTradingLimits(e,t,i={}){return{info:e,precision:{amount:this.safeInteger(e,"number_float"),price:this.safeInteger(e,"price_float")},limits:{amount:{min:this.safeFloat(e,"min_trade"),max:this.safeFloat(e,"max_trade")}}}}async fetchMarkets(e={}){const t=await this.publicGetApiMarketGetPriceList(e),i=[],s=Object.keys(t);for(let e=0;e<s.length;e++){const r=t[s[e]];for(let e=0;e<r.length;e++){const t=r[e],s=this.safeString(t,"coin_from"),a=this.safeString(t,"coin_to");let o=s.toUpperCase(),n=a.toUpperCase();const d=s+"2"+a,c=(o=this.safeCurrencyCode(o))+"/"+(n=this.safeCurrencyCode(n)),h=!0,l=this.safeValue(this.options.limits,c,{});i.push(this.extend({id:d,symbol:c,base:o,quote:n,baseId:s,quoteId:a,active:h,precision:{amount:void 0,price:void 0},limits:{amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:t},l))}}return i}parseTrade(e,t){let i=void 0;void 0!==t&&(i=t.symbol);const s=this.safeTimestamp2(e,"date","created"),r=this.safeString(e,"tid"),a=this.safeString(e,"order_id"),o=this.safeFloat2(e,"number","amount"),n=this.safeFloat(e,"price");let d=void 0;void 0!==n&&void 0!==o&&(d=o*n);let c=this.safeString(e,"side");return"sale"===c&&(c="sell"),{info:e,id:r,timestamp:s,datetime:this.iso8601(s),symbol:i,type:void 0,side:c,price:n,amount:o,cost:d,order:a,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r={symbol:this.marketId(e)};void 0!==i&&(r.limit=i);const a=this.market(e),o=await this.publicPostApiOrderMarketOrder(this.extend(r,s));return this.parseTrades(o.data,a,t,i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostApiUserUserBalance(e),i=this.safeValue(t,"data");let s=Object.keys(i);const r={};for(let e=0;e<s.length;e++){const t=s[e],a=this.safeFloat(i,t),o=t.split("_"),n=o[0],d=o[1],c=this.safeCurrencyCode(n);c in r||(r[c]=this.account()),"lock"===d?r[c].used=parseFloat(a):r[c].free=parseFloat(a)}s=Object.keys(r);for(let e=0;e<s.length;e++){const t=s[e],i=this.sum(r[t].used,r[t].free);r[t].total=i}return r.info=i,this.parseBalance(r)}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.markets[e],s={part:i.quoteId,coin:i.baseId},r=await this.publicPostApiMarketGetCoinTrade(this.extend(s,t)),a=this.milliseconds();return{symbol:e,timestamp:a,datetime:this.iso8601(a),high:this.safeFloat(r,"max"),low:this.safeFloat(r,"min"),bid:this.safeFloat(r,"buy"),bidVolume:void 0,ask:this.safeFloat(r,"sale"),askVolume:void 0,vwap:void 0,open:void 0,close:this.safeFloat(r,"price"),last:this.safeFloat(r,"price"),previousClose:void 0,change:void 0,percentage:this.safeFloat(r,"change_24h"),average:void 0,baseVolume:this.safeFloat(r,"volume_24h"),quoteVolume:void 0,info:r}}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={symbol:this.marketId(e)},r=await this.publicPostApiOrderDepth(this.extend(s,i)),a=this.safeValue(r,"data"),o=this.safeTimestamp(a,"date");return this.parseOrderBook(a,o)}async fetchMyTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id},o=await this.privatePostApiOrderOrderList(this.extend(a,s));return this.parseTrades(o.data,r,t,i)}parseOrderStatus(e){return this.safeString({0:"open",1:"open",2:"closed",3:"canceled"},e,e)}async fetchOrder(e,t,i={}){if(void 0===t)throw new a(this.id+" fetchOrder requires a `symbol` argument");await this.loadMarkets();const s={symbol:this.marketId(t),trust_id:e},r=await this.privatePostApiOrderOrderInfo(this.extend(s,i)),o=this.safeValue(r,"data"),n=this.safeTimestamp(o,"created"),d=this.parseOrderStatus(this.safeString(o,"status"));let c=this.safeString(o,"flag");return"sale"===c&&(c="sell"),{info:o,id:e,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,symbol:t,type:void 0,side:c,price:this.safeFloat(o,"price"),cost:void 0,average:this.safeFloat(o,"avg_price"),amount:this.safeFloat(o,"number"),filled:this.safeFloat(o,"numberdeal"),remaining:this.safeFloat(o,"numberover"),status:d,fee:void 0}}parseOrder(e,t){const i=this.safeString(e,"id"),s=this.safeTimestamp(e,"datetime");let r=void 0;void 0!==t&&(r=t.symbol);let a=this.safeString(e,"type");"sale"===a&&(a="sell");const o=this.safeFloat(e,"price"),n=this.safeFloat(e,"avg_price"),d=this.safeFloat(e,"amount"),c=this.safeFloat(e,"amount_outstanding"),h=d-c,l=this.parseOrderStatus(this.safeString(e,"status")),u=h*o;return{info:e,id:i,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,symbol:r,type:void 0,side:a,price:o,cost:u,average:n,amount:d,filled:h,remaining:c,status:l,fee:void 0}}async fetchOrdersByType(e,t,i,s,r={}){await this.loadMarkets();const a={type:e};let o=void 0;void 0!==t&&(o=this.market(t),a.symbol=o.id);const n=await this.privatePostApiOrderTradeList(this.extend(a,r));return"data"in n?this.parseOrders(n.data,o,i,s):[]}async fetchOpenOrders(e,t,i,s={}){return this.fetchOrdersByType("open",e,t,i,s)}async fetchClosedOrders(e,t,i,s={}){const r=await this.fetchOrders(e,t,i,s);return this.filterBy(r,"status","closed")}async fetchOrders(e,t,i,s={}){return this.fetchOrdersByType("all",e,t,i,s)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o={symbol:this.marketId(e),type:i,price:this.priceToPrecision(e,r),number:this.amountToPrecision(e,s)},n=await this.privatePostApiOrderCoinTrust(this.extend(o,a)),d=this.safeValue(n,"data",{});return{info:n,id:this.safeString(d,"order_id")}}async cancelOrder(e,t,i={}){if(void 0===t)throw new a(this.id+" cancelOrder requires a `symbol` argument");await this.loadMarkets();const s={};return void 0!==t&&(s.symbol=this.marketId(t)),void 0!==e&&(s.order_id=e),await this.privatePostApiOrderCancel(this.extend(s,i))}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api+"/"+this.implodeParams(e,s);const n=this.omit(s,this.extractParams(e));if("public"===t)Object.keys(n).length&&(o+="?"+this.urlencode(n));else{this.checkRequiredCredentials();let e=this.urlencode({api_key:this.apiKey});Object.keys(n).length&&(e+="&"+this.urlencode(this.keysort(n)));const t=e+"&secret_key="+this.secret;a=e+"&sign="+this.hash(this.encode(t)),r={"Content-Type":"application/x-www-form-urlencoded"}}return{url:o,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,o,n,c,h){if(void 0===n)return;const l=this.safeValue(n,"code");if(void 0!==l&&0!==l){const e=this.safeString(n,"msg"),t=this.id+" "+e,i=this.exceptions;throw e in i?new i[e](t):e.indexOf("")>=0?new d(t):new r(t)}}calculateFee(e,t,i,s,r,a="taker",o={}){const n=this.markets[e],d=n[i],c=parseFloat(this.costToPrecision(e,s*r));return{type:a,currency:n.quote,rate:d,cost:parseFloat(this.feeToPrecision(e,d*c))}}}},function(e,t,i){"use strict";const s=i(30);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"bequant",name:"Bequant",countries:["MT"],urls:{logo:"https://user-images.githubusercontent.com/1294454/55248342-a75dfe00-525a-11e9-8aa2-05e9dca943c6.jpg",api:"https://api.bequant.io",www:"https://bequant.io",doc:["https://api.bequant.io/"],fees:["https://bequant.io/fees-and-limits"],referral:"https://bequant.io"}})}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,ArgumentsRequired:a,AuthenticationError:o,DDoSProtection:n,ExchangeNotAvailable:d,InvalidOrder:c,OrderNotFound:h,PermissionDenied:l,InsufficientFunds:u}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"bibox",name:"Bibox",countries:["CN","US","KR"],version:"v1",has:{CORS:!1,publicAPI:!1,fetchBalance:!0,fetchDeposits:!0,fetchWithdrawals:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchFundingFees:!0,fetchTickers:!0,fetchOrder:!0,fetchOpenOrders:!0,fetchClosedOrders:!0,fetchMyTrades:!0,fetchOHLCV:!0,createMarketOrder:!1,withdraw:!0},timeframes:{"1m":"1min","5m":"5min","15m":"15min","30m":"30min","1h":"1hour","2h":"2hour","4h":"4hour","6h":"6hour","12h":"12hour","1d":"day","1w":"week"},urls:{logo:"https://user-images.githubusercontent.com/1294454/34902611-2be8bf1a-f830-11e7-91a2-11b2f292e750.jpg",api:"https://api.bibox.com",www:"https://www.bibox.com",doc:["https://github.com/Biboxcom/API_Docs_en/wiki"],fees:"https://bibox.zendesk.com/hc/en-us/articles/360002336133",referral:"https://www.bibox.com/signPage?id=11114745&lang=en"},api:{public:{post:["mdata"],get:["mdata"]},private:{post:["user","orderpending","transfer"]},v2private:{post:["assets/transfer/spot"]}},fees:{trading:{tierBased:!1,percentage:!0,taker:.001,maker:.001},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{}}},exceptions:{2021:u,2015:o,2027:u,2033:h,2067:c,2068:c,2085:c,3012:o,3024:l,3025:o,4000:d,4003:n},commonCurrencies:{KEY:"Bihu",PAI:"PCHAIN"}})}async fetchMarkets(e={}){const t=await this.publicGetMdata(this.extend({cmd:"marketAll"},e)),i=this.safeValue(t,"result"),s=[];for(let e=0;e<i.length;e++){const t=i[e],r=this.safeInteger(t,"id"),a=this.safeString(t,"coin_symbol"),o=this.safeString(t,"currency_symbol"),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o),c=n+"/"+d,h=a+"_"+o,l={amount:4,price:8};s.push({id:h,numericId:r,symbol:c,base:n,quote:d,baseId:n,quoteId:d,active:!0,info:t,precision:l,limits:{amount:{min:Math.pow(10,-l.amount),max:void 0},price:{min:Math.pow(10,-l.price),max:void 0}}})}return s}parseTicker(e,t){const i=this.safeInteger(e,"timestamp");let s=void 0;if(void 0!==t)s=t.symbol;else{const t=this.safeString(e,"coin_symbol"),i=this.safeString(e,"currency_symbol");s=this.safeCurrencyCode(t)+"/"+this.safeCurrencyCode(i)}const r=this.safeFloat(e,"last"),a=this.safeFloat(e,"change"),o=this.safeFloat2(e,"vol","vol24H");let n=void 0;void 0!==r&&void 0!==a&&(n=r-a);let d=this.safeString(e,"percent");return void 0!==d&&(d=d.replace("%",""),d=parseFloat(d)),{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"buy"),bidVolume:void 0,ask:this.safeFloat(e,"sell"),askVolume:void 0,vwap:void 0,open:n,close:r,last:r,previousClose:void 0,change:a,percentage:d,average:void 0,baseVolume:o,quoteVolume:this.safeFloat(e,"amount"),info:e}}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={cmd:"ticker",pair:i.id},r=await this.publicGetMdata(this.extend(s,t));return this.parseTicker(r.result,i)}parseTickers(e,t){const i=[];for(let s=0;s<e.length;s++){const r=this.parseTicker(e[s]);(void 0===t||this.inArray(r.symbol,t))&&i.push(r)}return i}async fetchTickers(e,t={}){const i=await this.publicGetMdata(this.extend({cmd:"marketAll"},t)),s=this.parseTickers(i.result,e);return this.indexBy(s,"symbol")}parseTrade(e,t){const i=this.safeInteger2(e,"time","createdAt");let s=this.safeInteger2(e,"side","order_side");s=1===s?"buy":"sell";let r=void 0;if(void 0===t){let i=this.safeString(e,"pair");if(void 0===i){const t=this.safeString(e,"coin_symbol"),s=this.safeString(e,"currency_symbol");void 0!==t&&void 0!==s&&(i=t+"_"+s)}i in this.markets_by_id&&(t=this.markets_by_id[i])}void 0!==t&&(r=t.symbol);let a=void 0;const o=this.safeFloat(e,"fee");let n=this.safeString(e,"fee_symbol");void 0!==n&&(n=n in this.currencies_by_id?this.currencies_by_id[n].code:this.safeCurrencyCode(n));const d=this.safeFloat(e,"price"),c=this.safeFloat(e,"amount");let h=void 0;return void 0!==d&&void 0!==c&&(h=d*c),void 0!==o&&(a={cost:o,currency:n,rate:void 0}),{info:e,id:this.safeString(e,"id"),order:void 0,timestamp:i,datetime:this.iso8601(i),symbol:r,type:"limit",takerOrMaker:void 0,side:s,price:d,amount:c,cost:h,fee:a}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={cmd:"deals",pair:r.id};void 0!==i&&(a.size=i);const o=await this.publicGetMdata(this.extend(a,s));return this.parseTrades(o.result,r,t,i)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={cmd:"depth",pair:this.market(e).id};void 0!==t&&(s.size=t);const r=await this.publicGetMdata(this.extend(s,i));return this.parseOrderBook(r.result,this.safeFloat(r.result,"update_time"),"bids","asks","price","volume")}parseOHLCV(e,t,i="1m",s,r){return[e.time,this.safeFloat(e,"open"),this.safeFloat(e,"high"),this.safeFloat(e,"low"),this.safeFloat(e,"close"),this.safeFloat(e,"vol")]}async fetchOHLCV(e,t="1m",i,s=1e3,r={}){await this.loadMarkets();const a=this.market(e),o={cmd:"kline",pair:a.id,period:this.timeframes[t],size:s},n=await this.publicGetMdata(this.extend(o,r));return this.parseOHLCVs(n.result,a,t,i,s)}async fetchCurrencies(e={}){if(!this.apiKey||!this.secret)throw new o(this.id+" fetchCurrencies is an authenticated endpoint, therefore it requires 'apiKey' and 'secret' credentials. If you don't need currency details, set exchange.has['fetchCurrencies'] = false before calling its methods.");const t=await this.privatePostTransfer(this.extend({cmd:"transfer/coinList",body:{}},e)),i=this.safeValue(t,"result"),s={};for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"symbol"),a=this.safeString(t,"name"),o=this.safeCurrencyCode(r),n=8,d=this.safeValue(t,"enable_deposit"),c=this.safeValue(t,"enable_withdraw"),h=d&&c;s[o]={id:r,code:o,info:t,name:a,active:h,fee:void 0,precision:n,limits:{amount:{min:Math.pow(10,-n),max:Math.pow(10,n)},price:{min:Math.pow(10,-n),max:Math.pow(10,n)},cost:{min:void 0,max:void 0},withdraw:{min:void 0,max:Math.pow(10,n)}}}}return s}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString(e,"type","assets");e=this.omit(e,"type");const i={cmd:"transfer/"+t,body:this.extend({select:1},e)},s=await this.privatePostTransfer(i),r=this.safeValue(s,"result"),a={info:r};let o=void 0;o="assets_list"in r?this.indexBy(r.assets_list,"coin_symbol"):r;const n=Object.keys(o);for(let e=0;e<n.length;e++){const t=n[e];let i=t.toUpperCase();i.indexOf("TOTAL_")>=0&&(i=i.slice(6)),i in this.currencies_by_id&&(i=this.currencies_by_id[i].code);const s=this.account();let r=o[t];"string"==typeof r?(r=parseFloat(r),s.free=r,s.used=0,s.total=r):(s.free=this.safeFloat(r,"balance"),s.used=this.safeFloat(r,"freeze")),a[i]=s}return this.parseBalance(a)}async fetchDeposits(e,t,i,s={}){await this.loadMarkets();let r=void 0;const a={page:1};void 0!==e&&(r=this.currency(e),a.symbol=r.id),a.size=void 0!==i?i:100;const o=await this.privatePostTransfer({cmd:"transfer/transferInList",body:this.extend(a,s)}),n=this.safeValue(o.result,"items",[]);for(let e=0;e<n.length;e++)n[e].type="deposit";return this.parseTransactions(n,r,t,i)}async fetchWithdrawals(e,t,i,s={}){await this.loadMarkets();let r=void 0;const a={page:1};void 0!==e&&(r=this.currency(e),a.symbol=r.id),a.size=void 0!==i?i:100;const o=await this.privatePostTransfer({cmd:"transfer/transferOutList",body:this.extend(a,s)}),n=this.safeValue(o.result,"items",[]);for(let e=0;e<n.length;e++)n[e].type="withdrawal";return this.parseTransactions(n,r,t,i)}parseTransaction(e,t){const i=this.safeString(e,"id"),s=this.safeString(e,"to_address"),r=this.safeString(e,"coin_symbol"),a=this.safeCurrencyCode(r,t),o=this.safeString(e,"createdAt");let n=this.safeString(e,"addr_remark");const d=this.safeString(e,"type"),c=this.parseTransactionStatusByType(this.safeString(e,"status"),d),h=this.safeFloat(e,"amount");let l=this.safeFloat(e,"fee");"deposit"===d&&(l=0,n=void 0);const u={cost:l,currency:a};return{info:e,id:i,txid:void 0,timestamp:o,datetime:this.iso8601(o),address:s,tag:n,type:d,amount:h,currency:a,status:c,updated:void 0,fee:u}}parseTransactionStatusByType(e,t){return this.safeString(this.safeValue({deposit:{1:"pending",2:"ok"},withdrawal:{0:"pending",3:"ok"}},t,{}),e,e)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o=this.market(e),n="limit"===t?2:1,d="buy"===i?1:2,c={cmd:"orderpending/trade",body:this.extend({pair:o.id,account_type:0,order_type:n,order_side:d,pay_bix:0,amount:s,price:r},a)},h=await this.privatePostOrderpending(c);return{info:h,id:this.safeString(h,"result")}}async cancelOrder(e,t,i={}){const s={cmd:"orderpending/cancelTrade",body:this.extend({orders_id:e},i)};return await this.privatePostOrderpending(s)}async fetchOrder(e,t,i={}){await this.loadMarkets();const s={cmd:"orderpending/order",body:this.extend({id:e.toString(),account_type:0},i)},r=await this.privatePostOrderpending(s),a=this.safeValue(r,"result");if(this.isEmpty(a))throw new h(this.id+" order "+e+" not found");return this.parseOrder(a)}parseOrder(e,t){let i=void 0;if(void 0===t){let i=void 0;const s=this.safeString(e,"coin_symbol"),r=this.safeString(e,"currency_symbol");void 0!==s&&void 0!==r&&(i=s+"_"+r),i in this.markets_by_id&&(t=this.markets_by_id[i])}void 0!==t&&(i=t.symbol);const s=1===e.order_type?"market":"limit",r=e.createdAt,a=this.safeFloat(e,"price"),o=this.safeFloat(e,"deal_price"),n=this.safeFloat(e,"deal_amount"),d=this.safeFloat(e,"amount");let c=this.safeFloat2(e,"deal_money","money"),h=void 0;void 0!==n&&(void 0!==d&&(h=d-n),void 0===c&&(c=a*n));const l=1===e.order_side?"buy":"sell",u=this.parseOrderStatus(this.safeString(e,"status")),f=this.safeString(e,"id"),p=this.safeFloat(e,"fee");let m=void 0;return void 0!==p&&(m={cost:p,currency:void 0}),c=c||parseFloat(a)*n,{info:e,id:f,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,symbol:i,type:s,side:l,price:a,amount:d,cost:c,average:o,filled:n,remaining:h,status:u,fee:m}}parseOrderStatus(e){return this.safeString({1:"open",2:"open",3:"closed",4:"canceled",5:"canceled",6:"canceled"},e,e)}async fetchOpenOrders(e,t,i,s={}){await this.loadMarkets();let r=void 0,a=void 0;void 0!==e&&(a=(r=this.market(e)).id);const o=i||200,n={cmd:"orderpending/orderPendingList",body:this.extend({pair:a,account_type:0,page:1,size:o},s)},d=await this.privatePostOrderpending(n),c=this.safeValue(d.result,"items",[]);return this.parseOrders(c,r,t,i)}async fetchClosedOrders(e,t,i=200,s={}){if(void 0===e)throw new a(this.id+" fetchClosedOrders requires a `symbol` argument");await this.loadMarkets();const r=this.market(e),o={cmd:"orderpending/pendingHistoryList",body:this.extend({pair:r.id,account_type:0,page:1,size:i},s)},n=await this.privatePostOrderpending(o),d=this.safeValue(n.result,"items",[]);return this.parseOrders(d,r,t,i)}async fetchMyTrades(e,t,i,s={}){if(void 0===e)throw new a(this.id+" fetchMyTrades requires a `symbol` argument");await this.loadMarkets();const r=this.market(e),o=i||200,n={cmd:"orderpending/orderHistoryList",body:this.extend({pair:r.id,account_type:0,page:1,size:o,coin_symbol:r.baseId,currency_symbol:r.quoteId},s)},d=await this.privatePostOrderpending(n),c=this.safeValue(d.result,"items",[]);return this.parseTrades(c,r,t,i)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i=this.currency(e),s={cmd:"transfer/transferIn",body:this.extend({coin_symbol:i.id},t)},r=await this.privatePostTransfer(s);return{currency:e,address:this.safeString(r,"result"),tag:void 0,info:r}}async withdraw(e,t,i,s,a={}){this.checkAddress(i),await this.loadMarkets();const o=this.currency(e);if(void 0===this.password&&!("trade_pwd"in a))throw new r(this.id+" withdraw() requires this.password set on the exchange instance or a trade_pwd parameter");if(!("totp_code"in a))throw new r(this.id+" withdraw() requires a totp_code parameter for 2FA authentication");const n={trade_pwd:this.password,coin_symbol:o.id,amount:t,addr:i};return void 0!==s&&(n.address_remark=s),{info:await this.privatePostTransfer({cmd:"transfer/transferOut",body:this.extend(n,a)}),id:void 0}}async fetchFundingFees(e,t={}){await this.loadMarkets();const i={},s={};void 0===e&&(e=Object.keys(this.currencies));for(let r=0;r<e.length;r++){const a=e[r],o=this.currency(a),n={cmd:"transfer/coinConfig",body:this.extend({coin_symbol:o.id},t)},d=await this.privatePostTransfer(n);s[a]=d,i[a]=this.safeFloat(d.result,"withdraw_fee")}return{info:s,withdraw:i,deposit:{}}}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api+"/"+this.version+"/"+e;const n=this.json([s]);if("public"===t)"GET"!==i?a={cmds:n}:Object.keys(s).length&&(o+="?"+this.urlencode(s));else if("v2private"===t){this.checkRequiredCredentials(),o=this.urls.api+"/v2/"+e;const t=this.json(s);a={body:t,apikey:this.apiKey,sign:this.hmac(this.encode(t),this.encode(this.secret),"md5")}}else this.checkRequiredCredentials(),a={cmds:n,apikey:this.apiKey,sign:this.hmac(this.encode(n),this.encode(this.secret),"md5")};return void 0!==a&&(a=this.json(a,{convertArraysToObjects:!0})),{url:o,method:i,body:a,headers:{"Content-Type":"application/json"}}}handleErrors(e,t,i,s,a,o,n,d,c){if(void 0!==n){if("error"in n){if("code"in n.error){const e=this.safeString(n.error,"code"),t=this.id+" "+o,i=this.exceptions;throw e in i?new i[e](t):new r(t)}throw new r(this.id+': "error" in response: '+o)}if(!("result"in n))throw new r(this.id+" "+o)}}async request(e,t="public",i="GET",s={},r,a){const o=await this.fetch2(e,t,i,s,r,a);return"GET"===i?o:o.result[0]}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,ArgumentsRequired:a,AuthenticationError:o,ExchangeNotAvailable:n,InvalidNonce:d}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"bigone",name:"BigONE",countries:["GB"],version:"v2",has:{cancelAllOrders:!0,createMarketOrder:!1,fetchDepositAddress:!0,fetchMyTrades:!1,fetchOHLCV:!1,fetchOpenOrders:!0,fetchTickers:!0,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/42803606-27c2b5ec-89af-11e8-8d15-9c8c245e8b2c.jpg",api:{public:"https://big.one/api/v2",private:"https://big.one/api/v2/viewer"},www:"https://big.one",doc:"https://open.big.one/docs/api.html",fees:"https://bigone.zendesk.com/hc/en-us/articles/115001933374-BigONE-Fee-Policy",referral:"https://b1.run/users/new?code=D3LLBVFT"},api:{public:{get:["ping","markets","markets/{symbol}/depth","markets/{symbol}/trades","markets/{symbol}/ticker","orders","orders/{id}","tickers","trades"]},private:{get:["accounts","orders","orders/{order_id}","trades","withdrawals","deposits"],post:["orders","orders/{order_id}/cancel","orders/cancel_all"]}},fees:{trading:{maker:.001,taker:.001},funding:{withdraw:{BTC:.001,ETH:.005,EOS:.01,ZEC:.003,LTC:.01,QTUM:.01,ETC:.01,GAS:0,BTS:1,GXS:.1,BITCNY:19}}},exceptions:{codes:{401:o,10030:d},detail:{"Internal server error":n}}})}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),i=this.safeValue(t,"data"),s=[];this.options.marketsByUuid={};for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"name"),a=this.safeString(t,"uuid"),o=this.safeValue(t,"baseAsset",{}),n=this.safeValue(t,"quoteAsset",{}),d=this.safeString(o,"symbol"),c=this.safeString(n,"symbol"),h=this.safeCurrencyCode(d),l=this.safeCurrencyCode(c),u=h+"/"+l,f={amount:this.safeInteger(t,"baseScale"),price:this.safeInteger(t,"quoteScale")},p={id:r,symbol:u,base:h,quote:l,baseId:d,quoteId:c,active:!0,precision:f,limits:{amount:{min:Math.pow(10,-f.amount),max:Math.pow(10,f.amount)},price:{min:Math.pow(10,-f.price),max:Math.pow(10,f.price)},cost:{min:void 0,max:void 0}},info:t};this.options.marketsByUuid[a]=p,s.push(p)}return s}parseTicker(e,t){if(void 0===t){const i=this.safeString(e,"market_id");i in this.markets_by_id&&(t=this.markets_by_id[i])}let i=void 0;void 0!==t&&(i=t.symbol);const s=this.milliseconds(),r=this.safeFloat(e,"close"),a=this.safeValue(e,"bid",{}),o=this.safeValue(e,"ask",{});return{symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(a,"price"),bidVolume:this.safeFloat(a,"amount"),ask:this.safeFloat(o,"price"),askVolume:this.safeFloat(o,"amount"),vwap:void 0,open:this.safeFloat(e,"open"),close:r,last:r,previousClose:void 0,change:this.safeFloat(e,"daily_change"),percentage:this.safeFloat(e,"daily_change_perc"),average:void 0,baseVolume:this.safeFloat(e,"volume"),quoteVolume:void 0,info:e}}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={symbol:i.id},r=await this.publicGetMarketsSymbolTicker(this.extend(s,t));return this.parseTicker(r.data,i)}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetTickers(t),s=this.safeValue(i,"data"),r={};for(let e=0;e<s.length;e++){const t=this.parseTicker(s[e]);r[t.symbol]=t}return r}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={symbol:this.marketId(e)},r=await this.publicGetMarketsSymbolDepth(this.extend(s,i));return this.parseOrderBook(r.data,void 0,"bids","asks","price","amount")}parseTrade(e,t){const i=this.safeValue(e,"node",{}),s=this.parse8601(this.safeString(i,"inserted_at")),r=this.safeFloat(i,"price"),a=this.safeFloat(i,"amount");if(void 0===t){const e=this.safeString(i,"market_id");e in this.markets_by_id&&(t=this.markets_by_id[e])}let o=void 0;void 0!==t&&(o=t.symbol);let n=void 0;void 0!==a&&void 0!==r&&(n=this.costToPrecision(o,r*a));let d=void 0;d="ASK"===i.taker_side?"sell":"buy";const c=this.safeString(i,"id");return{timestamp:s,datetime:this.iso8601(s),symbol:o,id:c,order:void 0,type:"limit",side:d,takerOrMaker:void 0,price:r,amount:a,cost:parseFloat(n),fee:void 0,info:e}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id};void 0!==i&&(a.first=i);const o=await this.publicGetMarketsSymbolTrades(this.extend(a,s));return this.parseTrades(o.data.edges,r,t,i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccounts(e),i={info:t},s=this.safeValue(t,"data");for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"asset_id"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeFloat(t,"balance"),o.used=this.safeFloat(t,"locked_balance"),i[a]=o}return this.parseBalance(i)}parseOrder(e,t){const i=this.safeString(e,"id");if(void 0===t){const i=this.safeString(e,"market_id");if(i in this.markets_by_id)t=this.markets_by_id[i];else{const i=this.safeString(e,"market_uuid");i in this.options.marketsByUuid&&(t=this.options.marketsByUuid[i])}}let s=void 0;void 0!==t&&(s=t.symbol);const r=this.parse8601(this.safeString(e,"inserted_at")),a=this.safeFloat(e,"price"),o=this.safeFloat(e,"amount"),n=this.safeFloat(e,"filled_amount"),d=Math.max(0,o-n),c=this.parseOrderStatus(this.safeString(e,"state"));let h=this.safeString(e,"side");h="BID"===h?"buy":"sell";let l=void 0;return void 0!==n&&void 0!==a&&(l=n*a),{id:i,datetime:this.iso8601(r),timestamp:r,status:c,symbol:s,type:void 0,side:h,price:a,cost:l,amount:o,filled:n,remaining:d,trades:void 0,fee:void 0,info:e}}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o=this.market(e);i="buy"===i?"BID":"ASK";const n={market_id:o.id,side:i,amount:this.amountToPrecision(e,s),price:this.priceToPrecision(e,r)},d=await this.privatePostOrders(this.extend(n,a)),c=this.safeValue(d,"data");return this.parseOrder(c,o)}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={order_id:e},r=await this.privatePostOrdersOrderIdCancel(this.extend(s,i)),a=this.safeValue(r,"data");return this.parseOrder(a)}async cancelAllOrders(e,t={}){await this.loadMarkets();const i=await this.privatePostOrdersOrderIdCancel(t);return this.parseOrders(i)}async fetchOrder(e,t,i={}){await this.loadMarkets();const s={order_id:e},r=await this.privateGetOrdersOrderId(this.extend(s,i)),a=this.safeValue(r,"data");return this.parseOrder(a)}async fetchOrders(e,t,i,s={}){if(void 0===e)throw new a(this.id+" fetchOrders requires a symbol argument");await this.loadMarkets();const r=this.market(e),o={market_id:r.id};void 0!==i&&(o.first=i);const n=await this.privateGetOrders(this.extend(o,s)),d=this.safeValue(n,"data",{}),c=this.safeValue(d,"edges",[]),h=[];for(let e=0;e<c.length;e++)h.push(this.parseOrder(c[e].node,r));return this.filterBySymbolSinceLimit(h,e,t,i)}parseOrderStatus(e){return this.safeString({PENDING:"open",FILLED:"closed",CANCELED:"canceled"},e)}async fetchOpenOrders(e,t,i,s={}){return await this.fetchOrders(e,t,i,this.extend({state:"PENDING"},s))}async fetchClosedOrders(e,t,i,s={}){return await this.fetchOrders(e,t,i,this.extend({state:"FILLED"},s))}nonce(){return 1e3*this.microseconds()}sign(e,t="public",i="GET",s={},r,a){const o=this.omit(s,this.extractParams(e));let n=this.urls.api[t]+"/"+this.implodeParams(e,s);if("public"===t)Object.keys(o).length&&(n+="?"+this.urlencode(o));else{this.checkRequiredCredentials();const e=this.nonce(),t={type:"OpenAPI",sub:this.apiKey,nonce:e};r={Authorization:"Bearer "+this.jwt(t,this.encode(this.secret))},"GET"===i?Object.keys(o).length&&(n+="?"+this.urlencode(o)):"POST"===i&&(r["Content-Type"]="application/json",a=this.json(o))}return{url:n,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,o,n,d,c){if(void 0===n)return;const h=this.safeValue(n,"error"),l=this.safeValue(n,"errors"),u=this.safeValue(n,"data");if(void 0!==h||void 0!==l||void 0===u){const e=this.id+" "+this.json(n);let t=void 0;void 0!==h&&(t=this.safeInteger(h,"code"));let i=this.exceptions.codes;throw void 0!==l&&(Array.isArray(l)?t=this.safeString(l[0],"code"):(t=this.safeString(l,"detail"),i=this.exceptions.detail)),t in i?new i[t](e):new r(e)}}}},function(e,t,i){"use strict";const s=i(12);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"binanceje",name:"Binance Jersey",countries:["JE"],certified:!1,urls:{logo:"https://user-images.githubusercontent.com/1294454/54874009-d526eb00-4df3-11e9-928c-ce6a2b914cd1.jpg",api:{web:"https://www.binance.je",wapi:"https://api.binance.je/wapi/v3",public:"https://api.binance.je/api/v1",private:"https://api.binance.je/api/v3",v3:"https://api.binance.je/api/v3",v1:"https://api.binance.je/api/v1"},www:"https://www.binance.je",referral:"https://www.binance.je/?ref=35047921",doc:"https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md",fees:"https://www.binance.je/fees.html"},fees:{trading:{tierBased:!1,percentage:!0,taker:5e-4,maker:5e-4},funding:{tierBased:!1,percentage:!1,withdraw:{BTC:5e-4,ETH:.01},deposit:{}}}})}}},function(e,t,i){"use strict";const s=i(12);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"binanceus",name:"Binance US",countries:["US"],certified:!1,urls:{logo:"https://user-images.githubusercontent.com/1294454/65177307-217b7c80-da5f-11e9-876e-0b748ba0a358.jpg",api:{web:"https://www.binance.us",wapi:"https://api.binance.us/wapi/v3",public:"https://api.binance.us/api/v1",private:"https://api.binance.us/api/v3",v3:"https://api.binance.us/api/v3",v1:"https://api.binance.us/api/v1"},www:"https://www.binance.us",referral:"https://www.binance.us/?ref=35005074",doc:"https://github.com/binance-us/binance-official-api-docs",fees:"https://www.binance.us/en/fee/schedule"},fees:{trading:{tierBased:!1,percentage:!0,taker:0,maker:0}}})}}},function(e,t,i){"use strict";const s=i(1),{ArgumentsRequired:r,ExchangeError:a}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"bit2c",name:"Bit2C",countries:["IL"],rateLimit:3e3,has:{CORS:!1,fetchOpenOrders:!0,fetchMyTrades:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766119-3593220e-5ece-11e7-8b3a-5a041f6bcc3f.jpg",api:"https://bit2c.co.il",www:"https://www.bit2c.co.il",referral:"https://bit2c.co.il/Aff/63bfed10-e359-420c-ab5a-ad368dab0baf",doc:["https://www.bit2c.co.il/home/api","https://github.com/OferE/bit2c"]},api:{public:{get:["Exchanges/{pair}/Ticker","Exchanges/{pair}/orderbook","Exchanges/{pair}/trades","Exchanges/{pair}/lasttrades"]},private:{post:["Merchant/CreateCheckout","Order/AddCoinFundsRequest","Order/AddFund","Order/AddOrder","Order/AddOrderMarketPriceBuy","Order/AddOrderMarketPriceSell","Order/CancelOrder","Order/AddCoinFundsRequest","Order/AddStopOrder","Payment/GetMyId","Payment/Send","Payment/Pay"],get:["Account/Balance","Account/Balance/v2","Order/MyOrders","Order/GetById","Order/AccountHistory","Order/OrderHistory"]}},markets:{"BTC/NIS":{id:"BtcNis",symbol:"BTC/NIS",base:"BTC",quote:"NIS",baseId:"Btc",quoteId:"Nis"},"ETH/NIS":{id:"EthNis",symbol:"ETH/NIS",base:"ETH",quote:"NIS",baseId:"Eth",quoteId:"Nis"},"BCH/NIS":{id:"BchabcNis",symbol:"BCH/NIS",base:"BCH",quote:"NIS",baseId:"Bchabc",quoteId:"Nis"},"LTC/NIS":{id:"LtcNis",symbol:"LTC/NIS",base:"LTC",quote:"NIS",baseId:"Ltc",quoteId:"Nis"},"ETC/NIS":{id:"EtcNis",symbol:"ETC/NIS",base:"ETC",quote:"NIS",baseId:"Etc",quoteId:"Nis"},"BTG/NIS":{id:"BtgNis",symbol:"BTG/NIS",base:"BTG",quote:"NIS",baseId:"Btg",quoteId:"Nis"},"BSV/NIS":{id:"BchsvNis",symbol:"BSV/NIS",base:"BSV",quote:"NIS",baseId:"Bchsv",quoteId:"Nis"},"GRIN/NIS":{id:"GrinNis",symbol:"GRIN/NIS",base:"GRIN",quote:"NIS",baseId:"Grin",quoteId:"Nis"}},fees:{trading:{maker:.005,taker:.005}},options:{fetchTradesMethod:"public_get_exchanges_pair_lasttrades"},exceptions:{}})}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccountBalanceV2(e),i={info:t},s=Object.keys(this.currencies);for(let e=0;e<s.length;e++){const r=s[e],a=this.account(),o=this.currencyId(r).toUpperCase();o in t&&(a.free=this.safeFloat(t,"AVAILABLE_"+o),a.total=this.safeFloat(t,o)),i[r]=a}return this.parseBalance(i)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={pair:this.marketId(e)},r=await this.publicGetExchangesPairOrderbook(this.extend(s,i));return this.parseOrderBook(r)}async fetchTicker(e,t={}){await this.loadMarkets();const i={pair:this.marketId(e)},s=await this.publicGetExchangesPairTicker(this.extend(i,t)),r=this.milliseconds(),a=this.safeFloat(s,"av"),o=this.safeFloat(s,"a");let n=void 0;void 0!==o&&void 0!==a&&(n=o*a);const d=this.safeFloat(s,"ll");return{symbol:e,timestamp:r,datetime:this.iso8601(r),high:void 0,low:void 0,bid:this.safeFloat(s,"h"),bidVolume:void 0,ask:this.safeFloat(s,"l"),askVolume:void 0,vwap:void 0,open:void 0,close:d,last:d,previousClose:void 0,change:void 0,percentage:void 0,average:a,baseVolume:o,quoteVolume:n,info:s}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),o=this.options.fetchTradesMethod,n={pair:r.id},d=await this[o](this.extend(n,s));if("string"==typeof d)throw new a(d);return this.parseTrades(d,r,t,i)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();let o="privatePostOrderAddOrder";const n={Amount:s,Pair:this.marketId(e)};"market"===t?o+="MarketPrice"+this.capitalize(i):(n.Price=r,n.Total=s*r,n.IsBid="buy"===i);const d=await this[o](this.extend(n,a));return{info:d,id:d.NewOrder.id}}async cancelOrder(e,t,i={}){const s={id:e};return await this.privatePostOrderCancelOrder(this.extend(s,i))}async fetchOpenOrders(e,t,i,s={}){if(void 0===e)throw new r(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o={pair:a.id},n=await this.privateGetOrderMyOrders(this.extend(o,s)),d=this.safeValue(n,a.id,{}),c=this.safeValue(d,"ask",[]),h=this.safeValue(d,"bid",[]);return this.parseOrders(this.arrayConcat(c,h),a,t,i)}parseOrder(e,t){const i=this.safeInteger(e,"created"),s=this.safeFloat(e,"price"),r=this.safeFloat(e,"amount");let a=void 0;void 0!==s&&void 0!==r&&(a=s*r);let o=void 0;void 0!==t&&(o=t.symbol);let n=this.safeValue(e,"type");0===n?n="buy":1===n&&(n="sell");const d=this.safeString(e,"id"),c=this.safeString(e,"status");return{id:d,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,status:c,symbol:o,type:void 0,side:n,price:s,amount:r,filled:void 0,remaining:void 0,cost:a,trades:void 0,fee:void 0,info:e}}async fetchMyTrades(e,t,i,s={}){await this.loadMarkets();let r=void 0;const a={};void 0!==i&&(a.take=i),a.take=i,void 0!==t&&(a.toTime=this.ymd(this.milliseconds(),"."),a.fromTime=this.ymd(t,".")),void 0!==e&&(r=this.market(e),a.pair=r.id);const o=await this.privateGetOrderOrderHistory(this.extend(a,s));return this.parseTrades(o,r,t,i)}parseTrade(e,t){let i=void 0,s=void 0,r=void 0,a=void 0,o=void 0,n=void 0,d=void 0;const c=this.safeString(e,"reference");if(void 0!==c){i=this.safeTimestamp(e,"ticks"),r=this.safeFloat(e,"price"),a=this.safeFloat(e,"firstAmount");const h=c.split("|");if(void 0===t){const i=this.safeString(e,"pair");i in this.markets_by_id[i]?t=this.markets_by_id[i]:h[0]in this.markets_by_id&&(t=this.markets_by_id[h[0]])}o=h[1],s=h[2],0===(d=this.safeInteger(e,"action"))?d="buy":1===d&&(d="sell"),n=this.safeFloat(e,"feeAmount")}else i=this.safeTimestamp(e,"date"),s=this.safeString(e,"tid"),r=this.safeFloat(e,"price"),a=this.safeFloat(e,"amount"),void 0!==(d=this.safeValue(e,"isBid"))&&(d=d?"buy":"sell");let h=void 0;return void 0!==t&&(h=t.symbol),{info:e,id:s,timestamp:i,datetime:this.iso8601(i),symbol:h,order:o,type:void 0,side:d,takerOrMaker:void 0,price:r,amount:a,cost:r*a,fee:{cost:n,currency:"NIS",rate:void 0}}}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api+"/"+this.implodeParams(e,s);if("public"===t)o+=".json";else{this.checkRequiredCredentials();const e=this.nonce(),t=this.extend({nonce:e},s),n=this.urlencode(t);"GET"===i?Object.keys(t).length&&(o+="?"+n):a=n;const d=this.hmac(this.encode(n),this.encode(this.secret),"sha512","base64");r={"Content-Type":"application/x-www-form-urlencoded",key:this.apiKey,sign:this.decode(d)}}return{url:o,method:i,body:a,headers:r}}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,AuthenticationError:a,InvalidNonce:o,InsufficientFunds:n,InvalidOrder:d,OrderNotFound:c,PermissionDenied:h}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"bitbank",name:"bitbank",countries:["JP"],version:"v1",has:{fetchOHLCV:!0,fetchOpenOrders:!0,fetchMyTrades:!0,fetchDepositAddress:!0,withdraw:!0},timeframes:{"1m":"1min","5m":"5min","15m":"15min","30m":"30min","1h":"1hour","4h":"4hour","8h":"8hour","12h":"12hour","1d":"1day","1w":"1week"},urls:{logo:"https://user-images.githubusercontent.com/1294454/37808081-b87f2d9c-2e59-11e8-894d-c1900b7584fe.jpg",api:{public:"https://public.bitbank.cc",private:"https://api.bitbank.cc"},www:"https://bitbank.cc/",doc:"https://docs.bitbank.cc/",fees:"https://bitbank.cc/docs/fees/"},api:{public:{get:["{pair}/ticker","{pair}/depth","{pair}/transactions","{pair}/transactions/{yyyymmdd}","{pair}/candlestick/{candletype}/{yyyymmdd}"]},private:{get:["user/assets","user/spot/order","user/spot/active_orders","user/spot/trade_history","user/withdrawal_account"],post:["user/spot/order","user/spot/cancel_order","user/spot/cancel_orders","user/spot/orders_info","user/request_withdrawal"]}},markets:{"BCH/BTC":{id:"bcc_btc",symbol:"BCH/BTC",base:"BCH",quote:"BTC",baseId:"bcc",quoteId:"btc"},"BCH/JPY":{id:"bcc_jpy",symbol:"BCH/JPY",base:"BCH",quote:"JPY",baseId:"bcc",quoteId:"jpy"},"MONA/BTC":{id:"mona_btc",symbol:"MONA/BTC",base:"MONA",quote:"BTC",baseId:"mona",quoteId:"btc"},"MONA/JPY":{id:"mona_jpy",symbol:"MONA/JPY",base:"MONA",quote:"JPY",baseId:"mona",quoteId:"jpy"},"ETH/BTC":{id:"eth_btc",symbol:"ETH/BTC",base:"ETH",quote:"BTC",baseId:"eth",quoteId:"btc"},"LTC/BTC":{id:"ltc_btc",symbol:"LTC/BTC",base:"LTC",quote:"BTC",baseId:"ltc",quoteId:"btc"},"XRP/JPY":{id:"xrp_jpy",symbol:"XRP/JPY",base:"XRP",quote:"JPY",baseId:"xrp",quoteId:"jpy"},"BTC/JPY":{id:"btc_jpy",symbol:"BTC/JPY",base:"BTC",quote:"JPY",baseId:"btc",quoteId:"jpy"}},fees:{trading:{maker:-2e-4,taker:.0012},funding:{withdraw:{BTC:.001,LTC:.001,XRP:.15,ETH:5e-4,MONA:.001,BCC:.001}}},precision:{price:8,amount:8},exceptions:{20001:a,20002:a,20003:a,20005:a,20004:o,40020:d,40021:d,40025:r,40013:c,40014:c,50008:h,50009:c,50010:c,60001:n,60005:d}})}parseTicker(e,t){let i=void 0;void 0!==t&&(i=t.symbol);const s=this.safeInteger(e,"timestamp"),r=this.safeFloat(e,"last");return{symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"buy"),bidVolume:void 0,ask:this.safeFloat(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeFloat(e,"vol"),quoteVolume:void 0,info:e}}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={pair:i.id},r=await this.publicGetPairTicker(this.extend(s,t));return this.parseTicker(r.data,i)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={pair:this.marketId(e)},r=await this.publicGetPairDepth(this.extend(s,i)),a=this.safeValue(r,"data",{}),o=this.safeInteger(a,"timestamp");return this.parseOrderBook(a,o)}parseTrade(e,t){const i=this.safeInteger(e,"executed_at");let s=void 0,r=void 0;void 0!==t&&(s=t.symbol,r=t.quote);const a=this.safeFloat(e,"price"),o=this.safeFloat(e,"amount");let n=void 0;void 0!==a&&void 0!==o&&(n=parseFloat(this.costToPrecision(s,a*o)));const d=this.safeString2(e,"transaction_id","trade_id"),c=this.safeString(e,"maker_taker");let h=void 0;void 0!==this.safeFloat(e,"fee_amount_quote")&&(h={currency:t.quote,cost:r});const l=this.safeString(e,"order_id"),u=this.safeString(e,"type"),f=this.safeString(e,"side");return{timestamp:i,datetime:this.iso8601(i),symbol:s,id:d,order:l,type:u,side:f,takerOrMaker:c,price:a,amount:o,cost:n,fee:h,info:e}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={pair:r.id},o=await this.publicGetPairTransactions(this.extend(a,s));return this.parseTrades(o.data.transactions,r,t,i)}parseOHLCV(e,t,i="5m",s,r){return[e[5],parseFloat(e[0]),parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3]),parseFloat(e[4])]}async fetchOHLCV(e,t="5m",i,s,r={}){await this.loadMarkets();const a=this.market(e);let o=this.milliseconds();o=(o=this.ymd(o)).split("-");const n={pair:a.id,candletype:this.timeframes[t],yyyymmdd:o.join("")},d=await this.publicGetPairCandlestickCandletypeYyyymmdd(this.extend(n,r)),c=this.safeValue(d.data.candlestick[0],"ohlcv");return this.parseOHLCVs(c,a,t,i,s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetUserAssets(e),i={info:t},s=t.data.assets;for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"asset"),a=this.safeCurrencyCode(r),o={free:this.safeFloat(t,"free_amount"),used:this.safeFloat(t,"locked_amount"),total:this.safeFloat(t,"onhand_amount")};i[a]=o}return this.parseBalance(i)}parseOrderStatus(e){return this.safeString({UNFILLED:"open",PARTIALLY_FILLED:"open",FULLY_FILLED:"closed",CANCELED_UNFILLED:"canceled",CANCELED_PARTIALLY_FILLED:"canceled"},e,e)}parseOrder(e,t){const i=this.safeString(e,"order_id"),s=this.safeString(e,"pair");let r=void 0;s&&!t&&s in this.marketsById&&(t=this.marketsById[s]),void 0!==t&&(r=t.symbol);const a=this.safeInteger(e,"ordered_at"),o=this.safeFloat(e,"price"),n=this.safeFloat(e,"start_amount"),d=this.safeFloat(e,"executed_amount"),c=this.safeFloat(e,"remaining_amount"),h=this.safeFloat(e,"average_price");let l=void 0;void 0!==d&&void 0!==h&&(l=d*h);const u=this.parseOrderStatus(this.safeString(e,"status")),f=this.safeStringLower(e,"type"),p=this.safeStringLower(e,"side");return{id:i,datetime:this.iso8601(a),timestamp:a,lastTradeTimestamp:void 0,status:u,symbol:r,type:f,side:p,price:o,cost:l,average:h,amount:n,filled:d,remaining:c,trades:void 0,fee:void 0,info:e}}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o=this.market(e);if(void 0===r)throw new d(this.id+" createOrder requires a price argument for both market and limit orders");const n={pair:o.id,amount:this.amountToPrecision(e,s),price:this.priceToPrecision(e,r),side:i,type:t},c=await this.privatePostUserSpotOrder(this.extend(n,a)),h=this.parseOrder(c.data,o),l=h.id;return this.orders[l]=h,h}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={order_id:e,pair:this.market(t).id};return(await this.privatePostUserSpotCancelOrder(this.extend(s,i))).data}async fetchOrder(e,t,i={}){await this.loadMarkets();const s={order_id:e,pair:this.market(t).id},r=await this.privateGetUserSpotOrder(this.extend(s,i));return this.parseOrder(r.data)}async fetchOpenOrders(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={pair:r.id};void 0!==i&&(a.count=i),void 0!==t&&(a.since=parseInt(t/1e3));const o=await this.privateGetUserSpotActiveOrders(this.extend(a,s));return this.parseOrders(o.data.orders,r,t,i)}async fetchMyTrades(e,t,i,s={}){await this.loadMarkets();let r=void 0;void 0!==e&&(r=this.market(e));const a={};void 0!==r&&(a.pair=r.id),void 0!==i&&(a.count=i),void 0!==t&&(a.since=parseInt(t/1e3));const o=await this.privateGetUserSpotTradeHistory(this.extend(a,s));return this.parseTrades(o.data.trades,r,t,i)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i=this.currency(e),s={asset:i.id},r=await this.privateGetUserWithdrawalAccount(this.extend(s,t)),a=r.data.accounts;return{currency:i,address:this.safeString(a[0],"address"),tag:void 0,info:r}}async withdraw(e,t,i,s,a={}){if(!("uuid"in a))throw new r(this.id+" uuid is required for withdrawal");await this.loadMarkets();const o={asset:this.currency(e).id,amount:t},n=await this.privatePostUserRequestWithdrawal(this.extend(o,a));return{info:n,id:this.safeString(n.data,"txid")}}nonce(){return this.milliseconds()}sign(e,t="public",i="GET",s={},r,a){let o=this.omit(s,this.extractParams(e)),n=this.urls.api[t]+"/";if("public"===t)n+=this.implodeParams(e,s),Object.keys(o).length&&(n+="?"+this.urlencode(o));else{this.checkRequiredCredentials();const t=this.nonce().toString();let d=t;n+=this.version+"/"+this.implodeParams(e,s),"POST"===i?d+=a=this.json(o):(d+="/"+this.version+"/"+e,Object.keys(o).length&&(n+="?"+(o=this.urlencode(o)),d+="?"+o)),r={"Content-Type":"application/json","ACCESS-KEY":this.apiKey,"ACCESS-NONCE":t,"ACCESS-SIGNATURE":this.hmac(this.encode(d),this.encode(this.secret))}}return{url:n,method:i,body:a,headers:r}}async request(e,t="public",i="GET",s={},a,o){const n=await this.fetch2(e,t,i,s,a,o),d=this.safeInteger(n,"success"),c=this.safeValue(n,"data");if(!d||!c){const e={10000:"URL does not exist",10001:"A system error occurred. Please contact support",10002:"Invalid JSON format. Please check the contents of transmission",10003:"A system error occurred. Please contact support",10005:"A timeout error occurred. Please wait for a while and try again",20001:"API authentication failed",20002:"Illegal API key",20003:"API key does not exist",20004:"API Nonce does not exist",20005:"API signature does not exist",20011:"Two-step verification failed",20014:"SMS authentication failed",30001:"Please specify the order quantity",30006:"Please specify the order ID",30007:"Please specify the order ID array",30009:"Please specify the stock",30012:"Please specify the order price",30013:"Trade Please specify either",30015:"Please specify the order type",30016:"Please specify asset name",30019:"Please specify uuid",30039:"Please specify the amount to be withdrawn",40001:"The order quantity is invalid",40006:"Count value is invalid",40007:"End time is invalid",40008:"end_id Value is invalid",40009:"The from_id value is invalid",40013:"The order ID is invalid",40014:"The order ID array is invalid",40015:"Too many specified orders",40017:"Incorrect issue name",40020:"The order price is invalid",40021:"The trading classification is invalid",40022:"Start date is invalid",40024:"The order type is invalid",40025:"Incorrect asset name",40028:"uuid is invalid",40048:"The amount of withdrawal is illegal",50003:"Currently, this account is in a state where you can not perform the operation you specified. Please contact support",50004:"Currently, this account is temporarily registered. Please try again after registering your account",50005:"Currently, this account is locked. Please contact support",50006:"Currently, this account is locked. Please contact support",50008:"User identification has not been completed",50009:"Your order does not exist",50010:"Can not cancel specified order",50011:"API not found",60001:"The number of possessions is insufficient",60002:"It exceeds the quantity upper limit of the tender buying order",60003:"The specified quantity exceeds the limit",60004:"The specified quantity is below the threshold",60005:"The specified price is above the limit",60006:"The specified price is below the lower limit",70001:"A system error occurred. Please contact support",70002:"A system error occurred. Please contact support",70003:"A system error occurred. Please contact support",70004:"We are unable to accept orders as the transaction is currently suspended",70005:"Order can not be accepted because purchase order is currently suspended",70006:"We can not accept orders because we are currently unsubscribed ",70009:"We are currently temporarily restricting orders to be carried out. Please use the limit order.",70010:"We are temporarily raising the minimum order quantity as the system load is now rising."},t=this.exceptions,i=this.safeString(c,"code"),s=this.safeString(e,i,"Error"),a=this.safeValue(t,i);throw void 0!==a?new a(s):new r(this.id+" "+this.json(n))}return n}}},function(e,t,i){"use strict";const s=i(1),{InvalidNonce:r,InsufficientFunds:a,AuthenticationError:o,InvalidOrder:n,ExchangeError:d,OrderNotFound:c}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"bitbay",name:"BitBay",countries:["MT","EU"],rateLimit:1e3,has:{CORS:!0,withdraw:!0,fetchMyTrades:!0,fetchOpenOrders:!0},urls:{referral:"https://auth.bitbay.net/ref/jHlbB4mIkdS1",logo:"https://user-images.githubusercontent.com/1294454/27766132-978a7bd8-5ece-11e7-9540-bc96d1e9bbb8.jpg",www:"https://bitbay.net",api:{public:"https://bitbay.net/API/Public",private:"https://bitbay.net/API/Trading/tradingApi.php",v1_01Public:"https://api.bitbay.net/rest",v1_01Private:"https://api.bitbay.net/rest"},doc:["https://bitbay.net/public-api","https://bitbay.net/en/private-api","https://bitbay.net/account/tab-api","https://github.com/BitBayNet/API","https://docs.bitbay.net/v1.0.1-en/reference"],fees:"https://bitbay.net/en/fees"},api:{public:{get:["{id}/all","{id}/market","{id}/orderbook","{id}/ticker","{id}/trades"]},private:{post:["info","trade","cancel","orderbook","orders","transfer","withdraw","history","transactions"]},v1_01Public:{get:["trading/ticker","trading/ticker/{symbol}","trading/stats","trading/orderbook/{symbol}","trading/transactions/{symbol}","trading/candle/history/{symbol}/{resolution}"]},v1_01Private:{get:["payments/withdrawal/{detailId}","payments/deposit/{detailId}","trading/offer","trading/config/{symbol}","trading/history/transactions","balances/BITBAY/history","balances/BITBAY/balance","fiat_cantor/rate/{baseId}/{quoteId}","fiat_cantor/history"],post:["trading/offer/{symbol}","trading/config/{symbol}","balances/BITBAY/balance","balances/BITBAY/balance/transfer/{source}/{destination}","fiat_cantor/exchange"],delete:["trading/offer/{symbol}/{id}/{side}/{price}"],put:["balances/BITBAY/balance/{id}"]}},fees:{trading:{maker:.003,taker:.0043},funding:{withdraw:{BTC:9e-4,LTC:.005,ETH:.00126,LSK:.2,BCH:6e-4,GAME:.005,DASH:.001,BTG:8e-4,PLN:4,EUR:1.5}}},exceptions:{400:d,401:n,402:n,403:n,404:n,405:n,406:a,408:n,501:o,502:o,503:r,504:d,505:o,506:o,509:d,510:d,FUNDS_NOT_SUFFICIENT:a,OFFER_FUNDS_NOT_EXCEEDING_MINIMUMS:n,OFFER_NOT_FOUND:c}})}async fetchMarkets(e={}){const t=await this.v1_01PublicGetTradingTicker(e),i=[],s=this.safeValue(t,"items"),r=Object.keys(s);for(let e=0;e<r.length;e++){const t=s[r[e]],a=this.safeValue(t,"market",{}),o=this.safeValue(a,"first",{}),n=this.safeValue(a,"second",{}),d=this.safeString(o,"currency"),c=this.safeString(n,"currency"),h=d+c,l=this.safeCurrencyCode(d),u=this.safeCurrencyCode(c),f=l+"/"+u,p={amount:this.safeInteger(o,"scale"),price:this.safeInteger(n,"scale")};i.push({id:h,symbol:f,base:l,quote:u,baseId:d,quoteId:c,precision:p,active:void 0,fee:void 0,limits:{amount:{min:this.safeFloat(o,"minOffer"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeFloat(n,"minOffer"),max:void 0}},info:t})}return i}async fetchOpenOrders(e,t,i,s={}){await this.loadMarkets();const r=await this.v1_01PrivateGetTradingOffer(this.extend({},s)),a=this.safeValue(r,"items",[]);return this.parseOrders(a,void 0,t,i,{status:"open"})}parseOrder(e,t){const i=this.safeString(e,"market");let s=void 0;if(void 0!==i)if(i in this.markets_by_id)t=this.markets_by_id[i];else{const[e,t]=i.split("-");s=this.safeCurrencyCode(e)+"/"+this.safeCurrencyCode(t)}void 0===s&&void 0!==t&&(s=t.symbol);const r=this.safeInteger(e,"time"),a=this.safeFloat(e,"startAmount"),o=this.safeFloat(e,"currentAmount");let n=void 0;return void 0!==a&&void 0!==o&&(n=Math.max(0,a-o)),{id:this.safeString(e,"id"),info:e,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,status:void 0,symbol:s,type:this.safeString(e,"mode"),side:this.safeStringLower(e,"offerType"),price:this.safeFloat(e,"rate"),amount:a,cost:void 0,filled:n,remaining:o,average:void 0,fee:void 0}}async fetchMyTrades(e,t,i,s={}){await this.loadMarkets();const r={};if(e){const t=[this.marketId(e)];r.markets=t}const a={query:this.json(this.extend(r,s))},o=await this.v1_01PrivateGetTradingHistoryTransactions(a),n=this.safeValue(o,"items"),d=this.parseTrades(n,void 0,t,i);return void 0===e?d:this.filterBySymbol(d,e)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.v1_01PrivateGetBalancesBITBAYBalance(e),i=this.safeValue(t,"balances");if(void 0===i)throw new d(this.id+" empty balance response "+this.json(t));const s={info:t};for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.used=this.safeFloat(t,"lockedFunds"),o.free=this.safeFloat(t,"availableFunds"),s[a]=o}return this.parseBalance(s)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={id:this.marketId(e)},r=await this.publicGetIdOrderbook(this.extend(s,i));return this.parseOrderBook(r)}async fetchTicker(e,t={}){await this.loadMarkets();const i={id:this.marketId(e)},s=await this.publicGetIdTicker(this.extend(i,t)),r=this.milliseconds(),a=this.safeFloat(s,"volume"),o=this.safeFloat(s,"vwap");let n=void 0;void 0!==a&&void 0!==o&&(n=a*o);const d=this.safeFloat(s,"last");return{symbol:e,timestamp:r,datetime:this.iso8601(r),high:this.safeFloat(s,"max"),low:this.safeFloat(s,"min"),bid:this.safeFloat(s,"bid"),bidVolume:void 0,ask:this.safeFloat(s,"ask"),askVolume:void 0,vwap:o,open:void 0,close:d,last:d,previousClose:void 0,change:void 0,percentage:void 0,average:this.safeFloat(s,"average"),baseVolume:a,quoteVolume:n,info:s}}async fetchLedger(e,t,i,s={}){const r=[];if(void 0!==e){const t=this.currency(e);r.push(t.id)}let a={balanceCurrencies:r};void 0!==t&&(a.fromTime=t),void 0!==i&&(a.limit=i),a=this.extend(a,s);const o=(await this.v1_01PrivateGetBalancesBITBAYHistory({query:this.json(a)})).items;return this.parseLedger(o,void 0,t,i)}parseLedgerEntry(e,t){const i=this.safeInteger(e,"time"),s=this.safeValue(e,"balance",{}),r=this.safeString(s,"currency"),a=this.safeCurrencyCode(r),o=this.safeValue(e,"change",{});let n=this.safeFloat(o,"total"),d="in";n<0&&(d="out",n=-n);const c=this.safeString(e,"historyId"),h=this.safeString(e,"detailId"),l=this.parseLedgerEntryType(this.safeString(e,"type")),u=this.safeValue(e,"fundsBefore",{}),f=this.safeFloat(u,"total"),p=this.safeValue(e,"fundsAfter",{});return{info:e,id:c,direction:d,account:void 0,referenceId:h,referenceAccount:void 0,type:l,currency:a,amount:n,before:f,after:this.safeFloat(p,"total"),status:"ok",timestamp:i,datetime:this.iso8601(i),fee:void 0}}parseLedgerEntryType(e){return this.safeString({ADD_FUNDS:"transaction",BITCOIN_GOLD_FORK:"transaction",CREATE_BALANCE:"transaction",FUNDS_MIGRATION:"transaction",WITHDRAWAL_LOCK_FUNDS:"transaction",WITHDRAWAL_SUBTRACT_FUNDS:"transaction",WITHDRAWAL_UNLOCK_FUNDS:"transaction",TRANSACTION_COMMISSION_OUTCOME:"fee",TRANSACTION_COMMISSION_RETURN:"fee",TRANSACTION_OFFER_ABORTED_RETURN:"trade",TRANSACTION_OFFER_COMPLETED_RETURN:"trade",TRANSACTION_POST_INCOME:"trade",TRANSACTION_POST_OUTCOME:"trade",TRANSACTION_PRE_LOCKING:"trade"},e,e)}parseTrade(e,t){const i=this.safeInteger2(e,"time","t"),s="Buy"===this.safeString(e,"userAction")?"buy":"sell",r=this.safeValue(e,"wasTaker");let a=void 0;void 0!==r&&(a=r?"taker":"maker");const o=this.safeFloat2(e,"rate","r"),n=this.safeFloat2(e,"amount","a");let d=void 0;void 0!==n&&void 0!==o&&(d=o*n);const c=this.safeFloat(e,"commissionValue"),h=this.safeString(e,"market");let l=void 0,u=void 0,f=void 0;if(void 0!==h)if(h in this.markets_by_id)f=(t=this.markets_by_id[h]).symbol,l=t.base,u=t.quote;else{const[e,t]=h.split("-");f=(l=this.safeCurrencyCode(e))+"/"+(u=this.safeCurrencyCode(t))}void 0!==t&&(void 0===f&&(f=t.symbol),void 0===l&&(l=t.base));let p=void 0;if(void 0!==c){p={currency:"buy"===s?l:u,cost:c}}const m=this.safeString(e,"offerId");let y=void 0;return void 0!==m&&(y=m?"limit":"market"),{id:this.safeString(e,"id"),order:m,timestamp:i,datetime:this.iso8601(i),symbol:f,type:y,side:s,price:o,amount:n,cost:d,takerOrMaker:a,fee:p,info:e}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.baseId+"-"+r.quoteId};void 0!==t&&(a.fromTime=t-1),void 0!==i&&(a.limit=i);const o=await this.v1_01PublicGetTradingTransactionsSymbol(this.extend(a,s)),n=this.safeValue(o,"items");return this.parseTrades(n,e,t,i)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o=this.market(e),n={symbol:o.baseId+"-"+o.quoteId,offerType:i,amount:s,mode:t};"limit"===t&&(n.rate=r);const d=await this.v1_01PrivatePostTradingOfferSymbol(this.extend(n,a));return{id:this.safeString(d,"offerId"),info:d}}async cancelOrder(e,t,i={}){const s=this.safeString(i,"side");if(void 0===s)throw new d(this.id+' cancelOrder() requires a `side` parameter ("buy" or "sell")');const r=this.safeValue(i,"price");if(void 0===r)throw new d(this.id+" cancelOrder() requires a `price` parameter (float or string)");await this.loadMarkets();const a=this.market(t),o={symbol:a.baseId+"-"+a.quoteId,id:e,side:s,price:r};return this.v1_01PrivateDeleteTradingOfferSymbolIdSidePrice(this.extend(o,i))}isFiat(e){return this.safeValue({USD:!0,EUR:!0,PLN:!0},e,!1)}async withdraw(e,t,i,s,r={}){this.checkAddress(i),await this.loadMarkets();let a=void 0;const o={currency:this.currency(e).id,quantity:t};return this.isFiat(e)?a="privatePostWithdraw":(a="privatePostTransfer",void 0!==s&&(i+="?dt="+s.toString()),o.address=i),{info:await this[a](this.extend(o,r)),id:void 0}}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api[t];if("public"===t){const t=this.omit(s,this.extractParams(e));o+="/"+this.implodeParams(e,s)+".json",Object.keys(t).length&&(o+="?"+this.urlencode(t))}else if("v1_01Public"===t){const t=this.omit(s,this.extractParams(e));o+="/"+this.implodeParams(e,s),Object.keys(t).length&&(o+="?"+this.urlencode(t))}else if("v1_01Private"===t){this.checkRequiredCredentials();const t=this.omit(s,this.extractParams(e));o+="/"+this.implodeParams(e,s);const n=this.milliseconds().toString();let d=void 0;"POST"!==i?(Object.keys(t).length&&(o+="?"+this.urlencode(t)),d=this.apiKey+n):void 0===a&&(a=this.json(t),d=this.apiKey+n+a),r={"Request-Timestamp":n,"Operation-Id":this.uuid(),"API-Key":this.apiKey,"API-Hash":this.hmac(this.encode(d),this.encode(this.secret),"sha512"),"Content-Type":"application/json"}}else this.checkRequiredCredentials(),a=this.urlencode(this.extend({method:e,moment:this.nonce()},s)),r={"Content-Type":"application/x-www-form-urlencoded","API-Key":this.apiKey,"API-Hash":this.hmac(this.encode(a),this.encode(this.secret),"sha512")};return{url:o,method:i,body:a,headers:r}}handleErrors(e,t,i,s,r,a,o,n,c){if(void 0!==o){if("code"in o){const e=this.safeString(o,"code"),t=this.id+" "+a,i=this.exceptions;throw e in this.exceptions?new i[e](t):new d(t)}if("status"in o){if("Fail"===this.safeString(o,"status")){const e=this.safeValue(o,"errors"),t=this.id+" "+this.json(o);for(let i=0;i<e.length;i++){const s=e[i];if(s in this.exceptions)throw new this.exceptions[s](t)}throw new d(t)}}}}}},function(e,t,i){"use strict";const s=i(32),{ExchangeError:r,NotSupported:a,InsufficientFunds:o}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"bitfinex2",name:"Bitfinex",countries:["VG"],version:"v2",certified:!1,has:{CORS:!0,createLimitOrder:!1,createMarketOrder:!1,createOrder:!1,deposit:!1,editOrder:!1,fetchDepositAddress:!1,fetchClosedOrders:!1,fetchFundingFees:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!1,fetchOrder:!0,fetchTickers:!0,fetchTradingFee:!1,fetchTradingFees:!1,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","3h":"3h","6h":"6h","12h":"12h","1d":"1D","1w":"7D","2w":"14D","1M":"1M"},rateLimit:1500,urls:{logo:"https://user-images.githubusercontent.com/1294454/27766244-e328a50c-5ed2-11e7-947b-041416579bb3.jpg",api:{v1:"https://api.bitfinex.com",public:"https://api-pub.bitfinex.com",private:"https://api.bitfinex.com"},www:"https://www.bitfinex.com",doc:["https://docs.bitfinex.com/v2/docs/","https://github.com/bitfinexcom/bitfinex-api-node"],fees:"https://www.bitfinex.com/fees"},api:{v1:{get:["symbols","symbols_details"]},public:{get:["conf/pub:map:currency:label","platform/status","tickers","ticker/{symbol}","trades/{symbol}/hist","book/{symbol}/{precision}","book/{symbol}/P0","book/{symbol}/P1","book/{symbol}/P2","book/{symbol}/P3","book/{symbol}/R0","stats1/{key}:{size}:{symbol}:{side}/{section}","stats1/{key}:{size}:{symbol}/{section}","stats1/{key}:{size}:{symbol}:long/last","stats1/{key}:{size}:{symbol}:long/hist","stats1/{key}:{size}:{symbol}:short/last","stats1/{key}:{size}:{symbol}:short/hist","candles/trade:{timeframe}:{symbol}/{section}","candles/trade:{timeframe}:{symbol}/last","candles/trade:{timeframe}:{symbol}/hist"],post:["calc/trade/avg","calc/fx"]},private:{post:["auth/r/wallets","auth/r/orders/{symbol}","auth/r/orders/{symbol}/new","auth/r/orders/{symbol}/hist","auth/r/order/{symbol}:{id}/trades","auth/r/trades/hist","auth/r/trades/{symbol}/hist","auth/r/positions","auth/r/positions/hist","auth/r/positions/audit","auth/r/funding/offers/{symbol}","auth/r/funding/offers/{symbol}/hist","auth/r/funding/loans/{symbol}","auth/r/funding/loans/{symbol}/hist","auth/r/funding/credits/{symbol}","auth/r/funding/credits/{symbol}/hist","auth/r/funding/trades/{symbol}/hist","auth/r/info/margin/{key}","auth/r/info/funding/{key}","auth/r/ledgers/hist","auth/r/movements/hist","auth/r/movements/{currency}/hist","auth/r/stats/perf:{timeframe}/hist","auth/r/alerts","auth/w/alert/set","auth/w/alert/{type}:{symbol}:{price}/del","auth/calc/order/avail","auth/r/ledgers/{symbol}/hist","auth/r/settings","auth/w/settings/set","auth/w/settings/del","auth/r/info/user"]}},fees:{trading:{maker:.001,taker:.002},funding:{withdraw:{BTC:4e-4,BCH:1e-4,ETH:.00135,EOS:0,LTC:.001,OMG:.15097,IOT:0,NEO:0,ETC:.01,XRP:.02,ETP:.01,ZEC:.001,BTG:0,DASH:.01,XMR:1e-4,QTM:.01,EDO:.23687,DAT:9.8858,AVT:1.1251,SAN:.35977,USDT:5,SPK:16.971,BAT:1.1209,GNT:2.8789,SNT:9.0848,QASH:1.726,YYW:7.9464}}},options:{precision:"R0",orderTypes:{MARKET:void 0,"EXCHANGE MARKET":"market",LIMIT:void 0,"EXCHANGE LIMIT":"limit",STOP:void 0,"EXCHANGE STOP":"stopOrLoss","TRAILING STOP":void 0,"EXCHANGE TRAILING STOP":void 0,FOK:void 0,"EXCHANGE FOK":"limit FOK","STOP LIMIT":void 0,"EXCHANGE STOP LIMIT":"limit stop",IOC:void 0,"EXCHANGE IOC":"limit ioc"},fiat:{USD:"USD",EUR:"EUR",JPY:"JPY",GBP:"GBP"}}})}isFiat(e){return e in this.options.fiat}getCurrencyId(e){return"f"+e}async fetchMarkets(e={}){const t=await this.v1GetSymbolsDetails(e),i=[];for(let e=0;e<t.length;e++){const s=t[e];let r=this.safeString(s,"pair"),a=void 0,o=void 0;if((r=r.toUpperCase()).indexOf(":")>=0){const e=r.split(":");a=e[0],o=e[1]}else a=r.slice(0,3),o=r.slice(3,6);const n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o),c=n+"/"+d;r="t"+r,a=this.getCurrencyId(a),o=this.getCurrencyId(o);const h={price:this.safeInteger(s,"price_precision"),amount:this.safeInteger(s,"price_precision")},l={amount:{min:this.safeFloat(s,"minimum_order_size"),max:this.safeFloat(s,"maximum_order_size")},price:{min:Math.pow(10,-h.price),max:Math.pow(10,h.price)}};l.cost={min:l.amount.min*l.price.min,max:void 0},i.push({id:r,symbol:c,base:n,quote:d,baseId:a,quoteId:o,active:!0,precision:h,limits:l,info:s,swap:!1,spot:!1,futures:!1})}return i}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostAuthRWallets(e),i=this.safeString(e,"type","exchange"),s={info:t};for(let e=0;e<t.length;e++){const r=t[e],a=r[0];let o=r[1];const n=r[2],d=r[4];if(a===i){"t"===o[0]&&(o=o.slice(1));const e=this.safeCurrencyCode(o),t=this.account();t.total=n,d?(t.free=d,t.used=t.total-t.free):0===d?(t.free=0,t.used=n):t.free=n,s[e]=t}}return this.parseBalance(s)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s=this.safeValue(this.options,"precision","R0"),r={symbol:this.marketId(e),precision:s};void 0!==t&&(r.len=t);const a=this.extend(r,i),o=await this.publicGetBookSymbolPrecision(a),n=this.milliseconds(),d={bids:[],asks:[],timestamp:n,datetime:this.iso8601(n),nonce:void 0},c="R0"===a.precision?1:0;for(let e=0;e<o.length;e++){const t=o[e],i=t[c],s=Math.abs(t[2]);d[t[2]>0?"bids":"asks"].push([i,s])}return d.bids=this.sortBy(d.bids,0,!0),d.asks=this.sortBy(d.asks,0),d}parseTicker(e,t){const i=this.milliseconds();let s=void 0;void 0!==t&&(s=t.symbol);const r=e.length,a=e[r-4];return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:e[r-2],low:e[r-1],bid:e[r-10],bidVolume:void 0,ask:e[r-8],askVolume:void 0,vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:e[r-6],percentage:100*e[r-5],average:void 0,baseVolume:e[r-3],quoteVolume:void 0,info:e}}async fetchTickers(e,t={}){await this.loadMarkets();const i={};if(void 0!==e){const t=this.marketIds(e);i.symbols=t.join(",")}else i.symbols="ALL";const s=await this.publicGetTickers(this.extend(i,t)),r={};for(let e=0;e<s.length;e++){const t=s[e],i=t[0];if(i in this.markets_by_id){const e=this.markets_by_id[i];r[e.symbol]=this.parseTicker(t,e)}}return r}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={symbol:i.id},r=await this.publicGetTickerSymbol(this.extend(s,t));return this.parseTicker(r,i)}parseTrade(e,t){const i=e.length>5,s=e[0].toString();let r=e[i?4:2],a=void 0;const o=e[i?5:3];let n=void 0,d=void 0,c=void 0,h=void 0,l=void 0,u=void 0;const f=e[i?2:1];if(i){const i=e[1];void 0!==i&&(u=i in this.markets_by_id?(t=this.markets_by_id[i]).symbol:i),d=e[3].toString(),c=1===e[8]?"maker":"taker";const s=e[9],r=this.safeCurrencyCode(e[10]);void 0!==s&&(l={cost:Math.abs(s),currency:r});const a=e[6];h=this.safeString(this.options.orderTypes,a)}return void 0===u&&void 0!==t&&(u=t.symbol),void 0!==r&&(n=r<0?"sell":"buy",r=Math.abs(r),void 0===a&&void 0!==o&&(a=r*o)),{id:s,timestamp:f,datetime:this.iso8601(f),symbol:u,order:d,side:n,type:h,takerOrMaker:c,price:o,amount:r,cost:a,fee:l,info:e}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e);let a="-1";const o={symbol:r.id};void 0!==t&&(o.start=t,a="1"),void 0!==i&&(o.limit=i),o.sort=a;const n=await this.publicGetTradesSymbolHist(this.extend(o,s)),d=this.sortBy(n,1);return this.parseTrades(d,r,void 0,i)}async fetchOHLCV(e,t="1m",i,s=100,r={}){await this.loadMarkets();const a=this.market(e);void 0===s&&(s=100),void 0===i&&(i=this.milliseconds()-this.parseTimeframe(t)*s*1e3);const o={symbol:a.id,timeframe:this.timeframes[t],sort:1,start:i,limit:s},n=await this.publicGetCandlesTradeTimeframeSymbolHist(this.extend(o,r));return this.parseOHLCVs(n,a,t,i,s)}async createOrder(e,t,i,s,r,o={}){throw new a(this.id+" createOrder not implemented yet")}cancelOrder(e,t,i={}){throw new a(this.id+" cancelOrder not implemented yet")}async fetchOrder(e,t,i={}){throw new a(this.id+" fetchOrder not implemented yet")}async fetchDepositAddress(e,t={}){throw new a(this.id+" fetchDepositAddress() not implemented yet.")}async withdraw(e,t,i,s,r={}){throw new a(this.id+" withdraw not implemented yet")}async fetchMyTrades(e,t,i,s={}){await this.loadMarkets();let r=void 0;const a={end:this.milliseconds()};void 0!==t&&(a.start=t),void 0!==i&&(a.limit=i);let o="privatePostAuthRTradesHist";void 0!==e&&(r=this.market(e),a.symbol=r.id,o="privatePostAuthRTradesSymbolHist");const n=await this[o](this.extend(a,s));return this.parseTrades(n,r,t,i)}nonce(){return this.milliseconds()}sign(e,t="public",i="GET",s={},r,a){let o="/"+this.implodeParams(e,s);const n=this.omit(s,this.extractParams(e));o="v1"===t?t+o:this.version+o;let d=this.urls.api[t]+"/"+o;if("public"===t&&Object.keys(n).length&&(d+="?"+this.urlencode(n)),"private"===t){this.checkRequiredCredentials();const e=this.nonce().toString(),t="/api/"+o+e+(a=this.json(n)),i=this.hmac(this.encode(t),this.encode(this.secret),"sha384");r={"bfx-nonce":e,"bfx-apikey":this.apiKey,"bfx-signature":i,"Content-Type":"application/json"}}return{url:d,method:i,body:a,headers:r}}async request(e,t="public",i="GET",s={},a,n){const d=await this.fetch2(e,t,i,s,a,n);if(d){if("message"in d){if(d.message.indexOf("not enough exchange balance")>=0)throw new o(this.id+" "+this.json(d));throw new r(this.id+" "+this.json(d))}return d}if(""===d)throw new r(this.id+" returned empty response");return d}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,ArgumentsRequired:a,OrderNotFound:o}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"bitflyer",name:"bitFlyer",countries:["JP"],version:"v1",rateLimit:1e3,has:{CORS:!1,withdraw:!0,fetchMyTrades:!0,fetchOrders:!0,fetchOrder:"emulated",fetchOpenOrders:"emulated",fetchClosedOrders:"emulated"},urls:{logo:"https://user-images.githubusercontent.com/1294454/28051642-56154182-660e-11e7-9b0d-6042d1e6edd8.jpg",api:"https://api.bitflyer.jp",www:"https://bitflyer.jp",doc:"https://lightning.bitflyer.com/docs?lang=en"},api:{public:{get:["getmarkets/usa","getmarkets/eu","getmarkets","getboard","getticker","getexecutions","gethealth","getboardstate","getchats"]},private:{get:["getpermissions","getbalance","getbalancehistory","getcollateral","getcollateralhistory","getcollateralaccounts","getaddresses","getcoinins","getcoinouts","getbankaccounts","getdeposits","getwithdrawals","getchildorders","getparentorders","getparentorder","getexecutions","getpositions","gettradingcommission"],post:["sendcoin","withdraw","sendchildorder","cancelchildorder","sendparentorder","cancelparentorder","cancelallchildorders"]}},fees:{trading:{maker:.002,taker:.002},"BTC/JPY":{maker:.0015,taker:.0015}}})}async fetchMarkets(e={}){const t=await this.publicGetGetmarkets(e),i=await this.publicGetGetmarketsUsa(e),s=await this.publicGetGetmarketsEu(e);let r=this.arrayConcat(t,i);r=this.arrayConcat(r,s);const a=[];for(let e=0;e<r.length;e++){const t=r[e],i=this.safeString(t,"product_code"),s=i.split("_");let o=void 0,n=void 0,d=void 0,c=void 0;const h=s.length;1===h?(o=i.slice(0,3),n=i.slice(3,6)):2===h?(o=s[0],n=s[1]):(o=s[1],n=s[2]),d=this.safeCurrencyCode(o),c=this.safeCurrencyCode(n);const l=2===h?d+"/"+c:i,u=this.safeValue(this.fees,l,this.fees.trading);let f=this.safeValue(u,"maker",this.fees.trading.maker),p=this.safeValue(u,"taker",this.fees.trading.taker),m=!0,y=!1,b="spot";("alias"in t||"FX"===s[0])&&(b="future",y=!0,m=!1,f=0,p=0),a.push({id:i,symbol:l,base:d,quote:c,baseId:o,quoteId:n,maker:f,taker:p,type:b,spot:m,future:y,info:t})}return a}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetGetbalance(e),i={info:t};for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"currency_code"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeFloat(s,"amount"),o.free=this.safeFloat(s,"available"),i[a]=o}return this.parseBalance(i)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={product_code:this.marketId(e)},r=await this.publicGetGetboard(this.extend(s,i));return this.parseOrderBook(r,void 0,"bids","asks","price","size")}async fetchTicker(e,t={}){await this.loadMarkets();const i={product_code:this.marketId(e)},s=await this.publicGetGetticker(this.extend(i,t)),r=this.parse8601(this.safeString(s,"timestamp")),a=this.safeFloat(s,"ltp");return{symbol:e,timestamp:r,datetime:this.iso8601(r),high:void 0,low:void 0,bid:this.safeFloat(s,"best_bid"),bidVolume:void 0,ask:this.safeFloat(s,"best_ask"),askVolume:void 0,vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeFloat(s,"volume_by_product"),quoteVolume:void 0,info:s}}parseTrade(e,t){let i=this.safeStringLower(e,"side");void 0!==i&&i.length<1&&(i=void 0);let s=void 0;if(void 0!==i){const t=i+"_child_order_acceptance_id";t in e&&(s=e[t])}void 0===s&&(s=this.safeString(e,"child_order_acceptance_id"));const r=this.parse8601(this.safeString(e,"exec_date")),a=this.safeFloat(e,"price"),o=this.safeFloat(e,"size");let n=void 0;void 0!==o&&void 0!==a&&(n=a*o);const d=this.safeString(e,"id");let c=void 0;return void 0!==t&&(c=t.symbol),{id:d,info:e,timestamp:r,datetime:this.iso8601(r),symbol:c,order:s,type:void 0,side:i,takerOrMaker:void 0,price:a,amount:o,cost:n,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={product_code:r.id},o=await this.publicGetGetexecutions(this.extend(a,s));return this.parseTrades(o,r,t,i)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o={product_code:this.marketId(e),child_order_type:t.toUpperCase(),side:i.toUpperCase(),price:r,size:s},n=await this.privatePostSendchildorder(this.extend(o,a));return{info:n,id:this.safeString(n,"child_order_acceptance_id")}}async cancelOrder(e,t,i={}){if(void 0===t)throw new a(this.id+" cancelOrder() requires a `symbol` argument");await this.loadMarkets();const s={product_code:this.marketId(t),child_order_acceptance_id:e};return await this.privatePostCancelchildorder(this.extend(s,i))}parseOrderStatus(e){return this.safeString({ACTIVE:"open",COMPLETED:"closed",CANCELED:"canceled",EXPIRED:"canceled",REJECTED:"canceled"},e,e)}parseOrder(e,t){const i=this.parse8601(this.safeString(e,"child_order_date")),s=this.safeFloat(e,"size"),r=this.safeFloat(e,"outstanding_size"),a=this.safeFloat(e,"executed_size"),o=this.safeFloat(e,"price"),n=o*a,d=this.parseOrderStatus(this.safeString(e,"child_order_state")),c=this.safeStringLower(e,"child_order_type"),h=this.safeStringLower(e,"side");let l=void 0;if(void 0===t){const i=this.safeString(e,"product_code");i in this.markets_by_id&&(t=this.markets_by_id[i])}void 0!==t&&(l=t.symbol);let u=void 0;const f=this.safeFloat(e,"total_commission");return void 0!==f&&(u={cost:f,currency:void 0,rate:void 0}),{id:this.safeString(e,"child_order_acceptance_id"),info:e,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,status:d,symbol:l,type:c,side:h,price:o,cost:n,amount:s,filled:a,remaining:r,fee:u}}async fetchOrders(e,t,i=100,s={}){if(void 0===e)throw new a(this.id+" fetchOrders() requires a `symbol` argument");await this.loadMarkets();const r=this.market(e),o={product_code:r.id,count:i},n=await this.privateGetGetchildorders(this.extend(o,s));let d=this.parseOrders(n,r,t,i);return void 0!==e&&(d=this.filterBy(d,"symbol",e)),d}async fetchOpenOrders(e,t,i=100,s={}){return await this.fetchOrders(e,t,i,this.extend({child_order_state:"ACTIVE"},s))}async fetchClosedOrders(e,t,i=100,s={}){return await this.fetchOrders(e,t,i,this.extend({child_order_state:"COMPLETED"},s))}async fetchOrder(e,t,i={}){if(void 0===t)throw new a(this.id+" fetchOrder() requires a `symbol` argument");const s=await this.fetchOrders(t),r=this.indexBy(s,"id");if(e in r)return r[e];throw new o(this.id+" No order found with id "+e)}async fetchMyTrades(e,t,i,s={}){if(void 0===e)throw new a(this.id+" fetchMyTrades requires a `symbol` argument");await this.loadMarkets();const r=this.market(e),o={product_code:r.id};void 0!==i&&(o.count=i);const n=await this.privateGetGetexecutions(this.extend(o,s));return this.parseTrades(n,r,t,i)}async withdraw(e,t,i,s,a={}){if(this.checkAddress(i),await this.loadMarkets(),"JPY"!==e&&"USD"!==e&&"EUR"!==e)throw new r(this.id+" allows withdrawing JPY, USD, EUR only, "+e+" is not supported");const o={currency_code:this.currency(e).id,amount:t},n=await this.privatePostWithdraw(this.extend(o,a));return{info:n,id:this.safeString(n,"message_id")}}sign(e,t="public",i="GET",s={},r,a){let o="/"+this.version+"/";"private"===t&&(o+="me/"),o+=e,"GET"===i&&Object.keys(s).length&&(o+="?"+this.urlencode(s));const n=this.urls.api+o;if("private"===t){this.checkRequiredCredentials();const e=this.nonce().toString();let t=[e,i,o].join("");Object.keys(s).length&&"GET"!==i&&(t+=a=this.json(s)),r={"ACCESS-KEY":this.apiKey,"ACCESS-TIMESTAMP":e,"ACCESS-SIGN":this.hmac(this.encode(t),this.encode(this.secret)),"Content-Type":"application/json"}}return{url:n,method:i,body:a,headers:r}}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,AuthenticationError:a,OrderNotFound:o,InsufficientFunds:n,DDoSProtection:d}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"bitforex",name:"Bitforex",countries:["CN"],version:"v1",has:{fetchBalance:!0,fetchMarkets:!0,createOrder:!0,cancelOrder:!0,fetchTicker:!0,fetchTickers:!1,fetchMyTrades:!1,fetchTrades:!0,fetchOrder:!0,fetchOrders:!1,fetchOpenOrders:!0,fetchClosedOrders:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/44310033-69e9e600-a3d8-11e8-873d-54d74d1bc4e4.jpg",api:"https://api.bitforex.com",www:"https://www.bitforex.com",doc:"https://github.com/bitforexapi/API_Docs/wiki",fees:"https://help.bitforex.com/en_us/?cat=13",referral:"https://www.bitforex.com/en/invitationRegister?inviterId=1867438"},api:{public:{get:["api/v1/market/symbols","api/v1/market/ticker","api/v1/market/depth","api/v1/market/trades","api/v1/market/kline"]},private:{post:["api/v1/fund/mainAccount","api/v1/fund/allAccount","api/v1/trade/placeOrder","api/v1/trade/placeMultiOrder","api/v1/trade/cancelOrder","api/v1/trade/orderInfo","api/v1/trade/orderInfos"]}},fees:{trading:{tierBased:!1,percentage:!0,maker:.001,taker:.001},funding:{tierBased:!1,percentage:!0,deposit:{},withdraw:{BTC:5e-4,ETH:.01,BCH:1e-4,LTC:.001,ETC:.005,USDT:5,CMCT:30,AION:3,LVT:0,DATA:40,RHP:50,NEO:0,AIDOC:10,BQT:2,R:2,DPY:.8,GTC:40,AGI:30,DENT:100,SAN:1,SPANK:8,AID:5,OMG:.1,BFT:5,SHOW:150,TRX:20,ABYSS:10,THM:25,ZIL:20,PPT:.2,WTC:.4,LRC:7,BNT:1,CTXC:1,MITH:20,TRUE:4,LYM:10,VEE:100,AUTO:200,REN:50,TIO:2.5,NGC:1.5,PST:10,CRE:200,IPC:5,PTT:1e3,XMCT:20,ATMI:40,TERN:40,XLM:.01,ODE:15,FTM:100,RTE:100,DCC:100,IMT:500,GOT:3,EGT:500,DACC:1e3,UBEX:500,ABL:100,OLT:100,DAV:40,THRT:10,RMESH:3,UPP:20,SDT:0,SHR:10,MTV:3,ESS:100,MET:3,TTC:20,LXT:10,XCLP:100,LUK:100,UBC:100,DTX:10,BEAT:20,DEED:2,BGX:3e3,PRL:20,ELY:50,CARD:300,SQR:15,VRA:400,BWX:3500,MAS:75,FLP:.6,UNC:300,CRNC:15,MFG:70,ZXC:70,TRT:30,ZIX:35,XRA:10,AMO:1600,IPG:3,uDoo:50,URB:30,ARCONA:3,CRAD:5,NOBS:1e3,ADF:2,ELF:5,LX:20,PATH:15,SILK:120,SKYFT:50,EDN:50,ADE:50,EDR:10,TIME:.25,SPRK:20,QTUM:.01,BF:5,ZPR:100,HYB:10,CAN:30,CEL:10,ATS:50,KCASH:1,ACT:.01,MT:300,DXT:30,WAB:4e3,HYDRO:400,LQD:5,OPTC:200,EQUAD:80,LATX:50,LEDU:100,RIT:70,ACDC:500,FSN:2}}},exceptions:{4004:o,1013:a,1016:a,3002:n,10204:d}})}async fetchMarkets(e={}){const t=(await this.publicGetApiV1MarketSymbols(e)).data,i=[];for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"symbol"),a=r.split("-"),o=a[2],n=a[1],d=this.safeCurrencyCode(o),c=this.safeCurrencyCode(n),h=d+"/"+c,l=!0,u={amount:this.safeInteger(s,"amountPrecision"),price:this.safeInteger(s,"pricePrecision")},f={amount:{min:this.safeFloat(s,"minOrderAmount"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}};i.push({id:r,symbol:h,base:d,quote:c,baseId:o,quoteId:n,active:l,precision:u,limits:f,info:s})}return i}parseTrade(e,t){let i=void 0;void 0!==t&&(i=t.symbol);const s=this.safeInteger(e,"time"),r=this.safeString(e,"tid"),a=this.safeFloat(e,"amount"),o=this.safeFloat(e,"price");let n=void 0;void 0!==o&&void 0!==a&&(n=a*o);const d=this.safeInteger(e,"direction"),c=this.parseSide(d);return{info:e,id:r,timestamp:s,datetime:this.iso8601(s),symbol:i,type:void 0,side:c,price:o,amount:a,cost:n,order:void 0,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r={symbol:this.marketId(e)};void 0!==i&&(r.size=i);const a=this.market(e),o=await this.publicGetApiV1MarketTrades(this.extend(r,s));return this.parseTrades(o.data,a,t,i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostApiV1FundAllAccount(e),i=t.data,s={info:t};for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.used=this.safeFloat(t,"frozen"),o.free=this.safeFloat(t,"active"),o.total=this.safeFloat(t,"fix"),s[a]=o}return this.parseBalance(s)}async fetchTicker(e,t={}){await this.loadMarkets();const i={symbol:this.markets[e].id},s=await this.publicGetApiV1MarketTicker(this.extend(i,t)),r=s.data,a=this.safeInteger(r,"date");return{symbol:e,timestamp:a,datetime:this.iso8601(a),high:this.safeFloat(r,"high"),low:this.safeFloat(r,"low"),bid:this.safeFloat(r,"buy"),bidVolume:void 0,ask:this.safeFloat(r,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:this.safeFloat(r,"last"),last:this.safeFloat(r,"last"),previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeFloat(r,"vol"),quoteVolume:void 0,info:s}}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={symbol:this.marketId(e)};void 0!==t&&(s.size=t);const r=await this.publicGetApiV1MarketDepth(this.extend(s,i)),a=this.safeValue(r,"data"),o=this.safeInteger(r,"time");return this.parseOrderBook(a,o,"bids","asks","price","amount")}parseOrderStatus(e){const t={0:"open",1:"open",2:"closed",3:"canceled",4:"canceled"};return e in t?t[e]:e}parseSide(e){return 1===e?"buy":2===e?"sell":void 0}parseOrder(e,t){const i=this.safeString(e,"orderId"),s=this.safeFloat(e,"createTime"),r=this.safeFloat(e,"lastTime"),a=t.symbol,o=this.safeInteger(e,"tradeType"),n=this.parseSide(o),d=this.safeFloat(e,"orderPrice"),c=this.safeFloat(e,"avgPrice"),h=this.safeFloat(e,"orderAmount"),l=this.safeFloat(e,"dealAmount"),u=h-l,f=this.parseOrderStatus(this.safeString(e,"orderState")),p=l*d,m=t["buy"===n?"base":"quote"],y={cost:this.safeFloat(e,"tradeFee"),currency:m};return{info:e,id:i,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:r,symbol:a,type:void 0,side:n,price:d,cost:p,average:c,amount:h,filled:l,remaining:u,status:f,fee:y}}async fetchOrder(e,t,i={}){await this.loadMarkets();const s=this.market(t),r={symbol:this.marketId(t),orderId:e},a=await this.privatePostApiV1TradeOrderInfo(this.extend(r,i));return this.parseOrder(a.data,s)}async fetchOpenOrders(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={symbol:this.marketId(e),state:0},o=await this.privatePostApiV1TradeOrderInfos(this.extend(a,s));return this.parseOrders(o.data,r,t,i)}async fetchClosedOrders(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={symbol:this.marketId(e),state:1},o=await this.privatePostApiV1TradeOrderInfos(this.extend(a,s));return this.parseOrders(o.data,r,t,i)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();let o=void 0;"buy"===i?o=1:"sell"===i&&(o=2);const n={symbol:this.marketId(e),price:r,amount:s,tradeType:o},d=await this.privatePostApiV1TradePlaceOrder(this.extend(n,a)),c=d.data;return{info:d,id:this.safeString(c,"orderId")}}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={orderId:e};void 0!==t&&(s.symbol=this.marketId(t));const r=await this.privatePostApiV1TradeCancelOrder(this.extend(s,i));return{info:r,success:r.success}}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api+"/"+this.implodeParams(e,s);const n=this.omit(s,this.extractParams(e));if("public"===t)Object.keys(n).length&&(o+="?"+this.urlencode(n));else{this.checkRequiredCredentials();let t=this.urlencode({accessKey:this.apiKey});n.nonce=this.milliseconds(),Object.keys(n).length&&(t+="&"+this.urlencode(this.keysort(n)));const i="/"+e+"?"+t;a=t+"&signData="+this.hmac(this.encode(i),this.encode(this.secret)),r={"Content-Type":"application/x-www-form-urlencoded"}}return{url:o,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,o,n,d,c){if("string"==typeof o&&("{"===o[0]||"["===o[0])){const e=this.id+" "+o,t=this.safeValue(n,"success");if(void 0!==t&&!t){const t=this.safeString(n,"code");throw t in this.exceptions?new this.exceptions[t](e):new r(e)}}}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,ExchangeNotAvailable:a,AuthenticationError:o,BadRequest:n,PermissionDenied:d,InvalidAddress:c}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"bithumb",name:"Bithumb",countries:["KR"],rateLimit:500,has:{CORS:!0,fetchTickers:!0,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/30597177-ea800172-9d5e-11e7-804c-b9d4fa9b56b0.jpg",api:{public:"https://api.bithumb.com/public",private:"https://api.bithumb.com"},www:"https://www.bithumb.com",doc:"https://apidocs.bithumb.com",fees:"https://en.bithumb.com/customer_support/info_fee"},api:{public:{get:["ticker/{currency}","ticker/all","orderbook/{currency}","orderbook/all","transaction_history/{currency}","transaction_history/all"]},private:{post:["info/account","info/balance","info/wallet_address","info/ticker","info/orders","info/user_transactions","trade/place","info/order_detail","trade/cancel","trade/btc_withdrawal","trade/krw_deposit","trade/krw_withdrawal","trade/market_buy","trade/market_sell"]}},fees:{trading:{maker:.0025,taker:.0025}},exceptions:{"Bad Request(SSL)":n,"Bad Request(Bad Method)":n,"Bad Request.(Auth Data)":o,"Not Member":o,"Invalid Apikey":o,"Method Not Allowed.(Access IP)":d,"Method Not Allowed.(BTC Adress)":c,"Method Not Allowed.(Access)":d,"Database Fail":a,"Invalid Parameter":n,5600:r,"Unknown Error":r,"After May 23th, recent_transactions is no longer, hence users will not be able to connect to recent_transactions":r}})}async fetchMarkets(e={}){const t=await this.publicGetTickerAll(e),i=this.safeValue(t,"data"),s=Object.keys(i),r=[];for(let e=0;e<s.length;e++){const t=s[e];if("date"===t)continue;const a=i[t],o=t,n="KRW",d=t+"/"+n;let c=!0;if(Array.isArray(a)){0===a.length&&(c=!1)}r.push({id:t,symbol:d,base:o,quote:n,info:a,active:c,precision:{amount:void 0,price:void 0},limits:{amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}}})}return r}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostInfoBalance(this.extend({currency:"ALL"},e)),i={info:t},s=this.safeValue(t,"data"),r=Object.keys(this.currencies);for(let e=0;e<r.length;e++){const t=r[e],a=this.account(),o=this.currency(t).id.toLowerCase();a.total=this.safeFloat(s,"total_"+o),a.used=this.safeFloat(s,"in_use_"+o),a.free=this.safeFloat(s,"available_"+o),i[t]=a}return this.parseBalance(i)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={currency:this.market(e).base};void 0!==t&&(s.count=t);const r=await this.publicGetOrderbookCurrency(this.extend(s,i)),a=this.safeValue(r,"data"),o=this.safeInteger(a,"timestamp");return this.parseOrderBook(a,o,"bids","asks","price","quantity")}parseTicker(e,t){const i=this.safeInteger(e,"date");let s=void 0;void 0!==t&&(s=t.symbol);const r=this.safeFloat(e,"opening_price"),a=this.safeFloat(e,"closing_price");let o=void 0,n=void 0,d=void 0;void 0!==a&&void 0!==r&&(o=a-r,r>0&&(n=o/r*100),d=this.sum(r,a)/2);const c=this.safeFloat(e,"units_traded_24H"),h=this.safeFloat(e,"acc_trade_value_24H");let l=void 0;return void 0!==h&&void 0!==c&&(l=h/c),{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"max_price"),low:this.safeFloat(e,"min_price"),bid:this.safeFloat(e,"buy_price"),bidVolume:void 0,ask:this.safeFloat(e,"sell_price"),askVolume:void 0,vwap:l,open:r,close:a,last:a,previousClose:void 0,change:o,percentage:n,average:d,baseVolume:c,quoteVolume:h,info:e}}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetTickerAll(t),s={},r=this.safeInteger(i.data,"date"),a=this.omit(i.data,"date"),o=Object.keys(a);for(let e=0;e<o.length;e++){const t=o[e];let i=t,n=void 0;t in this.markets_by_id&&(i=(n=this.markets_by_id[t]).symbol);const d=a[t];Array.isArray(d)||(d.date=r,s[i]=this.parseTicker(d,n))}return s}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={currency:i.base},r=await this.publicGetTickerCurrency(this.extend(s,t));return this.parseTicker(r.data,i)}parseTrade(e,t){const i=e.transaction_date.split(" "),s=i[0];let r=i[1];r.length<8&&(r="0"+r);let a=this.parse8601(s+" "+r);a-=324e5;let o=this.safeString(e,"type");o="ask"===o?"sell":"buy";const n=this.safeString(e,"cont_no");let d=void 0;void 0!==t&&(d=t.symbol);const c=this.safeFloat(e,"price"),h=this.safeFloat(e,"units_traded");let l=void 0;return void 0!==h&&void 0!==c&&(l=c*h),{id:n,info:e,timestamp:a,datetime:this.iso8601(a),symbol:d,order:void 0,type:void 0,side:o,takerOrMaker:void 0,price:c,amount:h,cost:l,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={currency:r.base};void 0===i&&(a.count=i);const o=await this.publicGetTransactionHistoryCurrency(this.extend(a,s));return this.parseTrades(o.data,r,t,i)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o=this.market(e);let n=void 0,d="privatePostTrade";"limit"===t?(n={order_currency:o.id,Payment_currency:o.quote,units:s,price:r,type:"buy"===i?"bid":"ask"},d+="Place"):"market"===t&&(n={currency:o.id,units:s},d+="Market"+this.capitalize(i));const c=await this[d](this.extend(n,a));return{info:c,id:this.safeString(c,"order_id")}}async cancelOrder(e,t,i={}){if(!("side"in i))throw new r(this.id+" cancelOrder requires a `side` parameter (sell or buy) and a `currency` parameter");const s=this.safeString(i,"currency");if(void 0===s)throw new r(this.id+" cancelOrder requires a `currency` parameter (a currency id)");const a="buy"===i.side?"bid":"ask";i=this.omit(i,["side","currency"]);const o={order_id:e,type:a,currency:s};return await this.privatePostTradeCancel(this.extend(o,i))}async withdraw(e,t,i,s,a={}){this.checkAddress(i),await this.loadMarkets();const o=this.currency(e),n={units:t,address:i,currency:o.id};if("XRP"===o||"XMR"===o){const t=this.safeString(a,"destination");if(void 0===s&&void 0===t)throw new r(this.id+" "+e+" withdraw() requires a tag argument or an extra destination param");void 0!==s&&(n.destination=s)}return{info:await this.privatePostTradeBtcWithdrawal(this.extend(n,a)),id:void 0}}nonce(){return this.milliseconds()}sign(e,t="public",i="GET",s={},r,a){const o="/"+this.implodeParams(e,s);let n=this.urls.api[t]+o;const d=this.omit(s,this.extractParams(e));if("public"===t)Object.keys(d).length&&(n+="?"+this.urlencode(d));else{this.checkRequiredCredentials(),a=this.urlencode(this.extend({endpoint:o},d));const e=this.nonce().toString(),t=o+"\0"+a+"\0"+e,i=this.hmac(this.encode(t),this.encode(this.secret),"sha512"),s=this.decode(this.stringToBase64(this.encode(i)));r={Accept:"application/json","Content-Type":"application/x-www-form-urlencoded","Api-Key":this.apiKey,"Api-Sign":s.toString(),"Api-Nonce":e}}return{url:n,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,o,n,d,c){if(void 0!==n&&"status"in n){const e=this.safeString(n,"status"),t=this.safeString(n,"message");if(void 0!==e){if("0000"===e)return;const i=this.id+" "+this.json(n),s=this.exceptions;throw e in s?new s[e](i):t in s?new s[t](i):new r(i)}}}async request(e,t="public",i="GET",s={},a,o){const n=await this.fetch2(e,t,i,s,a,o);if("status"in n){if("0000"===n.status)return n;throw new r(this.id+" "+this.json(n))}return n}}},function(e,t,i){"use strict";const s=i(33);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"bitkk",name:"bitkk",comment:"a Chinese ZB clone",urls:{api:{public:"http://api.bitkk.com/data",private:"https://trade.bitkk.com/api"},www:"https://www.bitkk.com",doc:"https://www.bitkk.com/i/developer",fees:"https://www.bitkk.com/i/rate"}})}}},function(e,t,i){"use strict";const s=i(1),{NotSupported:r}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"bitlish",name:"Bitlish",countries:["GB","EU","RU"],rateLimit:1500,version:"v1",has:{CORS:!1,fetchTickers:!0,fetchOHLCV:!0,withdraw:!0},timeframes:{"1h":3600},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766275-dcfc6c30-5ed3-11e7-839d-00a846385d0b.jpg",api:"https://bitlish.com/api",www:"https://bitlish.com",doc:"https://bitlish.com/api",fees:"https://bitlish.com/fees"},requiredCredentials:{apiKey:!0,secret:!1},fees:{trading:{tierBased:!1,percentage:!0,taker:.003,maker:.002},funding:{tierBased:!1,percentage:!1,withdraw:{BTC:.001,LTC:.001,DOGE:.001,ETH:.001,XMR:0,ZEC:.001,DASH:1e-4,EUR:50},deposit:{BTC:0,LTC:0,DOGE:0,ETH:0,XMR:0,ZEC:0,DASH:0,EUR:0}}},api:{public:{get:["instruments","ohlcv","pairs","tickers","trades_depth","trades_history"],post:["instruments","ohlcv","pairs","tickers","trades_depth","trades_history"]},private:{post:["accounts_operations","balance","cancel_trade","cancel_trades_by_ids","cancel_all_trades","create_bcode","create_template_wallet","create_trade","deposit","list_accounts_operations_from_ts","list_active_trades","list_bcodes","list_my_matches_from_ts","list_my_trades","list_my_trads_from_ts","list_payment_methods","list_payments","redeem_code","resign","signin","signout","trade_details","trade_options","withdraw","withdraw_by_id"]}},commonCurrencies:{DSH:"DASH",XDG:"DOGE"}})}async fetchMarkets(e={}){const t=await this.publicGetPairs(e),i=[],s=Object.keys(t);for(let e=0;e<s.length;e++){const r=t[s[e]],a=this.safeString(r,"id"),o=this.safeString(r,"name"),[n,d]=o.split("/"),c=this.safeCurrencyCode(n),h=this.safeCurrencyCode(d),l=c+"/"+h;i.push({id:a,symbol:l,base:c,quote:h,baseId:n,quoteId:d,info:r})}return i}parseTicker(e,t){const i=this.milliseconds();let s=void 0;void 0!==t&&(s=t.symbol);const r=this.safeFloat(e,"last");return{timestamp:i,datetime:this.iso8601(i),symbol:s,high:this.safeFloat(e,"max"),low:this.safeFloat(e,"min"),bid:this.safeFloat(e,"bid"),bidVolume:void 0,ask:this.safeFloat(e,"ask"),askVolume:void 0,vwap:void 0,open:this.safeFloat(e,"first"),close:r,last:r,previousClose:void 0,change:void 0,percentage:100*this.safeFloat(e,"prc"),average:void 0,baseVolume:this.safeFloat(e,"sum"),quoteVolume:void 0,info:e}}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetTickers(t),s=Object.keys(i),r={};for(let e=0;e<s.length;e++){const t=s[e],a=this.safeValue(this.markets_by_id,t);let o=void 0;if(void 0!==a)o=a.symbol;else{const e=t.slice(0,3),i=t.slice(3,6);o=this.safeCurrencyCode(e)+"/"+this.safeCurrencyCode(i)}const n=i[t];r[o]=this.parseTicker(n,a)}return r}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s=await this.publicGetTickers(t),r=i.id;return this.parseTicker(s[r],i)}async fetchOHLCV(e,t="1h",i,s,r={}){await this.loadMarkets();let a=this.seconds()-2592e3;void 0!==i&&(a=parseInt(i/1e3));const o={time_range:[a.toString(),void 0]};return await this.publicPostOhlcv(this.extend(o,r))}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={pair_id:this.marketId(e)},r=await this.publicGetTradesDepth(this.extend(s,i));let a=void 0;const o=this.safeInteger(r,"last");return void 0!==o&&(a=parseInt(o/1e3)),this.parseOrderBook(r,a,"bid","ask","price","volume")}parseTrade(e,t){const i="bid"===e.dir?"buy":"sell";let s=void 0;void 0!==t&&(s=t.symbol);let r=this.safeInteger(e,"created");void 0!==r&&(r=parseInt(r/1e3));const a=this.safeFloat(e,"price"),o=this.safeFloat(e,"amount");let n=void 0;return void 0!==o&&void 0!==a&&(n=a*o),{id:void 0,info:e,timestamp:r,datetime:this.iso8601(r),symbol:s,order:void 0,type:void 0,side:i,takerOrMaker:void 0,price:a,amount:o,cost:n,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a=await this.publicGetTradesHistory(this.extend({pair_id:r.id},s));return this.parseTrades(a.list,r,t,i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostBalance(e),i={info:t},s=Object.keys(t);for(let e=0;e<s.length;e++){const r=s[e],a=this.safeCurrencyCode(r),o=this.account(),n=this.safeValue(t,r,{});o.free=this.safeFloat(n,"funds"),o.used=this.safeFloat(n,"holded"),i[a]=o}return this.parseBalance(i)}async signIn(e={}){const t={login:this.login,passwd:this.password};return await this.privatePostSignin(this.extend(t,e))}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o={pair_id:this.marketId(e),dir:"buy"===i?"bid":"ask",amount:s};"limit"===t&&(o.price=r);const n=await this.privatePostCreateTrade(this.extend(o,a));return{info:n,id:this.safeString(n,"id")}}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={id:e};return await this.privatePostCancelTrade(this.extend(s,i))}async withdraw(e,t,i,s,a={}){if("BTC"!==e)throw new r(this.id+" currently supports BTC withdrawals only, until they document other currencies...");this.checkAddress(i),await this.loadMarkets();const o={currency:this.currency(e).id,amount:parseFloat(t),account:i,payment_method:"bitcoin"},n=await this.privatePostWithdraw(this.extend(o,a));return{info:n,id:n.message_id}}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api+"/"+this.version+"/"+e;return"public"===t?"GET"===i?Object.keys(s).length&&(o+="?"+this.urlencode(s)):(a=this.json(s),r={"Content-Type":"application/json"}):(this.checkRequiredCredentials(),a=this.json(this.extend({token:this.apiKey},s)),r={"Content-Type":"application/json"}),{url:o,method:i,body:a,headers:r}}}},function(e,t,i){"use strict";const s=i(1),{AuthenticationError:r,ArgumentsRequired:a,ExchangeError:o,InvalidOrder:n,BadRequest:d,OrderNotFound:c,DDoSProtection:h}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"bitmart",name:"BitMart",countries:["US","CN","HK","KR"],rateLimit:1e3,version:"v2",has:{CORS:!0,fetchMarkets:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchCurrencies:!0,fetchOrderBook:!0,fetchTrades:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchBalance:!0,createOrder:!0,cancelOrder:!0,cancelAllOrders:!0,fetchOrders:!1,fetchOrderTrades:!0,fetchOpenOrders:!0,fetchClosedOrders:!0,fetchCanceledOrders:!0,fetchOrder:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/61835713-a2662f80-ae85-11e9-9d00-6442919701fd.jpg",api:"https://openapi.bitmart.com",www:"https://www.bitmart.com/",doc:"https://github.com/bitmartexchange/bitmart-official-api-docs",referral:"http://www.bitmart.com/?r=rQCFLh"},requiredCredentials:{apiKey:!0,secret:!0,uid:!0},api:{token:{post:["authentication"]},public:{get:["currencies","ping","steps","symbols","symbols_details","symbols/{symbol}/kline","symbols/{symbol}/orders","symbols/{symbol}/trades","ticker","time"]},private:{get:["orders","orders/{id}","trades","wallet"],post:["orders"],delete:["orders","orders/{id}"]}},timeframes:{"1m":1,"3m":3,"5m":5,"15m":15,"30m":30,"45m":45,"1h":60,"2h":120,"3h":180,"4h":240,"1d":1440,"1w":10080,"1M":43200},fees:{trading:{tierBased:!0,percentage:!0,taker:.002,maker:.001,tiers:{taker:[[0,.002],[10,.0018],[50,.0016],[250,.14/100],[1e3,.0012],[5e3,.001],[25e3,8e-4],[5e4,6e-4]],maker:[[0,.001],[10,9e-4],[50,8e-4],[250,.07/100],[1e3,6e-4],[5e3,5e-4],[25e3,4e-4],[5e4,3e-4]]}}},exceptions:{exact:{"Place order error":n,"Not found":c,"Visit too often, please try again later":h},broad:{"Maximum price is":n,"is not present":d}}})}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.safeInteger(t,"server_time")}async signIn(e={}){const t=this.apiKey+":"+this.secret+":"+this.uid,i={grant_type:"client_credentials",client_id:this.apiKey,client_secret:this.hmac(this.encode(t),this.encode(this.secret),"sha256")},s=await this.tokenPostAuthentication(this.extend(i,e)),a=this.safeString(s,"access_token");if(!a)throw new r(this.id+" signIn() failed to authenticate. Access token missing from response.");const o=this.safeInteger(s,"expires_in");return this.options.expires=this.sum(this.nonce(),1e3*o),this.options.accessToken=a,s}async fetchMarkets(e={}){const t=await this.publicGetSymbolsDetails(e),i=[];for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"id"),a=this.safeString(s,"base_currency"),o=this.safeString(s,"quote_currency"),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o),c=n+"/"+d,h=this.safeString(s,"quote_increment"),l={amount:this.precisionFromString(h),price:this.safeInteger(s,"price_max_precision")},u={amount:{min:this.safeFloat(s,"base_min_size"),max:this.safeFloat(s,"base_max_size")},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}};i.push({id:r,symbol:c,base:n,quote:d,baseId:a,quoteId:o,precision:l,limits:u,info:s})}return i}parseTicker(e,t){const i=this.milliseconds(),s=this.safeString(e,"symbol_id");let r=void 0;if(void 0!==s)if(s in this.markets_by_id)r=this.markets_by_id[s].symbol;else if(void 0!==s){const[e,t]=s.split("_");r=this.safeCurrencyCode(e)+"/"+this.safeCurrencyCode(t)}const a=this.safeFloat(e,"current_price"),o=this.safeFloat(e,"fluctuation");return{symbol:r,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"highest_price"),low:this.safeFloat(e,"lowest_price"),bid:this.safeFloat(e,"bid_1"),bidVolume:this.safeFloat(e,"bid_1_amount"),ask:this.safeFloat(e,"ask_1"),askVolume:this.safeFloat(e,"ask_1_amount"),vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:void 0,percentage:100*o,average:void 0,baseVolume:this.safeFloat(e,"volume"),quoteVolume:this.safeFloat(e,"base_volume"),info:e}}async fetchTicker(e,t={}){await this.loadMarkets();const i={symbol:this.marketId(e)},s=await this.publicGetTicker(this.extend(i,t));return this.parseTicker(s)}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetTicker(t),s={};for(let e=0;e<i.length;e++){const t=this.parseTicker(i[e]);s[t.symbol]=t}return s}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),i={};for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"id"),a=this.safeCurrencyCode(r),o=this.safeString(s,"name"),n=this.safeValue(s,"withdraw_enabled"),d=this.safeValue(s,"deposit_enabled"),c=n&&d;i[a]={id:r,code:a,name:o,info:s,active:c,fee:void 0,precision:void 0,limits:{amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}}}}return i}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={symbol:this.marketId(e)},r=await this.publicGetSymbolsSymbolOrders(this.extend(s,i));return this.parseOrderBook(r,void 0,"buys","sells","price","amount")}parseTrade(e,t){const i=this.safeString(e,"trade_id"),s=this.safeInteger2(e,"timestamp","order_time"),r=this.safeStringLower(e,"type"),a=this.safeFloat(e,"price"),o=this.safeFloat(e,"amount");let n=void 0;void 0!==a&&void 0!==o&&(n=o*a);const d=this.safeInteger(e,"entrust_id"),c=this.safeString(e,"symbol");let h=void 0;if(void 0!==c)if(c in this.markets_by_id)h=(t=this.markets_by_id[c]).symbol;else{const[e,t]=c.split("_");h=this.safeCurrencyCode(e)+"/"+this.safeCurrencyCode(t)}void 0===h&&void 0!==t&&(h=t.symbol);const l=this.safeFloat(e,"fees");let u=void 0;if(void 0!==l){u={cost:l,currency:void 0}}return{info:e,id:i,order:d,timestamp:s,datetime:this.iso8601(s),symbol:h,type:void 0,side:r,price:a,amount:o,cost:n,takerOrMaker:void 0,fee:u}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id},o=await this.publicGetSymbolsSymbolTrades(this.extend(a,s));return this.parseTrades(o,r,t,i)}async fetchMyTrades(e,t,i,s={}){if(void 0===e)throw new a(this.id+" fetchMyTrades requires a symbol argument");await this.loadMarkets();const r=this.market(e),o={symbol:r.id};void 0===i&&(o.limit=i);const n=await this.privateGetTrades(this.extend(o,s)),d=this.safeValue(n,"trades",[]);return this.parseTrades(d,r,t,i)}async fetchOrderTrades(e,t,i,s,r={}){await this.loadMarkets();const a={entrust_id:e};return await this.fetchMyTrades(t,i,s,this.extend(a,r))}parseOHLCV(e,t,i="1m",s,r){return[this.safeInteger(e,"timestamp"),this.safeFloat(e,"open_price"),this.safeFloat(e,"highest_price"),this.safeFloat(e,"lowest_price"),this.safeFloat(e,"current_price"),this.safeFloat(e,"volume")]}async fetchOHLCV(e,t="1m",i,s,r={}){if(void 0===i&&void 0===s)throw new a(this.id+" fetchOHLCV requires either a `since` argument or a `limit` argument (or both)");await this.loadMarkets();const o=this.market(e),n=this.parseTimeframe(t)*s*1e3;let d=this.milliseconds();void 0===i?i=d-n:d=this.sum(i,n);const c={symbol:o.id,from:i,to:d,step:this.timeframes[t]},h=await this.publicGetSymbolsSymbolKline(this.extend(c,r));return this.parseOHLCVs(h,o,t,i,s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetWallet(e),i={info:t};for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"id"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeFloat(s,"available"),o.used=this.safeFloat(s,"frozen"),i[a]=o}return this.parseBalance(i)}parseOrder(e,t){const i=this.safeString(e,"entrust_id"),s=this.milliseconds(),r=this.parseOrderStatus(this.safeString(e,"status")),a=this.findSymbol(this.safeString(e,"symbol"),t),o=this.safeFloat(e,"price"),n=this.safeFloat(e,"original_amount");let d=void 0,c=this.safeFloat(e,"executed_amount"),h=this.safeFloat(e,"remaining_amount");void 0!==n&&(void 0!==h&&void 0===c&&(c=n-h),void 0!==c&&(void 0===h&&(h=n-c),void 0===d&&void 0!==o&&(d=o*c)));const l=this.safeString(e,"side");return{id:i,info:e,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,symbol:a,type:void 0,side:l,price:o,amount:n,cost:void 0,average:void 0,filled:c,remaining:h,status:r,fee:void 0,trades:void 0}}parseOrderStatus(e){return this.safeString({0:"all",1:"open",2:"open",3:"closed",4:"canceled",5:"open",6:"closed"},e,e)}async createOrder(e,t,i,s,r,a={}){if("limit"!==t)throw new o(this.id+" allows limit orders only");await this.loadMarkets();const n=this.market(e),d={symbol:n.id,side:i.toLowerCase(),amount:parseFloat(this.amountToPrecision(e,s)),price:parseFloat(this.priceToPrecision(e,r))},c=await this.privatePostOrders(this.extend(d,a));return this.parseOrder(c,n)}async cancelOrder(e,t,i={}){await this.loadMarkets();const s=parseInt(e),r={id:s,entrust_id:s},a=await this.privateDeleteOrdersId(this.extend(r,i));return this.parseOrder(a)}async cancelAllOrders(e,t={}){if(void 0===e)throw new a(this.id+" cancelAllOrders requires a symbol argument");const i=this.safeString(t,"side");if(void 0===i)throw new a(this.id+" cancelAllOrders requires a `side` parameter ('buy' or 'sell')");await this.loadMarkets();const s={symbol:this.market(e).id,side:i};return await this.privateDeleteOrders(this.extend(s,t))}async fetchOrdersByStatus(e,t,i,s,r={}){if(void 0===t)throw new a(this.id+" fetchOrdersByStatus requires a symbol argument");await this.loadMarkets();const o=this.market(t);void 0===s&&(s=500);const n={symbol:o.id,status:e,offset:0,limit:s},d=await this.privateGetOrders(this.extend(n,r)),c=this.safeValue(d,"orders",[]);return this.parseOrders(c,o,i,s)}async fetchOpenOrders(e,t,i,s={}){return await this.fetchOrdersByStatus(5,e,t,i,s)}async fetchClosedOrders(e,t,i,s={}){return await this.fetchOrdersByStatus(3,e,t,i,s)}async fetchCanceledOrders(e,t,i,s={}){return await this.fetchOrdersByStatus(4,e,t,i,s)}async fetchOrder(e,t,i={}){await this.loadMarkets();const s={id:e},r=await this.privateGetOrdersId(this.extend(s,i));return this.parseOrder(r)}nonce(){return this.milliseconds()}sign(e,t="public",i="GET",s={},a,o){let n=this.urls.api+"/"+this.version+"/"+this.implodeParams(e,s),d=this.omit(s,this.extractParams(e));if("public"===t)Object.keys(d).length&&(n+="?"+this.urlencode(d));else if("token"===t)this.checkRequiredCredentials(),o=this.urlencode(d),a={"Content-Type":"application/x-www-form-urlencoded"};else{const t=this.nonce();this.checkRequiredCredentials();const s=this.safeString(this.options,"accessToken");if(void 0===s)throw new r(this.id+" "+e+" endpoint requires an accessToken option or a prior call to signIn() method");const c=this.safeInteger(this.options,"expires");if(void 0!==c&&t>=c)throw new r(this.id+" accessToken expired, supply a new accessToken or call the signIn() method");if(Object.keys(d).length&&(n+="?"+this.urlencode(d)),a={"Content-Type":"application/json","X-BM-TIMESTAMP":t.toString(),"X-BM-AUTHORIZATION":"Bearer "+s},"GET"!==i){d=this.keysort(d),o=this.json(d);const e=this.urlencode(d);a["X-BM-SIGNATURE"]=this.hmac(this.encode(e),this.encode(this.secret),"sha256")}}return{url:n,method:i,body:o,headers:a}}handleErrors(e,t,i,s,r,a,n,d,c){if(void 0===n)return;const h=this.id+" "+a,l=this.safeString2(n,"message","msg");if(void 0!==l){const e=this.exceptions.exact;if(l in e)throw new e[l](h);const t=this.exceptions.broad,i=this.findBroadlyMatchedKey(t,l);if(void 0!==i)throw new t[i](h);throw new o(h)}}}},function(e,t,i){"use strict";const s=i(1),{ArgumentsRequired:r,AuthenticationError:a,ExchangeError:o,InsufficientFunds:n,InvalidOrder:d}=i(0),{ROUND:c}=i(2);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"bitmax",name:"BitMax",countries:["CN"],rateLimit:500,certified:!1,has:{CORS:!1,fetchAccounts:!0,fetchTickers:!0,fetchOHLCV:!0,fetchMyTrades:!1,fetchOrder:!0,fetchOrders:!1,fetchOpenOrders:!0,fetchOrderTrades:!0,fetchClosedOrders:!0,fetchTransactions:!1,fetchCurrencies:!0,cancelAllOrders:!0,fetchDepositAddress:!0},timeframes:{"1m":"1","3m":"3","5m":"5","15m":"15","30m":"30","1h":"60","2h":"120","4h":"240","6h":"360","12h":"720","1d":"1d","1w":"1w","1M":"1m"},version:"v1",urls:{logo:"https://user-images.githubusercontent.com/1294454/66820319-19710880-ef49-11e9-8fbe-16be62a11992.jpg",api:"https://bitmax.io",test:"https://bitmax-test.io/api",www:"https://bitmax.io",doc:["https://github.com/bitmax-exchange/api-doc/blob/master/bitmax-api-doc-v1.2.md"],fees:"https://bitmax.io/#/feeRate/tradeRate",referral:"https://bitmax.io/#/register?inviteCode=EL6BXBQM"},api:{public:{get:["assets","depth","fees","quote","depth","trades","products","ticker/24hr","barhist","barhist/info","margin/ref-price"]},private:{get:["deposit","user/info","balance","order/batch","order/open","order","order/history","order/{coid}","order/fills/{coid}","transaction","margin/balance","margin/order/open","margin/order"],post:["margin/order","order","order/batch"],delete:["margin/order","order","order/all","order/batch"]}},fees:{trading:{tierBased:!1,percentage:!0,taker:4e-4,maker:4e-4}},options:{accountGroup:void 0,parseOrderToPrecision:!1},exceptions:{exact:{2100:a,6010:n,60060:d,600503:d},broad:{}}})}async fetchCurrencies(e={}){const t=await this.publicGetAssets(e),i={};for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"assetCode"),a=this.safeCurrencyCode(r),o=this.safeInteger(s,"precisionScale"),n=this.safeFloat(s,"withdrawalFee"),d="Normal"===this.safeString(s,"status");i[a]={id:r,code:a,info:s,type:void 0,name:this.safeString(s,"assetName"),active:d,fee:n,precision:o,limits:{amount:{min:Math.pow(10,-o),max:void 0},price:{min:Math.pow(10,-o),max:void 0},cost:{min:void 0,max:void 0},withdraw:{min:this.safeFloat(s,"minWithdrawalAmt"),max:void 0}}}}return i}async fetchMarkets(e={}){const t=await this.publicGetProducts(e),i=[];for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"symbol"),a=this.safeString(s,"baseAsset"),o=this.safeString(s,"quoteAsset"),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o),c=n+"/"+d,h={amount:this.safeInteger(s,"qtyScale"),price:this.safeInteger(s,"notionalScale")},l={id:r,symbol:c,base:n,quote:d,baseId:a,quoteId:o,info:s,active:"Normal"===this.safeString(s,"status"),precision:h,limits:{amount:{min:this.safeFloat(s,"minQty"),max:this.safeFloat(s,"maxQty")},price:{min:void 0,max:void 0},cost:{min:this.safeFloat(s,"minNotional"),max:this.safeFloat(s,"maxNotional")}}};i.push(l)}return i}calculateFee(e,t,i,s,r,a="taker",o={}){const n=this.markets[e];let d="quote";const h=n[a];let l=s*h,u=n.precision.price;return"sell"===i?l*=r:(d="base",u=n.precision.amount),l=this.decimalToPrecision(l,c,u,this.precisionMode),{type:a,currency:n[d],rate:h,cost:parseFloat(l)}}async fetchAccounts(e={}){let t=this.safeString(this.options,"accountGroup"),i=void 0;return void 0===t&&(i=await this.privateGetUserInfo(e),t=this.safeString(i,"accountGroup")),[{id:t,type:void 0,currency:void 0,info:i}]}async fetchBalance(e={}){await this.loadMarkets(),await this.loadAccounts();const t=await this.privateGetBalance(e),i={info:t},s=this.safeValue(t,"data",[]);for(let e=0;e<s.length;e++){const t=s[e],r=this.safeCurrencyCode(this.safeString(t,"assetCode")),a=this.account();a.free=this.safeFloat(t,"availableAmount"),a.used=this.safeFloat(t,"inOrderAmount"),a.total=this.safeFloat(t,"totalAmount"),i[r]=a}return this.parseBalance(i)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={symbol:this.market(e).symbol};void 0!==t&&(s.n=t);const r=await this.publicGetDepth(this.extend(s,i)),a=this.safeInteger(r,"ts"),o=this.parseOrderBook(r,a);return o.nonce=this.safeInteger(r,"seqnum"),o}parseTicker(e,t){const i=this.safeInteger(e,"barStartTime");let s=void 0;const r=this.safeString(e,"symbol");if(r in this.markets_by_id)t=this.markets_by_id[r];else if(void 0!==r){const[e,t]=r.split("/");s=this.safeCurrencyCode(e)+"/"+this.safeCurrencyCode(t)}void 0===s&&void 0!==t&&(s=t.symbol);const a=this.safeFloat(e,"closePrice");return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"highPrice"),low:this.safeFloat(e,"lowPrice"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:this.safeFloat(e,"openPrice"),close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeFloat(e,"volume"),quoteVolume:void 0,info:e}}parseTickers(e,t){const i=[];for(let t=0;t<e.length;t++)i.push(this.parseTicker(e[t]));return this.filterByArray(i,"symbol",t)}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={symbol:i.symbol},r=await this.publicGetTicker24hr(this.extend(s,t));return this.parseTicker(r,i)}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetTicker24hr(t);return this.parseTickers(i,e)}parseOHLCV(e,t,i="1m",s,r){return[this.safeInteger(e,"t"),this.safeFloat(e,"o"),this.safeFloat(e,"h"),this.safeFloat(e,"l"),this.safeFloat(e,"c"),this.safeFloat(e,"v")]}async fetchOHLCV(e,t="1m",i,s,r={}){await this.loadMarkets();const a=this.market(e),o={symbol:a.symbol,interval:this.timeframes[t]},n=this.parseTimeframe(t);void 0!==i?(o.from=i,void 0!==s&&(o.to=this.sum(o.from,s*n*1e3,1))):void 0!==s&&(o.to=this.milliseconds(),o.from=o.to-s*n*1e3-1);const d=await this.publicGetBarhist(this.extend(o,r));return this.parseOHLCVs(d,a,t,i,s)}parseTrade(e,t){const i=this.safeInteger(e,"t"),s=this.safeFloat(e,"p"),r=this.safeFloat(e,"q"),a=this.safeValue(e,"bm");let o=void 0;const n=this.safeString(e,"s");if(void 0!==n)if(n in this.markets_by_id)o=(t=this.markets_by_id[n]).symbol;else{const[e,i]=t.split("/");o=this.safeCurrencyCode(e)+"/"+this.safeCurrencyCode(i)}void 0===o&&void 0!==t&&(o=t.symbol);let d=void 0;const c=this.safeFloat(e,"fee");if(void 0!==c){const t=this.safeString(e,"fa");d={cost:c,currency:this.safeCurrencyCode(t)}}const h=this.safeString(e,"coid");let l=this.safeStringLower(e,"side");void 0===l&&void 0!==a&&(l=a?"buy":"sell");const u=this.safeStringLower(e,"orderType");return{info:e,timestamp:i,datetime:this.iso8601(i),symbol:o,id:void 0,order:h,type:u,takerOrMaker:void 0,side:l,price:s,amount:r,cost:s*r,fee:d}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id};void 0!==i&&(a.n=i);const o=await this.publicGetTrades(this.extend(a,s)),n=this.safeValue(o,"trades",[]);return this.parseTrades(n,r,t,i)}parseOrderStatus(e){return this.safeString({PendingNew:"open",New:"open",PartiallyFilled:"open",Filled:"closed",Canceled:"canceled",Rejected:"rejected"},e,e)}parseOrder(e,t){const i=this.parseOrderStatus(this.safeString(e,"status")),s=this.findSymbol(this.safeString(e,"symbol"),t),r=this.safeInteger(e,"sendingTime");let a=this.safeFloat(e,"orderPrice");const o=this.safeFloat(e,"orderQty"),n=this.safeFloat(e,"filledQty");let d=void 0,c=this.safeFloat(e,"cummulativeQuoteQty");void 0!==n&&(void 0!==o&&(d=o-n,this.options.parseOrderToPrecision&&(d=parseFloat(this.amountToPrecision(s,d))),d=Math.max(d,0)),void 0!==a&&void 0===c&&(c=a*n));const h=this.safeString(e,"coid");let l=this.safeString(e,"orderType");void 0!==l&&"market"===(l=l.toLowerCase())&&0===a&&void 0!==c&&void 0!==n&&c>0&&n>0&&(a=c/n);let u=this.safeString(e,"side");void 0!==u&&(u=u.toLowerCase());const f={cost:this.safeFloat(e,"fee"),currency:this.safeString(e,"feeAsset")},p=this.safeFloat(e,"avgPrice");return{info:e,id:h,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,symbol:s,type:l,side:u,price:a,amount:o,cost:c,average:p,filled:n,remaining:d,status:i,fee:f,trades:void 0}}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets(),await this.loadAccounts();const o=this.market(e),n={coid:this.coid(),symbol:o.id,orderQty:this.amountToPrecision(e,s),orderType:t,side:i};"limit"!==t&&"stop_limit"!==t||(n.orderPrice=this.priceToPrecision(e,r));const d=await this.privatePostOrder(this.extend(n,a)),c=this.safeValue(d,"data",{});return this.parseOrder(c,o)}async fetchOrder(e,t,i={}){await this.loadMarkets(),await this.loadAccounts();let s=void 0;void 0!==t&&(s=this.market(t));const r={coid:e},a=await this.privateGetOrderCoid(this.extend(r,i)),o=this.safeValue(a,"data",{});return this.parseOrder(o,s)}async fetchOrderTrades(e,t,i,s,r={}){await this.loadMarkets(),await this.loadAccounts();let a=void 0;void 0!==t&&(a=this.market(t));const o={coid:e},n=await this.privateGetOrderFillsCoid(this.extend(o,r)),d=this.safeValue(n,"data",{});return this.parseTrades(d,a,i,s)}async fetchOpenOrders(e,t,i,s={}){await this.loadMarkets(),await this.loadAccounts();let r=void 0;const a={};void 0!==e&&(r=this.market(e),a.symbol=r.id);const o=await this.privateGetOrderOpen(this.extend(a,s)),n=this.safeValue(o,"data",[]);return this.parseOrders(n,r,t,i)}async fetchClosedOrders(e,t,i,s={}){await this.loadMarkets(),await this.loadAccounts();let r=void 0;const a={};void 0!==e&&(r=this.market(e),a.symbol=r.id),void 0!==t&&(a.startTime=t),void 0!==i&&(a.pageSize=i);const o=await this.privateGetOrderHistory(this.extend(a,s)),n=this.safeValue(o,"data",{}),d=this.safeValue(n,"data",[]);return this.parseOrders(d,r,t,i)}async cancelOrder(e,t,i={}){if(void 0===t)throw new r(this.id+" cancelOrder requires a symbol argument");await this.loadMarkets(),await this.loadAccounts();const s={symbol:this.market(t).id,coid:this.coid(),origCoid:e},a=await this.privateDeleteOrder(this.extend(s,i)),o=this.safeValue(a,"data",{});return this.parseOrder(o)}async cancelAllOrders(e,t={}){await this.loadMarkets(),await this.loadAccounts();const i={};let s=void 0;return void 0!==e&&(s=this.market(e),i.symbol=s.id),await this.privateDeleteOrderAll(this.extend(i,t))}coid(){return this.uuid().split("-").join("").slice(0,32)}async fetchDepositAddress(e,t={}){await this.loadMarkets(),await this.loadAccounts();const i=this.currency(e),s={requestId:this.coid(),assetCode:i.id},r=await this.privateGetDeposit(this.extend(s,t)),a=this.safeValue(r,"data",{}),o=this.safeString(a,"address");return this.checkAddress(o),{currency:e,address:o,info:r}}sign(e,t="public",i="GET",s={},r,a){let o="/api/"+this.version+"/"+this.implodeParams(e,s);const n=this.omit(s,this.extractParams(e));if("public"===t)Object.keys(n).length&&(o+="?"+this.urlencode(n));else{this.checkRequiredCredentials();let t=this.safeString(this.options,"accountGroup");void 0===t&&void 0!==this.accounts&&(t=this.accounts[0].id),void 0!==t&&(o="/"+t+o);const s=this.safeString(n,"coid");n.time=this.milliseconds().toString();let d=n.time+"+"+e.replace("/{coid}","");r={"x-auth-key":this.apiKey,"x-auth-timestamp":n.time,"Content-Type":"application/json"},void 0!==s&&(d+="+"+s,r["x-auth-coid"]=s);const c=this.hmac(this.encode(d),this.encode(this.secret),"sha256","base64");r["x-auth-signature"]=c,"GET"!==i&&(a=this.json(n))}return{url:o=this.urls.api+o,method:i,body:a,headers:r}}handleErrors(e,t,i,s,r,a,n,d,c){if(void 0===n)return;const h=this.safeString(n,"code"),l=this.safeString(n,"message");if(void 0!==h&&"0"!==h||void 0!==l){const e=this.id+" "+a,t=this.exceptions.exact;if(h in t)throw new t[h](e);if(l in t)throw new t[l](e);const i=this.exceptions.broad,s=this.findBroadlyMatchedKey(i,l);if(void 0!==s)throw new i[s](e);throw new o(e)}}}},function(e,t,i){"use strict";const s=i(1),{TICK_SIZE:r}=i(2),{AuthenticationError:a,BadRequest:o,DDoSProtection:n,ExchangeError:d,ExchangeNotAvailable:c,InsufficientFunds:h,InvalidOrder:l,OrderNotFound:u,PermissionDenied:f}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"bitmex",name:"BitMEX",countries:["SC"],version:"v1",userAgent:void 0,rateLimit:2e3,has:{CORS:!1,fetchOHLCV:!0,withdraw:!0,editOrder:!0,fetchOrder:!0,fetchOrders:!0,fetchOpenOrders:!0,fetchClosedOrders:!0,fetchMyTrades:!0,fetchLedger:!0,fetchTransactions:"emulated"},timeframes:{"1m":"1m","5m":"5m","1h":"1h","1d":"1d"},urls:{test:"https://testnet.bitmex.com",logo:"https://user-images.githubusercontent.com/1294454/27766319-f653c6e6-5ed4-11e7-933d-f0bc3699ae8f.jpg",api:"https://www.bitmex.com",www:"https://www.bitmex.com",doc:["https://www.bitmex.com/app/apiOverview","https://github.com/BitMEX/api-connectors/tree/master/official-http"],fees:"https://www.bitmex.com/app/fees",referral:"https://www.bitmex.com/register/rm3C16"},api:{public:{get:["announcement","announcement/urgent","funding","instrument","instrument/active","instrument/activeAndIndices","instrument/activeIntervals","instrument/compositeIndex","instrument/indices","insurance","leaderboard","liquidation","orderBook","orderBook/L2","quote","quote/bucketed","schema","schema/websocketHelp","settlement","stats","stats/history","trade","trade/bucketed"]},private:{get:["apiKey","chat","chat/channels","chat/connected","execution","execution/tradeHistory","notification","order","position","user","user/affiliateStatus","user/checkReferralCode","user/commission","user/depositAddress","user/margin","user/minWithdrawalFee","user/wallet","user/walletHistory","user/walletSummary"],post:["apiKey","apiKey/disable","apiKey/enable","chat","order","order/bulk","order/cancelAllAfter","order/closePosition","position/isolate","position/leverage","position/riskLimit","position/transferMargin","user/cancelWithdrawal","user/confirmEmail","user/confirmEnableTFA","user/confirmWithdrawal","user/disableTFA","user/logout","user/logoutAll","user/preferences","user/requestEnableTFA","user/requestWithdrawal"],put:["order","order/bulk","user"],delete:["apiKey","order","order/all"]}},exceptions:{exact:{"Invalid API Key.":a,"This key is disabled.":f,"Access Denied":f,"Duplicate clOrdID":l,"orderQty is invalid":l,"Invalid price":l,"Invalid stopPx for ordType":l},broad:{"Signature not valid":a,overloaded:c,"Account has insufficient Available Balance":h}},precisionMode:r,options:{"api-expires":5,fetchOHLCVOpenTimestamp:!0}})}async fetchMarkets(e={}){const t=await this.publicGetInstrumentActiveAndIndices(e),i=[];for(let e=0;e<t.length;e++){const s=t[e],r="Unlisted"!==s.state,a=s.symbol,o=s.underlying,n=s.quoteCurrency,d=o+n,c=this.safeCurrencyCode(o),h=this.safeCurrencyCode(n),l=a===d,u=this.safeString2(s,"positionCurrency","quoteCurrency");let f=void 0,p=!1,m=!1;const y=this.safeCurrencyCode(u);let b=a;l?(f="swap",b=c+"/"+h):a.indexOf("B_")>=0?(m=!0,f="prediction"):(p=!0,f="future");const v={amount:void 0,price:void 0},g=this.safeFloat(s,"lotSize"),w=this.safeFloat(s,"tickSize");void 0!==g&&(v.amount=g),void 0!==w&&(v.price=w);const k={amount:{min:void 0,max:void 0},price:{min:w,max:this.safeFloat(s,"maxPrice")},cost:{min:void 0,max:void 0}};k[y===h?"cost":"amount"]={min:g,max:this.safeFloat(s,"maxOrderQty")},i.push({id:a,symbol:b,base:c,quote:h,baseId:o,quoteId:n,active:r,precision:v,limits:k,taker:this.safeFloat(s,"takerFee"),maker:this.safeFloat(s,"makerFee"),type:f,spot:!1,swap:l,future:p,prediction:m,info:s})}return i}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetUserMargin(this.extend({currency:"all"},e)),i={info:t};for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeFloat(s,"availableMargin"),o.total=this.safeFloat(s,"marginBalance"),"BTC"===a&&(o.free=1e-8*o.free,o.total=1e-8*o.total),i[a]=o}return this.parseBalance(i)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={symbol:this.market(e).id};void 0!==t&&(s.depth=t);const r=await this.publicGetOrderBookL2(this.extend(s,i)),a={bids:[],asks:[],timestamp:void 0,datetime:void 0,nonce:void 0};for(let e=0;e<r.length;e++){const t=r[e],i="Sell"===t.side?"asks":"bids",s=this.safeFloat(t,"size"),o=this.safeFloat(t,"price");void 0!==o&&a[i].push([o,s])}return a.bids=this.sortBy(a.bids,0,!0),a.asks=this.sortBy(a.asks,0),a}async fetchOrder(e,t,i={}){const s={filter:{orderID:e}},r=await this.fetchOrders(t,void 0,void 0,this.deepExtend(s,i));if(1===r.length)return r[0];throw new u(this.id+": The order "+e+" not found.")}async fetchOrders(e,t,i,s={}){await this.loadMarkets();let r=void 0,a={};void 0!==e&&(r=this.market(e),a.symbol=r.id),void 0!==t&&(a.startTime=this.iso8601(t)),void 0!==i&&(a.count=i),"filter"in(a=this.deepExtend(a,s))&&(a.filter=this.json(a.filter));const o=await this.privateGetOrder(a);return this.parseOrders(o,r,t,i)}async fetchOpenOrders(e,t,i,s={}){return await this.fetchOrders(e,t,i,this.deepExtend({filter:{open:!0}},s))}async fetchClosedOrders(e,t,i,s={}){const r=await this.fetchOrders(e,t,i,s);return this.filterBy(r,"status","closed")}async fetchMyTrades(e,t,i,s={}){await this.loadMarkets();let r=void 0,a={};void 0!==e&&(r=this.market(e),a.symbol=r.id),void 0!==t&&(a.startTime=this.iso8601(t)),void 0!==i&&(a.count=i),"filter"in(a=this.deepExtend(a,s))&&(a.filter=this.json(a.filter));const o=await this.privateGetExecutionTradeHistory(a);return this.parseTrades(o,r,t,i)}parseLedgerEntryType(e){return this.safeString({Withdrawal:"transaction",RealisedPNL:"margin",Deposit:"transaction",Transfer:"transfer",AffiliatePayout:"referral"},e,e)}parseLedgerEntry(e,t){const i=this.safeString(e,"transactID"),s=this.safeString(e,"account"),r=this.safeString(e,"tx"),a=this.parseLedgerEntryType(this.safeString(e,"transactType")),o=this.safeString(e,"currency"),n=this.safeCurrencyCode(o,t);let d=this.safeFloat(e,"amount");void 0!==d&&(d*=1e-8);const c=this.parse8601(this.safeString(e,"transactTime"));let h=this.safeFloat(e,"fee",0);void 0!==h&&(h*=1e-8);const l={cost:h,currency:n};let u=this.safeFloat(e,"walletBalance");void 0!==u&&(u*=1e-8);const f=this.sum(u,-d);let p=void 0;d<0?(p="out",d=Math.abs(d)):p="in";const m=this.parseTransactionStatus(this.safeString(e,"transactStatus"));return{id:i,info:e,timestamp:c,datetime:this.iso8601(c),direction:p,account:s,referenceId:r,referenceAccount:void 0,type:a,currency:n,amount:d,before:f,after:u,status:m,fee:l}}async fetchLedger(e,t,i,s={}){await this.loadMarkets();let r=void 0;void 0!==e&&(r=this.currency(e));const a={};void 0!==i&&(a.count=i);const o=await this.privateGetUserWalletHistory(this.extend(a,s));return this.parseLedger(o,r,t,i)}async fetchTransactions(e,t,i,s={}){await this.loadMarkets();const r={};void 0!==i&&(r.count=i);const a=await this.privateGetUserWalletHistory(this.extend(r,s)),o=this.filterByArray(a,"transactType",["Withdrawal","Deposit"],!1);let n=void 0;return void 0!==e&&(n=this.currency(e)),this.parseTransactions(o,n,t,i)}parseTransactionStatus(e){return this.safeString({Canceled:"canceled",Completed:"ok",Pending:"pending"},e,e)}parseTransaction(e,t){const i=this.safeString(e,"transactID"),s=this.parse8601(this.safeString(e,"transactTime")),r=this.parse8601(this.safeString(e,"timestamp")),a=this.safeStringLower(e,"transactType");let o=void 0,n=void 0,d=void 0;"withdrawal"===a&&(o=this.safeString(e,"address"),n=this.safeString(e,"tx"),d=o);let c=this.safeInteger(e,"amount");void 0!==c&&(c=1e-8*Math.abs(c));let h=this.safeInteger(e,"fee");void 0!==h&&(h*=1e-8);const l={cost:h,currency:"BTC"};let u=this.safeString(e,"transactStatus");return void 0!==u&&(u=this.parseTransactionStatus(u)),{info:e,id:i,txid:void 0,timestamp:s,datetime:this.iso8601(s),addressFrom:n,address:o,addressTo:d,tagFrom:void 0,tag:void 0,tagTo:void 0,type:a,amount:c,currency:"BTC",status:u,updated:r,comment:void 0,fee:l}}async fetchTicker(e,t={}){if(await this.loadMarkets(),!this.market(e).active)throw new d(this.id+": symbol "+e+" is delisted");const i=await this.fetchTickers([e],t),s=this.safeValue(i,e);if(void 0===s)throw new d(this.id+" ticker symbol "+e+" not found");return s}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetInstrumentActiveAndIndices(t),s={};for(let e=0;e<i.length;e++){const t=this.parseTicker(i[e]),r=this.safeString(t,"symbol");void 0!==r&&(s[r]=t)}return s}parseTicker(e,t){let i=void 0;const s=this.safeString(e,"symbol");void 0!==(t=this.safeValue(this.markets_by_id,s,t))&&(i=t.symbol);const r=this.parse8601(this.safeString(e,"timestamp")),a=this.safeFloat(e,"prevPrice24h"),o=this.safeFloat(e,"lastPrice");let n=void 0,d=void 0;return void 0!==o&&void 0!==a&&(n=o-a,a>0&&(d=n/a*100)),{symbol:i,timestamp:r,datetime:this.iso8601(r),high:this.safeFloat(e,"highPrice"),low:this.safeFloat(e,"lowPrice"),bid:this.safeFloat(e,"bidPrice"),bidVolume:void 0,ask:this.safeFloat(e,"askPrice"),askVolume:void 0,vwap:this.safeFloat(e,"vwap"),open:a,close:o,last:o,previousClose:void 0,change:n,percentage:d,average:this.sum(a,o)/2,baseVolume:this.safeFloat(e,"homeNotional24h"),quoteVolume:this.safeFloat(e,"foreignNotional24h"),info:e}}parseOHLCV(e,t,i="1m",s,r){return[this.parse8601(this.safeString(e,"timestamp")),this.safeFloat(e,"open"),this.safeFloat(e,"high"),this.safeFloat(e,"low"),this.safeFloat(e,"close"),this.safeFloat(e,"volume")]}async fetchOHLCV(e,t="1m",i,s,r={}){await this.loadMarkets();const a=this.market(e),o={symbol:a.id,binSize:this.timeframes[t],partial:!0};void 0!==s&&(o.count=s);const n=1e3*this.parseTimeframe(t),d=this.safeValue(this.options,"fetchOHLCVOpenTimestamp",!0);if(void 0!==i){let e=i;d&&(e=this.sum(e,n));const t=this.ymdhms(e);o.startTime=t}const c=await this.publicGetTradeBucketed(this.extend(o,r)),h=this.parseOHLCVs(c,a,t,i,s);if(d)for(let e=0;e<h.length;e++)h[e][0]=h[e][0]-n;return h}parseTrade(e,t){const i=this.parse8601(this.safeString(e,"timestamp")),s=this.safeFloat(e,"price"),r=this.safeFloat2(e,"size","lastQty"),a=this.safeString(e,"trdMatchID"),o=this.safeString(e,"orderID"),n=this.safeStringLower(e,"side");let d=this.safeFloat(e,"execCost");void 0!==d&&(d=Math.abs(d)/1e8);let c=void 0;if("execComm"in e){let t=this.safeFloat(e,"execComm");t/=1e8;const i=this.safeString(e,"settlCurrency");c={cost:t,currency:this.safeCurrencyCode(i),rate:this.safeFloat(e,"commission")}}let h=void 0;void 0!==c&&(h=c.cost<0?"maker":"taker");let l=void 0;const u=this.safeString(e,"symbol");void 0!==u&&(l=u in this.markets_by_id?this.markets_by_id[u].symbol:u);const f=this.safeStringLower(e,"ordType");return{info:e,timestamp:i,datetime:this.iso8601(i),symbol:l,id:a,order:o,type:f,takerOrMaker:h,side:n,price:s,cost:d,amount:r,fee:c}}parseOrderStatus(e){return this.safeString({New:"open",PartiallyFilled:"open",Filled:"closed",DoneForDay:"open",Canceled:"canceled",PendingCancel:"open",PendingNew:"open",Rejected:"rejected",Expired:"expired",Stopped:"open",Untriggered:"open",Triggered:"open"},e,e)}parseOrder(e,t){const i=this.parseOrderStatus(this.safeString(e,"ordStatus"));let s=void 0;if(void 0!==t)s=t.symbol;else{const i=this.safeString(e,"symbol");i in this.markets_by_id&&(s=(t=this.markets_by_id[i]).symbol)}const r=this.parse8601(this.safeString(e,"timestamp")),a=this.parse8601(this.safeString(e,"transactTime")),o=this.safeFloat(e,"price"),n=this.safeFloat(e,"orderQty"),d=this.safeFloat(e,"cumQty",0);let c=void 0;void 0!==n&&void 0!==d&&(c=Math.max(n-d,0));const h=this.safeFloat(e,"avgPx");let l=void 0;void 0!==d&&(void 0!==h?l=h*d:void 0!==o&&(l=o*d));const u=this.safeString(e,"orderID"),f=this.safeStringLower(e,"ordType"),p=this.safeStringLower(e,"side");return{info:e,id:u,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:a,symbol:s,type:f,side:p,price:o,amount:n,cost:l,average:h,filled:d,remaining:c,status:i,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id};void 0!==t&&(a.startTime=this.iso8601(t)),void 0!==i&&(a.count=i);const o=await this.publicGetTrade(this.extend(a,s));return this.parseTrades(o,r,t,i)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o={symbol:this.marketId(e),side:this.capitalize(i),orderQty:s,ordType:this.capitalize(t)};void 0!==r&&(o.price=r);const n=await this.privatePostOrder(this.extend(o,a)),d=this.parseOrder(n),c=this.safeString(d,"id");return this.orders[c]=d,this.extend({info:n},d)}async editOrder(e,t,i,s,r,a,o={}){await this.loadMarkets();const n={orderID:e};void 0!==r&&(n.orderQty=r),void 0!==a&&(n.price=a);const d=await this.privatePutOrder(this.extend(n,o)),c=this.parseOrder(d);return this.orders[c.id]=c,this.extend({info:d},c)}async cancelOrder(e,t,i={}){await this.loadMarkets();const s=await this.privateDeleteOrder(this.extend({orderID:e},i));let r=s[0];const a=this.safeString(r,"error");if(void 0!==a&&a.indexOf("Unable to cancel order due to existing state")>=0)throw new u(this.id+" cancelOrder() failed: "+a);return r=this.parseOrder(r),this.orders[r.id]=r,this.extend({info:s},r)}isFiat(e){return"EUR"===e||"PLN"===e}async withdraw(e,t,i,s,r={}){if(this.checkAddress(i),await this.loadMarkets(),"BTC"!==e)throw new d(this.id+" supoprts BTC withdrawals only, other currencies coming soon...");const a={currency:"XBt",amount:t,address:i},o=await this.privatePostUserRequestWithdrawal(this.extend(a,r));return{info:o,id:o.transactID}}handleErrors(e,t,i,s,r,a,c,h,l){if(void 0!==c){if(429===e)throw new n(this.id+" "+a);if(e>=400){const t=this.safeValue(c,"error",{}),i=this.safeString(t,"message"),s=this.id+" "+a,r=this.exceptions.exact;if(i in r)throw new r[i](s);const n=this.exceptions.broad,h=this.findBroadlyMatchedKey(n,i);if(void 0!==h)throw new n[h](s);if(400===e)throw new o(s);throw new d(s)}}}nonce(){return this.milliseconds()}sign(e,t="public",i="GET",s={},r,a){let o="/api/"+this.version+"/"+e;if("GET"===i)Object.keys(s).length&&(o+="?"+this.urlencode(s));else{const e=this.safeString(s,"_format");void 0!==e&&(o+="?"+this.urlencode({_format:e}),s=this.omit(s,"_format"))}const n=this.urls.api+o;if(this.apiKey&&this.secret){let e=i+o,t=this.safeInteger(this.options,"api-expires");r={"Content-Type":"application/json","api-key":this.apiKey},e+=t=(t=this.sum(this.seconds(),t)).toString(),r["api-expires"]=t,"POST"!==i&&"PUT"!==i&&"DELETE"!==i||Object.keys(s).length&&(e+=a=this.json(s)),r["api-signature"]=this.hmac(this.encode(e),this.encode(this.secret))}return{url:n,method:i,body:a,headers:r}}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,InvalidNonce:a,AuthenticationError:o,OrderNotFound:n}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"bitso",name:"Bitso",countries:["MX"],rateLimit:2e3,version:"v3",has:{CORS:!0,fetchMyTrades:!0,fetchOpenOrders:!0,fetchOrder:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766335-715ce7aa-5ed5-11e7-88a8-173a27bb30fe.jpg",api:"https://api.bitso.com",www:"https://bitso.com",doc:"https://bitso.com/api_info",fees:"https://bitso.com/fees?l=es",referral:"https://bitso.com/?ref=itej"},options:{precision:{XRP:6,MXN:2,TUSD:2},defaultPrecision:8},api:{public:{get:["available_books","ticker","order_book","trades"]},private:{get:["account_status","balance","fees","fundings","fundings/{fid}","funding_destination","kyc_documents","ledger","ledger/trades","ledger/fees","ledger/fundings","ledger/withdrawals","mx_bank_codes","open_orders","order_trades/{oid}","orders/{oid}","user_trades","user_trades/{tid}","withdrawals/","withdrawals/{wid}"],post:["bitcoin_withdrawal","debit_card_withdrawal","ether_withdrawal","ripple_withdrawal","bcash_withdrawal","litecoin_withdrawal","orders","phone_number","phone_verification","phone_withdrawal","spei_withdrawal","ripple_withdrawal","bcash_withdrawal","litecoin_withdrawal"],delete:["orders/{oid}","orders/all"]}},exceptions:{"0201":o,104:a}})}async fetchMarkets(e={}){const t=await this.publicGetAvailableBooks(e),i=this.safeValue(t,"payload"),s=[];for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"book"),[a,o]=r.split("_");let n=a.toUpperCase(),d=o.toUpperCase();const c=(n=this.safeCurrencyCode(n))+"/"+(d=this.safeCurrencyCode(d)),h={amount:{min:this.safeFloat(t,"minimum_amount"),max:this.safeFloat(t,"maximum_amount")},price:{min:this.safeFloat(t,"minimum_price"),max:this.safeFloat(t,"maximum_price")},cost:{min:this.safeFloat(t,"minimum_value"),max:this.safeFloat(t,"maximum_value")}},l={amount:this.safeInteger(this.options.precision,n,this.options.defaultPrecision),price:this.safeInteger(this.options.precision,d,this.options.defaultPrecision)};s.push({id:r,symbol:c,base:n,quote:d,baseId:a,quoteId:o,info:t,limits:h,precision:l})}return s}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalance(e),i=this.safeValue(t.payload,"balances"),s={info:t};for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"currency"),a=this.safeCurrencyCode(r),o={free:this.safeFloat(t,"available"),used:this.safeFloat(t,"locked"),total:this.safeFloat(t,"total")};s[a]=o}return this.parseBalance(s)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={book:this.marketId(e)},r=await this.publicGetOrderBook(this.extend(s,i)),a=this.safeValue(r,"payload"),o=this.parse8601(this.safeString(a,"updated_at"));return this.parseOrderBook(a,o,"bids","asks","price","amount")}async fetchTicker(e,t={}){await this.loadMarkets();const i={book:this.marketId(e)},s=await this.publicGetTicker(this.extend(i,t)),r=this.safeValue(s,"payload"),a=this.parse8601(this.safeString(r,"created_at")),o=this.safeFloat(r,"vwap"),n=this.safeFloat(r,"volume");let d=void 0;void 0!==n&&void 0!==o&&(d=n*o);const c=this.safeFloat(r,"last");return{symbol:e,timestamp:a,datetime:this.iso8601(a),high:this.safeFloat(r,"high"),low:this.safeFloat(r,"low"),bid:this.safeFloat(r,"bid"),bidVolume:void 0,ask:this.safeFloat(r,"ask"),askVolume:void 0,vwap:o,open:void 0,close:c,last:c,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:n,quoteVolume:d,info:r}}parseTrade(e,t){const i=this.parse8601(this.safeString(e,"created_at"));let s=void 0;if(void 0===t){const i=this.safeString(e,"book");i in this.markets_by_id&&(t=this.markets_by_id[i])}void 0!==t&&(s=t.symbol);const r=this.safeString2(e,"side","maker_side");let a=this.safeFloat2(e,"amount","major");void 0!==a&&(a=Math.abs(a));let o=void 0;const n=this.safeFloat(e,"fees_amount");if(void 0!==n){const t=this.safeString(e,"fees_currency");o={cost:n,currency:this.safeCurrencyCode(t)}}let d=this.safeFloat(e,"minor");void 0!==d&&(d=Math.abs(d));const c=this.safeFloat(e,"price"),h=this.safeString(e,"oid");return{id:this.safeString(e,"tid"),info:e,timestamp:i,datetime:this.iso8601(i),symbol:s,order:h,type:void 0,side:r,takerOrMaker:void 0,price:c,amount:a,cost:d,fee:o}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={book:r.id},o=await this.publicGetTrades(this.extend(a,s));return this.parseTrades(o.payload,r,t,i)}async fetchMyTrades(e,t,i=25,s={}){await this.loadMarkets();const a=this.market(e),o="marker"in s;if(void 0!==t&&!o)throw new r(this.id+" fetchMyTrades does not support fetching trades starting from a timestamp with the `since` argument, use the `marker` extra param to filter starting from an integer trade id");o&&(s=this.extend(s,{marker:parseInt(s.marker)}));const n={book:a.id,limit:i},d=await this.privateGetUserTrades(this.extend(n,s));return this.parseTrades(d.payload,a,t,i)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o={book:this.marketId(e),side:i,type:t,major:this.amountToPrecision(e,s)};"limit"===t&&(o.price=this.priceToPrecision(e,r));const n=await this.privatePostOrders(this.extend(o,a));return{info:n,id:this.safeString(n.payload,"oid")}}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={oid:e};return await this.privateDeleteOrdersOid(this.extend(s,i))}parseOrderStatus(e){return this.safeString({"partial-fill":"open",completed:"closed"},e,e)}parseOrder(e,t){const i=this.safeString(e,"oid"),s=this.safeString(e,"side"),r=this.parseOrderStatus(this.safeString(e,"status"));let a=void 0;const o=this.safeString(e,"book");if(void 0!==o)if(o in this.markets_by_id)t=this.markets_by_id[o];else{const[e,t]=o.split("_");a=this.safeCurrencyCode(e)+"/"+this.safeCurrencyCode(t)}void 0===a&&void 0!==t&&(a=t.symbol);const n=this.safeString(e,"type"),d=this.parse8601(this.safeString(e,"created_at")),c=this.safeFloat(e,"price"),h=this.safeFloat(e,"original_amount"),l=this.safeFloat(e,"unfilled_amount");let u=void 0;return void 0!==h&&void 0!==l&&(u=h-l),{info:e,id:i,timestamp:d,datetime:this.iso8601(d),lastTradeTimestamp:void 0,symbol:a,type:n,side:s,price:c,amount:h,cost:void 0,remaining:l,filled:u,status:r,fee:void 0}}async fetchOpenOrders(e,t,i=25,s={}){await this.loadMarkets();const a=this.market(e),o="marker"in s;if(void 0!==t&&!o)throw r(this.id+" fetchOpenOrders does not support fetching orders starting from a timestamp with the `since` argument, use the `marker` extra param to filter starting from an integer trade id");o&&(s=this.extend(s,{marker:parseInt(s.marker)}));const n={book:a.id,limit:i},d=await this.privateGetOpenOrders(this.extend(n,s));return this.parseOrders(d.payload,a,t,i)}async fetchOrder(e,t,i={}){await this.loadMarkets();const s=await this.privateGetOrdersOid({oid:e}),r=this.safeValue(s,"payload");if(Array.isArray(r)){if(1===s.payload.length)return this.parseOrder(r[0])}throw new n(this.id+": The order "+e+" not found.")}async fetchOrderTrades(e,t,i,s,r={}){await this.loadMarkets();const a=this.market(t),o={oid:e},n=await this.privateGetOrderTradesOid(this.extend(o,r));return this.parseTrades(n.payload,a)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={fund_currency:this.currency(e).id},s=await this.privateGetFundingDestination(this.extend(i,t));let r=this.safeString(s.payload,"account_identifier"),a=void 0;if("XRP"===e){const e=r.split("?dt=");r=e[0],a=e[1]}return this.checkAddress(r),{currency:e,address:r,tag:a,info:s}}async withdraw(e,t,i,s,a={}){this.checkAddress(i),await this.loadMarkets();const o={BTC:"Bitcoin",ETH:"Ether",XRP:"Ripple",BCH:"Bcash",LTC:"Litecoin"},n=e in o?o[e]:void 0;if(void 0===n)throw new r(this.id+" not valid withdraw coin: "+e);const d={amount:t,address:i,destination_tag:s},c="privatePost"+n+"Withdrawal",h=await this[c](this.extend(d,a));return{info:h,id:this.safeString(h.payload,"wid")}}sign(e,t="public",i="GET",s={},r,a){let o="/"+this.version+"/"+this.implodeParams(e,s);const n=this.omit(s,this.extractParams(e));"GET"===i&&Object.keys(n).length&&(o+="?"+this.urlencode(n));const d=this.urls.api+o;if("private"===t){this.checkRequiredCredentials();const e=this.nonce().toString();let t=[e,i,o].join("");"GET"!==i&&Object.keys(n).length&&(t+=a=this.json(n));const s=this.hmac(this.encode(t),this.encode(this.secret));r={Authorization:"Bitso "+(this.apiKey+":"+e+":"+s),"Content-Type":"application/json"}}return{url:d,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,o,n,d,c){if(void 0!==n&&"success"in n){let e=this.safeValue(n,"success",!1);if("string"==typeof e&&(e="true"===e||"1"===e),!e){const e=this.id+" "+this.json(n),t=this.safeValue(n,"error");if(void 0===t)throw new r(e);const i=this.safeString(t,"code"),s=this.exceptions;throw i in s?new s[i](e):new r(e)}}}async request(e,t="public",i="GET",s={},a,o){const n=await this.fetch2(e,t,i,s,a,o);if("success"in n&&n.success)return n;throw new r(this.id+" "+this.json(n))}}},function(e,t,i){"use strict";const s=i(1),{AuthenticationError:r,ExchangeError:a,NotSupported:o,PermissionDenied:n,InvalidNonce:d,OrderNotFound:c,InsufficientFunds:h,InvalidAddress:l,InvalidOrder:u}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"bitstamp",name:"Bitstamp",countries:["GB"],rateLimit:1e3,version:"v2",userAgent:this.userAgents.chrome,has:{CORS:!0,fetchDepositAddress:!0,fetchOrder:"emulated",fetchOpenOrders:!0,fetchMyTrades:!0,fetchTransactions:!0,fetchWithdrawals:!0,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27786377-8c8ab57e-5fe9-11e7-8ea4-2b05b6bcceec.jpg",api:"https://www.bitstamp.net/api",www:"https://www.bitstamp.net",doc:"https://www.bitstamp.net/api"},requiredCredentials:{apiKey:!0,secret:!0,uid:!0},api:{public:{get:["order_book/{pair}/","ticker_hour/{pair}/","ticker/{pair}/","transactions/{pair}/","trading-pairs-info/"]},private:{post:["balance/","balance/{pair}/","bch_withdrawal/","bch_address/","user_transactions/","user_transactions/{pair}/","open_orders/all/","open_orders/{pair}/","order_status/","cancel_order/","buy/{pair}/","buy/market/{pair}/","buy/instant/{pair}/","sell/{pair}/","sell/market/{pair}/","sell/instant/{pair}/","ltc_withdrawal/","ltc_address/","eth_withdrawal/","eth_address/","xrp_withdrawal/","xrp_address/","transfer-to-main/","transfer-from-main/","withdrawal-requests/","withdrawal/open/","withdrawal/status/","withdrawal/cancel/","liquidation_address/new/","liquidation_address/info/"]},v1:{post:["bitcoin_deposit_address/","unconfirmed_btc/","bitcoin_withdrawal/","ripple_withdrawal/","ripple_address/"]}},fees:{trading:{tierBased:!0,percentage:!0,taker:.0025,maker:.0025,tiers:{taker:[[0,.0025],[2e4,.0024],[1e5,.0022],[4e5,.002],[6e5,.0015],[1e6,.14/100],[2e6,.0013],[4e6,.0012],[2e7,.0011],[20000001,.001]],maker:[[0,.0025],[2e4,.0024],[1e5,.0022],[4e5,.002],[6e5,.0015],[1e6,.14/100],[2e6,.0013],[4e6,.0012],[2e7,.0011],[20000001,.001]]}},funding:{tierBased:!1,percentage:!1,withdraw:{BTC:0,BCH:0,LTC:0,ETH:0,XRP:0,USD:25,EUR:.9},deposit:{BTC:0,BCH:0,LTC:0,ETH:0,XRP:0,USD:25,EUR:0}}},exceptions:{exact:{"No permission found":n,"API key not found":r,"IP address not allowed":n,"Invalid nonce":d,"Invalid signature":r,"Authentication failed":r,"Missing key, signature and nonce parameters":r,"Your account is frozen":n,"Please update your profile with your FATCA information, before using API.":n,"Order not found":c,"Price is more than 20% below market price.":u},broad:{"Minimum order size is":u,"Check your account balance for details.":h,"Ensure this value has at least":l}}})}async fetchMarkets(e={}){const t=await this.publicGetTradingPairsInfo(e),i=[];for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"name");let[a,o]=r.split("/");const n=a.toLowerCase(),d=o.toLowerCase(),c=(a=this.safeCurrencyCode(a))+"/"+(o=this.safeCurrencyCode(o)),h=n+"_"+d,l=this.safeString(s,"url_symbol"),u={amount:s.base_decimals,price:s.counter_decimals},f=s.minimum_order.split(" ")[0],p="Enabled"===s.trading;i.push({id:l,symbol:c,base:a,quote:o,baseId:n,quoteId:d,symbolId:h,info:s,active:p,precision:u,limits:{amount:{min:Math.pow(10,-u.amount),max:void 0},price:{min:Math.pow(10,-u.price),max:void 0},cost:{min:parseFloat(f),max:void 0}}})}return i}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={pair:this.marketId(e)},r=await this.publicGetOrderBookPair(this.extend(s,i)),a=this.safeTimestamp(r,"timestamp");return this.parseOrderBook(r,a)}async fetchTicker(e,t={}){await this.loadMarkets();const i={pair:this.marketId(e)},s=await this.publicGetTickerPair(this.extend(i,t)),r=this.safeTimestamp(s,"timestamp"),a=this.safeFloat(s,"vwap"),o=this.safeFloat(s,"volume");let n=void 0;void 0!==o&&void 0!==a&&(n=o*a);const d=this.safeFloat(s,"last");return{symbol:e,timestamp:r,datetime:this.iso8601(r),high:this.safeFloat(s,"high"),low:this.safeFloat(s,"low"),bid:this.safeFloat(s,"bid"),bidVolume:void 0,ask:this.safeFloat(s,"ask"),askVolume:void 0,vwap:a,open:this.safeFloat(s,"open"),close:d,last:d,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:o,quoteVolume:n,info:s}}getCurrencyIdFromTransaction(e){const t=this.safeStringLower(e,"currency");if(void 0!==t)return t;e=this.omit(e,["fee","price","datetime","type","status","id"]);const i=Object.keys(e);for(let t=0;t<i.length;t++){const s=i[t];if(s.indexOf("_")<0){const t=this.safeFloat(e,s);if(void 0!==t&&0!==t)return s}}}getMarketFromTrade(e){e=this.omit(e,["fee","price","datetime","tid","type","order_id","side"]);const t=Object.keys(e),i=t.length;if(i>2)throw new a(this.id+" getMarketFromTrade too many keys: "+this.json(t)+" in the trade: "+this.json(e));if(2===i){let e=t[0]+t[1];if(e in this.markets_by_id)return this.markets_by_id[e];if((e=t[1]+t[0])in this.markets_by_id)return this.markets_by_id[e]}}getMarketFromTrades(e){const t=this.indexBy(e,"symbol"),i=Object.keys(t);if(1===i.length)return this.markets[i[0]]}parseTrade(e,t){const i=this.safeString2(e,"id","tid");let s=void 0,r=void 0,a=this.safeFloat(e,"price"),o=this.safeFloat(e,"amount");const n=this.safeString(e,"order_id");let d=this.safeFloat(e,"cost");if(void 0===t){const i=Object.keys(e);for(let e=0;e<i.length;e++)if(i[e].indexOf("_")>=0){const s=i[e].replace("_","");s in this.markets_by_id&&(t=this.markets_by_id[s])}void 0===t&&(t=this.getMarketFromTrade(e))}const c=this.safeFloat(e,"fee");let h=void 0;void 0!==t&&(a=this.safeFloat(e,t.symbolId,a),o=this.safeFloat(e,t.baseId,o),d=this.safeFloat(e,t.quoteId,d),h=t.quote,s=t.symbol);let l=this.safeString2(e,"date","datetime");void 0!==l&&(l.indexOf(" ")>=0?l=this.parse8601(l):(l=parseInt(l),l*=1e3)),"id"in e?void 0!==o&&(o<0?(r="sell",o=-o):r="buy"):"1"===(r=this.safeString(e,"type"))?r="sell":"0"===r&&(r="buy"),void 0===d&&void 0!==a&&void 0!==o&&(d=a*o),void 0!==d&&(d=Math.abs(d));let u=void 0;return void 0!==c&&(u={cost:c,currency:h}),{id:i,info:e,timestamp:l,datetime:this.iso8601(l),symbol:s,order:n,type:void 0,side:r,takerOrMaker:void 0,price:a,amount:o,cost:d,fee:u}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={pair:r.id,time:"hour"},o=await this.publicGetTransactionsPair(this.extend(a,s));return this.parseTrades(o,r,t,i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostBalance(e),i={info:t},s=Object.keys(this.currencies);for(let e=0;e<s.length;e++){const r=s[e],a=this.currency(r).id,o=this.account();o.free=this.safeFloat(t,a+"_available"),o.used=this.safeFloat(t,a+"_reserved"),o.total=this.safeFloat(t,a+"_balance"),i[r]=o}return this.parseBalance(i)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o=this.market(e);let n="privatePost"+this.capitalize(i);const d={pair:o.id,amount:this.amountToPrecision(e,s)};"market"===t?n+="Market":d.price=this.priceToPrecision(e,r),n+="Pair";const c=await this[n](this.extend(d,a)),h=this.parseOrder(c,o);return this.extend(h,{type:t})}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={id:e};return await this.privatePostCancelOrder(this.extend(s,i))}parseOrderStatus(e){return this.safeString({"In Queue":"open",Open:"open",Finished:"closed",Canceled:"canceled"},e,e)}async fetchOrderStatus(e,t,i={}){await this.loadMarkets();const s={id:e},r=await this.privatePostOrderStatus(this.extend(s,i));return this.parseOrderStatus(this.safeString(r,"status"))}async fetchOrder(e,t,i={}){await this.loadMarkets();let s=void 0;void 0!==t&&(s=this.market(t));const r={id:e},a=await this.privatePostOrderStatus(this.extend(r,i));return this.parseOrder(a,s)}async fetchMyTrades(e,t,i,s={}){await this.loadMarkets();const r={};let a="privatePostUserTransactions",o=void 0;void 0!==e&&(o=this.market(e),r.pair=o.id,a+="Pair"),void 0!==i&&(r.limit=i);const n=await this[a](this.extend(r,s)),d=this.filterBy(n,"type","2");return this.parseTrades(d,o,t,i)}async fetchTransactions(e,t,i,s={}){await this.loadMarkets();const r={};void 0!==i&&(r.limit=i);const a=await this.privatePostUserTransactions(this.extend(r,s));let o=void 0;void 0!==e&&(o=this.currency(e));const n=this.filterByArray(a,"type",["0","1"],!1);return this.parseTransactions(n,o,t,i)}async fetchWithdrawals(e,t,i,s={}){await this.loadMarkets();const r={};void 0!==t&&(r.timedelta=this.milliseconds()-t);const a=await this.privatePostWithdrawalRequests(this.extend(r,s));return this.parseTransactions(a,void 0,t,i)}parseTransaction(e,t){const i=this.parse8601(this.safeString(e,"datetime")),s=this.safeString(e,"id"),r=this.getCurrencyIdFromTransaction(e),a=this.safeCurrencyCode(r,t),o=this.safeFloat(e,"fee");let n=void 0,d=void 0;"amount"in e?d=this.safeFloat(e,"amount"):void 0!==t?(d=this.safeFloat(e,t.id,d),n=t.code):void 0!==a&&void 0!==r&&(d=this.safeFloat(e,r,d),n=a),void 0!==d&&(d=Math.abs(d));let c="ok";"status"in e&&(c=this.parseTransactionStatus(this.safeString(e,"status")));let h=void 0;if("type"in e){const t=this.safeString(e,"type");"0"===t?h="deposit":"1"===t&&(h="withdrawal")}else h="withdrawal";const l=this.safeString(e,"transaction_id");let u=void 0,f=this.safeString(e,"address");if(void 0!==f){const e=f.split("?dt=");e.length>1&&(f=e[0],u=e[1])}const p=f,m=u;let y=void 0;return void 0!==o&&(y={currency:n,cost:o,rate:void 0}),{info:e,id:s,txid:l,timestamp:i,datetime:this.iso8601(i),addressFrom:void 0,addressTo:p,address:f,tagFrom:void 0,tagTo:m,tag:u,type:h,amount:d,currency:a,status:c,updated:void 0,fee:y}}parseTransactionStatus(e){return this.safeString({0:"pending",1:"pending",2:"ok",3:"canceled",4:"failed"},e,e)}parseOrder(e,t){const i=this.safeString(e,"id");let s=this.safeString(e,"type");void 0!==s&&(s="1"===s?"sell":"buy");const r=this.parse8601(this.safeString(e,"datetime"));let a=void 0,o=void 0,n=this.safeString(e,"currency_pair");void 0!==n&&(n=(n=n.replace("/","")).toLowerCase())in this.markets_by_id&&(o=(t=this.markets_by_id[n]).symbol);let d=this.safeFloat(e,"amount"),c=0;const h=[],l=this.safeValue(e,"transactions",[]);let u=void 0,f=void 0;const p=l.length;if(p>0){u=0;for(let e=0;e<p;e++){const r=this.parseTrade(this.extend({order_id:i,side:s},l[e]),t);c=this.sum(c,r.amount),u=this.sum(u,r.fee.cost),void 0===f&&(f=0),f=this.sum(f,r.cost),h.push(r)}a=h[p-1].timestamp}const m=this.parseOrderStatus(this.safeString(e,"status"));"closed"===m&&void 0===d&&(d=c);let y=void 0;void 0!==d&&(y=d-c);let b=this.safeFloat(e,"price");void 0===t&&(t=this.getMarketFromTrades(h));let v=void 0;void 0!==t&&(void 0===o&&(o=t.symbol),v=t.quote),void 0===f?void 0!==b&&(f=b*c):void 0===b&&c>0&&(b=f/c);let g=void 0;return void 0!==u&&void 0!==v&&(g={cost:u,currency:v}),{id:i,datetime:this.iso8601(r),timestamp:r,lastTradeTimestamp:a,status:m,symbol:o,type:void 0,side:s,price:b,cost:f,amount:d,filled:c,remaining:y,trades:h,fee:g,info:e}}async fetchOpenOrders(e,t,i,s={}){let r=void 0;await this.loadMarkets(),void 0!==e&&(r=this.market(e));const a=await this.privatePostOpenOrdersAll(s),o=[];for(let e=0;e<a.length;e++){const t=this.parseOrder(a[e],r);o.push(this.extend(t,{status:"open",type:"limit"}))}return void 0===e?this.filterBySinceLimit(o,t,i):this.filterBySymbolSinceLimit(o,e,t,i)}getCurrencyName(e){return"BTC"===e?"bitcoin":e.toLowerCase()}isFiat(e){return"USD"===e||"EUR"===e}async fetchDepositAddress(e,t={}){if(this.isFiat(e))throw new o(this.id+" fiat fetchDepositAddress() for "+e+" is not implemented yet");const i=this.getCurrencyName(e),s="BTC"===e;let r=s?"v1":"private";r+="Post"+this.capitalize(i),r+=s?"Deposit":"",r+="Address";const a=await this[r](t),n=s?a:this.safeString(a,"address"),d=s?void 0:this.safeString(a,"destination_tag");return this.checkAddress(n),{currency:e,address:n,tag:d,info:a}}async withdraw(e,t,i,s,r={}){if(this.checkAddress(i),this.isFiat(e))throw new o(this.id+" fiat withdraw() for "+e+" is not implemented yet");const a=this.getCurrencyName(e),n={amount:t,address:i};let d="BTC"===e?"v1":"private";d+="Post"+this.capitalize(a)+"Withdrawal","XRP"===e&&void 0!==s&&(n.destination_tag=s);const c=await this[d](this.extend(n,r));return{info:c,id:c.id}}nonce(){return this.milliseconds()}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api+"/";"v1"!==t&&(o+=this.version+"/"),o+=this.implodeParams(e,s);let n=this.omit(s,this.extractParams(e));if("public"===t)Object.keys(n).length&&(o+="?"+this.urlencode(n));else{this.checkRequiredCredentials();const e=this.nonce().toString(),t=e+this.uid+this.apiKey,i=this.encode(this.hmac(this.encode(t),this.encode(this.secret)));n=this.extend({key:this.apiKey,signature:i.toUpperCase(),nonce:e},n),a=this.urlencode(n),r={"Content-Type":"application/x-www-form-urlencoded"}}return{url:o,method:i,body:a,headers:r}}handleErrors(e,t,i,s,o,n,d,c,h){if(void 0===d)return;const l=this.safeString(d,"status"),u=this.safeValue(d,"error");if("error"===l||void 0!==u){let e=[];if("string"==typeof u)e.push(u);else if(void 0!==u){const t=Object.keys(u);for(let i=0;i<t.length;i++){const s=t[i],r=this.safeValue(u,s);Array.isArray(r)?e=this.arrayConcat(e,r):e.push(r)}}const t=this.safeValue(d,"reason",{});if("string"==typeof t)e.push(t);else{const i=this.safeValue(t,"__all__",[]);for(let t=0;t<i.length;t++)e.push(i[t])}if("API0005"===this.safeString(d,"code"))throw new r(this.id+" invalid signature, use the uid for the main account if you have subaccounts");const i=this.exceptions.exact,s=this.exceptions.broad,o=this.id+" "+n;for(let t=0;t<e.length;t++){const r=e[t];if(r in i)throw new i[r](o);const a=this.findBroadlyMatchedKey(s,r);if(void 0!==a)throw new s[a](o)}throw new a(o)}}}},function(e,t,i){"use strict";const s=i(1),{BadSymbol:r,ExchangeError:a,NotSupported:o}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"bitstamp1",name:"Bitstamp",countries:["GB"],rateLimit:1e3,version:"v1",has:{CORS:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27786377-8c8ab57e-5fe9-11e7-8ea4-2b05b6bcceec.jpg",api:"https://www.bitstamp.net/api",www:"https://www.bitstamp.net",doc:"https://www.bitstamp.net/api"},requiredCredentials:{apiKey:!0,secret:!0,uid:!0},api:{public:{get:["ticker","ticker_hour","order_book","transactions","eur_usd"]},private:{post:["balance","user_transactions","open_orders","order_status","cancel_order","cancel_all_orders","buy","sell","bitcoin_deposit_address","unconfirmed_btc","ripple_withdrawal","ripple_address","withdrawal_requests","bitcoin_withdrawal"]}},markets:{"BTC/USD":{id:"btcusd",symbol:"BTC/USD",base:"BTC",quote:"USD",baseId:"btc",quoteId:"usd",maker:.0025,taker:.0025},"BTC/EUR":{id:"btceur",symbol:"BTC/EUR",base:"BTC",quote:"EUR",baseId:"btc",quoteId:"eur",maker:.0025,taker:.0025},"EUR/USD":{id:"eurusd",symbol:"EUR/USD",base:"EUR",quote:"USD",baseId:"eur",quoteId:"usd",maker:.0025,taker:.0025},"XRP/USD":{id:"xrpusd",symbol:"XRP/USD",base:"XRP",quote:"USD",baseId:"xrp",quoteId:"usd",maker:.0025,taker:.0025},"XRP/EUR":{id:"xrpeur",symbol:"XRP/EUR",base:"XRP",quote:"EUR",baseId:"xrp",quoteId:"eur",maker:.0025,taker:.0025},"XRP/BTC":{id:"xrpbtc",symbol:"XRP/BTC",base:"XRP",quote:"BTC",baseId:"xrp",quoteId:"btc",maker:.0025,taker:.0025},"LTC/USD":{id:"ltcusd",symbol:"LTC/USD",base:"LTC",quote:"USD",baseId:"ltc",quoteId:"usd",maker:.0025,taker:.0025},"LTC/EUR":{id:"ltceur",symbol:"LTC/EUR",base:"LTC",quote:"EUR",baseId:"ltc",quoteId:"eur",maker:.0025,taker:.0025},"LTC/BTC":{id:"ltcbtc",symbol:"LTC/BTC",base:"LTC",quote:"BTC",baseId:"ltc",quoteId:"btc",maker:.0025,taker:.0025},"ETH/USD":{id:"ethusd",symbol:"ETH/USD",base:"ETH",quote:"USD",baseId:"eth",quoteId:"usd",maker:.0025,taker:.0025},"ETH/EUR":{id:"etheur",symbol:"ETH/EUR",base:"ETH",quote:"EUR",baseId:"eth",quoteId:"eur",maker:.0025,taker:.0025},"ETH/BTC":{id:"ethbtc",symbol:"ETH/BTC",base:"ETH",quote:"BTC",baseId:"eth",quoteId:"btc",maker:.0025,taker:.0025}}})}async fetchOrderBook(e,t,i={}){if("BTC/USD"!==e)throw new a(this.id+" "+this.version+" fetchOrderBook doesn't support "+e+", use it for BTC/USD only");await this.loadMarkets();const s=await this.publicGetOrderBook(i),r=this.safeTimestamp(s,"timestamp");return this.parseOrderBook(s,r)}async fetchTicker(e,t={}){if("BTC/USD"!==e)throw new a(this.id+" "+this.version+" fetchTicker doesn't support "+e+", use it for BTC/USD only");await this.loadMarkets();const i=await this.publicGetTicker(t),s=this.safeTimestamp(i,"timestamp"),r=this.safeFloat(i,"vwap"),o=this.safeFloat(i,"volume");let n=void 0;void 0!==o&&void 0!==r&&(n=o*r);const d=this.safeFloat(i,"last");return{symbol:e,timestamp:s,datetime:this.iso8601(s),high:this.safeFloat(i,"high"),low:this.safeFloat(i,"low"),bid:this.safeFloat(i,"bid"),bidVolume:void 0,ask:this.safeFloat(i,"ask"),askVolume:void 0,vwap:r,open:this.safeFloat(i,"open"),close:d,last:d,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:o,quoteVolume:n,info:i}}parseTrade(e,t){const i=this.safeTimestamp2(e,"date","datetime"),s=0===e.type?"buy":"sell",r=this.safeString(e,"order_id");"currency_pair"in e&&e.currency_pair in this.markets_by_id&&(t=this.markets_by_id[e.currency_pair]);const a=this.safeString(e,"tid"),o=this.safeFloat(e,"price"),n=this.safeFloat(e,"amount");let d=void 0;void 0!==o&&void 0!==n&&(d=o*n);let c=void 0;return void 0!==t&&(c=t.symbol),{id:a,info:e,timestamp:i,datetime:this.iso8601(i),symbol:c,order:r,type:void 0,side:s,takerOrMaker:void 0,price:o,amount:n,cost:d,fee:void 0}}async fetchTrades(e,t,i,s={}){if("BTC/USD"!==e)throw new r(this.id+" "+this.version+" fetchTrades doesn't support "+e+", use it for BTC/USD only");await this.loadMarkets();const a=this.market(e),o=await this.publicGetTransactions(this.extend({time:"minute"},s));return this.parseTrades(o,a,t,i)}async fetchBalance(e={}){const t=await this.privatePostBalance(e),i={info:t},s=Object.keys(this.currencies);for(let e=0;e<s.length;e++){const r=s[e],a=this.currency(r).id,o=this.account();o.free=this.safeFloat(t,a+"_available"),o.used=this.safeFloat(t,a+"_reserved"),o.total=this.safeFloat(t,a+"_balance"),i[r]=o}return this.parseBalance(i)}async createOrder(e,t,i,s,r,o={}){if("limit"!==t)throw new a(this.id+" "+this.version+" accepts limit orders only");if("BTC/USD"!==e)throw new a(this.id+" v1 supports BTC/USD orders only");await this.loadMarkets();const n="privatePost"+this.capitalize(i),d={amount:s,price:r},c=await this[n](this.extend(d,o));return{info:c,id:this.safeString(c,"id")}}async cancelOrder(e,t,i={}){return await this.privatePostCancelOrder({id:e})}parseOrderStatus(e){return this.safeString({"In Queue":"open",Open:"open",Finished:"closed",Canceled:"canceled"},e,e)}async fetchOrderStatus(e,t,i={}){await this.loadMarkets();const s={id:e},r=await this.privatePostOrderStatus(this.extend(s,i));return this.parseOrderStatus(r)}async fetchMyTrades(e,t,i,s={}){await this.loadMarkets();let r=void 0;void 0!==e&&(r=this.market(e));const a={id:r?r.id:"all"},o=await this.privatePostOpenOrdersId(this.extend(a,s));return this.parseTrades(o,r,t,i)}async fetchOrder(e,t,i={}){throw new o(this.id+" fetchOrder is not implemented yet")}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api+"/"+this.implodeParams(e,s),n=this.omit(s,this.extractParams(e));if("public"===t)Object.keys(n).length&&(o+="?"+this.urlencode(n));else{this.checkRequiredCredentials();const e=this.nonce().toString(),t=e+this.uid+this.apiKey,i=this.encode(this.hmac(this.encode(t),this.encode(this.secret)));n=this.extend({key:this.apiKey,signature:i.toUpperCase(),nonce:e},n),a=this.urlencode(n),r={"Content-Type":"application/x-www-form-urlencoded"}}return{url:o,method:i,body:a,headers:r}}async request(e,t="public",i="GET",s={},r,o){const n=await this.fetch2(e,t,i,s,r,o);if("status"in n&&"error"===n.status)throw new a(this.id+" "+this.json(n));return n}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,ArgumentsRequired:a,ExchangeNotAvailable:o,PermissionDenied:n,InvalidOrder:d,AuthenticationError:c,InsufficientFunds:h,OrderNotFound:l,DDoSProtection:u}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"bitz",name:"Bit-Z",countries:["HK"],rateLimit:2e3,version:"v2",userAgent:this.userAgents.chrome,has:{fetchTickers:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchClosedOrders:!0,fetchOrders:!0,fetchOrder:!0,createMarketOrder:!1,fetchDeposits:!0,fetchWithdrawals:!0,fetchTransactions:!1},timeframes:{"1m":"1min","5m":"5min","15m":"15min","30m":"30min","1h":"60min","4h":"4hour","1d":"1day","5d":"5day","1w":"1week","1M":"1mon"},urls:{logo:"https://user-images.githubusercontent.com/1294454/35862606-4f554f14-0b5d-11e8-957d-35058c504b6f.jpg",api:{market:"https://apiv2.bit-z.pro",trade:"https://apiv2.bit-z.pro",assets:"https://apiv2.bit-z.pro"},www:"https://www.bit-z.com",doc:"https://apidoc.bit-z.com/en/",fees:"https://www.bit-z.com/fee?type=1",referral:"https://u.bit-z.com/register?invite_code=1429193"},api:{market:{get:["ticker","depth","order","tickerall","kline","symbolList","currencyRate","currencyCoinRate","coinRate"]},trade:{post:["addEntrustSheet","cancelEntrustSheet","cancelAllEntrustSheet","getUserHistoryEntrustSheet","getUserNowEntrustSheet","getEntrustSheetInfo","depositOrWithdraw"]},assets:{post:["getUserAssets"]}},fees:{trading:{maker:.001,taker:.001},funding:{withdraw:{BTC:"0.5%",DKKT:"0.5%",ETH:.01,USDT:"0.5%",LTC:"0.5%",FCT:"0.5%",LSK:"0.5%",HXI:"0.8%",ZEC:"0.5%",DOGE:"0.5%",MZC:"0.5%",ETC:"0.5%",GXS:"0.5%",XPM:"0.5%",PPC:"0.5%",BLK:"0.5%",XAS:"0.5%",HSR:"0.5%",NULS:5,VOISE:350,PAY:1.5,EOS:.6,YBCT:35,OMG:.3,OTN:.4,BTX:"0.5%",QTUM:"0.5%",DASH:"0.5%",GAME:"0.5%",BCH:"0.5%",GNT:9,SSS:1500,ARK:"0.5%",PART:"0.5%",LEO:"0.5%",DGB:"0.5%",ZSC:130,VIU:350,BTG:"0.5%",ARN:10,VTC:"0.5%",BCD:"0.5%",TRX:200,HWC:"0.5%",UNIT:"0.5%",OXY:"0.5%",MCO:.35,SBTC:"0.5%",BCX:"0.5%",ETF:"0.5%",PYLNT:.4,XRB:"0.5%",ETP:"0.5%"}}},precision:{amount:8,price:8},options:{fetchOHLCVVolume:!0,fetchOHLCVWarning:!0,lastNonceTimestamp:0},commonCurrencies:{BOX:"BOX Token",XRB:"NANO",PXC:"Pixiecoin"},exceptions:{"-102":r,"-103":c,"-104":o,"-105":c,"-106":o,"-109":c,"-110":u,"-111":n,"-112":o,"-100015":c,"-100044":r,"-100101":r,"-100201":r,"-100301":r,"-100401":r,"-100302":r,"-100303":r,"-200003":c,"-200005":n,"-200025":o,"-200027":d,"-200028":d,"-200029":d,"-200030":d,"-200031":h,"-200032":r,"-200033":r,"-200034":l,"-200035":l,"-200037":d,"-200038":r,"-200055":l,"-300069":c,"-300101":r,"-300102":d,"-300103":c,"-301001":o}})}async fetchMarkets(e={}){const t=await this.marketGetSymbolList(e),i=this.safeValue(t,"data"),s=Object.keys(i),r=[];for(let e=0;e<s.length;e++){const t=s[e],a=i[t],o=this.safeString(a,"id"),n=this.safeString(a,"coinFrom"),d=this.safeString(a,"coinTo");let c=n.toUpperCase(),h=d.toUpperCase();const l=(c=this.safeCurrencyCode(c))+"/"+(h=this.safeCurrencyCode(h)),u={amount:this.safeInteger(a,"numberFloat"),price:this.safeInteger(a,"priceFloat")};r.push({info:a,id:t,numericId:o,symbol:l,base:c,quote:h,baseId:n,quoteId:d,active:!0,precision:u,limits:{amount:{min:this.safeFloat(a,"minTrade"),max:this.safeFloat(a,"maxTrade")},price:{min:Math.pow(10,-u.price),max:void 0},cost:{min:void 0,max:void 0}}})}return r}async fetchBalance(e={}){await this.loadMarkets();const t=await this.assetsPostGetUserAssets(e),i=this.safeValue(t.data,"info"),s={info:t};for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"name"),a=this.safeCurrencyCode(r),o=this.account();o.used=this.safeFloat(t,"lock"),o.total=this.safeFloat(t,"num"),o.free=this.safeFloat(t,"over"),s[a]=o}return this.parseBalance(s)}parseTicker(e,t){let i=void 0;if(void 0===t){const i=this.safeString(e,"symbol");t=this.safeValue(this.markets_by_id,i)}void 0!==t&&(i=t.symbol);const s=this.safeFloat(e,"now"),r=this.safeFloat(e,"open");let a=void 0,o=void 0;return void 0!==s&&void 0!==r&&(a=s-r,o=this.sum(s,r)/2),{symbol:i,timestamp:void 0,datetime:this.iso8601(void 0),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"bidPrice"),bidVolume:this.safeFloat(e,"bidQty"),ask:this.safeFloat(e,"askPrice"),askVolume:this.safeFloat(e,"askQty"),vwap:void 0,open:r,close:s,last:s,previousClose:void 0,change:a,percentage:this.safeFloat(e,"priceChange24h"),average:o,baseVolume:this.safeFloat(e,"volume"),quoteVolume:this.safeFloat(e,"quoteVolume"),info:e}}parseMicrotime(e){if(void 0===e)return e;const t=e.split(" "),i=parseFloat(t[0]),s=parseInt(t[1]),r=this.sum(s,i);return parseInt(1e3*r)}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={symbol:i.id},r=await this.marketGetTicker(this.extend(s,t)),a=this.parseTicker(r.data,i),o=this.parseMicrotime(this.safeString(r,"microtime"));return this.extend(a,{timestamp:o,datetime:this.iso8601(o)})}async fetchTickers(e,t={}){await this.loadMarkets();const i={};if(void 0!==e){const t=this.marketIds(e);i.symbols=t.join(",")}const s=await this.marketGetTickerall(this.extend(i,t)),r=this.safeValue(s,"data"),a=this.parseMicrotime(this.safeString(s,"microtime")),o={},n=Object.keys(r);for(let e=0;e<n.length;e++){const t=n[e];let i=r[t],s=void 0;t in this.markets_by_id&&(s=this.markets_by_id[t]);let d=(i=this.parseTicker(r[t],s)).symbol;if(void 0===d)if(void 0!==s)d=s.symbol;else{const[e,i]=t.split("_");d=this.safeCurrencyCode(e)+"/"+this.safeCurrencyCode(i)}void 0!==d&&(o[d]=this.extend(i,{timestamp:a,datetime:this.iso8601(a)}))}return o}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={symbol:this.marketId(e)},r=await this.marketGetDepth(this.extend(s,i)),a=this.safeValue(r,"data"),o=this.parseMicrotime(this.safeString(r,"microtime"));return this.parseOrderBook(a,o)}parseTrade(e,t){const i=this.safeString(e,"id"),s=this.safeTimestamp(e,"T");let r=void 0;void 0!==t&&(r=t.symbol);const a=this.safeFloat(e,"p"),o=this.safeFloat(e,"n");let n=void 0;void 0!==a&&void 0!==o&&(n=this.priceToPrecision(r,o*a));const d=this.safeString(e,"s");return{timestamp:s,datetime:this.iso8601(s),symbol:r,id:i,order:void 0,type:"limit",side:d,takerOrMaker:void 0,price:a,amount:o,cost:n,fee:void 0,info:e}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id},o=await this.marketGetOrder(this.extend(a,s));return this.parseTrades(o.data,r,t,i)}parseOHLCV(e,t,i="1m",s,r){return[this.safeInteger(e,"time"),this.safeFloat(e,"open"),this.safeFloat(e,"high"),this.safeFloat(e,"low"),this.safeFloat(e,"close"),this.safeFloat(e,"volume")]}async fetchOHLCV(e,t="1m",i,s,a={}){await this.loadMarkets();const o=1e3*this.parseTimeframe(t),n=this.market(e),d={symbol:n.id,resolution:this.timeframes[t]};if(void 0!==s)d.size=Math.min(s,300),void 0!==i&&(d.to=this.sum(i,s*o*1e3));else if(void 0!==i)throw new r(this.id+" fetchOHLCV requires a limit argument if the since argument is specified");const c=await this.marketGetKline(this.extend(d,a)),h=this.safeValue(c.data,"bars",void 0);return void 0===h?[]:this.parseOHLCVs(h,n,t,i,s)}parseOrderStatus(e){return this.safeString({0:"open",1:"open",2:"closed",3:"canceled"},e,e)}parseOrder(e,t){const i=this.safeString(e,"id");let s=void 0;if(void 0===t){const i=this.safeString(e,"coinFrom"),r=this.safeString(e,"coinTo");if(void 0!==i&&void 0!==r){const e=i+"_"+r;if(e in this.markets_by_id)t=this.safeValue(this.markets_by_id,e);else{s=this.safeCurrencyCode(i)+"/"+this.safeCurrencyCode(r)}}}void 0!==t&&(s=t.symbol);let r=this.safeString(e,"flag");void 0!==r&&(r="sale"===r?"sell":"buy");const a=this.safeFloat(e,"price"),o=this.safeFloat(e,"number"),n=this.safeFloat(e,"numberOver"),d=this.safeFloat(e,"numberDeal");let c=this.safeInteger(e,"timestamp");void 0===c&&(c=this.safeTimestamp(e,"created"));let h=this.safeFloat(e,"orderTotalPrice");void 0!==a&&void 0!==d&&(h=d*a);const l=this.parseOrderStatus(this.safeString(e,"status"));return{id:i,datetime:this.iso8601(c),timestamp:c,lastTradeTimestamp:void 0,status:l,symbol:s,type:"limit",side:r,price:a,cost:h,amount:o,filled:d,remaining:n,trades:void 0,fee:void 0,info:e}}async createOrder(e,t,i,s,a,o={}){if(await this.loadMarkets(),"limit"!==t)throw new r(this.id+" createOrder allows limit orders only");const n=this.market(e),d="buy"===i?"1":"2";if(!this.password)throw new r(this.id+' createOrder() requires you to set exchange.password = "YOUR_TRADING_PASSWORD" (a trade password is NOT THE SAME as your login password)');const c={symbol:n.id,type:d,price:this.priceToPrecision(e,a),number:this.amountToPrecision(e,s),tradePwd:this.password},h=await this.tradePostAddEntrustSheet(this.extend(c,o)),l=this.parseMicrotime(this.safeString(h,"microtime")),u=this.extend({timestamp:l},h.data);return this.parseOrder(u,n)}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={entrustSheetId:e};return await this.tradePostCancelEntrustSheet(this.extend(s,i))}async cancelOrders(e,t,i={}){await this.loadMarkets();const s={ids:e.join(",")};return await this.tradePostCancelEntrustSheet(this.extend(s,i))}async fetchOrder(e,t,i={}){await this.loadMarkets();const s={entrustSheetId:e},r=await this.tradePostGetEntrustSheetInfo(this.extend(s,i));return this.parseOrder(r.data)}async fetchOrdersWithMethod(e,t,i,s,r={}){if(void 0===t)throw new a(this.id+" fetchOpenOrders requires a symbol argument");await this.loadMarkets();const o=this.market(t),n={coinFrom:o.baseId,coinTo:o.quoteId};void 0!==s&&(n.page=1,n.pageSize=s),void 0!==i&&(n.startTime=parseInt(i/1e3));const d=await this[e](this.extend(n,r)),c=this.safeValue(d.data,"data",[]);return this.parseOrders(c,void 0,i,s)}async fetchOrders(e,t,i,s={}){return await this.fetchOrdersWithMethod("tradePostGetUserHistoryEntrustSheet",e,t,i,s)}async fetchOpenOrders(e,t,i,s={}){return await this.fetchOrdersWithMethod("tradePostGetUserNowEntrustSheet",e,t,i,s)}async fetchClosedOrders(e,t,i,s={}){return await this.fetchOrdersWithMethod("tradePostGetUserHistoryEntrustSheet",e,t,i,s)}parseTransactionStatus(e){return this.safeString({1:"pending",2:"pending",3:"pending",4:"ok",5:"canceled"},e,e)}parseTransaction(e,t){let i=this.safeInteger(e,"updated");0===i&&(i=void 0);const s=this.safeString(e,"coin"),r=this.safeCurrencyCode(s,t),a=this.safeStringLower(e,"type"),o=this.parseTransactionStatus(this.safeString(e,"status"));return{id:this.safeString(e,"id"),txid:this.safeString(e,"txid"),timestamp:i,datetime:this.iso8601(i),address:this.safeString(e,"wallet"),tag:this.safeString(e,"memo"),type:a,amount:this.safeFloat(e,"number"),currency:r,status:o,updated:i,fee:void 0,info:e}}parseTransactionsByType(e,t,i,s,r){const a=[];for(let i=0;i<t.length;i++){const s=this.parseTransaction(this.extend({type:e},t[i]));a.push(s)}return this.filterByCurrencySinceLimit(a,i,s,r)}parseTransactionType(e){return this.safeInteger({deposit:1,withdrawal:2},e,e)}async fetchDeposits(e,t,i,s={}){return await this.fetchTransactionsForType("deposit",e,t,i,s)}async fetchWithdrawals(e,t,i,s={}){return await this.fetchTransactionsForType("withdrawal",e,t,i,s)}async fetchTransactionsForType(e,t,i,s,r={}){if(void 0===t)throw new a(this.id+" fetchTransactions() requires a currency `code` argument");await this.loadMarkets();const o={coin:this.currency(t).id,type:this.parseTransactionType(e)};void 0!==i&&(o.startTime=parseInt(i/1e3).toString()),void 0!==s&&(o.page=1,o.pageSize=s);const n=await this.tradePostDepositOrWithdraw(this.extend(o,r)),d=this.safeValue(n.data,"data",[]);return this.parseTransactionsByType(e,d,t,i,s)}nonce(){const e=this.seconds();return e>this.options.lastNonceTimestamp&&(this.options.lastNonceTimestamp=e,this.options.lastNonce=1e5),this.options.lastNonce=this.sum(this.options.lastNonce,1),this.options.lastNonce}sign(e,t="market",i="GET",s={},r,a){let o=this.urls.api[t]+"/"+this.capitalize(t)+"/"+e,n=void 0;return"market"===t?(n=this.urlencode(s)).length&&(o+="?"+n):(this.checkRequiredCredentials(),a=this.rawencode(this.keysort(this.extend({apiKey:this.apiKey,timeStamp:this.seconds(),nonce:this.nonce()},s))),a+="&sign="+this.hash(this.encode(a+this.secret)),r={"Content-type":"application/x-www-form-urlencoded"}),{url:o,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,o,n,d,c){if(void 0===n)return;const h=this.safeString(n,"status");if(void 0!==h){const e=this.id+" "+o,t=this.exceptions;if("200"===h){const i=this.safeInteger(n,"data");if(void 0!==i)throw i in t?new t[i](e):new r(e);return}throw h in t?new t[h](e):new r(e)}}}},function(e,t,i){"use strict";const s=i(1);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"bl3p",name:"BL3P",countries:["NL","EU"],rateLimit:1e3,version:"1",comment:"An exchange market by BitonicNL",has:{CORS:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/28501752-60c21b82-6feb-11e7-818b-055ee6d0e754.jpg",api:"https://api.bl3p.eu",www:["https://bl3p.eu","https://bitonic.nl"],doc:["https://github.com/BitonicNL/bl3p-api/tree/master/docs","https://bl3p.eu/api","https://bitonic.nl/en/api"]},api:{public:{get:["{market}/ticker","{market}/orderbook","{market}/trades"]},private:{post:["{market}/money/depth/full","{market}/money/order/add","{market}/money/order/cancel","{market}/money/order/result","{market}/money/orders","{market}/money/orders/history","{market}/money/trades/fetch","GENMKT/money/info","GENMKT/money/deposit_address","GENMKT/money/new_deposit_address","GENMKT/money/wallet/history","GENMKT/money/withdraw"]}},markets:{"BTC/EUR":{id:"BTCEUR",symbol:"BTC/EUR",base:"BTC",quote:"EUR",baseId:"BTC",quoteId:"EUR",maker:.0025,taker:.0025},"LTC/EUR":{id:"LTCEUR",symbol:"LTC/EUR",base:"LTC",quote:"EUR",baseId:"LTC",quoteId:"EUR",maker:.0025,taker:.0025}}})}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGENMKTMoneyInfo(e),i=this.safeValue(t,"data",{}),s=this.safeValue(i,"wallets"),r={info:i},a=Object.keys(this.currencies);for(let e=0;e<a.length;e++){const t=a[e],i=this.currency(t).id,o=this.safeValue(s,i,{}),n=this.safeValue(o,"available",{}),d=this.safeValue(o,"balance",{}),c=this.account();c.free=this.safeFloat(n,"value"),c.total=this.safeFloat(d,"value"),r[t]=c}return this.parseBalance(r)}parseBidAsk(e,t=0,i=1){return[e[t]/1e5,e[i]/1e8]}async fetchOrderBook(e,t,i={}){const s={market:this.market(e).id},r=await this.publicGetMarketOrderbook(this.extend(s,i)),a=this.safeValue(r,"data");return this.parseOrderBook(a,void 0,"bids","asks","price_int","amount_int")}async fetchTicker(e,t={}){const i={market:this.marketId(e)},s=await this.publicGetMarketTicker(this.extend(i,t)),r=this.safeTimestamp(s,"timestamp"),a=this.safeFloat(s,"last");return{symbol:e,timestamp:r,datetime:this.iso8601(r),high:this.safeFloat(s,"high"),low:this.safeFloat(s,"low"),bid:this.safeFloat(s,"bid"),bidVolume:void 0,ask:this.safeFloat(s,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeFloat(s.volume,"24h"),quoteVolume:void 0,info:s}}parseTrade(e,t){const i=this.safeString(e,"trade_id"),s=this.safeInteger(e,"date");let r=this.safeFloat(e,"price_int");void 0!==r&&(r/=1e5);let a=this.safeFloat(e,"amount_int");void 0!==a&&(a/=1e8);let o=void 0;void 0!==r&&void 0!==a&&(o=a*r);let n=void 0;return void 0!==t&&(n=t.symbol),{id:i,info:e,timestamp:s,datetime:this.iso8601(s),symbol:n,type:void 0,side:void 0,order:void 0,takerOrMaker:void 0,price:r,amount:a,cost:o,fee:void 0}}async fetchTrades(e,t,i,s={}){const r=this.market(e),a=await this.publicGetMarketTrades(this.extend({market:r.id},s));return this.parseTrades(a.data.trades,r,t,i)}async createOrder(e,t,i,s,r,a={}){const o=this.market(e),n={market:o.id,amount_int:parseInt(1e8*s),fee_currency:o.quote,type:"buy"===i?"bid":"ask"};"limit"===t&&(n.price_int=parseInt(1e5*r));const d=await this.privatePostMarketMoneyOrderAdd(this.extend(n,a));return{info:d,id:this.safeString(d.data,"order_id")}}async cancelOrder(e,t,i={}){const s={order_id:e};return await this.privatePostMarketMoneyOrderCancel(this.extend(s,i))}sign(e,t="public",i="GET",s={},r,a){const o=this.implodeParams(e,s);let n=this.urls.api+"/"+this.version+"/"+o;const d=this.omit(s,this.extractParams(e));if("public"===t)Object.keys(d).length&&(n+="?"+this.urlencode(d));else{this.checkRequiredCredentials();const e=this.nonce();a=this.urlencode(this.extend({nonce:e},d));const t=this.base64ToBinary(this.secret),i=o+"\0"+a,s=this.hmac(this.encode(i),t,"sha512","base64");r={"Content-Type":"application/x-www-form-urlencoded","Rest-Key":this.apiKey,"Rest-Sign":this.decode(s)}}return{url:n,method:i,body:a,headers:r}}}},function(e,t,i){"use strict";const s=i(34),{ExchangeError:r,AuthenticationError:a,InvalidOrder:o,InsufficientFunds:n}=i(0);e.exports=class extends s{describe(){const e={"15m":"15m","20m":"20m","30m":"30m","1h":"1h","2h":"2h","3h":"3h","4h":"4h","6h":"6h","8h":"8h","12h":"12h","1d":"1d"},t=this.deepExtend(super.describe(),{id:"bleutrade",name:"Bleutrade",countries:["BR"],rateLimit:1e3,version:"v2",certified:!1,has:{CORS:!0,fetchTickers:!0,fetchOrders:!0,fetchClosedOrders:!0,fetchOrderTrades:!0,fetchLedger:!0},timeframes:e,hostname:"bleutrade.com",urls:{logo:"https://user-images.githubusercontent.com/1294454/30303000-b602dbe6-976d-11e7-956d-36c5049c01e7.jpg",api:{public:"https://{hostname}/api/v2",account:"https://{hostname}/api/v2",market:"https://{hostname}/api/v2",v3Private:"https://{hostname}/api/v3/private",v3Public:"https://{hostname}/api/v3/public"},www:"https://bleutrade.com",doc:["https://app.swaggerhub.com/apis-docs/bleu/white-label/3.0.0"],fees:"https://bleutrade.com/help/fees_and_deadlines"},api:{account:{get:["balance","balances","depositaddress","deposithistory","order","orders","orderhistory","withdrawhistory","withdraw"]},public:{get:["candles","currencies","markethistory","markets","marketsummaries","marketsummary","orderbook","ticker"]},v3Public:{get:["assets","markets","ticker","marketsummary","marketsummaries","orderbook","markethistory","candles"]},v3Private:{get:["getbalance","getbalances","buylimit","selllimit","buylimitami","selllimitami","buystoplimit","sellstoplimit","ordercancel","getopenorders","getdeposithistory","getdepositaddress","getmytransactions","withdraw","directtransfer","getwithdrawhistory","getlimits"]}},fees:{funding:{withdraw:{ADC:.1,BTA:.1,BITB:.1,BTC:.001,BCC:.001,BTCD:.001,BTG:.001,BLK:.1,CDN:.1,CLAM:.01,DASH:.001,DCR:.05,DGC:.1,DP:.1,DPC:.1,DOGE:10,EFL:.1,ETH:.01,EXP:.1,FJC:.1,BSTY:.001,GB:.1,NLG:.1,HTML:1,LTC:.001,MONA:.01,MOON:1,NMC:.015,NEOS:.1,NVC:.05,OK:.1,PPC:.1,POT:.1,XPM:.001,QTUM:.1,RDD:.1,SLR:.1,START:.1,SLG:.1,TROLL:.1,UNO:.01,VRC:.1,VTC:.1,XVP:.1,WDC:.001,ZET:.1}}},commonCurrencies:{EPC:"Epacoin"},exceptions:{"Insufficient funds!":n,"Invalid Order ID":o,"Invalid apikey or apisecret":a},options:{pricePrecisionByCode:{USD:3},parseOrderStatus:!0,disableNonce:!1,symbolSeparator:"_"}});return t.timeframes=e,t}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),i=[],s=this.safeValue(t,"result");for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"MarketName"),a=this.safeString(t,"MarketCurrency"),o=this.safeString(t,"BaseCurrency"),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o),c=n+"/"+d;let h=8;d in this.options.pricePrecisionByCode&&(h=this.options.pricePrecisionByCode[d]);const l={amount:8,price:h};let u=this.safeValue(t,"IsActive",!1);u=!("false"===u||!u),i.push({id:r,symbol:c,base:n,quote:d,baseId:a,quoteId:o,active:u,info:t,precision:l,limits:{amount:{min:this.safeFloat(t,"MinTradeSize"),max:void 0},price:{min:Math.pow(10,-l.price),max:void 0}}})}return i}parseOrderStatus(e){return this.safeString({OK:"closed",OPEN:"open",CANCELED:"canceled"},e,e)}async fetchOrders(e,t,i,s={}){await this.loadMarkets();let r=void 0,a="ALL";void 0!==e&&(a=(r=this.market(e)).id);const o={market:a,orderstatus:"ALL"},n=await this.accountGetOrders(this.extend(o,s));return this.parseOrders(n.result,r,t,i)}async fetchClosedOrders(e,t,i,s={}){const r=await this.fetchOrders(e,t,i,s);return this.filterBy(r,"status","closed")}getOrderIdField(){return"orderid"}parseSymbol(e){let[t,i]=e.split(this.options.symbolSeparator);return(t=this.safeCurrencyCode(t))+"/"+(i=this.safeCurrencyCode(i))}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={market:this.marketId(e),type:"ALL"};void 0!==t&&(s.depth=t);const a=await this.publicGetOrderbook(this.extend(s,i)),o=this.safeValue(a,"result");if(!o)throw new r(this.id+" publicGetOrderbook() returneded no result "+this.json(a));return this.parseOrderBook(o,void 0,"buy","sell","Rate","Quantity")}async fetchOrderTrades(e,t,i,s,r={}){await this.loadMarkets();const a={orderid:e},o=await this.accountGetOrderhistory(this.extend(a,r));return this.parseTrades(o.result,void 0,i,s,{order:e})}async fetchTransactionsByType(e,t,i,s,r={}){await this.loadMarkets();const a="deposit"===e?"accountGetDeposithistory":"accountGetWithdrawhistory",o=await this[a](r),n=this.parseTransactions(o.result);return this.filterByCurrencySinceLimit(n,t,i,s)}async fetchDeposits(e,t,i,s={}){return await this.fetchTransactionsByType("deposit",e,t,i,s)}async fetchWithdrawals(e,t,i,s={}){return await this.fetchTransactionsByType("withdrawal",e,t,i,s)}parseOHLCV(e,t,i="1d",s,r){return[this.parse8601(e.TimeStamp+"+00:00"),this.safeFloat(e,"Open"),this.safeFloat(e,"High"),this.safeFloat(e,"Low"),this.safeFloat(e,"Close"),this.safeFloat(e,"Volume")]}async fetchOHLCV(e,t="15m",i,s,r={}){await this.loadMarkets();const a=this.market(e),o={period:this.timeframes[t],market:a.id,count:s},n=await this.publicGetCandles(this.extend(o,r));if("result"in n&&n.result)return this.parseOHLCVs(n.result,a,t,i,s)}parseTrade(e,t){const i=this.parse8601(e.TimeStamp+"+00:00");let s=void 0;"BUY"===e.OrderType?s="buy":"SELL"===e.OrderType&&(s="sell");const r=this.safeString2(e,"TradeID","ID");let a=void 0;void 0!==t&&(a=t.symbol);let o=void 0;const n=this.safeFloat(e,"Price"),d=this.safeFloat(e,"Quantity");return void 0!==d&&void 0!==n&&(o=n*d),{id:r,info:e,timestamp:i,datetime:this.iso8601(i),symbol:a,type:"limit",side:s,order:void 0,takerOrMaker:void 0,price:n,amount:d,cost:o,fee:void 0}}parseLedgerEntryType(e){return this.safeString({TRADE:"trade",WITHDRAW:"transaction"},e,e)}parseLedgerEntry(e,t){const i=this.safeCurrencyCode(this.safeString(e,"CoinSymbol"),t),s=this.safeString(e,"Description"),r=this.parseLedgerEntryType(this.safeString(e,"Type"));let a=void 0,o=void 0;const n="trade"===r?", ":"; ",d=s.split(n);for(let e=0;e<d.length;e++){let t=d[e];if(0===t.indexOf("fee")){t=t.replace("fee ","");let e=parseFloat(t);e<0&&(e=-e),o={cost:e,currency:i}}else 0===t.indexOf("order id")&&(a=t.replace("order id",""))}const c=this.parse8601(this.safeString(e,"TimeStamp"));let h=this.safeFloat(e,"Amount"),l=void 0;return void 0!==h&&(l="in",h<0&&(l="out",h=-h)),{id:this.safeString(e,"ID"),info:e,timestamp:c,datetime:this.iso8601(c),direction:l,account:void 0,referenceId:a,referenceAccount:void 0,type:r,currency:i,amount:h,before:void 0,after:void 0,status:"ok",fee:o}}async fetchLedger(e,t,i,s={}){await this.loadMarkets();const r=await this.v3PrivateGetGetmytransactions(this.extend({},s));return this.parseLedger(r.result,e,t,i)}parseOrder(e,t){let i=this.safeString2(e,"OrderType","Type");const s="LIMIT_SELL"===i||"SELL"===i;("LIMIT_BUY"===i||"BUY"===i)&&(i="buy"),s&&(i="sell");let r=void 0;"Opened"in e&&e.Opened&&(r="open"),"Closed"in e&&e.Closed&&(r="closed"),"CancelInitiated"in e&&e.CancelInitiated&&(r="canceled"),"Status"in e&&this.options.parseOrderStatus&&(r=this.parseOrderStatus(this.safeString(e,"Status")));let a=void 0;const o=this.safeString(e,"Exchange");void 0===o?void 0!==t&&(a=t.symbol):a=o in this.markets_by_id?(t=this.markets_by_id[o]).symbol:this.parseSymbol(o);let n=void 0;"Opened"in e&&(n=this.parse8601(e.Opened+"+00:00")),"Created"in e&&(n=this.parse8601(e.Created+"+00:00"));let d=void 0;"TimeStamp"in e&&void 0!==e.TimeStamp&&(d=this.parse8601(e.TimeStamp+"+00:00")),"Closed"in e&&void 0!==e.Closed&&(d=this.parse8601(e.Closed+"+00:00")),void 0===n&&(n=d);let c=void 0,h=void 0;if("Commission"in e?h="Commission":"CommissionPaid"in e&&(h="CommissionPaid"),h)if(c={cost:this.safeFloat(e,h)},void 0!==t)c.currency=t.quote;else if(void 0!==a){const e=a.split("/")[1];c.currency=this.safeCurrencyCode(e)}let l=this.safeFloat(e,"Price"),u=void 0;const f=this.safeFloat(e,"Quantity"),p=this.safeFloat(e,"QuantityRemaining");let m=void 0;void 0!==f&&void 0!==p&&(m=f-p),u||l&&m&&(u=l*m),l||u&&m&&(l=u/m);const y=this.safeFloat(e,"PricePerUnit");return{info:e,id:this.safeString2(e,"OrderUuid","OrderId"),timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:d,symbol:a,type:"limit",side:i,price:l,cost:u,average:y,amount:f,filled:m,remaining:p,status:r,fee:c}}parseTransaction(e,t){const i=this.safeString(e,"Id");let s=this.safeFloat(e,"Amount"),r="deposit";s<0&&(s=Math.abs(s),r="withdrawal");const a=this.safeString(e,"Coin"),o=this.safeCurrencyCode(a,t),n=this.safeString(e,"Label"),d=this.parse8601(this.safeString(e,"TimeStamp"));let c=this.safeString(e,"TransactionId"),h=void 0,l=void 0;const u=n.split(";");3===u.length?(s=parseFloat(u[0]),h=u[1],l=parseFloat(u[2])):h=n;let f=void 0;void 0!==l&&(f={currency:o,cost:l});let p="ok";return"CANCELED"===c&&(c=void 0,p="canceled"),{info:e,timestamp:d,datetime:this.iso8601(d),id:i,currency:o,amount:s,address:h,tag:void 0,status:p,type:r,updated:void 0,txid:c,fee:f}}sign(e,t="public",i="GET",s={},r,a){let o=this.implodeParams(this.urls.api[t],{hostname:this.hostname})+"/";if("v3Private"===t||"account"===t){this.checkRequiredCredentials(),"account"===t&&(o+=t+"/"),("account"===t&&"withdraw"!==e||"openorders"===e)&&(o+=i.toLowerCase());const a={apikey:this.apiKey};a.nonce=this.nonce(),o+=e+"?"+this.urlencode(this.extend(a,s)),r={apisign:this.hmac(this.encode(o),this.encode(this.secret),"sha512")}}else o+=t+"/"+i.toLowerCase()+e,Object.keys(s).length&&(o+="?"+this.urlencode(s));return{url:o,method:i,body:a,headers:r}}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,InvalidOrder:a,AuthenticationError:o,ArgumentsRequired:n}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"braziliex",name:"Braziliex",countries:["BR"],rateLimit:1e3,has:{fetchCurrencies:!0,fetchTickers:!0,fetchOpenOrders:!0,fetchMyTrades:!0,fetchDepositAddress:!0,fetchOrder:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/34703593-c4498674-f504-11e7-8d14-ff8e44fb78c1.jpg",api:"https://braziliex.com/api/v1",www:"https://braziliex.com/",doc:"https://braziliex.com/exchange/api.php",fees:"https://braziliex.com/exchange/fees.php",referral:"https://braziliex.com/?ref=5FE61AB6F6D67DA885BC98BA27223465"},api:{public:{get:["currencies","ticker","ticker/{market}","orderbook/{market}","tradehistory/{market}"]},private:{post:["balance","complete_balance","open_orders","trade_history","deposit_address","sell","buy","cancel_order","order_status"]}},commonCurrencies:{EPC:"Epacoin",ABC:"Anti Bureaucracy Coin"},fees:{trading:{maker:.005,taker:.005}},precision:{amount:8,price:8},options:{fetchCurrencies:{expires:1e3}}})}async fetchCurrenciesFromCache(e={}){const t=this.safeValue(this.options,"fetchCurrencies",{}),i=this.safeInteger(t,"timestamp"),s=this.safeInteger(t,"expires",1e3),r=this.milliseconds();if(void 0===i||r-i>s){const i=await this.publicGetCurrencies(e);this.options.fetchCurrencies=this.extend(t,{response:i,timestamp:r})}return this.safeValue(this.options.fetchCurrencies,"response")}async fetchCurrencies(e={}){const t=await this.fetchCurrenciesFromCache(e);this.options.currencies={timestamp:this.milliseconds(),response:t};const i=Object.keys(t),s={};for(let e=0;e<i.length;e++){const r=i[e],a=t[r],o=this.safeInteger(a,"decimal"),n=this.safeCurrencyCode(r);let d=1===this.safeInteger(a,"active");0!==this.safeInteger(a,"under_maintenance")&&(d=!1);const c=1===this.safeInteger(a,"is_withdrawal_active"),h=1===this.safeInteger(a,"is_deposit_active");c&&h||(d=!1),s[n]={id:r,code:n,name:a.name,active:d,precision:o,funding:{withdraw:{active:c,fee:this.safeFloat(a,"txWithdrawalFee")},deposit:{active:h,fee:this.safeFloat(a,"txDepositFee")}},limits:{amount:{min:Math.pow(10,-o),max:Math.pow(10,o)},price:{min:Math.pow(10,-o),max:Math.pow(10,o)},cost:{min:void 0,max:void 0},withdraw:{min:this.safeFloat(a,"MinWithdrawal"),max:Math.pow(10,o)},deposit:{min:this.safeFloat(a,"minDeposit"),max:void 0}},info:a}}return s}async fetchMarkets(e={}){const t=await this.fetchCurrenciesFromCache(e),i=await this.publicGetTicker(),s=Object.keys(i),r=[];for(let e=0;e<s.length;e++){const a=s[e],o=i[a],[n,d]=a.split("_"),c=n.toUpperCase(),h=d.toUpperCase(),l=this.safeCurrencyCode(c),u=this.safeCurrencyCode(h),f=l+"/"+u,p=this.safeValue(t,n,{}),m=this.safeValue(t,d,{});let y=void 0;y=this.safeInteger(m,"is_fiat",0)?this.safeFloat(p,"minAmountTradeFIAT"):this.safeFloat(p,"minAmountTrade"+h);const b=1===this.safeInteger(o,"active"),v={amount:8,price:8};r.push({id:a,symbol:f,base:l,quote:u,baseId:n,quoteId:d,active:b,precision:v,limits:{amount:{min:Math.pow(10,-v.amount),max:Math.pow(10,v.amount)},price:{min:Math.pow(10,-v.price),max:Math.pow(10,v.price)},cost:{min:y,max:void 0}},info:o})}return r}parseTicker(e,t){let i=void 0;void 0!==t&&(i=t.symbol);const s=this.milliseconds(),r=this.safeFloat(e,"last");return{symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeFloat(e,"highestBid24"),low:this.safeFloat(e,"lowestAsk24"),bid:this.safeFloat(e,"highestBid"),bidVolume:void 0,ask:this.safeFloat(e,"lowestAsk"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:this.safeFloat(e,"percentChange"),percentage:void 0,average:void 0,baseVolume:this.safeFloat(e,"baseVolume24"),quoteVolume:this.safeFloat(e,"quoteVolume24"),info:e}}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={market:i.id},r=await this.publicGetTickerMarket(this.extend(s,t));return this.parseTicker(r,i)}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetTicker(t),s={},r=Object.keys(i);for(let e=0;e<r.length;e++){const t=r[e],a=this.markets_by_id[t];s[a.symbol]=this.parseTicker(i[t],a)}return s}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={market:this.marketId(e)},r=await this.publicGetOrderbookMarket(this.extend(s,i));return this.parseOrderBook(r,void 0,"bids","asks","price","amount")}parseTrade(e,t){const i=this.parse8601(this.safeString2(e,"date_exec","date")),s=this.safeFloat(e,"price"),r=this.safeFloat(e,"amount");let a=void 0;void 0!==t&&(a=t.symbol);const o=this.safeFloat(e,"total"),n=this.safeString(e,"order_number"),d=this.safeString(e,"type");return{id:this.safeString(e,"_id"),info:e,timestamp:i,datetime:this.iso8601(i),symbol:a,order:n,type:"limit",side:d,takerOrMaker:void 0,price:s,amount:r,cost:o,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={market:r.id},o=await this.publicGetTradehistoryMarket(this.extend(a,s));return this.parseTrades(o,r,t,i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostCompleteBalance(e),i={info:t},s=Object.keys(t);for(let e=0;e<s.length;e++){const r=s[e],a=t[r],o=this.safeCurrencyCode(r),n=this.account();n.free=this.safeFloat(a,"available"),n.total=this.safeFloat(a,"total"),i[o]=n}return this.parseBalance(i)}parseOrder(e,t){let i=void 0;if(void 0===t){const i=this.safeString(e,"market");i in this.markets_by_id&&(t=this.markets_by_id[i])}void 0!==t&&(i=t.symbol);let s=this.safeInteger(e,"timestamp");void 0===s&&(s=this.parse8601(this.safeString(e,"date")));const r=this.safeFloat(e,"price"),a=this.safeFloat(e,"total",0),o=this.safeFloat(e,"amount"),n=this.safeFloat(e,"progress"),d=o*n,c=parseFloat(this.amountToPrecision(i,o-d));let h=e;"info"in h&&(h=e.info);const l=this.safeString(e,"order_number"),u=this.safeValue(e,"fee"),f=1===n?"closed":"open";return{id:l,datetime:this.iso8601(s),timestamp:s,lastTradeTimestamp:void 0,status:f,symbol:i,type:"limit",side:e.type,price:r,cost:a,amount:o,filled:d,remaining:c,trades:void 0,fee:u,info:h}}async createOrder(e,t,i,s,r,o={}){await this.loadMarkets();const n=this.market(e),d="privatePost"+this.capitalize(i),c={market:n.id,price:r,amount:s},h=await this[d](this.extend(c,o));if(1!==this.safeInteger(h,"success"))throw new a(this.id+" "+this.json(h));let l=h.message.split(" / ");const u=(l=l.slice(1))[5].split(" "),f=this.parseOrder({timestamp:this.milliseconds(),order_number:h.order_number,type:l[0].toLowerCase(),market:l[0].toLowerCase(),amount:l[2].split(" ")[1],price:l[3].split(" ")[1],total:l[4].split(" ")[1],fee:{cost:parseFloat(u[1]),currency:u[2]},progress:"0.0",info:h},n),p=f.id;return this.orders[p]=f,f}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={order_number:e,market:this.market(t).id};return await this.privatePostCancelOrder(this.extend(s,i))}async fetchOrder(e,t,i={}){if(void 0===t)throw new n(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const s=this.market(t),r={order_number:e,market:s.id},a=await this.privatePostOrderStatus(this.extend(r,i));return this.parseOrder(a,s)}async fetchOpenOrders(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={market:r.id},o=await this.privatePostOpenOrders(this.extend(a,s));return this.parseOrders(o.order_open,r,t,i)}async fetchMyTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={market:r.id},o=await this.privatePostTradeHistory(this.extend(a,s));return this.parseTrades(o.trade_history,r,t,i)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},s=await this.privatePostDepositAddress(this.extend(i,t)),r=this.safeString(s,"deposit_address");return this.checkAddress(r),{currency:e,address:r,tag:this.safeString(s,"payment_id"),info:s}}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api+"/"+t,n=this.omit(s,this.extractParams(e));if("public"===t)o+="/"+this.implodeParams(e,s),Object.keys(n).length&&(o+="?"+this.urlencode(n));else{this.checkRequiredCredentials(),n=this.extend({command:e,nonce:this.nonce()},n),a=this.urlencode(n);const t=this.hmac(this.encode(a),this.encode(this.secret),"sha512");r={"Content-type":"application/x-www-form-urlencoded",Key:this.apiKey,Sign:this.decode(t)}}return{url:o,method:i,body:a,headers:r}}async request(e,t="public",i="GET",s={},a,n){const d=await this.fetch2(e,t,i,s,a,n);if("string"==typeof d&&d.length<1)throw new r(this.id+" returned empty response");if("success"in d){if(0===this.safeInteger(d,"success")){const e=this.safeString(d,"message");if("Invalid APIKey"===e)throw new o(e);throw new r(e)}}return d}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,AuthenticationError:a,DDoSProtection:o,InvalidOrder:n,InsufficientFunds:d}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"btcalpha",name:"BTC-Alpha",countries:["US"],version:"v1",has:{fetchTicker:!1,fetchOHLCV:!0,fetchOrders:!0,fetchOpenOrders:!0,fetchClosedOrders:!0,fetchMyTrades:!0},timeframes:{"1m":"1","5m":"5","15m":"15","30m":"30","1h":"60","4h":"240","1d":"D"},urls:{logo:"https://user-images.githubusercontent.com/1294454/42625213-dabaa5da-85cf-11e8-8f99-aa8f8f7699f0.jpg",api:"https://btc-alpha.com/api",www:"https://btc-alpha.com",doc:"https://btc-alpha.github.io/api-docs",fees:"https://btc-alpha.com/fees/",referral:"https://btc-alpha.com/?r=123788"},api:{public:{get:["currencies/","pairs/","orderbook/{pair_name}/","exchanges/","charts/{pair}/{type}/chart/"]},private:{get:["wallets/","orders/own/","order/{id}/","exchanges/own/","deposits/","withdraws/"],post:["order/","order-cancel/"]}},fees:{trading:{maker:.002,taker:.002},funding:{withdraw:{BTC:.00135,LTC:.0035,XMR:.018,ZEC:.002,ETH:.01,ETC:.01,SIB:1.5,CCRB:4,PZM:.05,ITI:.05,DCY:5,R:5,ATB:.05,BRIA:.05,KZC:.05,HWC:1,SPA:1,SMS:.001,REC:.01,SUP:1,BQ:100,GDS:.1,EVN:300,TRKC:.01,UNI:1,STN:1,BCH:void 0,QBIC:.5}}},commonCurrencies:{CBC:"Cashbery"},exceptions:{exact:{},broad:{"Out of balance":d}}})}async fetchMarkets(e={}){const t=await this.publicGetPairs(e),i=[];for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"name"),a=this.safeString(s,"currency1"),o=this.safeString(s,"currency2"),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o),c=n+"/"+d,h={amount:8,price:this.safeInteger(s,"price_precision")};i.push({id:r,symbol:c,base:n,quote:d,active:!0,precision:h,limits:{amount:{min:this.safeFloat(s,"minimum_order_size"),max:this.safeFloat(s,"maximum_order_size")},price:{min:Math.pow(10,-h.price),max:Math.pow(10,h.price)},cost:{min:void 0,max:void 0}},info:s})}return i}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={pair_name:this.marketId(e)};t&&(s.limit_sell=t,s.limit_buy=t);const r=await this.publicGetOrderbookPairName(this.extend(s,i));return this.parseOrderBook(r,void 0,"buy","sell","price","amount")}parseTrade(e,t){let i=void 0;void 0===t&&(t=this.safeValue(this.marketsById,e.pair)),void 0!==t&&(i=t.symbol);const s=this.safeTimestamp(e,"timestamp"),r=this.safeFloat(e,"price"),a=this.safeFloat(e,"amount");let o=void 0;void 0!==r&&void 0!==a&&(o=parseFloat(this.costToPrecision(i,r*a)));const n=this.safeString2(e,"id","tid"),d=this.safeString2(e,"my_side","side"),c=this.safeString(e,"o_id");return{id:n,info:e,timestamp:s,datetime:this.iso8601(s),symbol:i,order:c,type:"limit",side:d,takerOrMaker:void 0,price:r,amount:a,cost:o,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();let r=void 0;const a={};void 0!==e&&(r=this.market(e),a.pair=r.id),void 0!==i&&(a.limit=i);const o=await this.publicGetExchanges(this.extend(a,s));return this.parseTrades(o,r,t,i)}parseOHLCV(e,t,i="5m",s,r){return[this.safeTimestamp(e,"time"),this.safeFloat(e,"open"),this.safeFloat(e,"high"),this.safeFloat(e,"low"),this.safeFloat(e,"close"),this.safeFloat(e,"volume")]}async fetchOHLCV(e,t="5m",i,s,r={}){await this.loadMarkets();const a=this.market(e),o={pair:a.id,type:this.timeframes[t]};void 0!==s&&(o.limit=s),void 0!==i&&(o.since=parseInt(i/1e3));const n=await this.publicGetChartsPairTypeChart(this.extend(o,r));return this.parseOHLCVs(n,a,t,i,s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetWallets(e),i={info:t};for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.used=this.safeFloat(s,"reserve"),o.total=this.safeFloat(s,"balance"),i[a]=o}return this.parseBalance(i)}parseOrderStatus(e){return this.safeString({1:"open",2:"canceled",3:"closed"},e,e)}parseOrder(e,t){let i=void 0;void 0===t&&(t=this.safeValue(this.marketsById,e.pair)),void 0!==t&&(i=t.symbol);const s=this.safeTimestamp(e,"date"),r=this.safeFloat(e,"price"),a=this.safeFloat(e,"amount"),o=this.parseOrderStatus(this.safeString(e,"status")),n=this.safeString2(e,"oid","id");let d=this.safeValue(e,"trades",[]);d=this.parseTrades(d,t);const c=this.safeString2(e,"my_side","type");let h=void 0;const l=d.length;if(l>0){h=0;for(let e=0;e<l;e++)h=this.sum(h,d[e].amount)}let u=void 0;return void 0!==a&&a>0&&void 0!==h&&(u=Math.max(0,a-h)),{id:n,datetime:this.iso8601(s),timestamp:s,status:o,symbol:i,type:"limit",side:c,price:r,cost:void 0,amount:a,filled:h,remaining:u,trades:d,fee:void 0,info:e}}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o=this.market(e),d={pair:o.id,type:i,amount:s,price:this.priceToPrecision(e,r)},c=await this.privatePostOrder(this.extend(d,a));if(!c.success)throw new n(this.id+" "+this.json(c));const h=this.parseOrder(c,o);return s=h.amount>0?h.amount:s,this.extend(h,{amount:s})}async cancelOrder(e,t,i={}){const s={order:e};return await this.privatePostOrderCancel(this.extend(s,i))}async fetchOrder(e,t,i={}){await this.loadMarkets();const s={id:e},r=await this.privateGetOrderId(this.extend(s,i));return this.parseOrder(r)}async fetchOrders(e,t,i,s={}){await this.loadMarkets();const r={};let a=void 0;void 0!==e&&(a=this.market(e),r.pair=a.id),void 0!==i&&(r.limit=i);const o=await this.privateGetOrdersOwn(this.extend(r,s));return this.parseOrders(o,a,t,i)}async fetchOpenOrders(e,t,i,s={}){return await this.fetchOrders(e,t,i,this.extend({status:"1"},s))}async fetchClosedOrders(e,t,i,s={}){return await this.fetchOrders(e,t,i,this.extend({status:"3"},s))}async fetchMyTrades(e,t,i,s={}){await this.loadMarkets();const r={};if(void 0!==e){const t=this.market(e);r.pair=t.id}void 0!==i&&(r.limit=i);const a=await this.privateGetExchangesOwn(this.extend(r,s));return this.parseTrades(a,void 0,t,i)}nonce(){return this.milliseconds()}sign(e,t="public",i="GET",s={},r,a){const o=this.urlencode(this.keysort(this.omit(s,this.extractParams(e))));let n=this.urls.api+"/";if("charts/{pair}/{type}/chart/"!==e&&(n+="v1/"),n+=this.implodeParams(e,s),r={Accept:"application/json"},"public"===t)o.length&&(n+="?"+o);else{this.checkRequiredCredentials();let e=this.apiKey;"POST"===i?(r["Content-Type"]="application/x-www-form-urlencoded",e+=a=o):o.length&&(n+="?"+o),r["X-KEY"]=this.apiKey,r["X-SIGN"]=this.hmac(this.encode(e),this.encode(this.secret)),r["X-NONCE"]=this.nonce().toString()}return{url:n,method:i,body:a,headers:r}}handleErrors(e,t,i,s,n,d,c,h,l){if(void 0===c)return;const u=this.safeString(c,"error"),f=this.id+" "+d;if(void 0!==u){const e=this.exceptions.exact;if(u in e)throw new e[u](f);const t=this.exceptions.broad,i=this.findBroadlyMatchedKey(t,u);if(void 0!==i)throw new t[i](f)}if(401===e||403===e)throw new a(f);if(429===e)throw new o(f);if(!(e<400))throw new r(f)}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,InsufficientFunds:a,InvalidOrder:o,AuthenticationError:n,PermissionDenied:d,InvalidNonce:c,OrderNotFound:h,DDoSProtection:l}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"btcbox",name:"BtcBox",countries:["JP"],rateLimit:1e3,version:"v1",has:{CORS:!1,fetchOrder:!0,fetchOrders:!0,fetchOpenOrders:!0,fetchTickers:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/31275803-4df755a8-aaa1-11e7-9abb-11ec2fad9f2d.jpg",api:"https://www.btcbox.co.jp/api",www:"https://www.btcbox.co.jp/",doc:"https://www.btcbox.co.jp/help/asm",fees:"https://support.btcbox.co.jp/hc/en-us/articles/360001235694-Fees-introduction"},api:{public:{get:["depth","orders","ticker"]},private:{post:["balance","trade_add","trade_cancel","trade_list","trade_view","wallet"]}},markets:{"BTC/JPY":{id:"btc",symbol:"BTC/JPY",base:"BTC",quote:"JPY",baseId:"btc",quoteId:"jpy",taker:5e-4,maker:5e-4},"ETH/JPY":{id:"eth",symbol:"ETH/JPY",base:"ETH",quote:"JPY",baseId:"eth",quoteId:"jpy",taker:.001,maker:.001},"LTC/JPY":{id:"ltc",symbol:"LTC/JPY",base:"LTC",quote:"JPY",baseId:"ltc",quoteId:"jpy",taker:.001,maker:.001},"BCH/JPY":{id:"bch",symbol:"BCH/JPY",base:"BCH",quote:"JPY",baseId:"bch",quoteId:"jpy",taker:.001,maker:.001}},exceptions:{104:n,105:d,106:c,107:o,200:a,201:o,202:o,203:h,401:h,402:l}})}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostBalance(e),i={info:t},s=Object.keys(this.currencies);for(let e=0;e<s.length;e++){const r=s[e],a=this.currency(r).id,o=a+"_balance";if(o in t){const e=this.account(),s=a+"_lock";e.free=this.safeFloat(t,o),e.used=this.safeFloat(t,s),i[r]=e}}return this.parseBalance(i)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s=this.market(e),r={};this.symbols.length>1&&(r.coin=s.baseId);const a=await this.publicGetDepth(this.extend(r,i));return this.parseOrderBook(a)}parseTicker(e,t){const i=this.milliseconds();let s=void 0;void 0!==t&&(s=t.symbol);const r=this.safeFloat(e,"last");return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"buy"),bidVolume:void 0,ask:this.safeFloat(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeFloat(e,"vol"),quoteVolume:this.safeFloat(e,"volume"),info:e}}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={};this.symbols.length>1&&(s.coin=i.baseId);const r=await this.publicGetTicker(this.extend(s,t));return this.parseTicker(r,i)}parseTrade(e,t){const i=this.safeTimestamp(e,"date");let s=void 0;void 0!==t&&(s=t.symbol);const r=this.safeString(e,"tid"),a=this.safeFloat(e,"price"),o=this.safeFloat(e,"amount");let n=void 0;void 0!==o&&void 0!==a&&(n=a*o);const d=this.safeString(e,"type");return{info:e,id:r,order:void 0,timestamp:i,datetime:this.iso8601(i),symbol:s,type:void 0,side:d,takerOrMaker:void 0,price:a,amount:o,cost:n,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={};this.symbols.length>1&&(a.coin=r.baseId);const o=await this.publicGetOrders(this.extend(a,s));return this.parseTrades(o,r,t,i)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o=this.market(e),n={amount:s,price:r,type:i,coin:o.baseId},d=await this.privatePostTradeAdd(this.extend(n,a));return this.parseOrder(d,o)}async cancelOrder(e,t,i={}){await this.loadMarkets(),void 0===t&&(t="BTC/JPY");const s=this.market(t),r={id:e,coin:s.baseId},a=await this.privatePostTradeCancel(this.extend(r,i));return this.parseOrder(a,s)}parseOrderStatus(e){return this.safeString({part:"open",all:"closed",cancelled:"canceled",closed:"closed",no:"closed"},e,e)}parseOrder(e,t){const i=this.safeString(e,"id");let s=void 0;void 0!==this.safeString(e,"datetime")&&(s=this.parse8601(e.datetime+"+09:00"));const r=this.safeFloat(e,"amount_original"),a=this.safeFloat(e,"amount_outstanding");let o=void 0;void 0!==r&&void 0!==a&&(o=r-a);const n=this.safeFloat(e,"price");let d=void 0;void 0!==n&&void 0!==o&&(d=o*n);let c=this.parseOrderStatus(this.safeString(e,"status"));void 0===c&&void 0!==a&&0===a&&(c="closed");let h=void 0;void 0!==t&&(h=t.symbol);const l=this.safeString(e,"type");return{id:i,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,amount:r,remaining:a,filled:o,side:l,type:void 0,status:c,symbol:h,price:n,cost:d,trades:void 0,fee:void 0,info:e}}async fetchOrder(e,t,i={}){await this.loadMarkets(),void 0===t&&(t="BTC/JPY");const s=this.market(t),r=this.extend({id:e,coin:s.baseId},i),a=await this.privatePostTradeView(this.extend(r,i));return this.parseOrder(a,s)}async fetchOrdersByType(e,t,i,s,r={}){await this.loadMarkets(),void 0===t&&(t="BTC/JPY");const a=this.market(t),o={type:e,coin:a.baseId},n=await this.privatePostTradeList(this.extend(o,r)),d=this.parseOrders(n,a,i,s);if("open"===e)for(let e=0;e<d.length;e++)d[e].status="open";return d}async fetchOrders(e,t,i,s={}){return await this.fetchOrdersByType("all",e,t,i,s)}async fetchOpenOrders(e,t,i,s={}){return await this.fetchOrdersByType("open",e,t,i,s)}nonce(){return this.milliseconds()}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api+"/"+this.version+"/"+e;if("public"===t)Object.keys(s).length&&(o+="?"+this.urlencode(s));else{this.checkRequiredCredentials();const e=this.nonce().toString(),t=this.extend({key:this.apiKey,nonce:e},s),i=this.urlencode(t),o=this.hash(this.encode(this.secret));t.signature=this.hmac(this.encode(i),this.encode(o)),a=this.urlencode(t),r={"Content-Type":"application/x-www-form-urlencoded"}}return{url:o,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,o,n,d,c){if(void 0===n)return;if(e>=400)return;const h=this.safeValue(n,"result");if(void 0===h||!0===h)return;const l=this.safeValue(n,"code"),u=this.id+" "+this.json(n),f=this.exceptions;if(l in f)throw new f[l](u);throw new r(u)}async request(e,t="public",i="GET",s={},a,o){let n=await this.fetch2(e,t,i,s,a,o);if("string"==typeof n){if(n=this.strip(n),!this.isJsonEncodedObject(n))throw new r(this.id+" "+n);n=JSON.parse(n)}return n}}},function(e,t,i){"use strict";const s=i(1);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"btcchina",name:"BTCChina",countries:["CN"],rateLimit:1500,version:"v1",has:{CORS:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766368-465b3286-5ed6-11e7-9a11-0f6467e1d82b.jpg",api:{plus:"https://plus-api.btcchina.com/market",public:"https://data.btcchina.com/data",private:"https://api.btcchina.com/api_trade_v1.php"},www:"https://www.btcchina.com",doc:"https://www.btcchina.com/apidocs"},api:{plus:{get:["orderbook","ticker","trade"]},public:{get:["historydata","orderbook","ticker","trades"]},private:{post:["BuyIcebergOrder","BuyOrder","BuyOrder2","BuyStopOrder","CancelIcebergOrder","CancelOrder","CancelStopOrder","GetAccountInfo","getArchivedOrder","getArchivedOrders","GetDeposits","GetIcebergOrder","GetIcebergOrders","GetMarketDepth","GetMarketDepth2","GetOrder","GetOrders","GetStopOrder","GetStopOrders","GetTransactions","GetWithdrawal","GetWithdrawals","RequestWithdrawal","SellIcebergOrder","SellOrder","SellOrder2","SellStopOrder"]}},markets:{"BTC/CNY":{id:"btccny",symbol:"BTC/CNY",base:"BTC",quote:"CNY",api:"public",plus:!1},"LTC/CNY":{id:"ltccny",symbol:"LTC/CNY",base:"LTC",quote:"CNY",api:"public",plus:!1},"LTC/BTC":{id:"ltcbtc",symbol:"LTC/BTC",base:"LTC",quote:"BTC",api:"public",plus:!1},"BCH/CNY":{id:"bcccny",symbol:"BCH/CNY",base:"BCH",quote:"CNY",api:"plus",plus:!0},"ETH/CNY":{id:"ethcny",symbol:"ETH/CNY",base:"ETH",quote:"CNY",api:"plus",plus:!0}}})}async fetchMarkets(e={}){const t=await this.publicGetTicker(this.extend({market:"all"},e)),i=[],s=Object.keys(t);for(let e=0;e<s.length;e++){const r=s[e],a=t[r],o=r.split("_")[1],n=o.slice(0,3),d=o.slice(3,6);let c=n.toUpperCase(),h=d.toUpperCase();const l=(c=this.safeCurrencyCode(c))+"/"+(h=this.safeCurrencyCode(h));i.push({id:o,symbol:l,base:c,quote:h,baseId:n,quoteId:d,info:a})}return i}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGetAccountInfo(e),i=this.safeValue(t,"result"),s={info:i},r=Object.keys(this.currencies);for(let e=0;e<r.length;e++){const t=r[e],a=this.currency(t),o=this.account(),n=a.id;n in i.balance&&(o.total=parseFloat(i.balance[n].amount)),n in i.frozen&&(o.used=parseFloat(i.frozen[n].amount)),s[t]=o}return this.parseBalance(s)}createMarketRequest(e){const t={};return t[e.plus?"symbol":"market"]=e.id,t}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s=this.market(e),r=s.api+"GetOrderbook",a=this.createMarketRequest(s),o=await this[r](this.extend(a,i)),n=this.safeTimestamp(o,"date");return this.parseOrderBook(o,n)}parseTicker(e,t){const i=this.safeTimestamp(e,"date"),s=this.safeFloat(e,"last");return{timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"buy"),ask:this.safeFloat(e,"sell"),vwap:this.safeFloat(e,"vwap"),open:this.safeFloat(e,"open"),close:s,last:s,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeFloat(e,"vol"),quoteVolume:void 0,info:e}}parseTickerPlus(e,t){const i=this.safeInteger(e,"Timestamp");let s=void 0;return void 0!==t&&(s=t.symbol),{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"High"),low:this.safeFloat(e,"Low"),bid:this.safeFloat(e,"BidPrice"),ask:this.safeFloat(e,"AskPrice"),vwap:void 0,open:this.safeFloat(e,"Open"),last:this.safeFloat(e,"Last"),change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeFloat(e,"Volume24H"),quoteVolume:void 0,info:e}}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s=i.api+"GetTicker",r=this.createMarketRequest(i),a=await this[s](this.extend(r,t)),o=this.safeValue(a,"ticker");return i.plus?this.parseTickerPlus(o,i):this.parseTicker(o,i)}parseTrade(e,t){const i=this.safeTimestamp(e,"date"),s=this.safeFloat(e,"price"),r=this.safeFloat(e,"amount");let a=void 0;return void 0!==r&&void 0!==s&&(a=r*s),{id:this.safeString(e,"tid"),info:e,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,type:void 0,side:void 0,price:s,amount:r,cost:a}}parseTradePlus(e,t){const i=this.parse8601(this.safeString(e,"timestamp")),s=this.safeFloat(e,"price"),r=this.safeFloat(e,"size");let a=void 0;void 0!==r&&void 0!==s&&(a=r*s);const o=this.safeStringLower(e,"side");return{id:void 0,info:e,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,type:void 0,side:o,price:s,amount:r,cost:a}}parseTradesPlus(e,t){const i=[];for(let s=0;s<e.length;s++)i.push(this.parseTradePlus(e[s],t));return i}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e);let a=r.api+"GetTrade";const o=this.createMarketRequest(r);if(r.plus){const e=this.milliseconds();o.start_time=e-864e5,o.end_time=e}else a+="s";const n=await this[a](this.extend(o,s));return r.plus?this.parseTradesPlus(n.trades,r):this.parseTrades(n,r,t,i)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o=this.market(e),n="privatePost"+this.capitalize(i)+"Order2",d={},c=o.id.toUpperCase();d.params="market"===t?[void 0,s,c]:[r,s,c];const h=await this[n](this.extend(d,a));return{info:h,id:this.safeString(h,"id")}}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={params:[e,i.market]};return await this.privatePostCancelOrder(this.extend(s,i))}nonce(){return this.microseconds()}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api[t]+"/"+e;if("private"===t){this.checkRequiredCredentials();let t=[];"params"in s&&(t=s.params);const o=this.nonce(),n={method:e,id:o,params:t};t=t.join(","),a=this.json(n);const d=["tonce="+o,"accesskey="+this.apiKey,"requestmethod="+i.toLowerCase(),"id="+o,"method="+e,"params="+t].join("&"),c=this.hmac(this.encode(d),this.encode(this.secret),"sha1"),h=this.encode(this.apiKey+":"+c);r={Authorization:"Basic "+this.stringToBase64(h),"Json-Rpc-Tonce":o}}else Object.keys(s).length&&(o+="?"+this.urlencode(s));return{url:o,method:i,body:a,headers:r}}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,OrderNotFound:a,ArgumentsRequired:o,InvalidOrder:n,DDoSProtection:d}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"btcmarkets",name:"BTC Markets",countries:["AU"],rateLimit:1e3,has:{CORS:!1,fetchOHLCV:!0,fetchOrder:!0,fetchOrders:!0,fetchClosedOrders:"emulated",fetchOpenOrders:!0,fetchMyTrades:!0,cancelOrders:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/29142911-0e1acfc2-7d5c-11e7-98c4-07d9532b29d7.jpg",api:{public:"https://api.btcmarkets.net",private:"https://api.btcmarkets.net",web:"https://btcmarkets.net/data"},www:"https://btcmarkets.net",doc:"https://github.com/BTCMarkets/API"},api:{public:{get:["market/{id}/tick","market/{id}/orderbook","market/{id}/trades","v2/market/{id}/tickByTime/{timeframe}","v2/market/{id}/trades","v2/market/active"]},private:{get:["account/balance","account/{id}/tradingfee","fundtransfer/history","v2/order/open","v2/order/open/{id}","v2/order/history/{instrument}/{currency}/","v2/order/trade/history/{id}","v2/transaction/history/{currency}"],post:["fundtransfer/withdrawCrypto","fundtransfer/withdrawEFT","order/create","order/cancel","order/history","order/open","order/trade/history","order/createBatch","order/detail"]},web:{get:["market/BTCMarkets/{id}/tickByTime"]}},timeframes:{"1m":"minute","1h":"hour","1d":"day"},exceptions:{3:n,6:d}})}async fetchTransactions(e,t,i,s={}){await this.loadMarkets();const r={};void 0!==i&&(r.limit=i),void 0!==t&&(r.since=t);const a=(await this.privateGetFundtransferHistory(this.extend(r,s))).fundTransfers;return this.parseTransactions(a,void 0,t,i)}parseTransactionStatus(e){return this.safeString({Complete:"ok"},e,e)}parseTransaction(e,t){const i=this.safeInteger(e,"creationTime"),s=this.safeInteger(e,"lastUpdate"),r=this.safeString(e,"transferType"),a=this.safeValue(e,"cryptoPaymentDetail",{}),o=this.safeString(a,"address"),n=this.safeString(a,"txId");let d=void 0;d="DEPOSIT"===r?"deposit":"WITHDRAW"===r?"withdrawal":r;const c=this.safeFloat(e,"fee"),h=this.parseTransactionStatus(this.safeString(e,"status")),l=this.safeString(e,"currency"),u=this.safeCurrencyCode(l);let f=this.safeFloat(e,"amount");return void 0!==f&&(f*=1e-8),{id:this.safeString(e,"fundTransferId"),txid:n,timestamp:i,datetime:this.iso8601(i),address:o,tag:void 0,type:d,amount:f,currency:u,status:h,updated:s,fee:{currency:u,cost:c},info:e}}async fetchMarkets(e={}){const t=await this.publicGetV2MarketActive(e),i=[],s=this.safeValue(t,"markets");for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"instrument"),a=this.safeString(t,"currency"),o=r+"/"+a,n=this.safeCurrencyCode(r),d=this.safeCurrencyCode(a),c=n+"/"+d,h="AUD"===d?.0085:.0022;let l=2,u=4;const f=.001;let p=void 0;"AUD"===d&&("XRP"!==n&&"OMG"!==n||(l=4),u=-Math.log10(f),p=Math.pow(10,-l));const m={amount:u,price:l},y={amount:{min:f,max:void 0},price:{min:p,max:void 0},cost:{min:void 0,max:void 0}};i.push({info:t,id:o,symbol:c,base:n,quote:d,baseId:r,quoteId:a,active:void 0,maker:h,taker:h,limits:y,precision:m})}return i}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccountBalance(e),i={info:t};for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"currency"),a=this.safeCurrencyCode(r),o=1e8;let n=this.safeFloat(s,"balance");void 0!==n&&(n/=o);let d=this.safeFloat(s,"pendingFunds");void 0!==d&&(d/=o);const c=this.account();c.used=d,c.total=n,i[a]=c}return this.parseBalance(i)}parseOHLCV(e,t,i="1m",s,r){return[e[0],parseFloat(e[1])/1e8,parseFloat(e[2])/1e8,parseFloat(e[3])/1e8,parseFloat(e[4])/1e8,parseFloat(e[5])/1e8]}async fetchOHLCV(e,t="1m",i,s,r={}){await this.load_markets();const a=this.market(e),o={id:a.id,timeWindow:this.timeframes[t]};void 0!==i&&(o.since=i);const n=await this.webGetMarketBTCMarketsIdTickByTime(this.extend(o,r));return this.parseOHLCVs(n.ticks,a,t,i,s)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={id:this.market(e).id},r=await this.publicGetMarketIdOrderbook(this.extend(s,i)),a=this.safeTimestamp(r,"timestamp");return this.parseOrderBook(r,a)}parseTicker(e,t){const i=this.safeTimestamp(e,"timestamp");let s=void 0;void 0!==t&&(s=t.symbol);const r=this.safeFloat(e,"lastPrice");return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:void 0,low:void 0,bid:this.safeFloat(e,"bestBid"),bidVolume:void 0,ask:this.safeFloat(e,"bestAsk"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeFloat(e,"volume24h"),quoteVolume:void 0,info:e}}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={id:i.id},r=await this.publicGetMarketIdTick(this.extend(s,t));return this.parseTicker(r,i)}parseTrade(e,t){const i=this.safeTimestamp(e,"timestamp");let s=void 0;void 0!==t&&(s=t.symbol);const r=this.safeString(e,"tid"),a=this.safeFloat(e,"price"),o=this.safeFloat(e,"amount");let n=void 0;return void 0!==o&&void 0!==a&&(n=o*a),{info:e,id:r,order:void 0,timestamp:i,datetime:this.iso8601(i),symbol:s,type:void 0,side:void 0,takerOrMaker:void 0,price:a,amount:o,cost:n,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={id:r.id},o=await this.publicGetMarketIdTrades(this.extend(a,s));return this.parseTrades(o,r,t,i)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o=this.market(e),n="buy"===i?"Bid":"Ask",d=this.ordered({currency:o.quote});d.currency=o.quote,d.instrument=o.base,d.price=parseInt(1e8*r),d.volume=parseInt(1e8*s),d.orderSide=n,d.ordertype=this.capitalize(t),d.clientRequestId=this.nonce().toString();const c=await this.privatePostOrderCreate(this.extend(d,a));return{info:c,id:this.safeString(c,"id")}}async cancelOrders(e,t,i={}){await this.loadMarkets();for(let t=0;t<e.length;t++)e[t]=parseInt(e[t]);const s={orderIds:e};return await this.privatePostOrderCancel(this.extend(s,i))}async cancelOrder(e,t,i={}){return await this.loadMarkets(),await this.cancelOrders([e])}calculateFee(e,t,i,s,r,a="taker",o={}){const n=this.markets[e],d=n[a];let c=void 0,h=void 0;return"AUD"===n.quote?(c=n.quote,h=parseFloat(this.costToPrecision(e,s*r))):(c=n.base,h=parseFloat(this.amountToPrecision(e,s))),{type:a,currency:c,rate:d,cost:parseFloat(this.feeToPrecision(e,d*h))}}parseMyTrade(e,t){const i=this.safeInteger(e,"creationTime");let s=this.safeFloat(e,"side");s="Bid"===s?"buy":"sell";let r=void 0,a=void 0;void 0!==t&&(r="AUD"===t.quote?t.quote:t.base,a=t.symbol);const o=this.safeString(e,"id");let n=this.safeFloat(e,"price");void 0!==n&&(n/=1e8);let d=this.safeFloat(e,"volume");void 0!==d&&(d/=1e8);let c=this.safeFloat(e,"fee");void 0!==c&&(c/=1e8);let h=void 0;void 0!==n&&void 0!==d&&(h=n*d);const l=this.safeString(e,"orderId");return{info:e,id:o,timestamp:i,datetime:this.iso8601(i),order:l,symbol:a,type:void 0,side:s,price:n,amount:d,cost:h,fee:{currency:r,cost:c}}}parseMyTrades(e,t,i,s){const r=[];for(let i=0;i<e.length;i++){const s=this.parseMyTrade(e[i],t);r.push(s)}return r}parseOrder(e,t){const i="Bid"===e.orderSide?"buy":"sell",s="Limit"===e.ordertype?"limit":"market",r=this.safeInteger(e,"creationTime");void 0===t&&(t=this.market(e.instrument+"/"+e.currency));let a="open";"Failed"===e.status||"Cancelled"===e.status||"Partially Cancelled"===e.status||"Error"===e.status?a="canceled":"Fully Matched"!==e.status&&"Partially Matched"!==e.status||(a="closed");const o=this.safeFloat(e,"price")/1e8,n=this.safeFloat(e,"volume")/1e8,d=this.safeFloat(e,"openVolume",0)/1e8,c=n-d,h=this.parseMyTrades(e.trades,t),l=h.length;let u=c*o,f=void 0,p=void 0;if(l>0){u=0;for(let e=0;e<l;e++){const t=h[e];u=this.sum(u,t.cost)}c>0&&(f=u/c),p=h[l-1].timestamp}return{info:e,id:this.safeString(e,"id"),timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:p,symbol:t.symbol,type:s,side:i,price:o,cost:u,amount:n,filled:c,remaining:d,average:f,status:a,trades:h,fee:void 0}}async fetchOrder(e,t,i={}){await this.loadMarkets();const s={orderIds:[parseInt(e)]},r=await this.privatePostOrderDetail(this.extend(s,i));if(r.orders.length<1)throw new a(this.id+" No matching order found: "+e);const o=r.orders[0];return this.parseOrder(o)}createPaginatedRequest(e,t,i){return i=void 0===i?100:i,t=void 0===t?0:t,this.ordered({currency:e.quoteId,instrument:e.baseId,limit:i,since:t})}async fetchOrders(e,t,i,s={}){if(void 0===e)throw new o(this.id+": fetchOrders requires a `symbol` argument.");await this.loadMarkets();const r=this.market(e),a=this.createPaginatedRequest(r,t,i),n=await this.privatePostOrderHistory(this.extend(a,s));return this.parseOrders(n.orders,r)}async fetchOpenOrders(e,t,i,s={}){if(void 0===e)throw new o(this.id+": fetchOpenOrders requires a `symbol` argument.");await this.loadMarkets();const r=this.market(e),a=this.createPaginatedRequest(r,t,i),n=await this.privatePostOrderOpen(this.extend(a,s));return this.parseOrders(n.orders,r)}async fetchClosedOrders(e,t,i,s={}){const r=await this.fetchOrders(e,t,i,s);return this.filterBy(r,"status","closed")}async fetchMyTrades(e,t,i,s={}){if(void 0===e)throw new o(this.id+": fetchMyTrades requires a `symbol` argument.");await this.loadMarkets();const r=this.market(e),a=this.createPaginatedRequest(r,t,i),n=await this.privatePostOrderTradeHistory(this.extend(a,s));return this.parseMyTrades(n.trades,r)}nonce(){return this.milliseconds()}sign(e,t="public",i="GET",s={},r,a){const o="/"+this.implodeParams(e,s);let n=this.urls.api[t]+o;if("private"===t){this.checkRequiredCredentials();const t=this.nonce().toString();let d=void 0;if(r={apikey:this.apiKey,timestamp:t},"POST"===i)r["Content-Type"]="application/json",d=o+"\n"+t+"\n",d+=a=this.json(s);else{const i=this.keysort(this.omit(s,this.extractParams(e)));let r="";Object.keys(i).length&&(n+="?"+(r=this.urlencode(i)),r+="\n"),d=o+"\n"+r+t+"\n"}const c=this.base64ToBinary(this.secret),h=this.hmac(this.encode(d),c,"sha512","base64");r.signature=this.decode(h)}else Object.keys(s).length&&(n+="?"+this.urlencode(s));return{url:n,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,o,n,d,c){if(void 0!==n&&"success"in n&&!n.success){const e=this.safeString(n,"errorCode"),t=this.id+" "+this.json(n);if(e in this.exceptions){throw new(0,this.exceptions[e])(t)}throw new r(t)}}}},function(e,t,i){"use strict";const s=i(13),{ExchangeError:r}=i(0);e.exports=class extends s{describe(){const e=this.deepExtend(super.describe(),{id:"btctradeim",name:"BtcTrade.im",countries:["HK"],urls:{referral:"https://m.baobi.com/invite?inv=1765b2",logo:"https://user-images.githubusercontent.com/1294454/36770531-c2142444-1c5b-11e8-91e2-a4d90dc85fe8.jpg",api:{web:"https://api.btctrade.im/coin",rest:"https://api.btctrade.im/api/v1"},www:"https://www.btctrade.im",doc:"https://www.btctrade.im/help.api.html",fees:"https://www.btctrade.im/spend.price.html"},status:{status:"error",updated:void 0,eta:void 0,url:void 0},fees:{trading:{maker:.002,taker:.002},funding:{withdraw:{BTC:.001}}}});return e.options.quoteIds=["btc","eth","usc"],e}async request(e,t="public",i="GET",s={},a,o){const n=await this.fetch2(e,t,i,s,a,o);if("web"===t)return n;const d=this.safeValue(n,"data");if(d){if("0"!==this.safeString(n,"code")){const e=this.safeString(n,"msg","Error");throw new r(e)}return d}return n}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,ArgumentsRequired:a}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"btctradeua",name:"BTC Trade UA",countries:["UA"],rateLimit:3e3,has:{CORS:!0,createMarketOrder:!1,fetchOpenOrders:!0},urls:{referral:"https://btc-trade.com.ua/registration/22689",logo:"https://user-images.githubusercontent.com/1294454/27941483-79fc7350-62d9-11e7-9f61-ac47f28fcd96.jpg",api:"https://btc-trade.com.ua/api",www:"https://btc-trade.com.ua",doc:"https://docs.google.com/document/d/1ocYA0yMy_RXd561sfG3qEPZ80kyll36HUxvCRe5GbhE/edit"},api:{public:{get:["deals/{symbol}","trades/sell/{symbol}","trades/buy/{symbol}","japan_stat/high/{symbol}"]},private:{post:["auth","ask/{symbol}","balance","bid/{symbol}","buy/{symbol}","my_orders/{symbol}","order/status/{id}","remove/order/{id}","sell/{symbol}"]}},markets:{"BCH/UAH":{id:"bch_uah",symbol:"BCH/UAH",base:"BCH",quote:"UAH",baseId:"bch",quoteId:"uah"},"BTC/UAH":{id:"btc_uah",symbol:"BTC/UAH",base:"BTC",quote:"UAH",baseId:"btc",quoteId:"uah",precision:{price:1},limits:{amount:{min:1e-10}}},"DASH/BTC":{id:"dash_btc",symbol:"DASH/BTC",base:"DASH",quote:"BTC",baseId:"dash",quoteId:"btc"},"DASH/UAH":{id:"dash_uah",symbol:"DASH/UAH",base:"DASH",quote:"UAH",baseId:"dash",quoteId:"uah"},"DOGE/BTC":{id:"doge_btc",symbol:"DOGE/BTC",base:"DOGE",quote:"BTC",baseId:"doge",quoteId:"btc"},"DOGE/UAH":{id:"doge_uah",symbol:"DOGE/UAH",base:"DOGE",quote:"UAH",baseId:"doge",quoteId:"uah"},"ETH/UAH":{id:"eth_uah",symbol:"ETH/UAH",base:"ETH",quote:"UAH",baseId:"eth",quoteId:"uah"},"ITI/UAH":{id:"iti_uah",symbol:"ITI/UAH",base:"ITI",quote:"UAH",baseId:"iti",quoteId:"uah"},"KRB/UAH":{id:"krb_uah",symbol:"KRB/UAH",base:"KRB",quote:"UAH",baseId:"krb",quoteId:"uah"},"LTC/BTC":{id:"ltc_btc",symbol:"LTC/BTC",base:"LTC",quote:"BTC",baseId:"ltc",quoteId:"btc"},"LTC/UAH":{id:"ltc_uah",symbol:"LTC/UAH",base:"LTC",quote:"UAH",baseId:"ltc",quoteId:"uah"},"NVC/BTC":{id:"nvc_btc",symbol:"NVC/BTC",base:"NVC",quote:"BTC",baseId:"nvc",quoteId:"btc"},"NVC/UAH":{id:"nvc_uah",symbol:"NVC/UAH",base:"NVC",quote:"UAH",baseId:"nvc",quoteId:"uah"},"PPC/BTC":{id:"ppc_btc",symbol:"PPC/BTC",base:"PPC",quote:"BTC",baseId:"ppc",quoteId:"btc"},"SIB/UAH":{id:"sib_uah",symbol:"SIB/UAH",base:"SIB",quote:"UAH",baseId:"sib",quoteId:"uah"},"XMR/UAH":{id:"xmr_uah",symbol:"XMR/UAH",base:"XMR",quote:"UAH",baseId:"xmr",quoteId:"uah"},"ZEC/UAH":{id:"zec_uah",symbol:"ZEC/UAH",base:"ZEC",quote:"UAH",baseId:"zec",quoteId:"uah"}},fees:{trading:{maker:.001,taker:.001},funding:{withdraw:{BTC:6e-4,LTC:.01,NVC:.01,DOGE:10}}}})}async signIn(e={}){return await this.privatePostAuth(e)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostBalance(e),i={info:t},s=this.safeValue(t,"accounts");for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeFloat(t,"balance"),i[a]=o}return this.parseBalance(i)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={symbol:this.market(e).id},r=await this.publicGetTradesBuySymbol(this.extend(s,i)),a=await this.publicGetTradesSellSymbol(this.extend(s,i)),o={bids:[],asks:[]};return r&&"list"in r&&(o.bids=r.list),a&&"list"in a&&(o.asks=a.list),this.parseOrderBook(o,void 0,"bids","asks","price","currency_trade")}async fetchTicker(e,t={}){await this.loadMarkets();const i={symbol:this.marketId(e)},s=await this.publicGetJapanStatHighSymbol(this.extend(i,t)),r=this.safeValue(s,"trades"),a=this.milliseconds(),o={symbol:e,timestamp:a,datetime:this.iso8601(a),high:void 0,low:void 0,bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:void 0,close:void 0,last:void 0,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:void 0,info:r},n=r.length;if(n>0){for(let e=Math.max(n-48,0);e<r.length;e++){const t=r[e];void 0===o.open&&(o.open=t[1]),(void 0===o.high||o.high<t[2])&&(o.high=t[2]),(void 0===o.low||o.low>t[3])&&(o.low=t[3]),void 0===o.baseVolume?o.baseVolume=-t[5]:o.baseVolume-=t[5]}const e=n-1;o.last=r[e][4],o.close=o.last,o.baseVolume=-1*o.baseVolume}return o}convertCyrillicMonthNameToString(e){return this.safeString({"":"01","":"02","":"03","":"04","":"05","":"06","":"07","":"08","":"09","":"10","":"11","":"12"},e)}parseCyrillicDatetime(e){const t=e.split(" ");let i=t[0];const s=this.convertCyrillicMonthNameToString(t[1]);if(!s)throw new r(this.id+" parseTrade() undefined month name: "+e);const a=t[2];let o=t[4];7===o.length&&(o="0"+o),1===i.length&&(i="0"+i);const n=[a,s,i].join("-")+"T"+o,d=this.parse8601(n);let c=[s,i].join("");return(c=parseInt(c))<325||c>1028?d-72e5:d-108e5}parseTrade(e,t){const i=this.parseCyrillicDatetime(this.safeString(e,"pub_date")),s=this.safeString(e,"id"),r=this.safeString(e,"type"),a=this.safeFloat(e,"price"),o=this.safeFloat(e,"amnt_trade");let n=void 0;void 0!==o&&void 0!==a&&(n=a*o);let d=void 0;return void 0!==t&&(d=t.symbol),{id:s,info:e,timestamp:i,datetime:this.iso8601(i),symbol:d,type:"limit",side:r,order:void 0,takerOrMaker:void 0,price:a,amount:o,cost:n,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id},o=await this.publicGetDealsSymbol(this.extend(a,s)),n=[];for(let e=0;e<o.length;e++)o[e].id%2&&n.push(o[e]);return this.parseTrades(n,r,t,i)}async createOrder(e,t,i,s,a,o={}){if("market"===t)throw new r(this.id+" allows limit orders only");await this.loadMarkets();const n=this.market(e),d="privatePost"+this.capitalize(i)+"Id",c={count:s,currency1:n.quoteId,currency:n.baseId,price:a};return this[d](this.extend(c,o))}async cancelOrder(e,t,i={}){const s={id:e};return await this.privatePostRemoveOrderId(this.extend(s,i))}parseOrder(e,t){const i=this.milliseconds();let s=void 0;return void 0!==t&&(s=t.symbol),{id:this.safeString(e,"id"),timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,status:"open",symbol:s,type:void 0,side:this.safeString(e,"type"),price:this.safeFloat(e,"price"),amount:this.safeFloat(e,"amnt_trade"),filled:0,remaining:this.safeFloat(e,"amnt_trade"),trades:void 0,info:e}}async fetchOpenOrders(e,t,i,s={}){if(void 0===e)throw new a(this.id+" fetchOpenOrders requires a symbol argument");await this.loadMarkets();const r=this.market(e),o={symbol:r.id},n=await this.privatePostMyOrdersSymbol(this.extend(o,s)),d=this.safeValue(n,"your_open_orders");return this.parseOrders(d,r,t,i)}nonce(){return this.milliseconds()}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api+"/"+this.implodeParams(e,s);const n=this.omit(s,this.extractParams(e));if("public"===t)Object.keys(n).length&&(o+=this.implodeParams(e,n));else{this.checkRequiredCredentials();const e=this.nonce(),t=(a=this.urlencode(this.extend({out_order_id:e,nonce:e},n)))+this.secret;r={"public-key":this.apiKey,"api-sign":this.hash(this.encode(t),"sha256"),"Content-Type":"application/x-www-form-urlencoded"}}return{url:o,method:i,body:a,headers:r}}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"btcturk",name:"BTCTurk",countries:["TR"],rateLimit:1e3,has:{CORS:!0,fetchTickers:!0,fetchOHLCV:!0},timeframes:{"1d":"1d"},urls:{logo:"https://user-images.githubusercontent.com/1294454/27992709-18e15646-64a3-11e7-9fa2-b0950ec7712f.jpg",api:"https://www.btcturk.com/api",www:"https://www.btcturk.com",doc:"https://github.com/BTCTrader/broker-api-docs"},api:{public:{get:["ohlcdata","orderbook","ticker","trades"]},private:{get:["balance","openOrders","userTransactions"],post:["exchange","cancelOrder"]}},fees:{trading:{maker:.00236,taker:.003*1.18}}})}async fetchMarkets(e={}){const t=await this.publicGetTicker(e),i=[];for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"pair");let a=r.slice(0,3),o=r.slice(3,6);const n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o);a=a.toLowerCase(),o=o.toLowerCase();const c=n+"/"+d,h={amount:8,price:8},l=!0;i.push({id:r,symbol:c,base:n,quote:d,baseId:a,quoteId:o,active:l,info:s,precision:h,limits:{amount:{min:Math.pow(10,-h.amount),max:void 0},price:{min:Math.pow(10,-h.price),max:void 0},cost:{min:void 0,max:void 0}}})}return i}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalance(e),i={info:t},s=Object.keys(this.currencies);for(let e=0;e<s.length;e++){const r=s[e],a=this.currencies[r],o=a.id+"_available",n=a.id+"_balance",d=a.id+"_reserved";if(o in t){const e=this.account();e.free=this.safeFloat(t,o),e.total=this.safeFloat(t,n),e.used=this.safeFloat(t,d),i[r]=e}}return this.parseBalance(i)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={pairSymbol:this.market(e).id},r=await this.publicGetOrderbook(this.extend(s,i)),a=this.safeTimestamp(r,"timestamp");return this.parseOrderBook(r,a)}parseTicker(e,t){let i=void 0;t&&(i=t.symbol);const s=this.safeTimestamp(e,"timestamp"),r=this.safeFloat(e,"last");return{symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"bid"),bidVolume:void 0,ask:this.safeFloat(e,"ask"),askVolume:void 0,vwap:void 0,open:this.safeFloat(e,"open"),close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:this.safeFloat(e,"average"),baseVolume:this.safeFloat(e,"volume"),quoteVolume:void 0,info:e}}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetTicker(t),s={};for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"pair");let a=r,o=void 0;r in this.markets_by_id&&(a=(o=this.markets_by_id[a]).symbol),s[a]=this.parseTicker(t,o)}return s}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s=await this.fetchTickers(t);return this.safeValue2(s,i.id,e)}parseTrade(e,t){const i=this.safeTimestamp(e,"date"),s=this.safeString(e,"tid"),r=this.safeFloat(e,"price"),a=this.safeFloat(e,"amount");let o=void 0;void 0!==a&&void 0!==r&&(o=a*r);let n=void 0;return void 0!==t&&(n=t.symbol),{id:s,info:e,timestamp:i,datetime:this.iso8601(i),symbol:n,type:void 0,side:void 0,order:void 0,takerOrMaker:void 0,price:r,amount:a,cost:o,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={pairSymbol:r.id},o=await this.publicGetTrades(this.extend(a,s));return this.parseTrades(o,r,t,i)}parseOHLCV(e,t,i="1d",s,r){return[this.parse8601(this.safeString(e,"Time")),this.safeFloat(e,"Open"),this.safeFloat(e,"High"),this.safeFloat(e,"Low"),this.safeFloat(e,"Close"),this.safeFloat(e,"Volume")]}async fetchOHLCV(e,t="1d",i,s,r={}){await this.loadMarkets();const a=this.market(e),o={};void 0!==s&&(o.last=s);const n=await this.publicGetOhlcdata(this.extend(o,r));return this.parseOHLCVs(n,a,t,i,s)}async createOrder(e,t,i,s,a,o={}){await this.loadMarkets();const n={PairSymbol:this.marketId(e),OrderType:"buy"===i?0:1,OrderMethod:"market"===t?1:0};if("market"===t){if(!("Total"in o))throw new r(this.id+' createOrder requires the "Total" extra parameter for market orders (amount and price are both ignored)')}else n.Price=a,n.Amount=s;const d=await this.privatePostExchange(this.extend(n,o));return{info:d,id:this.safeString(d,"id")}}async cancelOrder(e,t,i={}){const s={id:e};return await this.privatePostCancelOrder(this.extend(s,i))}nonce(){return this.milliseconds()}sign(e,t="public",i="GET",s={},a,o){if("btctrader"===this.id)throw new r(this.id+" is an abstract base API for BTCExchange, BTCTurk");let n=this.urls.api+"/"+e;if("public"===t)Object.keys(s).length&&(n+="?"+this.urlencode(s));else{this.checkRequiredCredentials();const e=this.nonce().toString();o=this.urlencode(s);const t=this.base64ToBinary(this.secret),i=this.apiKey+e;a={"X-PCK":this.apiKey,"X-Stamp":e,"X-Signature":this.stringToBase64(this.hmac(this.encode(i),t,"sha256","binary")),"Content-Type":"application/x-www-form-urlencoded"}}return{url:n,method:i,body:o,headers:a}}}},function(e,t,i){"use strict";const s=i(1),{AddressPending:r,AuthenticationError:a,ExchangeError:o,NotSupported:n,PermissionDenied:d}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"buda",name:"Buda",countries:["AR","CL","CO","PE"],rateLimit:1e3,version:"v2",has:{CORS:!1,createDepositAddress:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingFees:!0,fetchMyTrades:!1,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrders:!0,fetchTrades:!0,fetchWithdrawals:!0,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/47380619-8a029200-d706-11e8-91e0-8a391fe48de3.jpg",api:"https://www.buda.com/api",www:"https://www.buda.com",doc:"https://api.buda.com",fees:"https://www.buda.com/comisiones"},status:{status:"error",updated:void 0,eta:void 0,url:void 0},api:{public:{get:["pairs","markets","currencies","markets/{market}","markets/{market}/ticker","markets/{market}/volume","markets/{market}/order_book","markets/{market}/trades","currencies/{currency}/fees/deposit","currencies/{currency}/fees/withdrawal","tv/history"],post:["markets/{market}/quotations"]},private:{get:["balances","balances/{currency}","currencies/{currency}/balances","orders","orders/{id}","markets/{market}/orders","deposits","currencies/{currency}/deposits","withdrawals","currencies/{currency}/withdrawals","currencies/{currency}/receive_addresses","currencies/{currency}/receive_addresses/{id}"],post:["markets/{market}/orders","currencies/{currency}/deposits","currencies/{currency}/withdrawals","currencies/{currency}/simulated_withdrawals","currencies/{currency}/receive_addresses"],put:["orders/{id}"]}},timeframes:{"1m":"1","5m":"5","30m":"30","1h":"60","2h":"120","1d":"D","1w":"W"},fees:{trading:{tierBased:!0,percentage:!0,taker:.008,maker:.004,tiers:{taker:[[0,.008],[2e3,.007],[2e4,.006],[1e5,.005],[5e5,.004],[25e5,.003],[125e5,.002]],maker:[[0,.004],[2e3,.0035],[2e4,.003],[1e5,.0025],[5e5,.002],[25e5,.0015],[125e5,.001]]}}},exceptions:{not_authorized:a,forbidden:d,invalid_record:o,not_found:o,parameter_missing:o,bad_parameter:o}})}async fetchCurrencyInfo(e,t){if(!t){const e=await this.publicGetCurrencies();t=this.safeValue(e,"currencies")}for(let i=0;i<t.length;i++){const s=t[i];if(s.id===e)return s}}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),i=this.safeValue(t,"markets"),s=await this.publicGetCurrencies(),r=this.safeValue(s,"currencies"),a=[];for(let e=0;e<i.length;e++){const t=i[e],s=this.safeString(t,"id"),o=this.safeString(t,"base_currency"),n=this.safeString(t,"quote_currency"),d=this.safeCurrencyCode(o),c=this.safeCurrencyCode(n),h=await this.fetchCurrencyInfo(o,r),l=await this.fetchCurrencyInfo(n,r),u=d+"/"+c,f={amount:h.input_decimals,price:l.input_decimals},p={amount:{min:parseFloat(t.minimum_order_amount[0]),max:void 0},price:{min:Math.pow(10,-f.price),max:void 0}};p.cost={min:p.amount.min*p.price.min,max:void 0},a.push({id:s,symbol:u,base:d,quote:c,baseId:o,quoteId:n,active:!0,precision:f,limits:p,info:t})}return a}async fetchCurrencies(e={}){const t=(await this.publicGetCurrencies()).currencies,i={};for(let e=0;e<t.length;e++){const s=t[e];if(!s.managed)continue;const r=this.safeString(s,"id"),a=this.safeCurrencyCode(r),o=this.safeFloat(s,"input_decimals"),n=Math.pow(10,-o);i[a]={id:r,code:a,info:s,name:void 0,active:!0,fee:void 0,precision:o,limits:{amount:{min:n,max:void 0},price:{min:n,max:void 0},cost:{min:void 0,max:void 0},deposit:{min:parseFloat(s.deposit_minimum[0]),max:void 0},withdraw:{min:parseFloat(s.withdrawal_minimum[0])}}}}return i}async fetchFundingFees(e,t={}){await this.loadMarkets();const i={},s={},r={};void 0===e&&(e=Object.keys(this.currencies));for(let t=0;t<e.length;t++){const a=e[t],o={currency:this.currency(a).id},n=await this.publicGetCurrenciesCurrencyFeesWithdrawal(o),d=await this.publicGetCurrenciesCurrencyFeesDeposit(o);i[a]=this.parseFundingFee(n.fee),s[a]=this.parseFundingFee(d.fee),r[a]={withdraw:n,deposit:d}}return{withdraw:i,deposit:s,info:r}}parseFundingFee(e,t){return void 0===t&&(t=e.name),"withdrawal"===t&&(t="withdraw"),{type:t,currency:e.base[1],rate:e.percent,cost:parseFloat(e.base[0])}}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={market:i.id},r=await this.publicGetMarketsMarketTicker(this.extend(s,t)),a=this.safeValue(r,"ticker");return this.parseTicker(a,i)}parseTicker(e,t){const i=this.milliseconds();let s=void 0;void 0!==t&&(s=t.symbol);const r=parseFloat(e.last_price[0]),a=parseFloat(e.price_variation_24h),o=parseFloat(this.priceToPrecision(s,r/(a+1))),n=r-o,d=this.sum(r,o)/2;return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:void 0,low:void 0,bid:parseFloat(e.max_bid[0]),bidVolume:void 0,ask:parseFloat(e.min_ask[0]),askVolume:void 0,vwap:void 0,open:o,close:r,last:r,previousClose:o,change:n,percentage:100*a,average:d,baseVolume:parseFloat(e.volume[0]),quoteVolume:void 0,info:e}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={market:r.id};void 0!==i&&(a.limit=i);const o=await this.publicGetMarketsMarketTrades(this.extend(a,s));return this.parseTrades(o.trades.entries,r,t,i)}parseTrade(e,t){let i=void 0,s=void 0;let r=void 0,a=void 0,o=void 0;let n=void 0,d=void 0;return t&&(n=t.symbol),Array.isArray(e)&&(i=parseInt(e[0]),d=(r=parseFloat(e[1]))*(a=parseFloat(e[2])),s=e[3],o=e[4].toString()),{id:o,order:void 0,info:e,timestamp:i,datetime:this.iso8601(i),symbol:n,type:void 0,side:s,takerOrMaker:void 0,price:r,amount:a,cost:d,fee:void 0}}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={market:this.market(e).id},r=await this.publicGetMarketsMarketOrderBook(this.extend(s,i)),a=this.safeValue(r,"order_book");return this.parseOrderBook(a)}async fetchOHLCV(e,t="1m",i,s,r={}){await this.loadMarkets();const a=this.market(e);void 0===i&&(i=this.milliseconds()-864e5);const o={symbol:a.id,resolution:this.timeframes[t],from:i/1e3,to:this.seconds()},n=await this.publicGetTvHistory(this.extend(o,r));return this.parseTradingViewOHLCV(n,a,t,i,s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalances(e),i={info:t},s=this.safeValue(t,"balances");for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"id"),a=this.safeCurrencyCode(r),o=this.account();o.free=parseFloat(t.available_amount[0]),o.total=parseFloat(t.amount[0]),i[a]=o}return this.parseBalance(i)}async fetchOrder(e,t,i={}){await this.loadMarkets();const s={id:parseInt(e)},r=await this.privateGetOrdersId(this.extend(s,i)),a=this.safeValue(r,"order");return this.parseOrder(a)}async fetchOrders(e,t,i,s={}){await this.loadMarkets();let r=void 0;void 0!==e&&(r=this.market(e));const a={market:r.id,per:i},o=await this.privateGetMarketsMarketOrders(this.extend(a,s)),n=this.safeValue(o,"orders");return this.parseOrders(n,r,t,i)}async fetchOpenOrders(e,t,i,s={}){return await this.fetchOrders(e,t,i,this.extend({state:"pending"},s))}async fetchClosedOrders(e,t,i,s={}){return await this.fetchOrders(e,t,i,this.extend({state:"traded"},s))}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets(),i="buy"===i?"Bid":"Ask";const o={market:this.marketId(e),price_type:t,type:i,amount:this.amountToPrecision(e,s)};"limit"===t&&(o.limit=this.priceToPrecision(e,r));const n=await this.privatePostMarketsMarketOrders(this.extend(o,a)),d=this.safeValue(n,"order");return this.parseOrder(d)}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={id:parseInt(e),state:"canceling"},r=await this.privatePutOrdersId(this.extend(s,i)),a=this.safeValue(r,"order");return this.parseOrder(a)}parseOrderStatus(e){return this.safeString({traded:"closed",received:"open",canceling:"canceled"},e,e)}parseOrder(e,t){const i=this.safeString(e,"id"),s=this.parse8601(this.safeString(e,"created_at"));let r=void 0;if(void 0===t){const i=e.market_id;i in this.markets_by_id&&(t=this.markets_by_id[i])}void 0!==t&&(r=t.symbol);const a=this.safeString(e,"price_type"),o=this.safeStringLower(e,"type"),n=this.parseOrderStatus(this.safeString(e,"state")),d=parseFloat(e.original_amount[0]),c=parseFloat(e.amount[0]),h=parseFloat(e.traded_amount[0]),l=parseFloat(e.total_exchanged[0]);let u=this.safeFloat(e,"limit");void 0!==u&&(u=parseFloat(u[0])),l>0&&h>0&&(u=this.priceToPrecision(r,l/h));const f={cost:parseFloat(e.paid_fee[0]),currency:e.paid_fee[1]};return{id:i,datetime:this.iso8601(s),timestamp:s,lastTradeTimestamp:void 0,status:n,symbol:r,type:a,side:o,price:u,cost:l,amount:d,filled:h,remaining:c,trades:void 0,fee:f,info:e}}isFiat(e){return this.safeValue({ARS:!0,CLP:!0,COP:!0,PEN:!0},e,!1)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i=this.currency(e);if(this.isFiat(e))throw new n(this.id+" fetchDepositAddress() for fiat "+e+" is not supported");const s={currency:i.id},a=await this.privateGetCurrenciesCurrencyReceiveAddresses(this.extend(s,t)),o=this.safeValue(a,"receive_addresses"),d=[];for(let e=1;e<o.length;e++){const t=o[e];if(t.ready){const e=t.address;this.checkAddress(e),d.push(e)}}if(d.length<1)throw new r(this.id+": there are no addresses ready for receiving "+e+", retry again later)");return{currency:e,address:d[0],tag:void 0,info:o}}async createDepositAddress(e,t={}){await this.loadMarkets();const i=this.currency(e);if(this.isFiat(e))throw new n(this.id+": fiat fetchDepositAddress() for "+e+" is not supported");const s={currency:i.id},r=await this.privatePostCurrenciesCurrencyReceiveAddresses(this.extend(s,t));return{currency:e,address:this.safeString(r.receive_address,"address"),tag:void 0,info:r}}parseTransactionStatus(e){return this.safeString({rejected:"failed",confirmed:"ok",anulled:"canceled",retained:"canceled",pending_confirmation:"pending"},e,e)}parseTransaction(e,t){const i=this.safeString(e,"id"),s=this.parse8601(this.safeString(e,"created_at")),r=this.safeString(e,"currency"),a=this.safeCurrencyCode(r,t),o=parseFloat(e.amount[0]),n=parseFloat(e.fee[0]),d=e.fee[1],c=this.parseTransactionStatus(this.safeString(e,"state")),h="deposit_data"in e?"deposit":"withdrawal",l=this.safeValue(e,h+"_data",{}),u=this.safeValue(l,"target_address"),f=this.safeString(l,"tx_hash"),p=this.parse8601(this.safeString(l,"updated_at"));return{info:e,id:i,txid:f,timestamp:s,datetime:this.iso8601(s),address:u,type:h,amount:o,currency:a,status:c,updated:p,fee:{cost:n,rate:d}}}async fetchDeposits(e,t,i,s={}){if(await this.loadMarkets(),void 0===e)throw new o(this.id+": fetchDeposits() requires a currency code argument");const r=this.currency(e),a={currency:r.id,per:i},n=await this.privateGetCurrenciesCurrencyDeposits(this.extend(a,s)),d=this.safeValue(n,"deposits");return this.parseTransactions(d,r,t,i)}async fetchWithdrawals(e,t,i,s={}){if(await this.loadMarkets(),void 0===e)throw new o(this.id+": fetchDeposits() requires a currency code argument");const r=this.currency(e),a={currency:r.id,per:i},n=await this.privateGetCurrenciesCurrencyWithdrawals(this.extend(a,s)),d=this.safeValue(n,"withdrawals");return this.parseTransactions(d,r,t,i)}async withdraw(e,t,i,s,r={}){this.checkAddress(i),await this.loadMarkets();const a={currency:this.currency(e).id,amount:t,withdrawal_data:{target_address:i}},o=await this.privatePostCurrenciesCurrencyWithdrawals(this.extend(a,r)),n=this.safeValue(o,"withdrawal");return this.parseTransaction(n)}nonce(){return this.microseconds()}sign(e,t="public",i="GET",s={},r,a){let o=this.implodeParams(e,s);const n=this.omit(s,this.extractParams(e));Object.keys(n).length&&("GET"===i?o+="?"+this.urlencode(n):a=this.json(n));const d=this.urls.api+"/"+this.version+"/"+o;if("private"===t){this.checkRequiredCredentials();const e=this.nonce().toString(),t=[i,"/api/"+this.version+"/"+o];if(a){const e=this.stringToBase64(this.encode(a));t.push(this.decode(e))}t.push(e);const s=t.join(" "),n=this.hmac(this.encode(s),this.encode(this.secret),"sha384");r={"X-SBTC-APIKEY":this.apiKey,"X-SBTC-SIGNATURE":n,"X-SBTC-NONCE":e,"Content-Type":"application/json"}}return{url:d,method:i,body:a,headers:r}}handleErrors(e,t,i,s,r,a,n,d,c){if(void 0!==n&&e>=400){const e=this.safeString(n,"code"),t=this.safeString(n,"message",a),i=this.id+" "+t,s=this.exceptions;if(void 0!==e)throw e in s?new s[e](i):new o(i)}}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,ArgumentsRequired:a,NullResponse:o,InvalidOrder:n,NotSupported:d}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"cex",name:"CEX.IO",countries:["GB","EU","CY","RU"],rateLimit:1500,has:{CORS:!0,fetchCurrencies:!0,fetchTickers:!0,fetchOHLCV:!0,fetchOrder:!0,fetchOpenOrders:!0,fetchClosedOrders:!0,fetchDepositAddress:!0,fetchOrders:!0},timeframes:{"1m":"1m"},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766442-8ddc33b0-5ed8-11e7-8b98-f786aef0f3c9.jpg",api:"https://cex.io/api",www:"https://cex.io",doc:"https://cex.io/cex-api",fees:["https://cex.io/fee-schedule","https://cex.io/limits-commissions"],referral:"https://cex.io/r/0/up105393824/0/"},requiredCredentials:{apiKey:!0,secret:!0,uid:!0},api:{public:{get:["currency_profile","currency_limits/","last_price/{pair}/","last_prices/{currencies}/","ohlcv/hd/{yyyymmdd}/{pair}","order_book/{pair}/","ticker/{pair}/","tickers/{currencies}/","trade_history/{pair}/"],post:["convert/{pair}","price_stats/{pair}"]},private:{post:["active_orders_status/","archived_orders/{pair}/","balance/","cancel_order/","cancel_orders/{pair}/","cancel_replace_order/{pair}/","close_position/{pair}/","get_address/","get_myfee/","get_order/","get_order_tx/","open_orders/{pair}/","open_orders/","open_position/{pair}/","open_positions/{pair}/","place_order/{pair}/"]}},fees:{trading:{maker:.0016,taker:.0025},funding:{withdraw:{BTC:.001,ETH:.01,BCH:.001,DASH:.01,BTG:.001,ZEC:.001,XRP:.02},deposit:{BTC:0,ETH:0,BCH:0,DASH:0,BTG:0,ZEC:0,XRP:0,XLM:0}}},options:{fetchOHLCVWarning:!0,createMarketBuyOrderRequiresPrice:!0,order:{status:{c:"canceled",d:"closed",cd:"closed",a:"open"}}}})}async fetchCurrenciesFromCache(e={}){const t=this.safeValue(this.options,"fetchCurrencies",{}),i=this.safeInteger(t,"timestamp"),s=this.safeInteger(t,"expires",1e3),r=this.milliseconds();if(void 0===i||r-i>s){const i=await this.publicGetCurrencyProfile(e);this.options.fetchCurrencies=this.extend(t,{response:i,timestamp:r})}return this.safeValue(this.options.fetchCurrencies,"response")}async fetchCurrencies(e={}){const t=await this.fetchCurrenciesFromCache(e);this.options.currencies={timestamp:this.milliseconds(),response:t};const i=this.safeValue(t,"data",[]),s=this.safeValue(i,"symbols",[]),r={};for(let e=0;e<s.length;e++){const t=s[e],i=this.safeString(t,"code"),a=this.safeCurrencyCode(i),o=this.safeInteger(t,"precision"),n=!0;r[a]={id:i,code:a,name:i,active:n,precision:o,fee:void 0,limits:{amount:{min:this.safeFloat(t,"minimumCurrencyAmount"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0},withdraw:{min:this.safeFloat(t,"minimalWithdrawalAmount"),max:void 0}},info:t}}return r}async fetchMarkets(e={}){const t=await this.fetchCurrenciesFromCache(e),i=this.safeValue(t,"data",{}),s=this.safeValue(i,"symbols",[]),r=this.indexBy(s,"code"),a=this.safeValue(i,"pairs",[]),o=await this.publicGetCurrencyLimits(e),n=[],d=this.safeValue(o.data,"pairs");for(let e=0;e<d.length;e++){const t=d[e],i=this.safeString(t,"symbol1"),s=this.safeString(t,"symbol2"),o=i+"/"+s,c=this.safeCurrencyCode(i),h=this.safeCurrencyCode(s),l=c+"/"+h,u=this.safeValue(r,i,{}),f=this.safeValue(r,s,{});let p=this.safeInteger(f,"precision",8);for(let e=0;e<a.length;e++){const t=a[e];t.symbol1===i&&t.symbol2===s&&(p=this.safeInteger(t,"pricePrecision",p))}const m={amount:this.safeInteger(u,"precision",8)-this.safeInteger(u,"scale",0),price:p};n.push({id:o,info:t,symbol:l,base:c,quote:h,baseId:i,quoteId:s,precision:m,limits:{amount:{min:this.safeFloat(t,"minLotSize"),max:this.safeFloat(t,"maxLotSize")},price:{min:this.safeFloat(t,"minPrice"),max:this.safeFloat(t,"maxPrice")},cost:{min:this.safeFloat(t,"minLotSizeS2"),max:void 0}}})}return n}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostBalance(e),i={info:t},s=this.omit(t,["username","timestamp"]),r=Object.keys(s);for(let e=0;e<r.length;e++){const t=r[e],a=this.safeValue(s,t,{}),o=this.account();o.free=this.safeFloat(a,"available"),o.used=this.safeFloat(a,"orders",0),i[this.safeCurrencyCode(t)]=o}return this.parseBalance(i)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={pair:this.marketId(e)};void 0!==t&&(s.depth=t);const r=await this.publicGetOrderBookPair(this.extend(s,i)),a=this.safeTimestamp(r,"timestamp");return this.parseOrderBook(r,a)}parseOHLCV(e,t,i="1m",s,r){return[1e3*e[0],e[1],e[2],e[3],e[4],e[5]]}async fetchOHLCV(e,t="1m",i,s,a={}){await this.loadMarkets();const n=this.market(e);if(void 0===i)i=this.milliseconds()-864e5;else if(this.options.fetchOHLCVWarning)throw new r(this.id+" fetchOHLCV warning: CEX can return historical candles for a certain date only, this might produce an empty or null reply. Set exchange.options['fetchOHLCVWarning'] = false or add ({ 'options': { 'fetchOHLCVWarning': false }}) to constructor params to suppress this warning message.");let d=this.ymd(i);d=(d=d.split("-")).join("");const c={pair:n.id,yyyymmdd:d};try{const e=await this.publicGetOhlcvHdYyyymmddPair(this.extend(c,a)),r="data"+this.timeframes[t],d=JSON.parse(e[r]);return this.parseOHLCVs(d,n,t,i,s)}catch(e){if(e instanceof o)return[]}}parseTicker(e,t){const i=this.safeTimestamp(e,"timestamp"),s=this.safeFloat(e,"volume"),r=this.safeFloat(e,"high"),a=this.safeFloat(e,"low"),o=this.safeFloat(e,"bid"),n=this.safeFloat(e,"ask"),d=this.safeFloat(e,"last");let c=void 0;return t&&(c=t.symbol),{symbol:c,timestamp:i,datetime:this.iso8601(i),high:r,low:a,bid:o,bidVolume:void 0,ask:n,askVolume:void 0,vwap:void 0,open:void 0,close:d,last:d,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:s,quoteVolume:void 0,info:e}}async fetchTickers(e,t={}){await this.loadMarkets();const i={currencies:Object.keys(this.currencies).join("/")},s=(await this.publicGetTickersCurrencies(this.extend(i,t))).data,r={};for(let e=0;e<s.length;e++){const t=s[e],i=t.pair.replace(":","/"),a=this.markets[i];r[i]=this.parseTicker(t,a)}return r}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={pair:i.id},r=await this.publicGetTickerPair(this.extend(s,t));return this.parseTicker(r,i)}parseTrade(e,t){const i=this.safeTimestamp(e,"date"),s=this.safeString(e,"tid"),r=this.safeString(e,"type"),a=this.safeFloat(e,"price"),o=this.safeFloat(e,"amount");let n=void 0;void 0!==o&&void 0!==a&&(n=o*a);let d=void 0;return void 0!==t&&(d=t.symbol),{info:e,id:s,timestamp:i,datetime:this.iso8601(i),symbol:d,type:void 0,side:r,order:void 0,takerOrMaker:void 0,price:a,amount:o,cost:n,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={pair:r.id},o=await this.publicGetTradeHistoryPair(this.extend(a,s));return this.parseTrades(o,r,t,i)}async createOrder(e,t,i,s,r,a={}){if("market"===t&&"buy"===i&&this.options.createMarketBuyOrderRequiresPrice){if(void 0===r)throw new n(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the cost in the amount argument (the exchange-specific behaviour)");s*=r}await this.loadMarkets();const o={pair:this.marketId(e),type:i,amount:s};"limit"===t?o.price=r:o.order_type=t;const d=await this.privatePostPlaceOrderPair(this.extend(o,a));return{info:d,id:d.id}}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={id:e};return await this.privatePostCancelOrder(this.extend(s,i))}parseOrder(e,t){let i=this.safeValue(e,"time");i="string"==typeof i&&i.indexOf("T")>=0?this.parse8601(i):parseInt(i);let s=void 0;if(void 0===t){const i=this.safeString(e,"symbol1"),r=this.safeString(e,"symbol2");(s=this.safeCurrencyCode(i)+"/"+this.safeCurrencyCode(r))in this.markets&&(t=this.market(s))}const r=this.parseOrderStatus(this.safeString(e,"status")),a=this.safeFloat(e,"price");let o=this.safeFloat(e,"amount");void 0!==o&&(o=Math.abs(o));const n=this.safeFloat2(e,"pending","remains"),d=o-n;let c=void 0,h=void 0;if(void 0!==t){s=t.symbol,void 0===(h=this.safeFloat(e,"ta:"+t.quote))&&(h=this.safeFloat(e,"tta:"+t.quote));const i="fa:"+t.base,r="tfa:"+t.base,a="fa:"+t.quote,o="tfa:"+t.quote;let n=this.safeFloat(e,"tradingFeeMaker");if(n||(n=this.safeFloat(e,"tradingFeeTaker",n)),n&&(n/=100),i in e||r in e){const s=this.safeFloat2(e,i,r);c={currency:t.base,rate:n,cost:s}}else if(a in e||o in e){const i=this.safeFloat2(e,a,o);c={currency:t.quote,rate:n,cost:i}}}h||(h=a*d);const l=e.type;let u=void 0;const f=e.id;if("vtx"in e){u=[];for(let i=0;i<e.vtx.length;i++){const r=e.vtx[i],a=this.safeString(r,"type");if("cancel"===r.type)continue;if(!r.price)continue;if("costsNothing"===r.type)continue;const o=this.safeString(r,"time"),n=this.parse8601(o),d=this.safeFloat(r,"amount"),c=this.safeFloat(r,"price"),h=this.safeFloat(r,"fee_amount");let l=d<0?-d:d,p=void 0;"sell"===a?(p=l,l=this.sum(h,p)/c):p=l*c,u.push({id:this.safeString(r,"id"),timestamp:n,datetime:this.iso8601(n),order:f,symbol:s,price:c,amount:l,cost:p,side:a,fee:{cost:h,currency:t.quote},info:r})}}return{id:f,datetime:this.iso8601(i),timestamp:i,lastTradeTimestamp:void 0,status:r,symbol:s,type:void 0,side:l,price:a,cost:h,amount:o,filled:d,remaining:n,trades:u,fee:c,info:e}}async fetchOpenOrders(e,t,i,s={}){await this.loadMarkets();const r={};let a="privatePostOpenOrders",o=void 0;void 0!==e&&(o=this.market(e),r.pair=o.id,a+="Pair");const n=await this[a](this.extend(r,s));for(let e=0;e<n.length;e++)n[e]=this.extend(n[e],{status:"open"});return this.parseOrders(n,o,t,i)}async fetchClosedOrders(e,t,i,s={}){await this.loadMarkets();if(void 0===e)throw new a(this.id+" fetchClosedOrders requires a symbol argument");const r=this.market(e),o={pair:r.id},n=await this.privatePostArchivedOrdersPair(this.extend(o,s));return this.parseOrders(n,r,t,i)}async fetchOrder(e,t,i={}){await this.loadMarkets();const s={id:e.toString()},r=await this.privatePostGetOrderTx(this.extend(s,i));return this.parseOrder(r.data)}async fetchOrders(e,t,i,s={}){await this.loadMarkets();const r={limit:i,pair:this.market(e).id,dateFrom:t},a=await this.privatePostArchivedOrdersPair(this.extend(r,s)),o=[];for(let e=0;e<a.length;e++){const t=a[e],i=this.parseOrderStatus(this.safeString(t,"status")),s=t.symbol1,r=t.symbol2,n=t.type,d=this.safeFloat(t,"a:"+s+":cds"),c=this.safeFloat(t,"a:"+r+":cds"),h=this.safeFloat(t,"f:"+r+":cds"),l=this.safeFloat(t,"amount"),u=this.safeFloat(t,"price"),f=this.safeFloat(t,"remains"),p=l-f;let m=void 0,y=void 0,b=void 0,v=void 0;if(u){const e=this.safeFloat(t,"ta:"+r,0),i=this.safeFloat(t,"tta:"+r,0),s=this.safeFloat(t,"fa:"+r,0),a=this.safeFloat(t,"tfa:"+r,0);v="limit",m=l,b=(y="sell"===n?e+i+(s+a):e+i-(s+a))/p}else v="market",b=(m=d)/(y=c);const g=this.safeString(t,"time"),w=this.safeString(t,"lastTxTime"),k=this.parse8601(g);o.push({id:t.id,timestamp:k,datetime:this.iso8601(k),lastUpdated:this.parse8601(w),status:i,symbol:this.findSymbol(s+"/"+r),side:n,price:u,amount:m,average:b,type:v,filled:p,cost:y,remaining:f,fee:{cost:h,currency:this.currencyId(r)},info:t})}return o}parseOrderStatus(e){return this.safeString(this.options.order.status,e,e)}async editOrder(e,t,i,s,r,o,n={}){if(void 0===r)throw new a(this.id+" editOrder requires a amount argument");if(void 0===o)throw new a(this.id+" editOrder requires a price argument");await this.loadMarkets();const d=this.market(t),c={pair:d.id,type:s,amount:r,price:o,order_id:e},h=await this.privatePostCancelReplaceOrderPair(this.extend(c,n));return this.parseOrder(h,d)}async fetchDepositAddress(e,t={}){if("XRP"===e||"XLM"===e)throw new d(this.id+" fetchDepositAddress does not support XRP and XLM addresses yet (awaiting docs from CEX.io)");await this.loadMarkets();const i={currency:this.currency(e).id},s=await this.privatePostGetAddress(this.extend(i,t)),r=this.safeString(s,"data");return this.checkAddress(r),{currency:e,address:r,tag:void 0,info:s}}nonce(){return this.milliseconds()}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api+"/"+this.implodeParams(e,s);const n=this.omit(s,this.extractParams(e));if("public"===t)Object.keys(n).length&&(o+="?"+this.urlencode(n));else{this.checkRequiredCredentials();const e=this.nonce().toString(),t=e+this.uid+this.apiKey,i=this.hmac(this.encode(t),this.encode(this.secret));a=this.json(this.extend({key:this.apiKey,signature:i.toUpperCase(),nonce:e},n)),r={"Content-Type":"application/json"}}return{url:o,method:i,body:a,headers:r}}async request(e,t="public",i="GET",s={},a,n){const d=await this.fetch2(e,t,i,s,a,n);if(Array.isArray(d))return d;if(!d)throw new o(this.id+" returned "+this.json(d));if(!0===d||"true"===d)return d;if("e"in d){if("ok"in d&&"ok"===d.ok)return d;throw new r(this.id+" "+this.json(d))}if("error"in d&&d.error)throw new r(this.id+" "+this.json(d));return d}}},function(e,t,i){"use strict";const s=i(9);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"chilebit",name:"ChileBit",countries:["CL"],has:{CORS:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/27991414-1298f0d8-647f-11e7-9c40-d56409266336.jpg",api:{public:"https://api.blinktrade.com/api",private:"https://api.blinktrade.com/tapi"},www:"https://chilebit.net",doc:"https://blinktrade.com/docs"},options:{brokerId:"9"}})}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,InvalidAddress:a,InsufficientFunds:o,InvalidNonce:n,InvalidOrder:d,OrderNotFound:c,PermissionDenied:h}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"cobinhood",name:"COBINHOOD",countries:["TW"],rateLimit:100,version:"v1",has:{fetchCurrencies:!0,fetchTickers:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchClosedOrders:!0,fetchOrderTrades:!0,fetchOrder:!0,fetchDepositAddress:!0,createDepositAddress:!0,fetchDeposits:!0,fetchWithdrawals:!0,withdraw:!0,fetchMyTrades:!0,editOrder:!0},requiredCredentials:{apiKey:!0,secret:!1},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","3h":"3h","6h":"6h","12h":"12h","1d":"1D","1w":"7D","2w":"14D","1M":"1M"},urls:{referral:"https://cobinhood.com?referrerId=a9d57842-99bb-4d7c-b668-0479a15a458b",logo:"https://user-images.githubusercontent.com/1294454/35755576-dee02e5c-0878-11e8-989f-1595d80ba47f.jpg",api:"https://api.cobinhood.com",www:"https://cobinhood.com",doc:"https://cobinhood.github.io/api-public"},api:{system:{get:["info","time","messages","messages/{message_id}"]},admin:{get:["system/messages","system/messages/{message_id}"],post:["system/messages"],patch:["system/messages/{message_id}"],delete:["system/messages/{message_id}"]},public:{get:["market/fundingbook/precisions/{currency_id}","market/fundingbooks/{currency_id}","market/tickers","market/currencies","market/quote_currencies","market/trading_pairs","market/orderbook/precisions/{trading_pair_id}","market/orderbooks/{trading_pair_id}","market/stats","market/tickers","market/tickers/{trading_pair_id}","market/trades/{trading_pair_id}","market/trades_history/{trading_pair_id}","market/trading_pairs","chart/candles/{trading_pair_id}","system/time"]},private:{get:["funding/auto_offerings","funding/auto_offerings/{currency_id}","funding/funding_history","funding/fundings","funding/loans","funding/loans/{loan_id}","trading/orders/{order_id}","trading/orders/{order_id}/trades","trading/orders","trading/order_history","trading/positions","trading/positions/{trading_pair_id}","trading/positions/{trading_pair_id}/claimable_size","trading/trades","trading/trades/{trade_id}","trading/volume","wallet/balances","wallet/ledger","wallet/limits/withdrawal","wallet/generic_deposits","wallet/generic_deposits/{generic_deposit_id}","wallet/generic_withdrawals","wallet/generic_withdrawals/{generic_withdrawal_id}","wallet/deposit_addresses","wallet/deposit_addresses/iota","wallet/withdrawal_addresses","wallet/withdrawal_frozen","wallet/withdrawals/{withdrawal_id}","wallet/withdrawals","wallet/deposits/{deposit_id}","wallet/deposits"],patch:["trading/positions/{trading_pair_id}"],post:["funding/auto_offerings","funding/fundings","trading/check_order","trading/orders","wallet/deposit_addresses","wallet/transfer","wallet/withdrawal_addresses","wallet/withdrawals","wallet/withdrawals/fee"],put:["funding/fundings/{funding_id}","trading/orders/{order_id}"],delete:["funding/auto_offerings/{currency_id}","funding/fundings/{funding_id}","funding/loans/{loan_id}","trading/orders/{order_id}","trading/positions/{trading_pair_id}","wallet/generic_withdrawals/{generic_withdrawal_id}","wallet/withdrawal_addresses/{wallet_id}"]}},fees:{trading:{maker:0,taker:0}},precision:{amount:8,price:8},exceptions:{insufficient_balance:o,invalid_order_size:d,invalid_nonce:n,unauthorized_scope:h,invalid_address:a,parameter_error:c},commonCurrencies:{SMT:"SocialMedia.Market",MTN:"Motion Token"}})}async fetchCurrencies(e={}){const t=(await this.publicGetMarketCurrencies(e)).result.currencies,i={};for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"currency"),a=this.safeString(s,"name"),o=this.safeCurrencyCode(r),n=this.safeFloat(s,"min_unit");i[o]={id:r,code:o,name:a,active:!0,fiat:!1,precision:this.precisionFromString(s.min_unit),limits:{amount:{min:n,max:void 0},price:{min:n,max:void 0},deposit:{min:n,max:void 0},withdraw:{min:n,max:void 0}},funding:{withdraw:{fee:this.safeFloat(s,"withdrawal_fee")},deposit:{fee:this.safeFloat(s,"deposit_fee")}},info:s}}return i}async fetchMarkets(e={}){const t=await this.publicGetMarketTradingPairs(e),i=this.safeValue(t.result,"trading_pairs"),s=[];for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"id"),[a,o]=r.split("-"),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o),c=n+"/"+d,h={amount:8,price:this.precisionFromString(t.quote_increment)},l=this.safeValue(t,"is_active",!0);s.push({id:r,symbol:c,base:n,quote:d,baseId:a,quoteId:o,active:l,precision:h,limits:{amount:{min:this.safeFloat(t,"base_min_size"),max:this.safeFloat(t,"base_max_size")},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:t})}return s}parseTicker(e,t){let i=void 0;if(void 0===t){const s=this.safeString(e,"trading_pair_id");if(s in this.markets_by_id)t=this.markets_by_id[s];else{const[e,t]=s.split("-");i=this.safeCurrencyCode(e)+"/"+this.safeCurrencyCode(t)}}void 0!==t&&(i=t.symbol);const s=this.safeInteger(e,"timestamp"),r=this.safeFloat(e,"last_trade_price");return{symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeFloat(e,"24h_high"),low:this.safeFloat(e,"24h_low"),bid:this.safeFloat(e,"highest_bid"),bidVolume:void 0,ask:this.safeFloat(e,"lowest_ask"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:this.safeFloat(e,"percentChanged24hr"),percentage:void 0,average:void 0,baseVolume:this.safeFloat(e,"24h_volume"),quoteVolume:this.safeFloat(e,"quote_volume"),info:e}}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={trading_pair_id:i.id},r=await this.publicGetMarketTickersTradingPairId(this.extend(s,t)),a=this.safeValue(r.result,"ticker");return this.parseTicker(a,i)}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetMarketTickers(t),s=this.safeValue(i.result,"tickers"),r=[];for(let e=0;e<s.length;e++)r.push(this.parseTicker(s[e]));return this.indexBy(r,"symbol")}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={trading_pair_id:this.marketId(e)};void 0!==t&&(s.limit=t);const r=await this.publicGetMarketOrderbooksTradingPairId(this.extend(s,i));return this.parseOrderBook(r.result.orderbook,void 0,"bids","asks",0,2)}parseTrade(e,t){let i=void 0;t&&(i=t.symbol);const s=this.safeInteger(e,"timestamp"),r=this.safeFloat(e,"price"),a=this.safeFloat(e,"size");let o=void 0;void 0!==r&&void 0!==a&&(o=r*a);const n=this.safeString(e,"id");return{info:e,timestamp:s,datetime:this.iso8601(s),symbol:i,id:n,order:void 0,type:void 0,side:void 0,takerOrMaker:void 0,price:r,amount:a,cost:o,fee:void 0}}async fetchTrades(e,t,i=50,s={}){await this.loadMarkets();const r=this.market(e),a={trading_pair_id:r.id,limit:i},o=await this.publicGetMarketTradesTradingPairId(this.extend(a,s)),n=this.safeValue(o.result,"trades");return this.parseTrades(n,r,t,i)}parseOHLCV(e,t,i="5m",s,r){return[e.timestamp,parseFloat(e.open),parseFloat(e.high),parseFloat(e.low),parseFloat(e.close),parseFloat(e.volume)]}async fetchOHLCV(e,t="1m",i,s,r={}){await this.loadMarkets();const a=this.market(e),o=this.milliseconds(),n={trading_pair_id:a.id,timeframe:this.timeframes[t],end_time:o};void 0!==i&&(n.start_time=i);const d=await this.publicGetChartCandlesTradingPairId(this.extend(n,r)),c=this.safeValue(d.result,"candles");return this.parseOHLCVs(c,a,t,i,s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetWalletBalances(e),i={info:t},s=this.safeValue(t.result,"balances");for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.used=this.safeFloat(t,"on_order"),o.total=this.safeFloat(t,"total"),i[a]=o}return this.parseBalance(i)}parseOrderStatus(e){return this.safeString({filled:"closed",rejected:"closed",partially_filled:"open",pending_cancellation:"open",pending_modification:"open",open:"open",new:"open",queued:"open",cancelled:"canceled",triggered:"triggered"},e,e)}parseOrder(e,t){let i=void 0;if(void 0===t){const i=this.safeString2(e,"trading_pair","trading_pair_id");t=this.safeValue(this.markets_by_id,i)}void 0!==t&&(i=t.symbol);const s=this.safeInteger(e,"timestamp"),r=this.safeFloat(e,"price"),a=this.safeFloat(e,"eq_price"),o=this.safeFloat(e,"size"),n=this.safeFloat(e,"filled");let d=void 0,c=void 0;void 0!==n&&void 0!==a?c=a*n:void 0!==a&&(c=a*o),void 0!==o&&void 0!==n&&(d=o-n);const h=this.parseOrderStatus(this.safeString(e,"state"));let l=this.safeString(e,"side");return"bid"===l?l="buy":"ask"===l&&(l="sell"),{id:this.safeString(e,"id"),datetime:this.iso8601(s),timestamp:s,lastTradeTimestamp:void 0,status:h,symbol:i,type:this.safeString(e,"type"),side:l,price:r,cost:c,average:a,amount:o,filled:n,remaining:d,trades:void 0,fee:void 0,info:e}}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o=this.market(e);i="sell"===i?"ask":"bid";const n={trading_pair_id:o.id,type:t,side:i,size:this.amountToPrecision(e,s)};"market"!==t&&(n.price=this.priceToPrecision(e,r));const d=await this.privatePostTradingOrders(this.extend(n,a)),c=this.parseOrder(d.result.order,o),h=c.id;return this.orders[h]=c,c}async editOrder(e,t,i,s,r,a,o={}){await this.loadMarkets();const n={order_id:e,price:this.priceToPrecision(t,a),size:this.amountToPrecision(t,r)},d=await this.privatePutTradingOrdersOrderId(this.extend(n,o));return this.parseOrder(this.extend(d,{id:e}))}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={order_id:e},r=await this.privateDeleteTradingOrdersOrderId(this.extend(s,i));return this.parseOrder(this.extend(r,{id:e}))}async fetchOrder(e,t,i={}){await this.loadMarkets();const s={order_id:e.toString()},r=await this.privateGetTradingOrdersOrderId(this.extend(s,i));return this.parseOrder(r.result.order)}async fetchOpenOrders(e,t,i,s={}){await this.loadMarkets();const r=await this.privateGetTradingOrders(s),a=this.parseOrders(r.result.orders,void 0,t,i);return void 0!==e?this.filterBySymbolSinceLimit(a,e,t,i):this.filterBySinceLimit(a,t,i)}async fetchClosedOrders(e,t,i,s={}){await this.loadMarkets();const r={};let a=void 0;void 0!==e&&(a=this.market(e),r.trading_pair_id=a.id),void 0!==i&&(r.limit=i);const o=await this.privateGetTradingOrderHistory(this.extend(r,s)),n=this.parseOrders(o.result.orders,a,t,i);return void 0!==e?this.filterBySymbolSinceLimit(n,e,t,i):this.filterBySinceLimit(n,t,i)}async fetchOrderTrades(e,t,i,s,r={}){await this.loadMarkets();const a={order_id:e},o=await this.privateGetTradingOrdersOrderIdTrades(this.extend(a,r)),n=void 0===t?void 0:this.market(t);return this.parseTrades(o.result.trades,n)}async fetchMyTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={};void 0!==e&&(a.trading_pair_id=r.id);const o=await this.privateGetTradingTrades(this.extend(a,s));return this.parseTrades(o.result.trades,r,t,i)}async createDepositAddress(e,t={}){await this.loadMarkets();const i=this.currency(e),s=this.safeString(t,"ledger_type","exchange"),r={currency:i.id,ledger_type:s},a=await this.privatePostWalletDepositAddresses(this.extend(r,t)),o=this.safeString(a.result.deposit_address,"address"),n=this.safeString(a.result.deposit_address,"memo");return this.checkAddress(o),{currency:e,address:o,tag:n,info:a}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},s=await this.privateGetWalletDepositAddresses(this.extend(i,t)),r=this.safeValue(s.result,"deposit_addresses",[]);let a=void 0,o=void 0;return r.length>0&&(a=this.safeString(r[0],"address"),o=this.safeString2(r[0],"memo","tag")),this.checkAddress(a),{currency:e,address:a,tag:o,info:s}}async withdraw(e,t,i,s,r={}){await this.loadMarkets();const a={currency:this.currency(e).id,amount:t,address:i};return void 0!==s&&(a.memo=s),{id:void 0,info:await this.privatePostWalletWithdrawals(this.extend(a,r))}}async fetchDeposits(e,t,i,s={}){if(await this.loadMarkets(),void 0===e)throw new r(this.id+" fetchDeposits() requires a currency code argument");const a=this.currency(e),o={currency:a.id},n=await this.privateGetWalletDeposits(this.extend(o,s));return this.parseTransactions(n.result.deposits,a)}async fetchWithdrawals(e,t,i,s={}){if(await this.loadMarkets(),void 0===e)throw new r(this.id+" fetchWithdrawals() requires a currency code argument");const a=this.currency(e),o={currency:a.id},n=await this.privateGetWalletWithdrawals(this.extend(o,s));return this.parseTransactions(n.result.withdrawals,a)}parseTransactionStatus(e){return this.safeString({tx_pending_two_factor_auth:"pending",tx_pending_email_auth:"pending",tx_pending_approval:"pending",tx_approved:"pending",tx_processing:"pending",tx_pending:"pending",tx_sent:"pending",tx_cancelled:"canceled",tx_timeout:"failed",tx_invalid:"failed",tx_rejected:"failed",tx_confirmed:"ok"},e,e)}parseTransaction(e,t){const i=this.safeInteger(e,"created_at"),s=this.safeString(e,"currency"),r=this.safeCurrencyCode(s,t);let a=void 0;const o=this.safeString(e,"withdrawal_id"),n=this.safeString(e,"deposit_id");let d=void 0,c=void 0;void 0!==o?(d="withdrawal",a=o,c=this.safeString(e,"to_address")):void 0!==n&&(d="deposit",a=n,c=this.safeString(e,"from_address"));const h=this.safeValue(e,"additional_info",{}),l=this.safeString(h,"memo");return{info:e,id:a,txid:this.safeString(e,"txhash"),timestamp:i,datetime:this.iso8601(i),address:c,tag:l,type:d,amount:this.safeFloat(e,"amount"),currency:r,status:this.parseTransactionStatus(e.status),updated:void 0,fee:{cost:this.safeFloat(e,"fee"),rate:void 0}}}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api+"/"+this.version+"/"+this.implodeParams(e,s),n=this.omit(s,this.extractParams(e));return r={},"private"===t&&(this.checkRequiredCredentials(),r.nonce=this.nonce().toString(),r.Authorization=this.apiKey),"GET"===i?(n=this.urlencode(n)).length&&(o+="?"+n):(r["Content-type"]="application/json; charset=UTF-8",a=this.json(n)),{url:o,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,o,n,c,h){if(e<400||e>=600)return;if("{"!==o[0])throw new r(this.id+" "+o);const l=this.id+" "+this.json(n),u=this.safeValue(n.error,"error_code");if(("DELETE"===s||"GET"===s)&&"parameter_error"===u&&i.indexOf("trading/orders/")>=0)throw new d(l);const f=this.exceptions;if(u in f)throw new f[u](l);throw new r(l)}nonce(){return this.milliseconds()}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,ArgumentsRequired:a,AuthenticationError:o,DDoSProtection:n}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"coinbase",name:"Coinbase",countries:["US"],rateLimit:400,version:"v2",userAgent:this.userAgents.chrome,headers:{"CB-VERSION":"2018-05-30"},has:{CORS:!0,cancelOrder:!1,createDepositAddress:!0,createOrder:!1,deposit:!1,fetchBalance:!0,fetchClosedOrders:!1,fetchCurrencies:!0,fetchDepositAddress:!1,fetchMarkets:!1,fetchMyTrades:!1,fetchOHLCV:!1,fetchOpenOrders:!1,fetchOrder:!1,fetchOrderBook:!1,fetchL2OrderBook:!1,fetchLedger:!0,fetchOrders:!1,fetchTicker:!0,fetchTickers:!1,fetchTime:!0,fetchBidsAsks:!1,fetchTrades:!1,withdraw:!1,fetchTransactions:!1,fetchDeposits:!0,fetchWithdrawals:!0,fetchMySells:!0,fetchMyBuys:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/40811661-b6eceae2-653a-11e8-829e-10bfadb078cf.jpg",api:"https://api.coinbase.com",www:"https://www.coinbase.com",doc:"https://developers.coinbase.com/api/v2",fees:"https://support.coinbase.com/customer/portal/articles/2109597-buy-sell-bank-transfer-fees",referral:"https://www.coinbase.com/join/58cbe25a355148797479dbd2"},requiredCredentials:{apiKey:!0,secret:!0},api:{public:{get:["currencies","time","exchange-rates","users/{user_id}","prices/{symbol}/buy","prices/{symbol}/sell","prices/{symbol}/spot"]},private:{get:["accounts","accounts/{account_id}","accounts/{account_id}/addresses","accounts/{account_id}/addresses/{address_id}","accounts/{account_id}/addresses/{address_id}/transactions","accounts/{account_id}/transactions","accounts/{account_id}/transactions/{transaction_id}","accounts/{account_id}/buys","accounts/{account_id}/buys/{buy_id}","accounts/{account_id}/sells","accounts/{account_id}/sells/{sell_id}","accounts/{account_id}/deposits","accounts/{account_id}/deposits/{deposit_id}","accounts/{account_id}/withdrawals","accounts/{account_id}/withdrawals/{withdrawal_id}","payment-methods","payment-methods/{payment_method_id}","user","user/auth"],post:["accounts","accounts/{account_id}/primary","accounts/{account_id}/addresses","accounts/{account_id}/transactions","accounts/{account_id}/transactions/{transaction_id}/complete","accounts/{account_id}/transactions/{transaction_id}/resend","accounts/{account_id}/buys","accounts/{account_id}/buys/{buy_id}/commit","accounts/{account_id}/sells","accounts/{account_id}/sells/{sell_id}/commit","accounts/{account_id}/deposists","accounts/{account_id}/deposists/{deposit_id}/commit","accounts/{account_id}/withdrawals","accounts/{account_id}/withdrawals/{withdrawal_id}/commit"],put:["accounts/{account_id}","user"],delete:["accounts/{id}","accounts/{account_id}/transactions/{transaction_id}"]}},exceptions:{two_factor_required:o,param_required:r,validation_error:r,invalid_request:r,personal_details_required:o,identity_verification_required:o,jumio_verification_required:o,jumio_face_match_verification_required:o,unverified_email:o,authentication_error:o,invalid_token:o,revoked_token:o,expired_token:o,invalid_scope:o,not_found:r,rate_limit_exceeded:n,internal_server_error:r},markets:{"BTC/USD":{id:"btc-usd",symbol:"BTC/USD",base:"BTC",quote:"USD"},"LTC/USD":{id:"ltc-usd",symbol:"LTC/USD",base:"LTC",quote:"USD"},"ETH/USD":{id:"eth-usd",symbol:"ETH/USD",base:"ETH",quote:"USD"},"BCH/USD":{id:"bch-usd",symbol:"BCH/USD",base:"BCH",quote:"USD"},"BTC/EUR":{id:"btc-eur",symbol:"BTC/EUR",base:"BTC",quote:"EUR"},"LTC/EUR":{id:"ltc-eur",symbol:"LTC/EUR",base:"LTC",quote:"EUR"},"ETH/EUR":{id:"eth-eur",symbol:"ETH/EUR",base:"ETH",quote:"EUR"},"BCH/EUR":{id:"bch-eur",symbol:"BCH/EUR",base:"BCH",quote:"EUR"},"BTC/GBP":{id:"btc-gbp",symbol:"BTC/GBP",base:"BTC",quote:"GBP"},"LTC/GBP":{id:"ltc-gbp",symbol:"LTC/GBP",base:"LTC",quote:"GBP"},"ETH/GBP":{id:"eth-gbp",symbol:"ETH/GBP",base:"ETH",quote:"GBP"},"BCH/GBP":{id:"bch-gbp",symbol:"BCH/GBP",base:"BCH",quote:"GBP"}},options:{accounts:["wallet","fiat"]}})}async fetchTime(e={}){const t=await this.publicGetTime(e),i=this.safeValue(t,"data",{});return this.parse8601(this.safeString(i,"iso"))}async fetchAccounts(e={}){const t=await this.privateGetAccounts(e),i=this.safeValue(t,"data",[]),s=[];for(let e=0;e<i.length;e++){const t=i[e],r=this.safeValue(t,"currency",{}),a=this.safeString(r,"code"),o=this.safeCurrencyCode(a);s.push({id:this.safeString(t,"id"),type:this.safeString(t,"type"),code:o,info:t})}return s}async createDepositAddress(e,t={}){let i=this.safeString(t,"account_id");if(t=this.omit(t,"account_id"),void 0===i){await this.loadAccounts();for(let t=0;t<this.accounts.length;t++){const s=this.accounts[t];if(s.code===e&&"wallet"===s.type){i=s.id;break}}}if(void 0===i)throw new r(this.id+" createDepositAddress could not find the account with matching currency code, specify an `account_id` extra param");const s={account_id:i},a=await this.privatePostAccountsAccountIdAddresses(this.extend(s,t)),o=this.safeValue(a,"data",{});return{currency:e,tag:this.safeString(o,"destination_tag"),address:this.safeString(o,"address"),info:a}}async fetchMySells(e,t,i,s={}){const r=await this.prepareAccountRequest(i,s);await this.loadMarkets();const a=this.omit(s,["account_id","accountId"]),o=await this.privateGetAccountsAccountIdSells(this.extend(r,a));return this.parseTrades(o.data,void 0,t,i)}async fetchMyBuys(e,t,i,s={}){const r=await this.prepareAccountRequest(i,s);await this.loadMarkets();const a=this.omit(s,["account_id","accountId"]),o=await this.privateGetAccountsAccountIdBuys(this.extend(r,a));return this.parseTrades(o.data,void 0,t,i)}async fetchTransactionsWithMethod(e,t,i,s,r={}){const a=await this.prepareAccountRequestWithCurrencyCode(t,s,r);await this.loadMarkets();const o=this.omit(r,["account_id","accountId"]),n=await this[e](this.extend(a,o));return this.parseTransactions(n.data,void 0,i,s)}async fetchWithdrawals(e,t,i,s={}){return await this.fetchTransactionsWithMethod("privateGetAccountsAccountIdWithdrawals",e,t,i,s)}async fetchDeposits(e,t,i,s={}){return await this.fetchTransactionsWithMethod("privateGetAccountsAccountIdDeposits",e,t,i,s)}parseTransactionStatus(e){return this.safeString({created:"pending",completed:"ok",canceled:"canceled"},e,e)}parseTransaction(e,t){const i=this.safeValue(e,"amount",{}),s=this.safeValue(e,"fee",{}),r=this.safeString(e,"id"),a=this.parse8601(this.safeValue(e,"created_at")),o=this.parse8601(this.safeValue(e,"updated_at")),n=this.safeString(e,"resource"),d=this.safeFloat(i,"amount"),c=this.safeString(i,"currency"),h=this.safeCurrencyCode(c),l=this.safeFloat(s,"amount"),u=this.safeString(s,"currency"),f={cost:l,currency:this.safeCurrencyCode(u)};let p=this.parseTransactionStatus(this.safeString(e,"status"));if(void 0===p){p=this.safeValue(e,"committed")?"ok":"pending"}return{info:e,id:r,txid:r,timestamp:a,datetime:this.iso8601(a),address:void 0,tag:void 0,type:n,amount:d,currency:h,status:p,updated:o,fee:f}}parseTrade(e,t){let i=void 0;const s=this.safeValue(e,"total",{}),r=this.safeValue(e,"amount",{}),a=this.safeValue(e,"subtotal",{}),o=this.safeValue(e,"fee",{}),n=this.safeString(e,"id"),d=this.parse8601(this.safeValue(e,"created_at"));if(void 0===t){const e=this.safeString(s,"currency"),t=this.safeString(r,"currency");if(void 0!==e&&void 0!==t){i=this.safeCurrencyCode(e)+"/"+this.safeCurrencyCode(t)}}const c=this.safeString(e,"resource"),h=this.safeFloat(a,"amount"),l=this.safeFloat(r,"amount");let u=void 0;void 0!==h&&void 0!==l&&(u=h/l);const f=this.safeFloat(o,"amount"),p=this.safeString(o,"currency"),m={cost:f,currency:this.safeCurrencyCode(p)};return{info:e,id:n,order:void 0,timestamp:d,datetime:this.iso8601(d),symbol:i,type:void 0,side:c,takerOrMaker:void 0,price:u,amount:l,cost:h,fee:m}}async fetchCurrencies(e={}){const t=(await this.publicGetCurrencies(e)).data,i={};for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"id"),a=this.safeString(s,"name"),o=this.safeCurrencyCode(r),n=this.safeFloat(s,"min_size");i[o]={id:r,code:o,info:s,name:a,active:!0,fee:void 0,precision:void 0,limits:{amount:{min:n,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}}}}return i}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.seconds(),s=this.market(e),r=this.extend({symbol:s.id},t),a=await this.publicGetPricesSymbolBuy(r),o=await this.publicGetPricesSymbolSell(r),n=await this.publicGetPricesSymbolSpot(r),d=this.safeFloat(a.data,"amount"),c=this.safeFloat(o.data,"amount"),h=this.safeFloat(n.data,"amount");return{symbol:e,timestamp:i,datetime:this.iso8601(i),bid:c,ask:d,last:h,high:void 0,low:void 0,bidVolume:void 0,askVolume:void 0,vwap:void 0,open:void 0,close:h,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:void 0,info:{buy:a,sell:o,spot:n}}}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccounts(e),i=this.safeValue(t,"data"),s=this.safeValue(e,"type",this.options.accounts),r={info:t};for(let e=0;e<i.length;e++){const t=i[e];if(this.inArray(t.type,s)){const e=this.safeString(t.balance,"currency"),i=this.safeCurrencyCode(e),s=this.safeFloat(t.balance,"amount"),a=s,o=void 0;if(i in r)r[i].free=this.sum(r[i].free,s),r[i].total=this.sum(r[i].total,s);else{const e={free:a,used:o,total:s};r[i]=e}}}return this.parseBalance(r)}async fetchLedger(e,t,i,s={}){await this.loadMarkets();const r=await this.prepareAccountRequestWithCurrencyCode(e,i,s),a=this.omit(s,["account_id","accountId"]),o=await this.privateGetAccountsAccountIdTransactions(this.extend(r,a));return this.parseLedger(o.data,void 0,t,i)}parseLedgerEntryStatus(e){return this.safeString({completed:"ok"},e,e)}parseLedgerEntryType(e){return this.safeString({buy:"trade",sell:"trade",fiat_deposit:"transaction",fiat_withdrawal:"transaction",exchange_deposit:"transaction",exchange_withdrawal:"transaction",send:"transaction",pro_deposit:"transaction",pro_withdrawal:"transaction"},e,e)}parseLedgerEntry(e,t){const i=this.safeValue(e,"amount",{});let s=this.safeFloat(i,"amount"),r=void 0;s<0?(r="out",s=-s):r="in";const a=this.safeString(i,"currency"),o=this.safeCurrencyCode(a,t);let n=void 0;const d=this.safeValue(e,"network",{}),c=this.safeValue(d,"transaction_fee");if(void 0!==c){const e=this.safeString(c,"currency"),i=this.safeCurrencyCode(e,t);n={cost:this.safeFloat(c,"amount"),currency:i}}const h=this.parse8601(this.safeValue(e,"created_at")),l=this.safeString(e,"id"),u=this.parseLedgerEntryType(this.safeString(e,"type")),f=this.parseLedgerEntryStatus(this.safeString(e,"status")),p=this.safeString(e,"resource_path");let m=void 0;if(void 0!==p){const e=p.split("/");e.length>3&&(m=e[3])}return{info:e,id:l,timestamp:h,datetime:this.iso8601(h),direction:r,account:m,referenceId:void 0,referenceAccount:void 0,type:u,currency:o,amount:s,before:void 0,after:void 0,status:f,fee:n}}async findAccountId(e){await this.loadMarkets(),await this.loadAccounts();for(let t=0;t<this.accounts.length;t++){const i=this.accounts[t];if(i.code===e)return i.id}}prepareAccountRequest(e,t={}){const i=this.safeString2(t,"account_id","accountId");if(void 0===i)throw new a(this.id+" method requires an account_id (or accountId) parameter");const s={account_id:i};return void 0!==e&&(s.limit=e),s}async prepareAccountRequestWithCurrencyCode(e,t,i={}){let s=this.safeString2(i,"account_id","accountId");if(void 0===s){if(void 0===e)throw new a(this.id+" method requires an account_id (or accountId) parameter OR a currency code argument");if(void 0===(s=await this.findAccountId(e)))throw new r(this.id+" could not find account id for "+e)}const o={account_id:s};return void 0!==t&&(o.limit=t),o}sign(e,t="public",i="GET",s={},r,a){let o="/"+this.version+"/"+this.implodeParams(e,s);const n=this.omit(s,this.extractParams(e));"GET"===i&&Object.keys(n).length&&(o+="?"+this.urlencode(n));const d=this.urls.api+o;if("private"===t){this.checkRequiredCredentials();const e=this.nonce().toString();let t="";"GET"!==i&&Object.keys(n).length&&(t=a=this.json(n));const s=e+i+o+t,d=this.hmac(this.encode(s),this.encode(this.secret));r={"CB-ACCESS-KEY":this.apiKey,"CB-ACCESS-SIGN":d,"CB-ACCESS-TIMESTAMP":e,"Content-Type":"application/json"}}return{url:d,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,o,n,d,c){if(void 0===n)return;const h=this.id+" "+o,l=this.exceptions;let u=this.safeString(n,"error");if(void 0!==u)throw u in l?new l[u](h):new r(h);const f=this.safeValue(n,"errors");if(void 0!==f&&Array.isArray(f)){if(f.length>0&&void 0!==(u=this.safeString(f[0],"id")))throw u in l?new l[u](h):new r(h)}if(void 0===this.safeValue(n,"data"))throw new r(this.id+" failed due to a malformed response "+this.json(n))}}},function(e,t,i){"use strict";const s=i(35);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"coinbaseprime",name:"Coinbase Prime",urls:{test:"https://api-public.sandbox.prime.coinbase.com",logo:"https://user-images.githubusercontent.com/1294454/44539184-29f26e00-a70c-11e8-868f-e907fc236a7c.jpg",api:"https://api.prime.coinbase.com",www:"https://prime.coinbase.com",doc:"https://docs.prime.coinbase.com",fees:"https://support.prime.coinbase.com/customer/en/portal/articles/2945629-fees?b_id=17475"}})}}},function(e,t,i){"use strict";const s=i(1),{BadSymbol:r,ExchangeError:a}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"coincheck",name:"coincheck",countries:["JP","ID"],rateLimit:1500,has:{CORS:!1,fetchOpenOrders:!0,fetchMyTrades:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766464-3b5c3c74-5ed9-11e7-840e-31b32968e1da.jpg",api:"https://coincheck.com/api",www:"https://coincheck.com",doc:"https://coincheck.com/documents/exchange/api",fees:["https://coincheck.com/exchange/fee","https://coincheck.com/info/fee"]},api:{public:{get:["exchange/orders/rate","order_books","rate/{pair}","ticker","trades"]},private:{get:["accounts","accounts/balance","accounts/leverage_balance","bank_accounts","deposit_money","exchange/orders/opens","exchange/orders/transactions","exchange/orders/transactions_pagination","exchange/leverage/positions","lending/borrows/matches","send_money","withdraws"],post:["bank_accounts","deposit_money/{id}/fast","exchange/orders","exchange/transfers/to_leverage","exchange/transfers/from_leverage","lending/borrows","lending/borrows/{id}/repay","send_money","withdraws"],delete:["bank_accounts/{id}","exchange/orders/{id}","withdraws/{id}"]}},markets:{"BTC/JPY":{id:"btc_jpy",symbol:"BTC/JPY",base:"BTC",quote:"JPY",baseId:"btc",quoteId:"jpy"}},fees:{trading:{tierBased:!1,percentage:!0,maker:0,taker:0}}})}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccountsBalance(e),i={info:t},s=Object.keys(this.currencies);for(let e=0;e<s.length;e++){const r=s[e],a=this.currencyId(r);if(a in t){const e=this.account(),s=a+"_reserved";e.free=this.safeFloat(t,a),e.used=this.safeFloat(t,s),i[r]=e}}return this.parseBalance(i)}async fetchOpenOrders(e,t,i,s={}){await this.loadMarkets();let r=void 0;void 0!==e&&(r=this.market(e));const a=await this.privateGetExchangeOrdersOpens(s),o=this.safeValue(a,"orders",[]),n=this.parseOrders(o,r,t,i),d=[];for(let e=0;e<n.length;e++)d.push(this.extend(n[e],{status:"open"}));return d}parseOrder(e,t){const i=this.safeString(e,"id"),s=this.safeString(e,"order_type"),r=this.parse8601(this.safeString(e,"created_at")),a=this.safeFloat(e,"pending_amount"),o=this.safeFloat(e,"pending_amount"),n=this.safeFloat(e,"rate");let d=void 0,c=void 0;void 0!==o&&void 0!==a&&(d=Math.max(a-o,0),void 0!==n&&(c=d*n));const h=this.safeString(e,"pair");let l=void 0;if(void 0!==h)if(h in this.markets_by_id)l=this.markets_by_id[h].symbol;else{const[e,t]=h.split("_");l=this.safeCurrencyCode(e)+"/"+this.safeCurrencyCode(t)}return{id:i,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,amount:a,remaining:o,filled:d,side:s,type:void 0,status:void 0,symbol:l,price:n,cost:c,fee:void 0,info:e}}async fetchOrderBook(e,t,i={}){if("BTC/JPY"!==e)throw new r(this.id+" fetchOrderBook () supports BTC/JPY only");await this.loadMarkets();const s=await this.publicGetOrderBooks(i);return this.parseOrderBook(s)}async fetchTicker(e,t={}){if("BTC/JPY"!==e)throw new r(this.id+" fetchTicker () supports BTC/JPY only");await this.loadMarkets();const i=await this.publicGetTicker(t),s=this.safeTimestamp(i,"timestamp"),a=this.safeFloat(i,"last");return{symbol:e,timestamp:s,datetime:this.iso8601(s),high:this.safeFloat(i,"high"),low:this.safeFloat(i,"low"),bid:this.safeFloat(i,"bid"),bidVolume:void 0,ask:this.safeFloat(i,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeFloat(i,"volume"),quoteVolume:void 0,info:i}}parseTrade(e,t){const i=this.parse8601(this.safeString(e,"created_at")),s=this.safeString(e,"id"),r=this.safeFloat(e,"rate"),a=this.safeString(e,"pair");t=this.safeValue(this.markets_by_id,a,t);let o=void 0,n=void 0,d=void 0;if(void 0!==a)if(a in this.markets_by_id)n=(t=this.markets_by_id[a]).baseId,d=t.quoteId,o=t.symbol;else{const e=a.split("_");n=e[0],d=e[1],o=this.safeCurrencyCode(n)+"/"+this.safeCurrencyCode(d)}void 0===o&&void 0!==t&&(o=t.symbol);let c=void 0,h=void 0,l=void 0,u=void 0,f=void 0,p=void 0;if("liquidity"in e){"T"===this.safeString(e,"liquidity")?c="taker":"M"===this.safeString(e,"liquidity")&&(c="maker");const t=this.safeValue(e,"funds",{});h=this.safeFloat(t,n),l=this.safeFloat(t,d),f={currency:this.safeString(e,"fee_currency"),cost:this.safeFloat(e,"fee")},u=this.safeString(e,"side"),p=this.safeString(e,"order_id")}else h=this.safeFloat(e,"amount"),u=this.safeString(e,"order_type");return void 0===l&&void 0!==h&&void 0!==r&&(l=h*r),{id:s,info:e,datetime:this.iso8601(i),timestamp:i,symbol:o,type:void 0,side:u,order:p,takerOrMaker:c,price:r,amount:h,cost:l,fee:f}}async fetchMyTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a=await this.privateGetExchangeOrdersTransactions(this.extend({},s)),o=this.safeValue(a,"transactions",[]);return this.parseTrades(o,r,t,i)}async fetchTrades(e,t,i,s={}){if("BTC/JPY"!==e)throw new r(this.id+" fetchTrades () supports BTC/JPY only");await this.loadMarkets();const a=this.market(e),o={pair:a.id};void 0!==i&&(o.limit=i);const n=await this.publicGetTrades(this.extend(o,s)),d=this.safeValue(n,"data",[]);return this.parseTrades(d,a,t,i)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o={pair:this.marketId(e)};if("market"===t){const e=t+"_"+i;o.order_type=e,o[("buy"===i?e+"_":"")+"amount"]=s}else o.order_type=i,o.rate=r,o.amount=s;const n=await this.privatePostExchangeOrders(this.extend(o,a));return{info:n,id:this.safeString(n,"id")}}async cancelOrder(e,t,i={}){const s={id:e};return await this.privateDeleteExchangeOrdersId(this.extend(s,i))}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api+"/"+this.implodeParams(e,s);const n=this.omit(s,this.extractParams(e));if("public"===t)Object.keys(n).length&&(o+="?"+this.urlencode(n));else{this.checkRequiredCredentials();const e=this.nonce().toString();let t="";"GET"===i?Object.keys(n).length&&(o+="?"+this.urlencode(this.keysort(n))):Object.keys(n).length&&(t=a=this.urlencode(this.keysort(n)));const s=e+o+t;r={"Content-Type":"application/x-www-form-urlencoded","ACCESS-KEY":this.apiKey,"ACCESS-NONCE":e,"ACCESS-SIGNATURE":this.hmac(this.encode(s),this.encode(this.secret))}}return{url:o,method:i,body:a,headers:r}}async request(e,t="public",i="GET",s={},r,o){const n=await this.fetch2(e,t,i,s,r,o);if("public"===t)return n;if("success"in n&&n.success)return n;throw new a(this.id+" "+this.json(n))}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,ArgumentsRequired:a,InsufficientFunds:o,OrderNotFound:n,InvalidOrder:d,AuthenticationError:c}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"coinex",name:"CoinEx",version:"v1",countries:["CN"],rateLimit:1e3,has:{fetchTickers:!0,fetchOHLCV:!0,fetchOrder:!0,fetchOpenOrders:!0,fetchClosedOrders:!0,fetchMyTrades:!0,withdraw:!0,fetchDeposits:!0,fetchWithdrawals:!0},timeframes:{"1m":"1min","3m":"3min","5m":"5min","15m":"15min","30m":"30min","1h":"1hour","2h":"2hour","4h":"4hour","6h":"6hour","12h":"12hour","1d":"1day","3d":"3day","1w":"1week"},urls:{logo:"https://user-images.githubusercontent.com/1294454/38046312-0b450aac-32c8-11e8-99ab-bc6b136b6cc7.jpg",api:"https://api.coinex.com",www:"https://www.coinex.com",doc:"https://github.com/coinexcom/coinex_exchange_api/wiki",fees:"https://www.coinex.com/fees",referral:"https://www.coinex.com/register?refer_code=yw5fz"},api:{public:{get:["common/currency/rate","common/asset/config","market/info","market/list","market/ticker","market/ticker/all","market/depth","market/deals","market/kline"]},private:{get:["balance/coin/deposit","balance/coin/withdraw","balance/info","future/account","future/config","future/limitprice","future/loan/history","future/market","margin/account","margin/config","margin/loan/history","margin/market","order","order/deals","order/finished","order/finished/{id}","order/pending","order/status","order/status/batch","order/user/deals"],post:["balance/coin/withdraw","future/flat","future/loan","future/transfer","margin/flat","margin/loan","margin/transfer","order/batchlimit","order/ioc","order/limit","order/market","sub_account/transfer"],delete:["balance/coin/withdraw","order/pending/batch","order/pending"]}},fees:{trading:{maker:.001,taker:.001},funding:{withdraw:{BCH:0,BTC:.001,LTC:.001,ETH:.001,ZEC:1e-4,DASH:1e-4}}},limits:{amount:{min:.001,max:void 0}},precision:{amount:8,price:8},options:{createMarketBuyOrderRequiresPrice:!0}})}async fetchMarkets(e={}){const t=await this.publicGetMarketInfo(e),i=this.safeValue(t,"data",{}),s=[],r=Object.keys(i);for(let e=0;e<r.length;e++){const t=i[r[e]],a=this.safeString(t,"name"),o=this.safeString(t,"trading_name"),n=o,d=this.safeString(t,"pricing_name"),c=this.safeCurrencyCode(n),h=this.safeCurrencyCode(d);let l=c+"/"+h;o===a&&(l=a);const u={amount:this.safeInteger(t,"trading_decimal"),price:this.safeInteger(t,"pricing_decimal")},f=void 0;s.push({id:a,symbol:l,base:c,quote:h,baseId:n,quoteId:d,active:f,taker:this.safeFloat(t,"taker_fee_rate"),maker:this.safeFloat(t,"maker_fee_rate"),info:t,precision:u,limits:{amount:{min:this.safeFloat(t,"min_amount"),max:void 0},price:{min:Math.pow(10,-u.price),max:void 0}}})}return s}parseTicker(e,t){const i=this.safeInteger(e,"date");let s=void 0;void 0!==t&&(s=t.symbol),e=this.safeValue(e,"ticker",{});const r=this.safeFloat(e,"last");return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"buy"),bidVolume:void 0,ask:this.safeFloat(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeFloat2(e,"vol","volume"),quoteVolume:void 0,info:e}}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={market:i.id},r=await this.publicGetMarketTicker(this.extend(s,t));return this.parseTicker(r.data,i)}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetMarketTickerAll(t),s=this.safeValue(i,"data"),r=this.safeInteger(s,"date"),a=this.safeValue(s,"ticker"),o=Object.keys(a),n={};for(let e=0;e<o.length;e++){const t=o[e];let i=t,s=void 0;t in this.markets_by_id&&(i=(s=this.markets_by_id[t]).symbol);const d={date:r,ticker:a[t]};n[i]=this.parseTicker(d,s)}return n}async fetchOrderBook(e,t=20,i={}){await this.loadMarkets(),void 0===t&&(t=20);const s={market:this.marketId(e),merge:"0.0000000001",limit:t.toString()},r=await this.publicGetMarketDepth(this.extend(s,i));return this.parseOrderBook(r.data)}parseTrade(e,t){let i=this.safeTimestamp(e,"create_time");void 0===i&&(i=this.safeInteger(e,"date_ms"));const s=this.safeString(e,"id"),r=this.safeString(e,"order_id"),a=this.safeFloat(e,"price"),o=this.safeFloat(e,"amount"),n=this.safeString(e,"market");let d=void 0;void 0!==(t=this.safeValue(this.markets_by_id,n,t))&&(d=t.symbol);let c=this.safeFloat(e,"deal_money");c||(c=parseFloat(this.costToPrecision(d,a*o)));let h=void 0;const l=this.safeFloat(e,"fee");if(void 0!==l){const t=this.safeString(e,"fee_asset");h={cost:l,currency:this.safeCurrencyCode(t)}}const u=this.safeString(e,"role"),f=this.safeString(e,"type");return{info:e,timestamp:i,datetime:this.iso8601(i),symbol:d,id:s,order:r,type:void 0,side:f,takerOrMaker:u,price:a,amount:o,cost:c,fee:h}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={market:r.id},o=await this.publicGetMarketDeals(this.extend(a,s));return this.parseTrades(o.data,r,t,i)}parseOHLCV(e,t,i="5m",s,r){return[1e3*e[0],parseFloat(e[1]),parseFloat(e[3]),parseFloat(e[4]),parseFloat(e[2]),parseFloat(e[5])]}async fetchOHLCV(e,t="5m",i,s,r={}){await this.loadMarkets();const a=this.market(e),o={market:a.id,type:this.timeframes[t]},n=await this.publicGetMarketKline(this.extend(o,r));return this.parseOHLCVs(n.data,a,t,i,s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalanceInfo(e),i={info:t},s=this.safeValue(t,"data"),r=Object.keys(s);for(let e=0;e<r.length;e++){const t=r[e],a=this.safeCurrencyCode(t),o=this.safeValue(s,t,{}),n=this.account();n.free=this.safeFloat(o,"available"),n.used=this.safeFloat(o,"frozen"),i[a]=n}return this.parseBalance(i)}parseOrderStatus(e){return this.safeString({not_deal:"open",part_deal:"open",done:"closed",cancel:"canceled"},e,e)}parseOrder(e,t){const i=this.safeTimestamp(e,"create_time"),s=this.safeFloat(e,"price"),r=this.safeFloat(e,"deal_money"),a=this.safeFloat(e,"amount"),o=this.safeFloat(e,"deal_amount"),n=this.safeFloat(e,"avg_price");let d=void 0;const c=this.safeString(e,"market");t=this.safeValue(this.markets_by_id,c);const h=this.safeString(e,"fee_asset");let l=this.safeCurrencyCode(h);void 0!==t&&(d=t.symbol,void 0===l&&(l=t.quote));const u=this.safeFloat(e,"left"),f=this.parseOrderStatus(this.safeString(e,"status")),p=this.safeString(e,"order_type"),m=this.safeString(e,"type");return{id:this.safeString(e,"id"),datetime:this.iso8601(i),timestamp:i,lastTradeTimestamp:void 0,status:f,symbol:d,type:p,side:m,price:s,cost:r,average:n,amount:a,filled:o,remaining:u,trades:void 0,fee:{currency:l,cost:this.safeFloat(e,"deal_fee")},info:e}}async createOrder(e,t,i,s,r,a={}){if(s=parseFloat(s),"market"===t&&"buy"===i&&this.options.createMarketBuyOrderRequiresPrice){if(void 0===r)throw new d(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the cost in the amount argument (the exchange-specific behaviour)");s*=r=parseFloat(r)}await this.loadMarkets();const o="privatePostOrder"+this.capitalize(t),n=this.market(e),c={market:n.id,amount:this.amountToPrecision(e,s),type:i};"limit"!==t&&"ioc"!==t||(c.price=this.priceToPrecision(e,r));const h=await this[o](this.extend(c,a)),l=this.parseOrder(h.data,n),u=l.id;return this.orders[u]=l,l}async cancelOrder(e,t,i={}){await this.loadMarkets();const s=this.market(t),r={id:e,market:s.id},a=await this.privateDeleteOrderPending(this.extend(r,i));return this.parseOrder(a.data,s)}async fetchOrder(e,t,i={}){if(void 0===t)throw new a(this.id+" fetchOrder requires a symbol argument");await this.loadMarkets();const s=this.market(t),r={id:e,market:s.id},o=await this.privateGetOrder(this.extend(r,i));return this.parseOrder(o.data,s)}async fetchOrdersByStatus(e,t,i,s,r={}){await this.loadMarkets(),void 0===s&&(s=100);const a={page:1,limit:s};let o=void 0;void 0!==t&&(o=this.market(t),a.market=o.id);const n="privateGetOrder"+this.capitalize(e),d=await this[n](this.extend(a,r));return this.parseOrders(d.data.data,o,i,s)}async fetchOpenOrders(e,t,i,s={}){return await this.fetchOrdersByStatus("pending",e,t,i,s)}async fetchClosedOrders(e,t,i,s={}){return await this.fetchOrdersByStatus("finished",e,t,i,s)}async fetchMyTrades(e,t,i,s={}){await this.loadMarkets(),void 0===i&&(i=100);const r={page:1,limit:i};let a=void 0;void 0!==e&&(a=this.market(e),r.market=a.id);const o=await this.privateGetOrderUserDeals(this.extend(r,s));return this.parseTrades(o.data.data,a,t,i)}async withdraw(e,t,i,s,r={}){this.checkAddress(i),await this.loadMarkets();const a=this.currency(e);s&&(i=i+":"+s);const o={coin_type:a.id,coin_address:i,actual_amount:parseFloat(t),transfer_method:"1"},n=await this.privatePostBalanceCoinWithdraw(this.extend(o,r)),d=this.safeValue(n,"data",{});return this.parseTransaction(d,a)}parseTransactionStatus(e){return this.safeString({audit:"pending",pass:"pending",processing:"pending",confirming:"pending",not_pass:"failed",cancel:"canceled",finish:"ok",fail:"failed"},e,e)}parseTransaction(e,t){const i=this.safeString2(e,"coin_withdraw_id","coin_deposit_id"),s=this.safeString(e,"coin_address");let r=this.safeString(e,"remark");void 0!==r&&r.length<1&&(r=void 0);let a=this.safeValue(e,"tx_id");void 0!==a&&a.length<1&&(a=void 0);const o=this.safeString(e,"coin_type"),n=this.safeCurrencyCode(o,t),d=this.safeTimestamp(e,"create_time"),c="coin_withdraw_id"in e?"withdraw":"deposit",h=this.parseTransactionStatus(this.safeString(e,"status"),c),l=this.safeFloat(e,"amount");let u=this.safeFloat(e,"tx_fee");"deposit"===c&&(u=0);const f={cost:u,currency:n};return{info:e,id:i,txid:a,timestamp:d,datetime:this.iso8601(d),address:s,tag:r,type:c,amount:l,currency:n,status:h,updated:void 0,fee:f}}async fetchWithdrawals(e,t,i,s={}){if(void 0===e)throw new a(this.id+" fetchWithdrawals requires a currency code argument");await this.loadMarkets();const r=this.currency(e),o={coin_type:r.id};void 0!==i&&(o.Limit=i);const n=await this.privateGetBalanceCoinWithdraw(this.extend(o,s));return this.parseTransactions(n.data,r,t,i)}async fetchDeposits(e,t,i,s={}){if(void 0===e)throw new a(this.id+" fetchDeposits requires a currency code argument");await this.loadMarkets();const r=this.currency(e),o={coin_type:r.id};void 0!==i&&(o.Limit=i);const n=await this.privateGetBalanceCoinDeposit(this.extend(o,s));return this.parseTransactions(n.data,r,t,i)}nonce(){return this.milliseconds()}sign(e,t="public",i="GET",s={},r,a){e=this.implodeParams(e,s);let o=this.urls.api+"/"+this.version+"/"+e,n=this.omit(s,this.extractParams(e));if("public"===t)Object.keys(n).length&&(o+="?"+this.urlencode(n));else{this.checkRequiredCredentials();const e=this.nonce();n=this.extend({access_id:this.apiKey,tonce:e.toString()},n),n=this.keysort(n);const t=this.urlencode(n);r={Authorization:this.hash(this.encode(t+"&secret_key="+this.secret)).toUpperCase(),"Content-Type":"application/json"},"GET"===i||"DELETE"===i?o+="?"+t:a=this.json(n)}return{url:o,method:i,body:a,headers:r}}async request(e,t="public",i="GET",s={},a,h){const l=await this.fetch2(e,t,i,s,a,h),u=this.safeString(l,"code"),f=this.safeValue(l,"data"),p=this.safeString(l,"message");if("0"!==u||void 0===f||"Ok"!==p&&!f){const e={24:c,25:c,107:o,600:n,601:d,602:d,606:d};throw new(this.safeValue(e,u,r))(l.message)}return l}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"coinexchange",name:"CoinExchange",countries:["IN","JP","KR","VN","US"],rateLimit:1e3,has:{privateAPI:!1,fetchBalance:!1,createOrder:!1,createMarketOrder:!1,createLimitOrder:!1,cancelOrder:!1,editOrder:!1,fetchTrades:!1,fetchOHLCV:!1,fetchCurrencies:!0,fetchTickers:!0},urls:{referral:"https://www.coinexchange.io/?r=a1669e56",logo:"https://user-images.githubusercontent.com/1294454/34842303-29c99fca-f71c-11e7-83c1-09d900cb2334.jpg",api:"https://www.coinexchange.io/api/v1",www:"https://www.coinexchange.io",doc:"https://coinexchangeio.github.io/slate/",fees:"https://www.coinexchange.io/fees"},api:{public:{get:["getcurrency","getcurrencies","getmarkets","getmarketsummaries","getmarketsummary","getorderbook"]}},fees:{trading:{maker:.0015,taker:.0015},funding:{withdraw:{1337:.01,"420G":.01,611:.1,ACC:.01,ACES:.01,ACO:.01,ACP:.01,ADCN:500,ADST:1,ADZ:.1,AGRI:.01,AI:1,AKY:.01,ALIS:1,ALL:.2,AMC:.1,AMMO:.01,AMS:.01,ANTX:.01,ANY:1,ARG:.1,ARGUS:.01,ARGUSOLD:.01,ASN:.01,ATOM:.01,ATX:.01,AU:.01,B2B:1,B3:.01,BAKED:.01,BCC:.01,BCH:.001,BCM:.01,BDL:.01,BEER:.01,BELA:.01,BENJI:.05,BET:.01,BFI:1,BIGUP:1,BIRDS:.01,BITB:.1,BIXC:.01,BIZ:.01,BLAS:.1,BLAZR:.2,BLK:.01,BLN:1,BLUE:1,BOAT:1,BON:.01,BONPAY:1,BOPS:.01,BPOK:.1,BQ:1,BRAT:.01,BRC:1,BRIT:.01,BSN:1,BSR:.01,BTBc:.01,BTC:.001,BTCRED:1,BTCRF:.01,BTDX:.1,BTE:1,BTPL:.01,BULLS:.01,BUZZ:.01,BXT:.01,C47:1,CACH:.2,CALC:.01,CANN:.01,CBANK:1,CDX:1,CHEAP:.01,CHESS:.01,CHILI:.01,CHIPS:.1,CJ:.1,CLT:.1,CMPCO:.2,CMX:.01,CNNC:.02,CNT:.01,CO2:1,COOC:.01,COUPE:.01,CQST:.1,CRACKERS:.01,CRDNC:.01,CREA:.02,CREAK:.01,CREVA2:.01,CRMSN:.01,CRN:.01,CRW:.01,CTIC2:.01,CUBE:.01,CXT:.01,CYCLONE:.01,CYDER:.01,DAG:.01,DALC:1,DARI:.01,DASH:.01,DAV:.01,DBIC:.1,DCN:1,DEM:.01,DFS:.01,DGB:.1,DGC:.1,DIME:.01,DMB:.01,DMC:.1,DNCV2:.01,DNE:1,DNR:.01,DOGE:2,DOGEJ:1,DP:.01,DRGN:1,DRS:.1,DSE:.01,DSR:.01,DTCT:1,DUTCH:.01,EBC:.01,EBT:.01,ECC:.1,ECN:.01,EDRC:.01,EECN:.01,EGC:.1,ELCO:.1,ELIX:1,ELS:.01,ELT:1,EMC:.01,EMIRG:.01,ENTRC:1,ENZO:.1,EQL:1,EQT:.1,ERSO:.01,ERT:1,ERY:.01,ESP:.1,ETBS:1,ETC:.1,ETG:1,ETH:.01,ETHD:.01,ETHOS:1,ETN:2,EUROP:.1,EXCL:.1,EXTN:.01,FAIR:.01,FAP:1,FAZZ:.01,FCH:.01,FGZ:.1,FLASH:.01,FLIK:1,FRT:.1,FSX:.1,FTC:.01,FXE:2,GAIN:1,GB:.1,GBX:.01,GDC:1,GEERT:.01,GET:.01,GFC:1,GLS:.01,GLT:.01,GLTC:.01,GMB:.01,GMX:.01,GOKUOLD:.1,GOLD:.01,GOLF:.1,GOOD:2,GP:.01,GRE:.01,GREENF:.01,GRMD:1,GRS:.01,GRX:1,GTC:.01,GWC:.2,HALLO:.01,HBC:.01,HC:.01,HEALTHY:.01,HIGH:.01,HarmonyCoin:.01,HNC:.01,HOC:.01,HODL:.01,HOLLY:1,HONEY:.01,HOPE:.01,HPC:.01,HUB:1,HYP:.01,HYPER:.01,IBC:1,ICE:1,ICOT:1,IFT:1,ILC:.01,IMX:.01,INDIA:.01,INFO:.01,INSN:.01,INXT:1,IOE:.01,IQT:1,IXC:.01,JAPAN:.01,JEDI:.01,JET:1,JIN:.2,KAYI:.01,KB3:.01,KGB:.01,KLC:.1,KMD:.01,KOBO:1,KOI:.01,KORUNA:.1,KRA:.01,KUBO:.01,KURT:.01,LA:1,LAMBO:.01,LCT:1,LDC:.01,LEVO:.1,LIFE:1,LINDA:.01,LINX:.01,LIZ:.01,LMC:.1,LNK:.05,LRC:1,LTC:.01,LTG:1,LUCK:.01,LUNA:.01,LVPS:.01,MAC:2,MAG:.01,MALC:.01,MARS:.01,MARS2:.01,MAXI:.01,MAY:.01,MBC:.01,MBIT:.01,MCB:1,MEC:.1,MENTAL:.1,MER:.1,MET:.01,MGM:.01,MGT:.01,MILO:.5,MINEX:1,MINT:1,MIPS:1,MNX:.01,MOIN:.1,MOON:.1,MSCN:.01,MSP:1,MST:.1,MTH:1,MUE:.1,MUX:1,MXC:.01,MXT:.1,MYB:1,NBIT:.1,NBX:.01,NEOG:1,NEON:.01,NLC2:.01,NLG:.1,NRN:.01,NRO:.01,NTC:1,NTO:1,NUA:1,NUMUS:.01,OC:.01,OGN:.01,ORO:.01,PARIS:.01,PAYU:.1,PCN:1,PCS:.01,PDG:.01,PEC:.01,PGL:1,PHN:1,PICO:.1,PIE:.01,PIGGY:.1,PIVX:.2,PIX:1,PKT:1,PLACO:.01,PLX:1,POL:.01,POLOB:.1,POS:1,POST:1,POSW:.01,POT:.1,PRE:1,PRIMU:.01,PRL:1,PRN:1,PRX:.01,PT:1,PTS:1,PURA:1,PURE:.01,PUT:.1,PWC:.01,PWR:.1,QTUM:.01,QUANT:.01,RAIN:.5,RBL:.01,RDC:.01,REC:.01,REGA:.1,REX:1,RHO:.1,RIYA:1,RMC:2,RNS:.01,ROC:0,ROOFS:.01,RUB:.01,RUNE:.01,RUNNERS:.01,RUP:.01,SBIT:.01,SCL:1,SCORE:.01,SCOREOLD:.01,SDASH:.01,SFC:.01,SFE:.01,SGR:1,SHIT:.1,SHM:.1,SHND:.1,SHOT:.1,SIC:.1,SILK2:.01,SIMP:.001,SISA:1,SKOIN:.01,SKULL:.01,SLEVIN:.01,SLR:.01,SMART:.01,SMS:.002,SNOW:.01,SOLAR:.01,SPRTS:1,SRC:.01,SST:.1,STARS:.01,STN:.01,STO:.01,STX:1,SUPER:.01,SUPERMAN:.01,SURGE:.01,SWC:.1,SYNQ:.01,SYNX:.01,TAAS:2,TBS:.01,TCOIN:.01,TELL:.1,TER:.005,TGT:1,TIGER:.01,TIPS:.01,TLE:.01,TOPAZ:.01,TOR:.01,TPC:.01,TPG:.01,TPI:1,TRANCE:.01,TRC:.01,TRUX:.01,TSE:.1,TSTR:.01,TURBO:.01,UFO:.01,UK:.01,ULA:.01,UNIFY:0,UNIT:.1,UNO:.001,UP:.01,UQC:1,USA:.01,VC:.01,VGS:.01,VIDZ:.01,VISIO:.05,VLTC:.1,VOISE:1,VONE:.01,VOX:.01,VSX:.01,VULCANO:.01,WASH:.1,WCL:1,WINK:.01,WOMEN:.01,WORM:.01,WOW:.1,WRP:.01,WYV:.01,XBC:.01,XBL:1,XBU:1,XCHE:.1,XCS:.01,XCT:.01,XCXT:.01,XDE2:.01,XEV:.1,XGOX:.01,XGTC:.01,XLR:.1,XMCC:.01,XP:1,XPASC:.01,XQN:.01,XSA:.1,XSTC:2,XTD:.01,XVS:.01,XXX:.1,XYOC:1,XYZ:.01,XZC:.1,XZCD:.01,YHC:.01,ZCC:.01,ZCG:1,ZCL:.001,ZEC:.001,ZEIT:.1,ZENI:.01,ZERO:.01,ZMC:.1,ZOI:.01,ZSE:.01,ZURMO:.1,ZZC:.01}}},precision:{amount:8,price:8},commonCurrencies:{ACC:"AdCoin",ANC:"AnyChain",BON:"BonPeKaO",BONPAY:"BON",eNAU:"ENAU",ETN:"Ethernex",FAIR:"FairCoin",FRC:"FireRoosterCoin",GET:"GreenEnergyToken",GDC:"GoldenCryptoCoin",GOLD:"GoldenCoin",GTC:"GlobalTourCoin",HMC:"HarmonyCoin",HNC:"Huncoin",IBC:"RCoin",MARS:"MarsBux",MER:"TheMermaidCoin",OC:"occnetwork",PUT:"PutinCoin",RUB:"RubbleCoin",UP:"UpscaleToken",VULCANO:"VULC"}})}async fetchCurrencies(e={}){const t=await this.publicGetGetcurrencies(e),i=this.safeValue(t,"result"),s=this.precision.amount,r={};for(let e=0;e<i.length;e++){const t=i[e],a=this.safeString(t,"CurrencyID"),o=this.safeCurrencyCode(this.safeString(t,"TickerCode")),n="online"===this.safeString(t,"WalletStatus"),d=this.safeString(t,"Name");r[o]={id:a,code:o,name:d,active:n,precision:s,limits:{amount:{min:void 0,max:Math.pow(10,s)},price:{min:Math.pow(10,-s),max:Math.pow(10,s)},cost:{min:void 0,max:void 0},withdraw:{min:void 0,max:Math.pow(10,s)}},info:t}}return r}async fetchMarkets(e={}){const t=(await this.publicGetGetmarkets(e)).result,i=[];for(let e=0;e<t.length;e++){const s=t[e],r=s.MarketID,a=this.safeString(s,"MarketAssetCode"),o=this.safeString(s,"BaseCurrencyCode");if(void 0!==a&&void 0!==o){const e=this.safeCurrencyCode(a),t=this.safeCurrencyCode(o),n=e+"/"+t;i.push({id:r,symbol:n,base:e,quote:t,baseId:a,quoteId:o,active:s.Active,info:s})}}return i}parseTicker(e,t){let i=void 0;if(void 0===t){const s=this.safeString(e,"MarketID");s in this.markets_by_id?t=this.markets_by_id[s]:i=s}t&&(i=t.symbol);const s=this.milliseconds(),r=this.safeFloat(e,"LastPrice");return{symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeFloat(e,"HighPrice"),low:this.safeFloat(e,"LowPrice"),bid:this.safeFloat(e,"BidPrice"),bidVolume:void 0,ask:this.safeFloat(e,"AskPrice"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:this.safeFloat(e,"Change"),average:void 0,baseVolume:void 0,quoteVolume:this.safeFloat(e,"Volume"),info:e}}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={market_id:i.id},r=await this.publicGetGetmarketsummary(this.extend(s,t));return this.parseTicker(r.result,i)}async fetchTickers(e,t={}){await this.loadMarkets();const i=(await this.publicGetGetmarketsummaries(t)).result,s={};for(let e=0;e<i.length;e++){const t=this.parseTicker(i[e]);s[t.symbol]=t}return s}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={market_id:this.marketId(e)},r=await this.publicGetGetorderbook(this.extend(s,i));return this.parseOrderBook(r.result,void 0,"BuyOrders","SellOrders","Price","Quantity")}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api+"/"+e;return"public"===t&&Object.keys(s).length&&(o+="?"+this.urlencode(s)),{url:o,method:i,body:a,headers:r}}async request(e,t="public",i="GET",s={},a,o){const n=await this.fetch2(e,t,i,s,a,o);if(1!==this.safeInteger(n,"success")){const e=this.safeString(n,"message","Error");throw new r(e)}return n}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,AuthenticationError:a,DDoSProtection:o,ArgumentsRequired:n}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"coinfalcon",name:"CoinFalcon",countries:["GB"],rateLimit:1e3,version:"v1",has:{fetchTickers:!0,fetchOpenOrders:!0,fetchMyTrades:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/41822275-ed982188-77f5-11e8-92bb-496bcd14ca52.jpg",api:"https://coinfalcon.com",www:"https://coinfalcon.com",doc:"https://docs.coinfalcon.com",fees:"https://coinfalcon.com/fees",referral:"https://coinfalcon.com/?ref=CFJSVGTUPASB"},api:{public:{get:["markets","markets/{market}/orders","markets/{market}/trades"]},private:{get:["user/accounts","user/orders","user/orders/{id}","user/trades"],post:["user/orders"],delete:["user/orders/{id}"]}},fees:{trading:{tierBased:!0,maker:0,taker:.002}},precision:{amount:8,price:8}})}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),i=this.safeValue(t,"data"),s=[];for(let e=0;e<i.length;e++){const t=i[e],[r,a]=t.name.split("-"),o=this.safeCurrencyCode(r),n=this.safeCurrencyCode(a),d=o+"/"+n,c={amount:this.safeInteger(t,"size_precision"),price:this.safeInteger(t,"price_precision")};s.push({id:t.name,symbol:d,base:o,quote:n,baseId:r,quoteId:a,active:!0,precision:c,limits:{amount:{min:Math.pow(10,-c.amount),max:void 0},price:{min:Math.pow(10,-c.price),max:void 0},cost:{min:void 0,max:void 0}},info:t})}return s}parseTicker(e,t){if(void 0===t){const i=this.safeString(e,"name");t=this.safeValue(this.markets_by_id,i,t)}let i=void 0;void 0!==t&&(i=t.symbol);const s=this.milliseconds(),r=parseFloat(e.last_price);return{symbol:i,timestamp:s,datetime:this.iso8601(s),high:void 0,low:void 0,bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:this.safeFloat(e,"change_in_24h"),percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:this.safeFloat(e,"volume"),info:e}}async fetchTicker(e,t={}){return await this.loadMarkets(),(await this.fetchTickers(t))[e]}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetMarkets(t),s=this.safeValue(i,"data"),r={};for(let e=0;e<s.length;e++){const t=this.parseTicker(s[e]);r[t.symbol]=t}return r}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={market:this.marketId(e),level:"3"},r=await this.publicGetMarketsMarketOrders(this.extend(s,i));return this.parseOrderBook(r.data,void 0,"bids","asks","price","size")}parseTrade(e,t){const i=this.parse8601(this.safeString(e,"created_at")),s=this.safeFloat(e,"price"),r=this.safeFloat(e,"size"),a=t.symbol;let o=void 0;void 0!==s&&void 0!==r&&(o=parseFloat(this.costToPrecision(a,s*r)));const n=this.safeString(e,"id"),d=this.safeString(e,"side"),c=this.safeString(e,"order_id");let h=void 0;const l=this.safeFloat(e,"fee");if(void 0!==l){const t=this.safeString(e,"fee_currency_code");h={cost:l,currency:this.safeCurrencyCode(t)}}return{info:e,timestamp:i,datetime:this.iso8601(i),symbol:a,id:n,order:c,type:void 0,side:d,takerOrMaker:void 0,price:s,amount:r,cost:o,fee:h}}async fetchMyTrades(e,t,i,s={}){if(void 0===e)throw new n(this.id+" fetchMyTrades requires a symbol argument");await this.loadMarkets();const r=this.market(e),a={market:r.id};void 0!==t&&(a.start_time=this.iso8601(t)),void 0!==i&&(a.limit=i);const o=await this.privateGetUserTrades(this.extend(a,s));return this.parseTrades(o.data,r,t,i)}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={market:r.id};void 0!==t&&(a.since=this.iso8601(t));const o=await this.publicGetMarketsMarketTrades(this.extend(a,s));return this.parseTrades(o.data,r,t,i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetUserAccounts(e),i={info:t},s=this.safeValue(t,"data");for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"currency_code"),a=this.safeCurrencyCode(r),o={free:this.safeFloat(t,"available_balance"),used:this.safeFloat(t,"hold_balance"),total:this.safeFloat(t,"balance")};i[a]=o}return this.parseBalance(i)}parseOrderStatus(e){return this.safeString({fulfilled:"closed",canceled:"canceled",pending:"open",open:"open",partially_filled:"open"},e,e)}parseOrder(e,t){if(void 0===t){const i=this.safeString(e,"market");i in this.markets_by_id&&(t=this.markets_by_id[i])}let i=void 0;void 0!==t&&(i=t.symbol);const s=this.parse8601(this.safeString(e,"created_at")),r=this.safeFloat(e,"price"),a=this.safeFloat(e,"size"),o=this.safeFloat(e,"size_filled");let n=void 0,d=void 0;void 0!==a&&(void 0!==o&&(n=parseFloat(this.amountToPrecision(i,a-o))),void 0!==r&&(d=parseFloat(this.priceToPrecision(i,o*r))));const c=this.parseOrderStatus(this.safeString(e,"status"));let h=this.safeString(e,"operation_type");void 0!==h&&(h=(h=h.split("_"))[0]);const l=this.safeString(e,"order_type");return{id:this.safeString(e,"id"),datetime:this.iso8601(s),timestamp:s,status:c,symbol:i,type:h,side:l,price:r,cost:d,amount:a,filled:o,remaining:n,trades:void 0,fee:void 0,info:e}}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o=this.market(e),n={market:o.id,size:this.amountToPrecision(e,s),order_type:i};"limit"===t&&(r=this.priceToPrecision(e,r),n.price=r.toString()),n.operation_type=t+"_order";const d=await this.privatePostUserOrders(this.extend(n,a)),c=this.parseOrder(d.data,o),h=c.id;return this.orders[h]=c,c}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={id:e},r=await this.privateDeleteUserOrdersId(this.extend(s,i)),a=this.market(t);return this.parseOrder(r.data,a)}async fetchOrder(e,t,i={}){await this.loadMarkets();const s={id:e},r=await this.privateGetUserOrdersId(this.extend(s,i));return this.parseOrder(r.data)}async fetchOpenOrders(e,t,i,s={}){await this.loadMarkets();const r={};void 0!==e&&(r.market=this.marketId(e)),void 0!==t&&(r.since_time=this.iso8601(this.milliseconds()));const a=await this.privateGetUserOrders(this.extend(r,s));return this.parseOrders(a.data)}nonce(){return this.milliseconds()}sign(e,t="public",i="GET",s={},r,a){let o="/api/"+this.version+"/"+this.implodeParams(e,s);const n=this.omit(s,this.extractParams(e));if("public"===t)Object.keys(n).length&&(o+="?"+this.urlencode(n));else{this.checkRequiredCredentials(),"GET"===i?Object.keys(n).length&&(o+="?"+this.urlencode(n)):a=this.json(n);const e=this.seconds().toString();let t=[e,i,o].join("|");a&&(t+="|"+a);const s=this.hmac(this.encode(t),this.encode(this.secret));r={"CF-API-KEY":this.apiKey,"CF-API-TIMESTAMP":e,"CF-API-SIGNATURE":s,"Content-Type":"application/json"}}return{url:this.urls.api+o,method:i,body:a,headers:r}}handleErrors(e,t,i,s,n,d,c,h,l){if(e<400)return;throw new(this.safeValue({401:a,429:o},e,r))(d)}}},function(e,t,i){"use strict";const s=i(1),{InsufficientFunds:r,ExchangeError:a,NotSupported:o,InvalidNonce:n}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"coinfloor",name:"coinfloor",rateLimit:1e3,countries:["UK"],has:{CORS:!1,fetchOpenOrders:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/28246081-623fc164-6a1c-11e7-913f-bac0d5576c90.jpg",api:"https://webapi.coinfloor.co.uk/bist",www:"https://www.coinfloor.co.uk",doc:["https://github.com/coinfloor/api","https://www.coinfloor.co.uk/api"]},requiredCredentials:{apiKey:!0,secret:!1,password:!0,uid:!0},api:{public:{get:["{id}/ticker/","{id}/order_book/","{id}/transactions/"]},private:{post:["{id}/balance/","{id}/user_transactions/","{id}/open_orders/","{symbol}/cancel_order/","{id}/buy/","{id}/sell/","{id}/buy_market/","{id}/sell_market/","{id}/estimate_sell_market/","{id}/estimate_buy_market/"]}},markets:{"BTC/GBP":{id:"XBT/GBP",symbol:"BTC/GBP",base:"BTC",quote:"GBP",baseId:"XBT",quoteId:"GBP",precision:{price:0,amount:4}},"BTC/EUR":{id:"XBT/EUR",symbol:"BTC/EUR",base:"BTC",quote:"EUR",baseId:"XBT",quoteId:"EUR",precision:{price:0,amount:4}},"ETH/GBP":{id:"ETH/GBP",symbol:"ETH/GBP",base:"ETH",quote:"GBP",baseId:"ETH",quoteId:"GBP",precision:{price:0,amount:4}}},exceptions:{exact:{"You have insufficient funds.":r,"Tonce is out of sequence.":n}}})}async fetchBalance(e={}){await this.loadMarkets();let t=void 0;if("symbol"in e&&(t=this.findMarket(e.symbol)),"id"in e&&(t=this.findMarket(e.id)),!t)throw new o(this.id+" fetchBalance requires a symbol param");const i={id:t.id},s=await this.privatePostIdBalance(this.extend(i,e)),r={info:s},a=t.id.toLowerCase().split("/");return r[t.base]={free:this.safeFloat(s,a[0]+"_available"),used:this.safeFloat(s,a[0]+"_reserved"),total:this.safeFloat(s,a[0]+"_balance")},r[t.quote]={free:this.safeFloat(s,a[1]+"_available"),used:this.safeFloat(s,a[1]+"_reserved"),total:this.safeFloat(s,a[1]+"_balance")},this.parseBalance(r)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={id:this.marketId(e)},r=await this.publicGetIdOrderBook(this.extend(s,i));return this.parseOrderBook(r)}parseTicker(e,t){const i=this.milliseconds();let s=void 0;void 0!==t&&(s=t.symbol);const r=this.safeFloat(e,"vwap"),a=this.safeFloat(e,"volume");let o=void 0;void 0!==r&&(o=a*r);const n=this.safeFloat(e,"last");return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"bid"),bidVolume:void 0,ask:this.safeFloat(e,"ask"),askVolume:void 0,vwap:r,open:void 0,close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:a,quoteVolume:o,info:e}}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={id:i.id},r=await this.publicGetIdTicker(this.extend(s,t));return this.parseTicker(r,i)}parseTrade(e,t){const i=this.safeTimestamp(e,"date"),s=this.safeString(e,"tid"),r=this.safeFloat(e,"price"),a=this.safeFloat(e,"amount");let o=void 0;void 0!==r&&void 0!==a&&(o=r*a);let n=void 0;return void 0!==t&&(n=t.symbol),{info:e,id:s,order:void 0,timestamp:i,datetime:this.iso8601(i),symbol:n,type:void 0,side:void 0,takerOrMaker:void 0,price:r,amount:a,cost:o,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={id:r.id},o=await this.publicGetIdTransactions(this.extend(a,s));return this.parseTrades(o,r,t,i)}async fetchLedger(e,t,i,s={}){await this.loadMarkets();let r=void 0;if(e&&!(r=this.findMarket(e)))throw new o(this.id+" fetchTransactions requires a code argument (a market symbol)");const a={id:r.id,limit:i},n=await this.privatePostIdUserTransactions(this.extend(a,s));return this.parseLedger(n,void 0,t,void 0)}parseLedgerEntryStatus(e){return this.safeString({completed:"ok"},e,e)}parseLedgerEntryType(e){return this.safeString({0:"transaction",1:"transaction",2:"trade"},e,e)}parseLedgerEntry(e,t){const i=Object.keys(e);let s=void 0,r=void 0,a=void 0,o=void 0;for(let t=0;t<i.length;t++){const n=i[t];if(n.indexOf("_")>0){const t=n.split("_");if(2===t.length){const i=this.safeFloat(e,t[0]),n=this.safeFloat(e,t[1]);void 0!==i&&void 0!==n&&(s=t[0],r=t[1],a=i,o=n)}}}const n=this.safeCurrencyCode(s),d=this.safeCurrencyCode(r),c=this.parseLedgerEntryType(this.safeString(e,"type")),h=this.safeString(e,"id"),l=this.parse8601(this.safeString(e,"datetime"));let u=void 0;const f=this.safeFloat(e,"fee"),p={id:void 0,timestamp:l,datetime:this.iso8601(l),amount:void 0,direction:void 0,currency:void 0,type:c,referenceId:h,referenceAccount:void 0,before:void 0,after:void 0,status:"ok",fee:u,info:e};if("trade"===c)return void 0!==f&&(u={cost:f,currency:d}),[this.extend(p,{currency:n,amount:Math.abs(a),direction:a>0?"in":"out"}),this.extend(p,{currency:d,amount:Math.abs(o),direction:o>0?"in":"out",fee:u})];{const e=0===a?o:a,t=0===a?d:n,i=e>0?"in":"out";return void 0!==f&&(u={cost:f,currency:t}),this.extend(p,{currency:t,amount:Math.abs(e),direction:i,fee:u})}}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o={id:this.marketId(e)};let n="privatePostId"+this.capitalize(i);return"market"===t?(o.quantity=s,n+="Market"):(o.price=r,o.amount=s),await this[n](this.extend(o,a))}async cancelOrder(e,t,i={}){if(void 0===t)throw new o(this.id+" cancelOrder requires a symbol argument");await this.loadMarkets();const s={symbol:this.market(t).id,id:e};return await this.privatePostSymbolCancelOrder(s)}parseOrder(e,t){const i=this.parse8601(this.safeString(e,"datetime")),s=this.safeFloat(e,"price"),r=this.safeFloat(e,"amount");let a=void 0;void 0!==s&&void 0!==r&&(a=s*r);let o=void 0;const n=this.safeString(e,"status");0===e.type?o="buy":1===e.type&&(o="sell");let d=void 0;return void 0!==t&&(d=t.symbol),{info:e,id:this.safeString(e,"id"),datetime:this.iso8601(i),timestamp:i,lastTradeTimestamp:void 0,status:n,symbol:d,type:"limit",side:o,price:s,amount:r,filled:void 0,remaining:void 0,cost:a,fee:void 0}}async fetchOpenOrders(e,t,i,s={}){if(void 0===e)throw new o(this.id+" fetchOpenOrders requires a symbol param");await this.loadMarkets();const r=this.market(e),a={id:r.id},n=await this.privatePostIdOpenOrders(this.extend(a,s));return this.parseOrders(n,r,t,i,{status:"open"})}handleErrors(e,t,i,s,r,o,n,d,c){if(e<400)return;if(void 0===n)return;const h=this.safeString(n,"error_msg"),l=this.id+" "+o,u=this.exceptions.exact;if(h in u)throw new u[h](l);throw new a(l)}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api+"/"+this.implodeParams(e,s);const n=this.omit(s,this.extractParams(e));if("public"===t)Object.keys(n).length&&(o+="?"+this.urlencode(n));else{this.checkRequiredCredentials();const e=this.nonce();a=this.urlencode(this.extend({nonce:e},n));const t=this.uid+"/"+this.apiKey+":"+this.password;r={"Content-Type":"application/x-www-form-urlencoded",Authorization:"Basic "+this.decode(this.stringToBase64(this.encode(t)))}}return{url:o,method:i,body:a,headers:r}}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"coingi",name:"Coingi",rateLimit:1e3,countries:["PA","BG","CN","US"],has:{CORS:!1,fetchTickers:!0},urls:{referral:"https://www.coingi.com/?r=XTPPMC",logo:"https://user-images.githubusercontent.com/1294454/28619707-5c9232a8-7212-11e7-86d6-98fe5d15cc6e.jpg",api:{www:"https://coingi.com",current:"https://api.coingi.com",user:"https://api.coingi.com"},www:"https://coingi.com",doc:"https://coingi.docs.apiary.io"},api:{www:{get:[""]},current:{get:["order-book/{pair}/{askCount}/{bidCount}/{depth}","transactions/{pair}/{maxCount}","24hour-rolling-aggregation"]},user:{post:["balance","add-order","cancel-order","orders","transactions","create-crypto-withdrawal"]}},fees:{trading:{tierBased:!1,percentage:!0,taker:.002,maker:.002},funding:{tierBased:!1,percentage:!1,withdraw:{BTC:.001,LTC:.01,DOGE:2,PPC:.02,VTC:.2,NMC:2,DASH:.002,USD:10,EUR:10},deposit:{BTC:0,LTC:0,DOGE:0,PPC:0,VTC:0,NMC:0,DASH:0,USD:5,EUR:1}}}})}async fetchMarkets(e={}){const t=(await this.wwwGet(e)).split('do=currencyPairSelector-selectCurrencyPair" class="active">')[1].split('<div class="currency-pair-label">'),i=[];for(let e=1;e<t.length;e++){let s=t[e].split("</div>")[0];s=(s=s.replace("/","-")).toLowerCase();const[r,a]=s.split("-");let o=r.toUpperCase(),n=a.toUpperCase();const d=(o=this.safeCurrencyCode(o))+"/"+(n=this.safeCurrencyCode(n)),c={amount:8,price:8};i.push({id:s,symbol:d,base:o,quote:n,baseId:r,quoteId:a,info:s,active:!0,precision:c,limits:{amount:{min:Math.pow(10,-c.amount),max:Math.pow(10,c.amount)},price:{min:Math.pow(10,-c.price),max:void 0},cost:{min:0,max:void 0}}})}return i}async fetchBalance(e={}){await this.loadMarkets();const t=[],i=Object.keys(this.currencies);for(let e=0;e<i.length;e++){const s=i[e];t.push(s.toLowerCase())}const s={currencies:t.join(",")},r=await this.userPostBalance(this.extend(s,e)),a={info:r};for(let e=0;e<r.length;e++){const t=r[e],i=this.safeString(t.currency,"name"),s=this.safeCurrencyCode(i),o=this.account();o.free=this.safeFloat(t,"available");const n=this.safeFloat(t,"blocked"),d=this.safeFloat(t,"inOrders"),c=this.safeFloat(t,"withdrawing");o.used=this.sum(n,d,c),a[s]=o}return this.parseBalance(a)}async fetchOrderBook(e,t=512,i={}){await this.loadMarkets();const s={pair:this.market(e).id,depth:32,askCount:t,bidCount:t},r=await this.currentGetOrderBookPairAskCountBidCountDepth(this.extend(s,i));return this.parseOrderBook(r,void 0,"bids","asks","price","baseAmount")}parseTicker(e,t){const i=this.milliseconds();let s=void 0;return void 0!==t&&(s=t.symbol),{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"highestBid"),bidVolume:void 0,ask:this.safeFloat(e,"lowestAsk"),askVolume:void 0,vwap:void 0,open:void 0,close:void 0,last:void 0,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeFloat(e,"baseVolume"),quoteVolume:this.safeFloat(e,"counterVolume"),info:e}}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.currentGet24hourRollingAggregation(t),s={};for(let e=0;e<i.length;e++){const t=i[e],r=t.currencyPair.base.toUpperCase()+"/"+t.currencyPair.counter.toUpperCase();let a=void 0;r in this.markets&&(a=this.markets[r]),s[r]=this.parseTicker(t,a)}return s}async fetchTicker(e,t={}){await this.loadMarkets();const i=await this.fetchTickers(void 0,t);if(e in i)return i[e];throw new r(this.id+" return did not contain "+e)}parseTrade(e,t){const i=this.safeFloat(e,"price"),s=this.safeFloat(e,"amount");let r=void 0;void 0!==i&&void 0!==s&&(r=i*s);const a=this.safeInteger(e,"timestamp"),o=this.safeString(e,"id"),n=this.safeString(e,"currencyPair");n in this.markets_by_id&&(t=this.markets_by_id[n]);let d=void 0;return void 0!==t&&(d=t.symbol),{id:o,info:e,timestamp:a,datetime:this.iso8601(a),symbol:d,type:void 0,side:void 0,order:void 0,takerOrMaker:void 0,price:i,amount:s,cost:r,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={pair:r.id,maxCount:128},o=await this.currentGetTransactionsPairMaxCount(this.extend(a,s));return this.parseTrades(o,r,t,i)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o={currencyPair:this.marketId(e),volume:s,price:r,orderType:"buy"===i?0:1},n=await this.userPostAddOrder(this.extend(o,a));return{info:n,id:n.result}}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={orderId:e};return await this.userPostCancelOrder(this.extend(s,i))}sign(e,t="current",i="GET",s={},r,a){let o=this.urls.api[t];"www"!==t&&(o+="/"+t+"/"+this.implodeParams(e,s));const n=this.omit(s,this.extractParams(e));if("current"===t)Object.keys(n).length&&(o+="?"+this.urlencode(n));else if("user"===t){this.checkRequiredCredentials();const e=this.nonce(),t=this.extend({token:this.apiKey,nonce:e},n),i=e.toString()+"$"+this.apiKey;t.signature=this.hmac(this.encode(i),this.encode(this.secret)),a=this.json(t),r={"Content-Type":"application/json"}}return{url:o,method:i,body:a,headers:r}}async request(e,t="current",i="GET",s={},a,o){const n=await this.fetch2(e,t,i,s,a,o);if("string"!=typeof n&&"errors"in n)throw new r(this.id+" "+this.json(n));return n}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"coinmarketcap",name:"CoinMarketCap",rateLimit:1e4,version:"v1",countries:["US"],has:{CORS:!0,privateAPI:!1,createOrder:!1,createMarketOrder:!1,createLimitOrder:!1,cancelOrder:!1,editOrder:!1,fetchBalance:!1,fetchOrderBook:!1,fetchL2OrderBook:!1,fetchOHLCV:!1,fetchTrades:!1,fetchTickers:!0,fetchCurrencies:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/28244244-9be6312a-69ed-11e7-99c1-7c1797275265.jpg",api:{public:"https://api.coinmarketcap.com",files:"https://files.coinmarketcap.com",charts:"https://graph.coinmarketcap.com"},www:"https://coinmarketcap.com",doc:"https://coinmarketcap.com/api"},requiredCredentials:{apiKey:!1,secret:!1},api:{files:{get:["generated/stats/global.json"]},graphs:{get:["currencies/{name}/"]},public:{get:["ticker/","ticker/{id}/","global/"]}},currencyCodes:["AUD","BRL","CAD","CHF","CNY","EUR","GBP","HKD","IDR","INR","JPY","KRW","MXN","RUB","USD","BTC","ETH","LTC"]})}async fetchOrderBook(e,t,i={}){throw new r("Fetching order books is not supported by the API of "+this.id)}currencyCode(e,t){return this.safeValue({ACChain:"ACChain",AdCoin:"AdCoin",BatCoin:"BatCoin",Bitgem:"Bitgem",BlazeCoin:"BlazeCoin",BlockCAT:"BlockCAT","Blocktrade Token":"Blocktrade Token",Catcoin:"Catcoin",CanYaCoin:"CanYaCoin",Comet:"Comet",CPChain:"CPChain",CrowdCoin:"CrowdCoin",Cubits:"Cubits","DAO.Casino":"DAO.Casino","E-Dinar Coin":"E-Dinar Coin",EDRcoin:"EDRcoin",ENTCash:"ENTCash",FairCoin:"FairCoin","Fabric Token":"Fabric Token","GET Protocol":"GET Protocol","Global Tour Coin":"Global Tour Coin",GuccioneCoin:"GuccioneCoin",HarmonyCoin:"HarmonyCoin","Harvest Masternode Coin":"Harvest Masternode Coin","HOT Token":"HOT Token","Hydro Protocol":"Hydro Protocol",Huncoin:"Huncoin",iCoin:"iCoin","Infinity Economics":"Infinity Economics","KingN Coin":"KingN Coin",LiteBitcoin:"LiteBitcoin",Maggie:"Maggie",IOTA:"IOTA",NetCoin:"NetCoin",PCHAIN:"PCHAIN",Polcoin:"Polcoin",PutinCoin:"PutinCoin",Rcoin:"Rcoin"},t,e)}async fetchMarkets(e={}){const t=await this.publicGetTicker(this.extend({limit:0},e)),i=[];for(let e=0;e<t.length;e++){const s=t[e],r=this.currencyCodes;for(let e=0;e<r.length;e++){const t=r[e],a=t.toLowerCase(),o=s.id,n=this.currencyCode(s.symbol,s.name),d=n+"/"+t,c=o+"/"+a;i.push({id:c,symbol:d,base:n,quote:t,baseId:o,quoteId:a,info:s})}}return i}async fetchGlobal(e="USD"){await this.loadMarkets();const t={};return e&&(t.convert=e),await this.publicGetGlobal(t)}parseTicker(e,t){let i=this.safeTimestamp(e,"last_updated");void 0===i&&(i=this.milliseconds());const s=this.safeFloat(e,"percent_change_24h");let r=void 0,a=void 0,o=void 0;if(void 0!==t){a=t.symbol;const i="price_"+t.quoteId;r=this.safeFloat(e,i);const s="24h_volume_"+t.quoteId;o=this.safeFloat(e,s)}return{symbol:a,timestamp:i,datetime:this.iso8601(i),high:void 0,low:void 0,bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:s,average:void 0,baseVolume:void 0,quoteVolume:o,info:e}}async fetchTickers(e="USD",t={}){await this.loadMarkets();const i={limit:1e4};e&&(i.convert=e);const s=await this.publicGetTicker(this.extend(i,t)),r={};for(let t=0;t<s.length;t++){const i=s[t],a=e.toLowerCase(),o=i.id+"/"+a;let n=o,d=void 0;o in this.markets_by_id&&(n=(d=this.markets_by_id[o]).symbol),r[n]=this.parseTicker(i,d)}return r}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={convert:i.quote,id:i.baseId},r=(await this.publicGetTickerId(this.extend(s,t)))[0];return this.parseTicker(r,i)}async fetchCurrencies(e={}){const t=await this.publicGetTicker(this.extend({limit:0},e)),i={};for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"symbol"),a=this.safeString(s,"name"),o=8,n=this.currencyCode(r,a);i[n]={id:r,code:n,info:s,name:a,active:!0,fee:void 0,precision:o,limits:{amount:{min:Math.pow(10,-o),max:Math.pow(10,o)},price:{min:Math.pow(10,-o),max:Math.pow(10,o)},cost:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}}}}return i}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api[t]+"/"+this.version+"/"+this.implodeParams(e,s);const n=this.omit(s,this.extractParams(e));return Object.keys(n).length&&(o+="?"+this.urlencode(n)),{url:o,method:i,body:a,headers:r}}async request(e,t="public",i="GET",s={},a,o){const n=await this.fetch2(e,t,i,s,a,o);if("error"in n&&n.error)throw new r(this.id+" "+this.json(n));return n}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"coinmate",name:"CoinMate",countries:["GB","CZ","EU"],rateLimit:1e3,has:{CORS:!0,fetchMyTrades:!0,fetchTransactions:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27811229-c1efb510-606c-11e7-9a36-84ba2ce412d8.jpg",api:"https://coinmate.io/api",www:"https://coinmate.io",fees:"https://coinmate.io/fees",doc:["https://coinmate.docs.apiary.io","https://coinmate.io/developers"],referral:"https://coinmate.io?referral=YTFkM1RsOWFObVpmY1ZjMGREQmpTRnBsWjJJNVp3PT0"},requiredCredentials:{apiKey:!0,secret:!0,uid:!0},api:{public:{get:["orderBook","ticker","transactions","tradingPairs"]},private:{post:["balances","bitcoinCashWithdrawal","bitcoinCashDepositAddresses","bitcoinDepositAddresses","bitcoinWithdrawal","bitcoinWithdrawalFees","buyInstant","buyLimit","cancelOrder","cancelOrderWithInfo","createVoucher","dashDepositAddresses","dashWithdrawal","ethereumWithdrawal","ethereumDepositAddresses","litecoinWithdrawal","litecoinDepositAddresses","openOrders","order","orderHistory","pusherAuth","redeemVoucher","replaceByBuyLimit","replaceByBuyInstant","replaceBySellLimit","replaceBySellInstant","rippleDepositAddresses","rippleWithdrawal","sellInstant","sellLimit","transactionHistory","traderFees","tradeHistory","transfer","transferHistory","unconfirmedBitcoinDeposits","unconfirmedBitcoinCashDeposits","unconfirmedDashDeposits","unconfirmedEthereumDeposits","unconfirmedLitecoinDeposits","unconfirmedRippleDeposits"]}},fees:{trading:{maker:5e-4,taker:.0015}}})}async fetchMarkets(e={}){const t=await this.publicGetTradingPairs(e),i=this.safeValue(t,"data"),s=[];for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"name"),a=this.safeString(t,"firstCurrency"),o=this.safeString(t,"secondCurrency"),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o),c=n+"/"+d;s.push({id:r,symbol:c,base:n,quote:d,baseId:a,quoteId:o,active:void 0,info:t,precision:{price:this.safeInteger(t,"priceDecimals"),amount:this.safeInteger(t,"lotDecimals")},limits:{amount:{min:this.safeFloat(t,"minAmount"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}}})}return s}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostBalances(e),i=this.safeValue(t,"data"),s={info:t},r=Object.keys(i);for(let e=0;e<r.length;e++){const t=r[e],a=this.safeCurrencyCode(t),o=this.safeValue(i,t),n=this.account();n.free=this.safeFloat(o,"available"),n.used=this.safeFloat(o,"reserved"),n.total=this.safeFloat(o,"balance"),s[a]=n}return this.parseBalance(s)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={currencyPair:this.marketId(e),groupByPriceLimit:"False"},r=(await this.publicGetOrderBook(this.extend(s,i))).data,a=this.safeTimestamp(r,"timestamp");return this.parseOrderBook(r,a,"bids","asks","price","amount")}async fetchTicker(e,t={}){await this.loadMarkets();const i={currencyPair:this.marketId(e)},s=await this.publicGetTicker(this.extend(i,t)),r=this.safeValue(s,"data"),a=this.safeTimestamp(r,"timestamp"),o=this.safeFloat(r,"last");return{symbol:e,timestamp:a,datetime:this.iso8601(a),high:this.safeFloat(r,"high"),low:this.safeFloat(r,"low"),bid:this.safeFloat(r,"bid"),bidVolume:void 0,ask:this.safeFloat(r,"ask"),vwap:void 0,askVolume:void 0,open:void 0,close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeFloat(r,"amount"),quoteVolume:void 0,info:r}}async fetchTransactions(e,t,i,s={}){await this.loadMarkets();const r={limit:1e3};void 0!==i&&(r.limit=i),void 0!==t&&(r.timestampFrom=t),void 0!==e&&(r.currency=this.currencyId(e));const a=(await this.privatePostTransferHistory(this.extend(r,s))).data;return this.parseTransactions(a,void 0,t,i)}parseTransactionStatus(e){return this.safeString({COMPLETED:"ok"},e,e)}parseTransaction(e,t){const i=this.safeInteger(e,"timestamp"),s=this.safeFloat(e,"amount"),r=this.safeFloat(e,"fee"),a=this.safeString(e,"txid"),o=this.safeString(e,"destination"),n=this.safeString(e,"destinationTag"),d=this.safeString(e,"amountCurrency"),c=this.safeCurrencyCode(d,t),h=this.safeStringLower(e,"transferType"),l=this.parseTransactionStatus(this.safeString(e,"transferStatus"));return{id:this.safeString(e,"transactionId"),timestamp:i,datetime:this.iso8601(i),currency:c,amount:s,type:h,txid:a,address:o,tag:n,status:l,fee:{cost:r,currency:t},info:e}}async fetchMyTrades(e,t,i,s={}){await this.loadMarkets(),void 0===i&&(i=1e3);const r={limit:i};void 0!==t&&(r.timestampFrom=t);const a=(await this.privatePostTradeHistory(this.extend(r,s))).data;return this.parseTrades(a,void 0,t,i)}parseTrade(e,t){let i=void 0;const s=this.safeString(e,"currencyPair");let r=void 0;if(void 0!==s)if(s in this.markets_by_id[s])r=(t=this.markets_by_id[s]).quote;else{const[e,t]=s.split("_");i=this.safeCurrencyCode(e)+"/"+(r=this.safeCurrencyCode(t))}void 0===i&&void 0!==t&&(i=t.symbol);const a=this.safeFloat(e,"price"),o=this.safeFloat(e,"amount");let n=void 0;void 0!==o&&void 0!==a&&(n=a*o);const d=this.safeStringLower2(e,"type","tradeType"),c=this.safeStringLower(e,"orderType"),h=this.safeString(e,"orderId"),l=this.safeString(e,"transactionId"),u=this.safeInteger2(e,"timestamp","createdTimestamp");let f=void 0;const p=this.safeFloat(e,"fee");void 0!==p&&(f={cost:p,currency:r});let m=this.safeString(e,"feeType");return m="MAKER"===m?"maker":"taker",{id:l,info:e,timestamp:u,datetime:this.iso8601(u),symbol:i,type:c,side:d,order:h,takerOrMaker:m,price:a,amount:o,cost:n,fee:f}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={currencyPair:r.id,minutesIntoHistory:10},o=await this.publicGetTransactions(this.extend(a,s)),n=this.safeValue(o,"data",[]);return this.parseTrades(n,r,t,i)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();let o="privatePost"+this.capitalize(i);const n={currencyPair:this.marketId(e)};"market"===t?("buy"===i?n.total=s:n.amount=s,o+="Instant"):(n.amount=s,n.price=r,o+=this.capitalize(t));const d=await this[o](this.extend(n,a));return{info:d,id:d.data.toString()}}async cancelOrder(e,t,i={}){return await this.privatePostCancelOrder({orderId:e})}nonce(){return this.milliseconds()}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api+"/"+e;if("public"===t)Object.keys(s).length&&(o+="?"+this.urlencode(s));else{this.checkRequiredCredentials();const e=this.nonce().toString(),t=e+this.uid+this.apiKey,i=this.hmac(this.encode(t),this.encode(this.secret));a=this.urlencode(this.extend({clientId:this.uid,nonce:e,publicKey:this.apiKey,signature:i.toUpperCase()},s)),r={"Content-Type":"application/x-www-form-urlencoded"}}return{url:o,method:i,body:a,headers:r}}async request(e,t="public",i="GET",s={},a,o){const n=await this.fetch2(e,t,i,s,a,o);if("error"in n&&n.error)throw new r(this.id+" "+this.json(n));return n}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,ArgumentsRequired:a,ExchangeNotAvailable:o,InvalidOrder:n,OrderNotFound:d}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"coinone",name:"CoinOne",countries:["KR"],rateLimit:667,version:"v2",has:{CORS:!1,createMarketOrder:!1,fetchTickers:!0,fetchOrder:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/38003300-adc12fba-323f-11e8-8525-725f53c4a659.jpg",api:"https://api.coinone.co.kr",www:"https://coinone.co.kr",doc:"https://doc.coinone.co.kr"},requiredCredentials:{apiKey:!0,secret:!0},api:{public:{get:["orderbook/","trades/","ticker/"]},private:{post:["account/btc_deposit_address/","account/balance/","account/daily_balance/","account/user_info/","account/virtual_account/","order/cancel_all/","order/cancel/","order/limit_buy/","order/limit_sell/","order/complete_orders/","order/limit_orders/","order/order_info/","transaction/auth_number/","transaction/history/","transaction/krw/history/","transaction/btc/","transaction/coin/"]}},markets:{"BCH/KRW":{id:"bch",symbol:"BCH/KRW",base:"BCH",quote:"KRW",baseId:"bch",quoteId:"krw"},"BTC/KRW":{id:"btc",symbol:"BTC/KRW",base:"BTC",quote:"KRW",baseId:"btc",quoteId:"krw"},"BTG/KRW":{id:"btg",symbol:"BTG/KRW",base:"BTG",quote:"KRW",baseId:"btg",quoteId:"krw"},"ETC/KRW":{id:"etc",symbol:"ETC/KRW",base:"ETC",quote:"KRW",baseId:"etc",quoteId:"krw"},"ETH/KRW":{id:"eth",symbol:"ETH/KRW",base:"ETH",quote:"KRW",baseId:"eth",quoteId:"krw"},"IOTA/KRW":{id:"iota",symbol:"IOTA/KRW",base:"IOTA",quote:"KRW",baseId:"iota",quoteId:"krw"},"LTC/KRW":{id:"ltc",symbol:"LTC/KRW",base:"LTC",quote:"KRW",baseId:"ltc",quoteId:"krw"},"OMG/KRW":{id:"omg",symbol:"OMG/KRW",base:"OMG",quote:"KRW",baseId:"omg",quoteId:"krw"},"QTUM/KRW":{id:"qtum",symbol:"QTUM/KRW",base:"QTUM",quote:"KRW",baseId:"qtum",quoteId:"krw"},"XRP/KRW":{id:"xrp",symbol:"XRP/KRW",base:"XRP",quote:"KRW",baseId:"xrp",quoteId:"krw"},"EOS/KRW":{id:"eos",symbol:"EOS/KRW",base:"EOS",quote:"KRW",baseId:"eos",quoteId:"krw"},"DATA/KRW":{id:"data",symbol:"DATA/KRW",base:"DATA",quote:"KRW",baseId:"data",quoteId:"krw"},"ZIL/KRW":{id:"zil",symbol:"ZIL/KRW",base:"ZIL",quote:"KRW",baseId:"zil",quoteId:"krw"},"KNC/KRW":{id:"knc",symbol:"KNC/KRW",base:"KNC",quote:"KRW",baseId:"knc",quoteId:"krw"},"ZRX/KRW":{id:"zrx",symbol:"ZRX/KRW",base:"ZRX",quote:"KRW",baseId:"zrx",quoteId:"krw"},"LUNA/KRW":{id:"luna",symbol:"LUNA/KRW",base:"LUNA",quote:"KRW",baseId:"luna",quoteId:"krw"},"ATOM/KRW":{id:"atom",symbol:"ATOM/KRW",base:"ATOM",quote:"KRW",baseId:"atom",quoteId:"krw"},"VNT/KRW":{id:"vnt",symbol:"VNT/KRW",base:"VNT",quote:"KRW",baseId:"vnt",quoteId:"krw"}},fees:{trading:{tierBased:!0,percentage:!0,taker:.001,maker:.001,tiers:{taker:[[0,.001],[1e8,9e-4],[1e9,8e-4],[5e9,7e-4],[1e10,6e-4],[2e10,5e-4],[3e10,4e-4],[4e10,3e-4],[5e10,2e-4]],maker:[[0,.001],[1e8,8e-4],[1e9,6e-4],[5e9,4e-4],[1e10,2e-4],[2e10,0],[3e10,0],[4e10,0],[5e10,0]]}}},exceptions:{405:o,104:d}})}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostAccountBalance(e),i={info:t},s=this.omit(t,["errorCode","result","normalWallets"]),r=Object.keys(s);for(let e=0;e<r.length;e++){const t=r[e],a=s[t],o=this.safeCurrencyCode(t),n=this.account();n.free=this.safeFloat(a,"avail"),n.total=this.safeFloat(a,"balance"),i[o]=n}return this.parseBalance(i)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={currency:this.market(e).id,format:"json"},r=await this.publicGetOrderbook(this.extend(s,i));return this.parseOrderBook(r,void 0,"bid","ask","price","qty")}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetTicker(this.extend({currency:"all",format:"json"},t)),s={},r=Object.keys(i);for(let e=0;e<r.length;e++){const t=r[e];let a=t,o=void 0;if(t in this.markets_by_id){a=(o=this.markets_by_id[t]).symbol;const e=i[t];s[a]=this.parseTicker(e,o)}}return s}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={currency:i.id,format:"json"},r=await this.publicGetTicker(this.extend(s,t));return this.parseTicker(r,i)}parseTicker(e,t){const i=this.milliseconds(),s=this.safeFloat(e,"last"),r=this.safeFloat(e,"yesterday_last");let a=void 0;return void 0!==s&&void 0!==r&&(a=r-s),{symbol:void 0!==t?t.symbol:void 0,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:this.safeFloat(e,"first"),close:s,last:s,previousClose:r,change:a,percentage:void 0,average:void 0,baseVolume:this.safeFloat(e,"volume"),quoteVolume:void 0,info:e}}parseTrade(e,t){const i=this.safeTimestamp(e,"timestamp"),s=void 0!==t?t.symbol:void 0,r=this.safeString(e,"is_ask");let a=void 0;"1"===r?a="sell":"0"===r&&(a="buy");const o=this.safeFloat(e,"price"),n=this.safeFloat(e,"qty");let d=void 0;return void 0!==o&&void 0!==n&&(d=o*n),{id:void 0,info:e,timestamp:i,datetime:this.iso8601(i),order:void 0,symbol:s,type:void 0,side:a,takerOrMaker:void 0,price:o,amount:n,cost:d,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={currency:r.id,period:"hour",format:"json"},o=await this.publicGetTrades(this.extend(a,s));return this.parseTrades(o.completeOrders,r,t,i)}async createOrder(e,t,i,s,a,o={}){if(await this.loadMarkets(),"limit"!==t)throw new r(this.id+" allows limit orders only");await this.loadMarkets();const n={price:a,currency:this.marketId(e),qty:s},d="privatePostOrder"+this.capitalize(t)+this.capitalize(i),c=await this[d](this.extend(n,o));let h=this.safeString(c,"orderId");void 0!==h&&(h=h.toUpperCase());const l=this.milliseconds(),u=a*s,f={info:c,id:h,timestamp:l,datetime:this.iso8601(l),lastTradeTimestamp:void 0,symbol:e,type:t,side:i,price:a,cost:u,average:void 0,amount:s,filled:void 0,remaining:s,status:"open",fee:void 0};return this.orders[h]=f,f}async fetchOrder(e,t,i={}){await this.loadMarkets();let s=void 0,r=void 0;if(void 0===t){if(!(e in this.orders))throw new a(this.id+" fetchOrder() requires a symbol argument for order ids missing in the .orders cache (the order was created with a different instance of this class or within a different run of this code).");r=this.market(this.orders[e].symbol)}else r=this.market(t);try{const t={order_id:e,currency:r.id},a=await this.privatePostOrderOrderInfo(this.extend(t,i));s=this.parseOrder(a),this.orders[e]=s}catch(t){if(!(t instanceof d))throw t;if(!(e in this.orders))throw t;this.orders[e].status="canceled",s=this.orders[e]}return s}parseOrderStatus(e){return this.safeString({live:"open",partially_filled:"open",filled:"closed"},e,e)}parseOrder(e,t){const i=this.safeValue(e,"info"),s=this.safeStringUpper(i,"orderId"),r=this.safeTimestamp(i,"timestamp"),a=this.parseOrderStatus(this.safeString(e,"status"));let o=void 0,n=this.safeString(i,"type");n=n.indexOf("ask")>=0?"sell":"buy";const d=this.safeFloat(i,"price"),c=this.safeFloat(i,"qty"),h=this.safeFloat(i,"remainQty");let l=void 0;void 0!==c&&(void 0!==h&&(l=c-h),void 0!==d&&(o=d*c));const u=this.safeString(i,"currency"),f={currency:u,cost:this.safeFloat(i,"fee"),rate:this.safeFloat(i,"feeRate")};let p=void 0;if(void 0===t){const e=u.toLowerCase();e in this.markets_by_id&&(t=this.markets_by_id[e])}return void 0!==t&&(p=t.symbol),{info:e,id:s,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,symbol:p,type:"limit",side:n,price:d,cost:o,amount:c,filled:l,remaining:h,status:a,fee:f}}async cancelOrder(e,t,i={}){await this.loadMarkets();const s=this.safeValue(this.orders,e);let r=void 0,a=void 0,o=void 0;if(void 0===s){if(void 0===t)throw new n(this.id+" cancelOrder could not find the order id "+e+" in orders cache. The order was probably created with a different instance of this class earlier. The `symbol` argument is missing. To cancel the order, pass a symbol argument and {'price': 12345, 'qty': 1.2345, 'is_ask': 0} in the params argument of cancelOrder.");if(void 0===(a=this.safeFloat(i,"price")))throw new n(this.id+" cancelOrder could not find the order id "+e+" in orders cache. The order was probably created with a different instance of this class earlier. The `price` parameter is missing. To cancel the order, pass a symbol argument and {'price': 12345, 'qty': 1.2345, 'is_ask': 0} in the params argument of cancelOrder.");if(void 0===(r=this.safeFloat(i,"qty")))throw new n(this.id+" cancelOrder could not find the order id "+e+" in orders cache. The order was probably created with a different instance of this class earlier. The `qty` (amount) parameter is missing. To cancel the order, pass a symbol argument and {'price': 12345, 'qty': 1.2345, 'is_ask': 0} in the params argument of cancelOrder.");if(void 0===(o=this.safeFloat(i,"is_ask")))throw new n(this.id+" cancelOrder could not find the order id "+e+" in orders cache. The order was probably created with a different instance of this class earlier. The `is_ask` (side) parameter is missing. To cancel the order, pass a symbol argument and {'price': 12345, 'qty': 1.2345, 'is_ask': 0} in the params argument of cancelOrder.")}else a=s.price,r=s.amount,o="buy"===s.side?0:1,t=s.symbol;const d={order_id:e,price:a,qty:r,is_ask:o,currency:this.marketId(t)};return this.orders[e].status="canceled",await this.privatePostOrderCancel(this.extend(d,i))}sign(e,t="public",i="GET",s={},r,a){const o=this.implodeParams(e,s),n=this.omit(s,this.extractParams(e));let d=this.urls.api+"/";if("public"===t)d+=o,Object.keys(n).length&&(d+="?"+this.urlencode(n));else{this.checkRequiredCredentials(),d+=this.version+"/"+o;const e=this.nonce().toString(),t=this.json(this.extend({access_token:this.apiKey,nonce:e},s)),i=this.stringToBase64(this.encode(t));a=this.decode(i);const n=this.secret.toUpperCase();r={"content-type":"application/json","X-COINONE-PAYLOAD":i,"X-COINONE-SIGNATURE":this.hmac(i,this.encode(n),"sha512")}}return{url:d,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,o,n,d,c){if(void 0!==n){if(!("result"in n))throw new r(this.id+" "+o);if("success"!==n.result){const e=this.safeString(n,"errorCode"),t=this.id+" "+this.json(n),i=this.exceptions;throw e in i?new i[e](t):new r(t)}}}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,AuthenticationError:a,NotSupported:o}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"coinspot",name:"CoinSpot",countries:["AU"],rateLimit:1e3,has:{CORS:!1,createMarketOrder:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/28208429-3cacdf9a-6896-11e7-854e-4c79a772a30f.jpg",api:{public:"https://www.coinspot.com.au/pubapi",private:"https://www.coinspot.com.au/api"},www:"https://www.coinspot.com.au",doc:"https://www.coinspot.com.au/api",referral:"https://www.coinspot.com.au/register?code=PJURCU"},api:{public:{get:["latest"]},private:{post:["orders","orders/history","my/coin/deposit","my/coin/send","quote/buy","quote/sell","my/balances","my/orders","my/buy","my/sell","my/buy/cancel","my/sell/cancel"]}},markets:{"BTC/AUD":{id:"btc",symbol:"BTC/AUD",base:"BTC",quote:"AUD",baseId:"btc",quoteId:"aud"},"LTC/AUD":{id:"ltc",symbol:"LTC/AUD",base:"LTC",quote:"AUD",baseId:"ltc",quoteId:"aud"},"DOGE/AUD":{id:"doge",symbol:"DOGE/AUD",base:"DOGE",quote:"AUD",baseId:"doge",quoteId:"aud"}},commonCurrencies:{DRK:"DASH"}})}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostMyBalances(e),i={info:t},s=this.safeValue(t,"balance",{}),r=Object.keys(s);for(let e=0;e<r.length;e++){const t=r[e],a=this.safeCurrencyCode(t),o=this.account();o.total=this.safeFloat(s,t),i[a]=o}return this.parseBalance(i)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={cointype:this.market(e).id},r=await this.privatePostOrders(this.extend(s,i));return this.parseOrderBook(r,void 0,"buyorders","sellorders","rate","amount")}async fetchTicker(e,t={}){await this.loadMarkets();const i=await this.publicGetLatest(t);let s=this.marketId(e);s=s.toLowerCase();const r=i.prices[s],a=this.milliseconds(),o=this.safeFloat(r,"last");return{symbol:e,timestamp:a,datetime:this.iso8601(a),high:void 0,low:void 0,bid:this.safeFloat(r,"bid"),bidVolume:void 0,ask:this.safeFloat(r,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:void 0,info:r}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={cointype:r.id},o=await this.privatePostOrdersHistory(this.extend(a,s)),n=this.safeValue(o,"orders",[]);return this.parseTrades(n,r,t,i)}async createOrder(e,t,i,s,a,o={}){await this.loadMarkets();const n="privatePostMy"+this.capitalize(i);if("market"===t)throw new r(this.id+" allows limit orders only");const d={cointype:this.marketId(e),amount:s,rate:a};return await this[n](this.extend(d,o))}async cancelOrder(e,t,i={}){throw new o(this.id+" cancelOrder () is not fully implemented yet")}sign(e,t="public",i="GET",s={},r,o){if(!this.apiKey)throw new a(this.id+" requires apiKey for all requests");const n=this.urls.api[t]+"/"+e;if("private"===t){this.checkRequiredCredentials();const e=this.nonce();o=this.json(this.extend({nonce:e},s)),r={"Content-Type":"application/json",key:this.apiKey,sign:this.hmac(this.encode(o),this.encode(this.secret),"sha512")}}return{url:n,method:i,body:o,headers:r}}}},function(e,t,i){"use strict";const s=i(14),{ExchangeError:r,ArgumentsRequired:a,BadRequest:o,ExchangeNotAvailable:n,AuthenticationError:d,InvalidOrder:c,InsufficientFunds:h,OrderNotFound:l,DDoSProtection:u}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"cointiger",name:"CoinTiger",countries:["CN"],hostname:"cointiger.pro",has:{fetchCurrencies:!1,fetchTickers:!0,fetchTradingLimits:!1,fetchOrder:!0,fetchOrders:!0,fetchOpenOrders:!0,fetchClosedOrders:!0,fetchOrderTrades:!1,cancelOrders:!0},headers:{Language:"en_US"},urls:{logo:"https://user-images.githubusercontent.com/1294454/39797261-d58df196-5363-11e8-9880-2ec78ec5bd25.jpg",api:{public:"https://api.{hostname}/exchange/trading/api/market",private:"https://api.{hostname}/exchange/trading/api",exchange:"https://www.{hostname}/exchange",v2public:"https://api.{hostname}/exchange/trading/api/v2",v2:"https://api.{hostname}/exchange/trading/api/v2"},www:"https://www.cointiger.pro",referral:"https://www.cointiger.one/#/register?refCode=FfvDtt",doc:"https://github.com/cointiger/api-docs-en/wiki"},api:{v2public:{get:["timestamp","currencys"]},v2:{get:["order/orders","order/match_results","order/make_detail","order/details"],post:["order","order/batch_cancel"]},public:{get:["history/kline","detail/merged","depth","trade","history/trade","detail"]},exchange:{get:["footer/tradingrule.html","api/public/market/detail"]},private:{get:["user/balance","order/new","order/history","order/trade"],post:["order"],delete:["order"]}},fees:{trading:{tierBased:!1,percentage:!0,maker:8e-4,taker:.0015}},exceptions:{1:r,2:o,5:c,6:c,8:l,16:d,100001:r,100002:n,100003:r,100005:d,110030:u},commonCurrencies:{FGC:"FoundGameCoin",TCT:"The Tycoon Chain Token"}})}async fetchMarkets(e={}){const t=await this.v2publicGetCurrencys(e),i=Object.keys(t.data),s=[];for(let e=0;e<i.length;e++){const r=i[e],a=t.data[r];for(let e=0;e<a.length;e++){const t=a[e],i=this.safeString(t,"baseCurrency"),r=this.safeString(t,"quoteCurrency"),o=this.safeCurrencyCode(i),n=this.safeCurrencyCode(r),d=i+r,c=d.toUpperCase(),h=o+"/"+n,l={amount:t.amountPrecision,price:t.pricePrecision},u=!0;s.push({id:d,uppercaseId:c,symbol:h,base:o,quote:n,baseId:i,quoteId:r,info:t,active:u,precision:l,limits:{amount:{min:Math.pow(10,-l.amount),max:void 0},price:{min:Math.pow(10,-l.price),max:void 0},cost:{min:0,max:void 0}}})}}return this.options.marketsByUppercaseId=this.indexBy(s,"uppercaseId"),s}parseTicker(e,t){let i=void 0;t&&(i=t.symbol);const s=this.safeInteger(e,"id"),r=this.safeFloat(e,"last"),a=this.safeFloat(e,"percentChange");return{symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeFloat(e,"high24hr"),low:this.safeFloat(e,"low24hr"),bid:this.safeFloat(e,"highestBid"),bidVolume:void 0,ask:this.safeFloat(e,"lowestAsk"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:a,average:void 0,baseVolume:this.safeFloat(e,"baseVolume"),quoteVolume:this.safeFloat(e,"quoteVolume"),info:e}}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={symbol:this.market(e).id,type:"step0"},a=await this.publicGetDepth(this.extend(s,i)),o=a.data.depth_data;if("tick"in o){if(!o.tick)throw new r(this.id+" fetchOrderBook() returned empty response: "+this.json(a));const e=o.tick,t=o.ts;return this.parseOrderBook(e,t,"buys")}throw new r(this.id+" fetchOrderBook() returned unrecognized response: "+this.json(a))}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s=i.uppercaseId,a=await this.exchangeGetApiPublicMarketDetail(t);if(!(s in a))throw new r(this.id+" fetchTicker symbol "+e+" ("+s+") not found");return this.parseTicker(a[s],i)}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.exchangeGetApiPublicMarketDetail(t),s={},r=Object.keys(i);for(let e=0;e<r.length;e++){const t=r[e];let a=void 0,o=t;t in this.options.marketsByUppercaseId&&(o=this.options.marketsByUppercaseId[t].symbol,a=this.options.marketsByUppercaseId[t]),s[o]=this.parseTicker(i[t],a)}return s}parseTrade(e,t){const i=this.safeString(e,"id"),s=this.safeString(e,"orderId"),r=this.safeStringLower(e,"type");let a=void 0,o=void 0;if(void 0!==r){const e=r.split("-");o=e[0],a=e[1]}let n=void 0,d=void 0,c=void 0;void 0===(o=this.safeStringLower(e,"side",o))?(d=this.safeFloat(e.price,"amount"),n=this.safeFloat(e.volume,"amount"),c=this.safeFloat(e.deal_price,"amount")):(d=this.safeFloat(e,"price"),n=this.safeFloat2(e,"amount","volume"));let h=void 0;const l=this.safeFloat(e,"fee");if(void 0!==l){let e=void 0;void 0!==t&&("buy"===o?e=t.base:"sell"===o&&(e=t.quote)),h={cost:l,currency:e}}void 0!==n&&void 0!==d&&void 0===c&&(c=n*d);let u=this.safeInteger2(e,"created_at","ts");u=this.safeInteger2(e,"created","mtime",u);let f=void 0;return void 0!==t&&(f=t.symbol),{id:i,info:e,order:s,timestamp:u,datetime:this.iso8601(u),symbol:f,type:a,side:o,takerOrMaker:void 0,price:d,amount:n,cost:c,fee:h}}async fetchTrades(e,t,i=1e3,s={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id};void 0!==i&&(a.size=i);const o=await this.publicGetHistoryTrade(this.extend(a,s));return this.parseTrades(o.data.trade_data,r,t,i)}async fetchMyTradesV1(e,t,i,s={}){if(void 0===e)throw new a(this.id+" fetchMyTrades requires a symbol argument");await this.loadMarkets();const r=this.market(e);void 0===i&&(i=100);const o={symbol:r.id,offset:1,limit:i},n=await this.privateGetOrderTrade(this.extend(o,s));return this.parseTrades(n.data.list,r,t,i)}async fetchMyTrades(e,t,i,s={}){if(void 0===e)throw new a(this.id+" fetchMyTrades requires a symbol argument");void 0===t&&(t=this.milliseconds()-6048e5),await this.loadMarkets();const r=this.market(e),o=this.ymd(t),n=this.ymd(this.sum(t,6048e5));void 0===i&&(i=1e3);const d={symbol:r.id,"start-date":o,"end-date":n,size:i},c=await this.v2GetOrderMatchResults(this.extend(d,s));return this.parseTrades(c.data,r,t,i)}parseOHLCV(e,t,i="1m",s,r){return[this.safeTimestamp(e,"id"),this.safeFloat(e,"open"),this.safeFloat(e,"high"),this.safeFloat(e,"low"),this.safeFloat(e,"close"),this.safeFloat(e,"vol")]}async fetchOHLCV(e,t="1m",i,s=1e3,r={}){await this.loadMarkets();const a=this.market(e),o={symbol:a.id,period:this.timeframes[t]};void 0!==s&&(o.size=s);const n=await this.publicGetHistoryKline(this.extend(o,r));return this.parseOHLCVs(n.data.kline_data,a,t,i,s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetUserBalance(e),i=this.safeValue(t,"data"),s={info:t};for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"coin"),a=this.safeCurrencyCode(r),o=this.account();o.used=this.safeFloat(t,"lock"),o.free=this.safeFloat(t,"normal"),s[a]=o}return this.parseBalance(s)}async fetchOrderTrades(e,t,i,s,r={}){if(void 0===t)throw new a(this.id+" fetchOrderTrades requires a symbol argument");await this.loadMarkets();const o=this.market(t),n={symbol:o.id,order_id:e},d=await this.v2GetOrderMakeDetail(this.extend(n,r));return this.parseTrades(d.data,o,i,s)}async fetchOrdersByStatusV1(e,t,i,s,r={}){if(void 0===t)throw new a(this.id+" fetchOrders requires a symbol argument");await this.loadMarkets();const o=this.market(t);void 0===s&&(s=100);const n="open"===e?"privateGetOrderNew":"privateGetOrderHistory",d={symbol:o.id,offset:1,limit:s},c=(await this[n](this.extend(d,r))).data.list,h=[];for(let t=0;t<c.length;t++){const i=this.extend(c[t],{status:e});h.push(this.parseOrder(i,o))}return h}async fetchOpenOrdersV1(e,t,i,s={}){return await this.fetchOrdersByStatusV1("open",e,t,i,s)}async fetchOrdersV1(e,t,i,s={}){return await this.fetchOrdersByStatusV1(void 0,e,t,i,s)}async fetchOrdersByStatesV2(e,t,i,s,r={}){if(void 0===t)throw new a(this.id+" fetchOrders requires a symbol argument");await this.loadMarkets();const o=this.market(t);void 0===s&&(s=50);const n={symbol:o.id,states:e,direct:"next",size:s},d=await this.v2GetOrderOrders(this.extend(n,r));return this.parseOrders(d.data,o,i,s)}async fetchOrders(e,t,i,s={}){return await this.fetchOrdersByStatesV2("new,part_filled,filled,canceled,expired",e,t,i,s)}async fetchOpenOrders(e,t,i,s={}){return await this.fetchOrdersByStatesV2("new,part_filled",e,t,i,s)}async fetchClosedOrders(e,t,i,s={}){return await this.fetchOrdersByStatesV2("filled,canceled",e,t,i,s)}async fetchOrder(e,t,i={}){if(void 0===t)throw new a(this.id+" fetchOrder requires a symbol argument");await this.loadMarkets();const s=this.market(t),r={symbol:s.id,order_id:e.toString()},o=await this.v2GetOrderDetails(this.extend(r,i));return this.parseOrder(o.data,s)}parseOrderStatus(e){return this.safeString({0:"open",1:"open",2:"closed",3:"open",4:"canceled",6:"error"},e,e)}parseOrder(e,t){const i=this.safeString(e,"id");let s=this.safeStringLower(e,"side"),r=void 0;const a=this.safeString(e,"type");let o=this.parseOrderStatus(this.safeString(e,"status"));const n=this.safeInteger2(e,"created_at","ctime"),d=this.safeInteger2(e,"mtime","finished-at");let c=void 0;if(void 0===t){const i=this.safeString(e,"symbol");i in this.markets_by_id&&(t=this.markets_by_id[i])}void 0!==t&&(c=t.symbol);let h=void 0,l=void 0,u=void 0,f=void 0,p=void 0,m=void 0,y=void 0;if(void 0!==s)l=this.safeFloat(e.volume,"amount"),h="remain_volume"in e?this.safeFloat(e.remain_volume,"amount"):void 0,u="deal_volume"in e?this.safeFloat(e.deal_volume,"amount"):void 0,f="price"in e?this.safeFloat(e.price,"amount"):void 0,y="age_price"in e?this.safeFloat(e.age_price,"amount"):void 0;else if(void 0!==a){const i=a.split("-");s=i[0],r=i[1],p=this.safeFloat(e,"deal_money"),f=this.safeFloat(e,"price"),y=this.safeFloat(e,"avg_price"),l=this.safeFloat2(e,"amount","volume"),u=this.safeFloat(e,"deal_volume");const o=this.safeFloat(e,"fee");if(void 0!==o){let e=void 0;void 0!==t&&("buy"===s?e=t.base:"sell"===s&&(e=t.quote)),m={cost:o,currency:e}}}return void 0!==l&&(void 0!==h?void 0===u&&(u=Math.max(0,l-h)):void 0!==u&&(p=u*f,void 0===h&&(h=Math.max(0,l-u)))),void 0===o&&void 0!==h&&0===h&&(o="closed"),{info:e,id:i,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:d,symbol:c,type:r,side:s,price:f,average:y,cost:p,amount:l,filled:u,remaining:h,status:o,fee:m,trades:void 0}}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets(),this.checkRequiredCredentials();const o="limit"===t?1:2,n={symbol:this.market(e).id,side:i.toUpperCase(),type:o,volume:this.amountToPrecision(e,s)};if("market"===t&&"buy"===i){if(void 0===r)throw new c(this.id+" createOrder requires price argument for market buy orders to calculate total cost according to exchange rules");n.volume=this.amountToPrecision(e,parseFloat(s)*parseFloat(r))}n.price="limit"===t?this.priceToPrecision(e,r):void 0===r?this.priceToPrecision(e,0):this.priceToPrecision(e,r);const d=await this.v2PostOrder(this.extend(n,a)),h=this.milliseconds();return{info:d,id:this.safeString(d.data,"order_id"),timestamp:h,datetime:this.iso8601(h),lastTradeTimestamp:void 0,status:void 0,symbol:e,type:t,side:i,price:r,amount:s,filled:void 0,remaining:void 0,cost:void 0,trades:void 0,fee:void 0}}async cancelOrder(e,t,i={}){if(await this.loadMarkets(),void 0===t)throw new a(this.id+" cancelOrder requires a symbol argument");const s={symbol:this.market(t).id,order_id:e};return{id:e,symbol:t,info:await this.privateDeleteOrder(this.extend(s,i))}}async cancelOrders(e,t,i={}){if(await this.loadMarkets(),void 0===t)throw new a(this.id+" cancelOrders requires a symbol argument");const s={};s[this.market(t).id]=e;const r={orderIdList:this.json(s)};return{info:await this.v2PostOrderBatchCancel(this.extend(r,i))}}sign(e,t="public",i="GET",s={},r,a){this.checkRequiredCredentials();let o=this.implodeParams(this.urls.api[t],{hostname:this.hostname});if(o+="/"+this.implodeParams(e,s),"private"===t||"v2"===t){const e=this.milliseconds().toString(),t=this.keysort(this.extend({time:e},s)),n=Object.keys(t);let d="";for(let e=0;e<n.length;e++)d+=n[e]+t[n[e]].toString();d+=this.secret;const c=this.hmac(this.encode(d),this.encode(this.secret),"sha512"),h="POST"===i?{}:t;o+="?"+this.urlencode(this.keysort(this.extend({api_key:this.apiKey,time:e},h))),o+="&sign="+c,"POST"===i&&(a=this.urlencode(t),r={"Content-Type":"application/x-www-form-urlencoded"})}else"public"===t||"v2public"===t?o+="?"+this.urlencode(this.extend({api_key:this.apiKey},s)):Object.keys(s).length&&(o+="?"+this.urlencode(s));return{url:o,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,n,u,f,p){if(void 0!==u&&"code"in u){const e=this.safeString(u,"code");if(void 0!==e){const t=this.safeString(u,"msg"),i=this.id+" "+this.json(u);if("0"!==e){const s=this.exceptions;if(e in s){if("1"===e){if(t.indexOf("Balance insufficient")>=0)throw new h(i)}else if("2"===e){if("offsetNot Null"===t)throw new r(i);if("api_keyNot EXIST"===t)throw new d(i);if("price precision exceed the limit"===t)throw new c(i);if("Parameter error"===t)throw new o(i)}throw new s[e](i)}throw new r(this.id+' unknown "error" value: '+this.json(u))}if(i.indexOf(",")>=0)throw i.indexOf("Parameter error")>=0?new l(i):new c(i);if(i.indexOf(",")>=0)throw new l(i)}}}}},function(e,t,i){"use strict";const s=i(13);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"coolcoin",name:"CoolCoin",countries:["HK"],urls:{logo:"https://user-images.githubusercontent.com/1294454/36770529-be7b1a04-1c5b-11e8-9600-d11f1996b539.jpg",api:{web:"https://www.coolcoin.com/coin",rest:"https://www.coolcoin.com/api/v1"},www:"https://www.coolcoin.com",doc:"https://www.coolcoin.com/help.api.html",fees:"https://www.coolcoin.com/spend.price.html",referral:"https://www.coolcoin.com/user/register?invite_code=bhaega"},fees:{trading:{maker:.001,taker:.001},funding:{withdraw:{BTC:.001,BCH:.002,ETH:.01,ETC:.01,LTC:.001,TBC:"1%",HSR:"1%",NEO:"1%",SDC:"1%",EOS:"1%",BTM:"1%",XAS:"1%",ACT:"1%",SAK:"1%",GCS:"1%",HCC:"1%",QTUM:"1%",GEC:"1%",TRX:"1%",IFC:"1%",PAY:"1%",PGC:"1%",KTC:"1%",INT:"1%",LSK:"0.5%",SKT:"1%",SSS:"1%",BT1:"1%",BT2:"1%"}}},options:{quoteIds:["btc","usdt"]}})}}},function(e,t,i){"use strict";const s=i(1),{ArgumentsRequired:r}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"coss",name:"COSS",countries:["SG","NL"],rateLimit:1e3,version:"v1",certified:!0,urls:{logo:"https://user-images.githubusercontent.com/1294454/50328158-22e53c00-0503-11e9-825c-c5cfd79bfa74.jpg",api:{trade:"https://trade.coss.io/c/api/v1",engine:"https://engine.coss.io/api/v1",public:"https://trade.coss.io/c/api/v1",web:"https://trade.coss.io/c",exchange:"https://exchange.coss.io/api"},www:"https://www.coss.io",doc:"https://api.coss.io/v1/spec",referral:"https://www.coss.io/c/reg?r=OWCMHQVW2Q"},has:{fetchTrades:!0,fetchTicker:!0,fetchTickers:!0,fetchMarkets:!0,fetchCurrencies:!0,fetchBalance:!0,fetchOrderBook:!0,fetchOrder:!0,fetchOrders:!0,fetchOrderTrades:!0,fetchClosedOrders:!0,fetchOpenOrders:!0,fetchOHLCV:!0,createOrder:!0,cancelOrder:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","12h":"12h","1d":"1d","1w":"1w"},api:{exchange:{get:["getmarketsummaries"]},public:{get:["market-price","exchange-info"]},web:{get:["coins/getinfo/all","order/symbols","coins/get_base_list"]},engine:{get:["dp","ht","cs"]},trade:{get:["ping","time","account/balances","account/details"],post:["order/add","order/details","order/list/open","order/list/completed","order/list/all","order/trade-detail"],delete:["order/cancel"]}},fees:{trading:{tierBased:!0,percentage:!0,taker:.0025,maker:0},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{}}}})}async fetchMarkets(e={}){const t=await this.publicGetExchangeInfo(e),i=[],s=this.safeValue(t,"symbols",[]),r=this.safeValue(t,"base_currencies",[]),a=this.indexBy(r,"currency_code"),o=this.safeValue(t,"coins",[]),n=this.indexBy(o,"currency_code");for(let e=0;e<s.length;e++){const t=s[e],r=t.symbol,[o,d]=r.split("_"),c=this.safeCurrencyCode(o),h=this.safeCurrencyCode(d),l=c+"/"+h,u={amount:this.safeInteger(t,"amount_limit_decimal"),price:this.safeInteger(t,"price_limit_decimal")},f=this.safeValue(t,"allow_trading",!1),p=this.safeValue(a,o,{}),m=this.safeFloat(p,"minimum_total_order"),y=this.safeValue(n,o,{}),b=Math.pow(10,-u.amount),v=this.safeFloat(y,"minimum_order_amount",b);i.push({symbol:l,id:r,baseId:o,quoteId:d,base:c,quote:h,active:f,precision:u,limits:{amount:{min:v,max:void 0},price:{min:void 0,max:void 0},cost:{min:m,max:void 0}},info:t})}return i}async fetchCurrencies(e={}){const t=await this.webGetCoinsGetinfoAll(e),i={};for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"currency_code"),a=this.safeCurrencyCode(r),o=this.safeString(s,"name"),n=this.safeValue(s,"allow_buy"),d=this.safeValue(s,"allow_sell"),c=this.safeValue(s,"allow_withdrawn"),h=this.safeValue(s,"allow_deposit"),l=n&&d&&c&&h,u=this.safeFloat(s,"withdrawn_fee"),f=this.safeString(s,"token_type"),p=this.safeString(s,"decimal_format");let m=8;if(void 0!==p){const e=p.split(".");e.length>1&&e[1].length>1&&(m=e[1].length)}i[a]={id:r,code:a,info:s,name:o,active:l,fee:u,precision:m,type:f,limits:{amount:{min:this.safeFloat(s,"minimum_order_amount"),max:void 0},withdraw:{min:this.safeFloat(s,"minimum_withdrawn_amount"),max:void 0}}}}return i}async fetchBalance(e={}){await this.loadMarkets();const t=await this.tradeGetAccountBalances(e),i={};for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"currency_code"),a=this.safeCurrencyCode(r),o=this.safeFloat(s,"total"),n=this.safeFloat(s,"in_order"),d=this.safeFloat(s,"available");i[a]={total:o,used:n,free:d}}return this.parseBalance(i)}parseOHLCV(e,t,i="1m",s,r){return[parseInt(e[0]),parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3]),parseFloat(e[4]),parseFloat(e[5])]}async fetchOHLCV(e,t="1m",i,s,r={}){await this.loadMarkets();const a=this.market(e),o={symbol:a.id,tt:this.timeframes[t]},n=await this.engineGetCs(this.extend(o,r));return this.parseOHLCVs(n.series,a,t,i,s)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={symbol:this.marketId(e)},r=await this.engineGetDp(this.extend(s,i)),a=this.safeInteger(r,"time");return this.parseOrderBook(r,a)}parseTicker(e,t){const i=this.parse8601(this.safeString(e,"TimeStamp"));let s=void 0,r=this.safeString(e,"MarketName");if(void 0!==r&&(r=r.replace("-","_")),void 0===(t=this.safeValue(this.markets_by_id,r,t))&&void 0!==r){const[e,t]=r.split("_");s=this.safeCurrencyCode(e)+"/"+this.safeCurrencyCode(t)}void 0!==t&&(s=t.symbol);const a=this.safeFloat(e,"PrevDay"),o=this.safeFloat(e,"Last");let n=void 0,d=void 0;return void 0!==o&&void 0!==a&&(n=o-a,a>0&&(d=n/a*100)),{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"High"),low:this.safeFloat(e,"Low"),bid:this.safeFloat(e,"Bid"),bidVolume:void 0,ask:this.safeFloat(e,"Ask"),askVolume:void 0,vwap:void 0,open:a,close:o,last:o,previousClose:void 0,change:n,percentage:d,average:void 0,baseVolume:this.safeFloat(e,"Volume"),quoteVolume:this.safeFloat(e,"BaseVolume"),info:e}}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.exchangeGetGetmarketsummaries(t),s=this.safeValue(i,"result",[]),r={};for(let e=0;e<s.length;e++){const t=this.parseTicker(s[e]);r[t.symbol]=t}return r}async fetchTicker(e,t={}){return(await this.fetchTickers([e],t))[e]}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id},o=await this.engineGetHt(this.extend(a,s));return this.parseTrades(o.history,r,t,i)}parseTradeFee(e){if(void 0===e)return e;const t=e.split(" "),i=t.length,s=t[0];let r=void 0;return i>1&&(r=this.safeCurrencyCode(t[1])),{cost:s,currency:r}}parseTrade(e,t){const i=this.safeString(e,"id"),s=this.safeInteger(e,"time"),r=this.safeString(e,"order_id"),a=this.safeStringLower(e,"order_side");let o=void 0;const n=this.safeString(e,"symbol");if(void 0!==n){if(void 0===(t=this.safeValue(this.markets_by_id,n,t))){const[e,t]=n.split("_");o=this.safeCurrencyCode(e)+"/"+this.safeCurrencyCode(t)}}else void 0!==t&&(o=t.symbol);let d=void 0;const c=this.safeFloat(e,"price"),h=this.safeFloat2(e,"qty","quantity");void 0!==h&&void 0!==c&&(d=c*h);const l={id:i,info:e,timestamp:s,datetime:this.iso8601(s),symbol:o,order:r,type:void 0,side:a,takerOrMaker:void 0,price:c,amount:h,cost:d,fee:void 0},u=this.parseTradeFee(this.safeString(e,"fee"));if(void 0!==u){const t=this.parseTradeFee(this.safeString(e,"additional_fee"));void 0===t?l.fee=u:l.fees=[u,t]}return l}async fetchOrdersByType(e,t,i,s,a={}){if(void 0===t)throw new r(this.id+" fetchOrders requires a symbol argument");await this.loadMarkets();const o=this.market(t),n={symbol:o.id};void 0!==s&&(n.limit=s);const d="tradePostOrderList"+e,c=await this[d](this.extend(n,a));let h=void 0;return h=Array.isArray(c)?c:this.safeValue(c,"list",[]),this.parseOrders(h,o,i,s)}async fetchOrders(e,t,i,s={}){return await this.fetchOrdersByType("All",e,t,i,s)}async fetchClosedOrders(e,t,i,s={}){return await this.fetchOrdersByType("Completed",e,t,i,s)}async fetchOpenOrders(e,t,i,s={}){return await this.fetchOrdersByType("Open",e,t,i,s)}async fetchOrder(e,t,i={}){await this.loadMarkets();const s={order_id:e},r=await this.tradePostOrderDetails(this.extend(s,i));return this.parseOrder(r)}async fetchOrderTrades(e,t,i,s,r={}){await this.loadMarkets();let a=void 0;void 0!==t&&(a=this.market(t));const o={order_id:e},n=await this.tradePostOrderTradeDetail(this.extend(o,r));return this.parseTrades(n,a,i,s)}parseOrderStatus(e){if(void 0===e)return e;return this.safeString({OPEN:"open",CANCELLED:"canceled",FILLED:"closed",PARTIAL_FILL:"closed",CANCELLING:"open"},e.toUpperCase(),e)}parseOrder(e,t){const i=this.safeString(e,"order_id");let s=void 0,r=this.safeString(e,"order_symbol");if(void 0===r)void 0!==t&&(s=t.symbol);else if(r=(r=r.toUpperCase()).replace("-","_"),void 0===(t=this.safeValue(this.markets_by_id,r,t))){const[e,t]=r.split("_");s=this.safeCurrencyCode(e)+"/"+this.safeCurrencyCode(t)}else s=t.symbol;const a=this.safeInteger(e,"createTime"),o=this.parseOrderStatus(this.safeString(e,"status")),n=this.safeFloat(e,"order_price"),d=this.safeFloat(e,"executed"),c=this.safeString(e,"type"),h=this.safeFloat(e,"order_size");let l=void 0;void 0!==h&&void 0!==d&&(l=h-d);const u=this.safeFloat(e,"avg"),f=this.safeStringLower(e,"order_side"),p=this.safeFloat(e,"total");return{info:e,id:i,timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:void 0,symbol:s,type:c,side:f,price:n,amount:h,cost:p,average:u,filled:d,remaining:l,status:o,fee:void 0,trades:void 0}}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o=this.market(e),n={order_symbol:o.id,order_size:this.amountToPrecision(e,s),order_side:i.toUpperCase(),type:t};void 0!==r&&(n.order_price=this.priceToPrecision(e,r));const d=await this.tradePostOrderAdd(this.extend(n,a));return this.parseOrder(d,o)}async cancelOrder(e,t,i={}){if(void 0===t)throw new r(this.id+" cancelOrder requires a symbol argument");await this.loadMarkets();const s={order_id:e,order_symbol:this.market(t).id},a=await this.tradeDeleteOrderCancel(this.extend(s,i));return this.parseOrder(a)}nonce(){return this.milliseconds()}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api[t]+"/"+e;if("trade"===t){this.checkRequiredCredentials();const e=this.nonce(),t=this.extend({timestamp:e},s);let n=void 0;"GET"===i?o+="?"+(n=this.urlencode(t)):a=n=this.json(t),r={Signature:this.hmac(this.encode(n),this.encode(this.secret)),Authorization:this.apiKey}}else Object.keys(s).length&&(o+="?"+this.urlencode(s));return{url:o,method:i,body:a,headers:r}}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,BadRequest:a,InvalidNonce:o,RequestTimeout:n,ExchangeNotAvailable:d,InsufficientFunds:c,OrderNotFound:h,InvalidOrder:l,DDoSProtection:u,AuthenticationError:f,BadSymbol:p}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"crex24",name:"CREX24",countries:["EE"],rateLimit:500,version:"v2",has:{cancelAllOrders:!0,CORS:!1,editOrder:!0,fetchBidsAsks:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingFees:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrders:!0,fetchOrderTrades:!0,fetchTickers:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactions:!0,fetchWithdrawals:!0,withdraw:!0},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","4h":"4h","1d":"1d","1w":"1w","1M":"1mo"},urls:{logo:"https://user-images.githubusercontent.com/1294454/47813922-6f12cc00-dd5d-11e8-97c6-70f957712d47.jpg",api:"https://api.crex24.com",www:"https://crex24.com",referral:"https://crex24.com/?refid=slxsjsjtil8xexl9hksr",doc:"https://docs.crex24.com/trade-api/v2",fees:"https://crex24.com/fees"},api:{public:{get:["currencies","instruments","tickers","recentTrades","orderBook","ohlcv"]},trading:{get:["orderStatus","orderTrades","activeOrders","orderHistory","tradeHistory","tradeFee","moneyTransferStatus"],post:["placeOrder","modifyOrder","cancelOrdersById","cancelOrdersByInstrument","cancelAllOrders"]},account:{get:["balance","depositAddress","moneyTransfers","moneyTransferStatus","previewWithdrawal"],post:["withdraw"]}},fees:{trading:{tierBased:!0,percentage:!0,taker:.001,maker:-1e-4},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{}}},commonCurrencies:{YOYO:"YOYOW",BCC:"BCH"},options:{fetchOrdersMethod:"tradingGetOrderHistory",fetchClosedOrdersMethod:"tradingGetOrderHistory",fetchTickersMethod:"publicGetTicker24hr",defaultTimeInForce:"GTC",defaultLimitOrderType:"limit",hasAlreadyAuthenticatedSuccessfully:!1,warnOnFetchOpenOrdersWithoutSymbol:!0,parseOrderToPrecision:!1,newOrderRespType:"RESULT"},exceptions:{exact:{"Parameter 'filter' contains invalid value.":a,"Mandatory parameter 'instrument' is missing.":a,"The value of parameter 'till' must be greater than or equal to the value of parameter 'from'.":a,"Failed to verify request signature.":f,"Nonce error. Make sure that the value passed in the 'X-CREX24-API-NONCE' header is greater in each consecutive request than in the previous one for the corresponding API-Key provided in 'X-CREX24-API-KEY' header.":o,"Market orders are not supported by the instrument currently.":l},broad:{"API Key":f,"Insufficient funds":c,"has been delisted.":p}}})}nonce(){return this.milliseconds()}async fetchMarkets(e={}){const t=await this.publicGetInstruments(e),i=[];for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"symbol"),a=this.safeString(s,"baseCurrency"),o=this.safeString(s,"quoteCurrency"),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o),c=n+"/"+d,h=this.safeValue(s,"tickSize"),l=this.safeValue(s,"minPrice"),u=this.safeFloat(s,"minVolume"),f={amount:this.precisionFromString(this.numberToString(u)),price:this.precisionFromString(this.numberToString(h))},p="active"===s.state;i.push({id:r,symbol:c,base:n,quote:d,baseId:a,quoteId:o,info:s,active:p,precision:f,limits:{amount:{min:u,max:void 0},price:{min:l,max:void 0},cost:{min:void 0,max:void 0}}})}return i}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),i={};for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"symbol"),a=this.safeCurrencyCode(r),o=this.safeInteger(s,"withdrawalPrecision"),n=this.safeValue(s,"BaseAddress"),d=s.depositsAllowed&&s.withdrawalsAllowed&&!s.isDelisted,c=s.isFiat?"fiat":"crypto";i[a]={id:r,code:a,address:n,info:s,type:c,name:this.safeString(s,"name"),active:d,fee:this.safeFloat(s,"flatWithdrawalFee"),precision:o,limits:{amount:{min:Math.pow(10,-o),max:Math.pow(10,o)},price:{min:Math.pow(10,-o),max:Math.pow(10,o)},cost:{min:void 0,max:void 0},deposit:{min:this.safeFloat(s,"minDeposit"),max:void 0},withdraw:{min:this.safeFloat(s,"minWithdrawal"),max:this.safeFloat(s,"maxWithdrawal")}}}}return i}async fetchBalance(e={}){await this.loadMarkets();const t=await this.accountGetBalance(this.extend({},e)),i={info:t};for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeFloat(s,"available"),o.used=this.safeFloat(s,"reserved"),i[a]=o}return this.parseBalance(i)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={instrument:this.market(e).id};void 0!==t&&(s.limit=t);const r=await this.publicGetOrderBook(this.extend(s,i));return this.parseOrderBook(r,void 0,"buyLevels","sellLevels","price","volume")}parseTicker(e,t){const i=this.parse8601(this.safeString(e,"timestamp"));let s=void 0;const r=this.safeString(e,"instrument");if(void 0!==(t=this.safeValue(this.markets_by_id,r,t)))s=t.symbol;else if(void 0!==r){const[e,t]=r.split("-");s=this.safeCurrencyCode(e)+"/"+this.safeCurrencyCode(t)}const a=this.safeFloat(e,"last");return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"bid"),bidVolume:void 0,ask:this.safeFloat(e,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:void 0,percentage:this.safeFloat(e,"percentChange"),average:void 0,baseVolume:this.safeFloat(e,"baseVolume"),quoteVolume:this.safeFloat(e,"quoteVolume"),info:e}}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={instrument:i.id},a=await this.publicGetTickers(this.extend(s,t));if(a.length<1)throw new r(this.id+" fetchTicker could not load quotes for symbol "+e);return this.parseTicker(a[0],i)}async fetchTickers(e,t={}){await this.loadMarkets();const i={};if(void 0!==e){const t=this.marketIds(e);i.instrument=t.join(",")}const s=await this.publicGetTickers(this.extend(i,t));return this.parseTickers(s,e)}parseTickers(e,t){const i=[];for(let t=0;t<e.length;t++)i.push(this.parseTicker(e[t]));return this.filterByArray(i,"symbol",t)}parseTrade(e,t){const i=this.parse8601(this.safeString(e,"timestamp")),s=this.safeFloat(e,"price"),r=this.safeFloat(e,"volume");let a=void 0;void 0!==s&&void 0!==r&&(a=r*s);const o=this.safeString(e,"id"),n=this.safeString(e,"side"),d=this.safeString(e,"orderId");let c=void 0;const h=this.safeString(e,"instrument");void 0!==(t=this.safeValue(this.markets_by_id,h,t))&&(c=t.symbol);let l=void 0;const u=this.safeString(e,"feeCurrency"),f=this.safeCurrencyCode(u),p=this.safeFloat(e,"fee");void 0!==p&&(l={cost:p,currency:f});return{info:e,timestamp:i,datetime:this.iso8601(i),symbol:c,id:o,order:d,type:void 0,takerOrMaker:void 0,side:n,price:s,cost:a,amount:r,fee:l}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={instrument:r.id};void 0!==i&&(a.limit=i);const o=await this.publicGetRecentTrades(this.extend(a,s));return this.parseTrades(o,r,t,i)}parseOHLCV(e,t,i="1m",s,r){const a=this.safeString(e,"timestamp");return[this.parse8601(a),this.safeFloat(e,"open"),this.safeFloat(e,"high"),this.safeFloat(e,"low"),this.safeFloat(e,"close"),this.safeFloat(e,"volume")]}async fetchOHLCV(e,t="1m",i,s,r={}){await this.loadMarkets();const a=this.market(e),o={granularity:this.timeframes[t],instrument:a.id};void 0!==s&&(o.limit=s);const n=await this.publicGetOhlcv(this.extend(o,r));return this.parseOHLCVs(n,a,t,i,s)}parseOrderStatus(e){const t={submitting:"open",unfilledActive:"open",partiallyFilledActive:"open",filled:"closed",partiallyFilledCancelled:"canceled",unfilledCancelled:"canceled"};return e in t?t[e]:e}parseOrder(e,t){const i=this.parseOrderStatus(this.safeString(e,"status")),s=this.findSymbol(this.safeString(e,"instrument"),t),r=this.parse8601(this.safeString(e,"timestamp"));let a=this.safeFloat(e,"price");const o=this.safeFloat(e,"volume"),n=this.safeFloat(e,"remainingVolume");let d=void 0;const c=this.parse8601(this.safeString(e,"lastUpdate"));let h=void 0;void 0!==n&&void 0!==o&&(d=o-n,this.options.parseOrderToPrecision&&(d=parseFloat(this.amountToPrecision(s,d))),d=Math.max(d,0),void 0!==a&&(h=a*d));const l=this.safeString(e,"id"),u=this.safeString(e,"type");"market"===u&&0===a&&void 0!==h&&void 0!==d&&h>0&&d>0&&(a=h/d);const f=this.safeString(e,"side");let p=void 0;return void 0!==h&&(d&&(p=h/d),this.options.parseOrderToPrecision&&(h=parseFloat(this.costToPrecision(s,h)))),{info:e,id:l,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:c,symbol:s,type:u,side:f,price:a,amount:o,cost:h,average:p,filled:d,remaining:n,status:i,fee:void 0,trades:void 0}}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o=this.market(e),n={instrument:o.id,volume:this.amountToPrecision(e,s),type:t,side:i};let d=!1,c=!1;if("limit"===t?d=!0:"stopLimit"===t&&(d=!0,c=!0),d){if(void 0===r)throw new l(this.id+" createOrder method requires a price argument for a "+t+" order");n.price=this.priceToPrecision(e,r)}if(c){const i=this.safeFloat(a,"stopPrice");if(void 0===i)throw new l(this.id+" createOrder method requires a stopPrice extra param for a "+t+" order");n.stopPrice=this.priceToPrecision(e,i)}const h=await this.tradingPostPlaceOrder(this.extend(n,a));return this.parseOrder(h,o)}async fetchOrder(e,t,i={}){await this.loadMarkets();const s={id:e},r=await this.tradingGetOrderStatus(this.extend(s,i));if(r.length<1)throw new h(this.id+" fetchOrder could not fetch order id "+e);return this.parseOrder(r[0])}async fetchOrders(e,t,i,s={}){await this.loadMarkets();const r={};if(void 0!==t&&(r.from=this.ymdhms(t,"T")),void 0!==i&&(r.limit=i),void 0!==e){const t=this.market(e);r.instrument=t.id}const a=this.safeString(this.options,"fetchOrdersMethod","tradingGetOrderHistory"),o=await this[a](this.extend(r,s));return this.parseOrders(o)}async fetchOrdersByIds(e,t,i,s={}){await this.loadMarkets();const r={id:e.join(",")},a=await this.tradingGetOrderStatus(this.extend(r,s));return this.parseOrders(a,void 0,t,i)}async fetchOpenOrders(e,t,i,s={}){await this.loadMarkets();let r=void 0;const a={};void 0!==e&&(r=this.market(e),a.instrument=r.id);const o=await this.tradingGetActiveOrders(this.extend(a,s));return this.parseOrders(o,r,t,i)}async fetchClosedOrders(e,t,i,s={}){await this.loadMarkets();let r=void 0;const a={};void 0!==e&&(r=this.market(e),a.instrument=r.id),void 0!==t&&(a.from=this.ymdhms(t,"T")),void 0!==i&&(a.limit=i);const o=this.safeString(this.options,"fetchClosedOrdersMethod","tradingGetOrderHistory"),n=await this[o](this.extend(a,s));return this.parseOrders(n,r,t,i)}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={ids:[parseInt(e)]},r=await this.tradingPostCancelOrdersById(this.extend(s,i));return this.parseOrder(r)}async cancelAllOrders(e,t={}){return await this.tradingPostCancelAllOrders(t)}async fetchMyTrades(e,t,i,s={}){await this.loadMarkets();let r=void 0;const a={};void 0!==e&&(r=this.market(e),a.instrument=r.id),void 0!==t&&(a.from=this.ymdhms(t,"T")),void 0!==i&&(a.limit=i);const o=await this.tradingGetTradeHistory(this.extend(a,s));return this.parseTrades(o,r,t,i)}async fetchTransactions(e,t,i,s={}){await this.loadMarkets();let r=void 0;const a={};void 0!==e&&(r=this.currency(e),a.currency=r.id),void 0!==t&&(a.from=this.ymd(t,"T"));const o=await this.accountGetMoneyTransfers(this.extend(a,s));return this.parseTransactions(o,r,t,i)}async fetchDeposits(e,t,i,s={}){return this.fetchTransactions(e,t,i,this.extend({type:"deposit"},s))}async fetchWithdrawals(e,t,i,s={}){return this.fetchTransactions(e,t,i,this.extend({type:"withdrawal"},s))}parseTransactionStatus(e){return this.safeString({pending:"pending",success:"ok",failed:"failed"},e,e)}parseTransaction(e,t){const i=this.safeString(e,"id"),s=this.safeString(e,"address"),r=this.safeString(e,"paymentId"),a=this.safeValue(e,"txId"),o=this.safeString(e,"currency"),n=this.safeCurrencyCode(o,t),d=this.safeString(e,"type"),c=this.parse8601(this.safeString(e,"createdAt")),h=this.parse8601(this.safeString(e,"processedAt")),l=this.parseTransactionStatus(this.safeString(e,"status")),u=this.safeFloat(e,"amount"),f={cost:this.safeFloat(e,"fee"),currency:n};return{info:e,id:i,txid:a,timestamp:c,datetime:this.iso8601(c),address:s,tag:r,type:d,amount:u,currency:n,status:l,updated:h,fee:f}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},s=await this.accountGetDepositAddress(this.extend(i,t)),r=this.safeString(s,"address"),a=this.safeString(s,"paymentId");return{currency:e,address:this.checkAddress(r),tag:a,info:s}}async withdraw(e,t,i,s,r={}){this.checkAddress(i),await this.loadMarkets();const a={currency:this.currency(e).id,address:i,amount:parseFloat(this.currencyToPrecision(e,t))};void 0!==s&&(a.paymentId=s);const o=await this.accountPostWithdraw(this.extend(a,r));return this.parseTransaction(o)}sign(e,t="public",i="GET",s={},r,a){let o="/"+this.version+"/"+t+"/"+this.implodeParams(e,s);const n=this.omit(s,this.extractParams(e));"GET"===i&&Object.keys(n).length&&(o+="?"+this.urlencode(n));const d=this.urls.api+o;if("trading"===t||"account"===t){this.checkRequiredCredentials();const e=this.nonce().toString(),t=this.base64ToBinary(this.secret);let n=o+e;r={"X-CREX24-API-KEY":this.apiKey,"X-CREX24-API-NONCE":e},"POST"===i&&(r["Content-Type"]="application/json",n+=a=this.json(s));const d=this.stringToBase64(this.hmac(this.encode(n),t,"sha512","binary"));r["X-CREX24-API-SIGN"]=this.decode(d)}return{url:d,method:i,body:a,headers:r}}handleErrors(e,t,i,s,o,c,h,l,p){if(!this.isJsonEncodedObject(c))return;if(e>=200&&e<300)return;const m=this.safeString(h,"errorDescription"),y=this.id+" "+this.json(h),b=this.exceptions.exact;if(m in b)throw new b[m](y);const v=this.exceptions.broad,g=this.findBroadlyMatchedKey(v,m);if(void 0!==g)throw new v[g](y);if(400===e)throw new a(y);if(401===e)throw new f(y);if(403===e)throw new f(y);if(429===e)throw new u(y);if(500===e)throw new r(y);if(503===e)throw new d(y);if(504===e)throw new n(y);throw new r(y)}}},function(e,t,i){"use strict";const s=i(1),{TICK_SIZE:r}=i(2),{AuthenticationError:a,ExchangeError:o,ArgumentsRequired:n,PermissionDenied:d,InvalidOrder:c,OrderNotFound:h,DDoSProtection:l,NotSupported:u,ExchangeNotAvailable:f,InsufficientFunds:p}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"deribit",name:"Deribit",countries:["NL"],version:"v1",userAgent:void 0,rateLimit:2e3,has:{CORS:!0,editOrder:!0,fetchOrder:!0,fetchOrders:!1,fetchOpenOrders:!0,fetchClosedOrders:!0,fetchMyTrades:!0,fetchTickers:!1},urls:{test:"https://test.deribit.com",logo:"https://user-images.githubusercontent.com/1294454/41933112-9e2dd65a-798b-11e8-8440-5bab2959fcb8.jpg",api:"https://www.deribit.com",www:"https://www.deribit.com",doc:["https://docs.deribit.com","https://github.com/deribit"],fees:"https://www.deribit.com/pages/information/fees",referral:"https://www.deribit.com/reg-1189.4038"},api:{public:{get:["ping","test","getinstruments","index","getcurrencies","getorderbook","getlasttrades","getsummary","stats","getannouncments"]},private:{get:["account","getopenorders","positions","orderhistory","orderstate","tradehistory","newannouncements"],post:["buy","sell","edit","cancel","cancelall"]}},exceptions:{9999:d,10000:a,10001:o,10002:c,10003:c,10004:h,10005:c,10006:c,10007:c,10008:c,10009:p,10010:h,10011:c,10012:c,10013:d,10014:d,10015:d,10016:d,10017:d,10019:d,10020:o,10022:c,10023:c,10024:c,10025:c,10026:c,10027:c,10028:l,10029:h,10030:o,10031:o,10032:c,10033:u,10034:c,10035:c,11035:c,11036:c,11037:c,11038:c,11039:c,11040:c,11041:c,11042:d,11044:h,11045:o,11046:o,11047:o,11048:o,11050:o,11051:f,11030:o,11031:o},precisionMode:r,options:{fetchTickerQuotes:!0}})}async fetchMarkets(e={}){const t=await this.publicGetGetinstruments(e),i=this.safeValue(t,"result"),s=[];for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"instrumentName"),a=this.safeString(t,"baseCurrency"),o=this.safeString(t,"currency"),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o),c=this.safeString(t,"kind"),h="future"===c,l="option"===c,u=this.safeValue(t,"isActive"),f={amount:this.safeFloat(t,"minTradeAmount"),price:this.safeFloat(t,"tickSize")};s.push({id:r,symbol:r,base:n,quote:d,active:u,precision:f,limits:{amount:{min:this.safeFloat(t,"minTradeAmount"),max:void 0},price:{min:this.safeFloat(t,"tickSize"),max:void 0},cost:{min:void 0,max:void 0}},type:c,spot:!1,future:h,option:l,info:t})}return s}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccount(e),i={info:t},s=this.safeValue(t,"result",{}),r=this.safeString(s,"currency"),a=this.safeCurrencyCode(r),o=this.account();return o.free=this.safeFloat(s,"availableFunds"),o.used=this.safeFloat(s,"maintenanceMargin"),o.total=this.safeFloat(s,"equity"),i[a]=o,this.parseBalance(i)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},s=await this.privateGetAccount(this.extend(i,t)),r=this.safeValue(s,"result",{});return{currency:e,address:this.safeString(r,"depositAddress"),tag:void 0,info:s}}parseTicker(e,t){const i=this.safeInteger(e,"created"),s=this.findSymbol(this.safeString(e,"instrumentName"),t),r=this.safeFloat(e,"last");return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"bidPrice"),bidVolume:void 0,ask:this.safeFloat(e,"askPrice"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:this.safeFloat(e,"volume"),info:e}}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={instrument:i.id},r=await this.publicGetGetsummary(this.extend(s,t));return this.parseTicker(r.result,i)}parseTrade(e,t){const i=this.safeString(e,"tradeId"),s=this.safeString(e,"orderId");let r=void 0;void 0!==t&&(r=t.symbol);const a=this.safeInteger(e,"timeStamp"),o=this.safeString2(e,"side","direction"),n=this.safeFloat(e,"price"),d=this.safeFloat(e,"quantity");let c=void 0;void 0!==d&&void 0!==n&&(c=d*n);let h=void 0;const l=this.safeFloat(e,"fee");if(void 0!==l){const t=this.safeString(e,"feeCurrency");h={cost:l,currency:this.safeCurrencyCode(t)}}return{id:i,info:e,timestamp:a,datetime:this.iso8601(a),symbol:r,order:s,type:void 0,side:o,takerOrMaker:void 0,price:n,amount:d,cost:c,fee:h}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={instrument:r.id};a.limit=void 0!==i?i:1e4;const o=await this.publicGetGetlasttrades(this.extend(a,s)),n=this.safeValue(o,"result",[]);return this.parseTrades(n,r,t,i)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={instrument:this.market(e).id},r=await this.publicGetGetorderbook(this.extend(s,i)),a=this.safeInteger(r,"usOut")/1e3,o=this.parseOrderBook(r.result,a,"bids","asks","price","quantity");return this.extend(o,{nonce:this.safeInteger(r,"tstamp")})}parseOrderStatus(e){return this.safeString({open:"open",cancelled:"canceled",filled:"closed"},e,e)}parseOrder(e,t){const i=this.safeInteger(e,"created"),s=this.safeInteger(e,"lastUpdate");let r=this.safeInteger2(e,"tstamp","modified");const a=this.safeString(e,"orderId"),o=this.safeFloat(e,"price"),n=this.safeFloat(e,"avgPrice"),d=this.safeFloat(e,"quantity"),c=this.safeFloat(e,"filledQuantity");void 0===r&&void 0!==c&&c>0&&(r=s);let h=void 0,l=void 0;void 0!==c&&(void 0!==d&&(h=d-c),void 0!==o&&(l=o*c));const u=this.parseOrderStatus(this.safeString(e,"state")),f=this.safeStringLower(e,"direction");let p=this.safeFloat(e,"commission");void 0!==p&&(p=Math.abs(p));const m={cost:p,currency:"BTC"},y=this.safeString(e,"type"),b=this.safeString(e,"instrument");let v=void 0;return b in this.markets_by_id&&(v=this.markets_by_id[b].symbol),{info:e,id:a,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:r,symbol:v,type:y,side:f,price:o,amount:d,cost:l,average:n,filled:c,remaining:h,status:u,fee:m,trades:void 0}}async fetchOrder(e,t,i={}){await this.loadMarkets();const s={orderId:e},r=await this.privateGetOrderstate(this.extend(s,i)),a=this.safeValue(r,"result");if(void 0===a)throw new h(this.id+" fetchOrder() "+this.json(r));return this.parseOrder(a)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o={instrument:this.marketId(e),quantity:s,type:t};void 0!==r&&(o.price=r);const n="privatePost"+this.capitalize(i),d=await this[n](this.extend(o,a)),c=this.safeValue(d.result,"order");return void 0===c?d:this.parseOrder(c)}async editOrder(e,t,i,s,r,a,o={}){await this.loadMarkets();const n={orderId:e};void 0!==r&&(n.quantity=r),void 0!==a&&(n.price=a);const d=await this.privatePostEdit(this.extend(n,o));return this.parseOrder(d.result.order)}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={orderId:e},r=await this.privatePostCancel(this.extend(s,i));return this.parseOrder(r.result.order)}async fetchOpenOrders(e,t,i,s={}){if(void 0===e)throw new n(this.id+" fetchClosedOrders() requires a `symbol` argument");await this.loadMarkets();const r=this.market(e),a={instrument:r.id},o=await this.privateGetGetopenorders(this.extend(a,s));return this.parseOrders(o.result,r,t,i)}async fetchClosedOrders(e,t,i,s={}){if(void 0===e)throw new n(this.id+" fetchClosedOrders() requires a `symbol` argument");await this.loadMarkets();const r=this.market(e),a={instrument:r.id},o=await this.privateGetOrderhistory(this.extend(a,s));return this.parseOrders(o.result,r,t,i)}async fetchMyTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={instrument:r.id};void 0!==i&&(a.count=i);const o=await this.privateGetTradehistory(this.extend(a,s)),n=this.safeValue(o,"result",[]);return this.parseTrades(n,r,t,i)}nonce(){return this.milliseconds()}sign(e,t="public",i="GET",s={},r,a){const o="/api/"+this.version+"/"+t+"/"+e;let n=this.urls.api+o;if("public"===t)Object.keys(s).length&&(n+="?"+this.urlencode(s));else{this.checkRequiredCredentials();const e=this.nonce().toString();let t="_="+e+"&_ackey="+this.apiKey+"&_acsec="+this.secret+"&_action="+o;Object.keys(s).length&&(s=this.keysort(s),t+="&"+this.urlencode(s));const d=this.hash(this.encode(t),"sha256","base64");r={"x-deribit-sig":this.apiKey+"."+e+"."+this.decode(d)},"GET"!==i?(r["Content-Type"]="application/x-www-form-urlencoded",a=this.urlencode(s)):Object.keys(s).length&&(n+="?"+this.urlencode(s))}return{url:n,method:i,body:a,headers:r}}handleErrors(e,t,i,s,r,a,n,d,c){if(!n)return;const h=this.safeString(n,"error");if(void 0!==h&&"0"!==h){const e=this.id+" "+a,t=this.exceptions;if(h in t)throw new t[h](e);throw new o(e)}}}},function(e,t,i){"use strict";const s=i(1),{AccountSuspended:r,BadRequest:a,BadResponse:o,NetworkError:n,DDoSProtection:d,AuthenticationError:c,PermissionDenied:h,ArgumentsRequired:l,ExchangeError:u,InsufficientFunds:f,InvalidOrder:p,InvalidNonce:m,OrderNotFound:y}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"digifinex",name:"DigiFinex",countries:["SG"],version:"v3",rateLimit:900,has:{cancelOrders:!0,fetchOrders:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchTickers:!0,fetchMyTrades:!0,fetchLedger:!0},timeframes:{"1m":"1","5m":"5","15m":"15","30m":"30","1h":"60","4h":"240","12h":"720","1d":"1D","1w":"1W"},urls:{logo:"https://user-images.githubusercontent.com/1294454/62184319-304e8880-b366-11e9-99fe-8011d6929195.jpg",api:"https://openapi.digifinex.vip",www:"https://www.digifinex.vip",doc:["https://docs.digifinex.vip"],fees:"https://digifinex.zendesk.com/hc/en-us/articles/360000328482-Fee-Structure-on-DigiFinex",referral:"https://www.digifinex.vip/en-ww/from/DhOzBg/3798****5114"},api:{v2:{get:["ticker"]},public:{get:["{market}/symbols","kline","margin/currencies","margin/symbols","markets","order_book","ping","spot/symbols","time","trades"]},private:{get:["{market}/financelog","{market}/mytrades","{market}/order","{market}/order/current","{market}/order/history","margin/assets","margin/financelog","margin/mytrades","margin/order","margin/order/current","margin/order/history","margin/positions","otc/financelog","spot/assets","spot/financelog","spot/mytrades","spot/order","spot/order/current","spot/order/history"],post:["{market}/order/cancel","{market}/order/new","margin/order/cancel","margin/order/new","margin/position/close","spot/order/cancel","spot/order/new","transfer"]}},exceptions:{exact:{10001:[a,"Wrong request method, please check it's a GET ot POST request"],10002:[c,"Invalid ApiKey"],10003:[c,"Sign doesn't match"],10004:[a,"Illegal request parameters"],10005:[d,"Request frequency exceeds the limit"],10006:[h,"Unauthorized to execute this request"],10007:[h,"IP address Unauthorized"],10008:[m,"Timestamp for this request is invalid, timestamp must within 1 minute"],10009:[n,"Unexist endpoint, please check endpoint URL"],10011:[r,"ApiKey expired. Please go to client side to re-create an ApiKey"],20001:[h,"Trade is not open for this trading pair"],20002:[h,"Trade of this trading pair is suspended"],20003:[p,"Invalid price or amount"],20007:[p,"Price precision error"],20008:[p,"Amount precision error"],20009:[p,"Amount is less than the minimum requirement"],20010:[p,"Cash Amount is less than the minimum requirement"],20011:[f,"Insufficient balance"],20012:[a,"Invalid trade type, valid value: buy/sell)"],20013:[p,"No order info found"],20014:[a,"Invalid date, Valid format: 2018-07-25)"],20015:[a,"Date exceeds the limit"],20018:[h,"Your trading rights have been banned by the system"],20019:[a,'Wrong trading pair symbol. Correct format:"usdt_btc". Quote asset is in the front'],20020:[d,"You have violated the API operation trading rules and temporarily forbid trading. At present, we have certain restrictions on the user's transaction rate and withdrawal rate."],50000:[u,"Exception error"]},broad:{}},options:{defaultType:"spot",types:["spot","margin","otc"]}})}async fetchMarketsByType(e,t={}){const i="publicGet"+this.capitalize(e)+"Symbols",s=await this[i](t),r=this.safeValue(s,"symbols_list",[]),a=[];for(let t=0;t<r.length;t++){const i=r[t],s=this.safeString(i,"symbol"),o=this.safeString(i,"base_asset"),n=this.safeString(i,"quote_asset"),d=this.safeCurrencyCode(o),c=this.safeCurrencyCode(n),h=d+"/"+c,l={amount:this.safeInteger(i,"amount_precision"),price:this.safeInteger(i,"price_precision")},u={amount:{min:this.safeFloat(i,"minimum_amount"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeFloat(i,"minimum_value"),max:void 0}},f=void 0,p="spot"===e,m="margin"===e;a.push({id:s,symbol:h,base:d,quote:c,baseId:o,quoteId:n,active:f,type:e,spot:p,margin:m,precision:l,limits:u,info:i})}return a}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),i=this.safeValue(t,"data",[]),s=[];for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"market"),[a,o]=r.split("_"),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o),c=n+"/"+d,h={amount:this.safeInteger(t,"volume_precision"),price:this.safeInteger(t,"price_precision")},l={amount:{min:this.safeFloat(t,"min_volume"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeFloat(t,"min_amount"),max:void 0}},u=void 0;s.push({id:r,symbol:c,base:n,quote:d,baseId:a,quoteId:o,active:u,precision:h,limits:l,info:t})}return s}async fetchBalance(e={}){const t=this.safeString(this.options,"defaultType","spot"),i=this.safeString(e,"type",t);e=this.omit(e,"type");const s="privateGet"+this.capitalize(i)+"Assets",r=await this[s](e),a=this.safeValue(r,"list",[]),o={info:r};for(let e=0;e<a.length;e++){const t=a[e],i=this.safeString(t,"currency"),s=this.safeCurrencyCode(i),r=this.account();r.used=this.safeFloat(t,"frozen"),r.free=this.safeFloat(t,"free"),r.total=this.safeFloat(t,"total"),o[s]=r}return this.parseBalance(o)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={symbol:this.market(e).id};void 0!==t&&(s.limit=t);const r=await this.publicGetOrderBook(this.extend(s,i)),a=this.safeTimestamp(r,"date");return this.parseOrderBook(r,a)}async fetchTickers(e,t={}){const i=this.safeValue(t,"apiKey",this.apiKey);if(!i)throw new l(this.id+" fetchTicker is a private v2 endpoint that requires an `exchange.apiKey` credential or an `apiKey` extra parameter");await this.loadMarkets();const s={apiKey:i},r=await this.v2GetTicker(this.extend(s,t)),a={},o=this.safeValue(r,"ticker",{}),n=this.safeInteger(r,"date"),d=Object.keys(o);for(let e=0;e<d.length;e++){const t=d[e],i=this.extend({date:n},o[t]),[s,r]=t.split("_"),c=r+"_"+s;let h=void 0,l=void 0;if(c in this.markets_by_id)l=(h=this.markets_by_id[c]).symbol;else{l=this.safeCurrencyCode(r)+"/"+this.safeCurrencyCode(s)}a[l]=this.parseTicker(i,h)}return a}async fetchTicker(e,t={}){const i=this.safeValue(t,"apiKey",this.apiKey);if(!i)throw new l(this.id+" fetchTicker is a private v2 endpoint that requires an `exchange.apiKey` credential or an `apiKey` extra parameter");await this.loadMarkets();const s=this.market(e),r=s.quoteId+"_"+s.baseId,a={symbol:r,apiKey:i},o=await this.v2GetTicker(this.extend(a,t)),n=this.safeInteger(o,"date"),d=this.safeValue(o,"ticker",{});let c=this.safeValue(d,r,{});return c=this.extend({date:n},c),this.parseTicker(c,s)}parseTicker(e,t){let i=void 0;void 0!==t&&(i=t.symbol);const s=this.safeTimestamp(e,"date"),r=this.safeFloat(e,"last"),a=this.safeFloat(e,"change");return{symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"buy"),bidVolume:void 0,ask:this.safeFloat(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:a,average:void 0,baseVolume:this.safeFloat(e,"vol"),quoteVolume:this.safeFloat(e,"base_vol"),info:e}}parseTrade(e,t){const i=this.safeString(e,"id"),s=this.safeString(e,"order_id"),r=this.safeTimestamp2(e,"date","timestamp"),a=this.safeString2(e,"type","side"),o=this.safeFloat(e,"price"),n=this.safeFloat(e,"amount");let d=void 0;void 0!==o&&void 0!==n&&(d=o*n);let c=void 0;const h=this.safeString(e,"symbol");if(void 0!==h)if(h in this.markets_by_id)c=(t=this.markets_by_id[t]).symbol;else{const[e,t]=h.split("_");c=this.safeCurrencyCode(e)+"/"+this.safeCurrencyCode(t)}void 0===c&&void 0!==t&&(c=t.symbol);const l=this.safeValue(e,"is_maker"),u=this.safeFloat(e,"fee");let f=void 0;if(void 0!==u){const t=this.safeString(e,"fee_currency");f={cost:u,currency:this.safeCurrencyCode(t)}}return{id:i,info:e,timestamp:r,datetime:this.iso8601(r),symbol:c,type:void 0,order:s,side:a,price:o,amount:n,cost:d,takerOrMaker:l,fee:f}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id};void 0!==i&&(a.limit=i);const o=await this.publicGetTrades(this.extend(a,s)),n=this.safeValue(o,"data",[]);return this.parseTrades(n,r,t,i)}parseOHLCV(e,t,i="1m",s,r){return[1e3*e[0],e[5],e[3],e[4],e[2],e[1]]}async fetchOHLCV(e,t="1m",i,s,r={}){await this.loadMarkets();const a=this.market(e),o={symbol:a.id,period:this.timeframes[t]};if(void 0!==i){const e=parseInt(i/1e3);if(o.start_time=e,void 0!==s){const i=this.parseTimeframe(t);o.end_time=this.sum(e,s*i)}}else if(void 0!==s){const e=this.seconds(),i=this.parseTimeframe(t);o.startTime=this.sum(e,-s*i)}const n=await this.publicGetKline(this.extend(o,r)),d=this.safeValue(n,"data",[]);return this.parseOHLCVs(d,a,t,i,s)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o=this.market(e),n=this.safeString(this.options,"defaultType","spot"),d=this.safeString(a,"type",n);a=this.omit(a,"type");const c={market:d,symbol:o.id,amount:this.amountToPrecision(e,s)};let h="";"market"===t?h="_market":c.price=this.priceToPrecision(e,r),c.type=i+h;const l=await this.privatePostMarketOrderNew(this.extend(c,a)),u=this.parseOrder(l,o);return this.extend(u,{symbol:e,side:i,type:t,amount:s,price:r})}async cancelOrder(e,t,i={}){await this.loadMarkets();const s=this.safeString(this.options,"defaultType","spot"),r=this.safeString(i,"type",s);i=this.omit(i,"type");const a={market:r,order_id:e},o=await this.privatePostMarketOrderCancel(this.extend(a,i));if(1!==this.safeValue(o,"success",[]).length)throw new y(this.id+" cancelOrder "+e+" not found");return o}async cancelOrders(e,t,i={}){await this.loadMarkets();const s=this.safeString(this.options,"defaultType","spot"),r=this.safeString(i,"type",s);i=this.omit(i,"type");const a={market:r,order_id:e.join(",")},o=await this.privatePostCancelOrder(this.extend(a,i));if(this.safeValue(o,"success",[]).length<1)throw new y(this.id+" cancelOrders error");return o}parseOrderStatus(e){return this.safeString({0:"open",1:"open",2:"closed",3:"canceled",4:"canceled"},e,e)}parseOrder(e,t){const i=this.safeString(e,"order_id"),s=this.safeTimestamp(e,"created_date"),r=this.safeTimestamp(e,"finished_date");let a=this.safeString(e,"type"),o=void 0;if(void 0!==a){const e=a.split("_");e.length>1?(a=e[0],o=e[1]):o="limit"}const n=this.parseOrderStatus(this.safeString(e,"status"));if(void 0===t){const i=e.symbol.toUpperCase();i in this.markets_by_id&&(t=this.markets_by_id[i])}let d=void 0;const c=this.safeString(e,"symbol");if(void 0!==c)if(c in this.markets_by_id)d=(t=this.markets_by_id[c]).symbol;else{const[e,t]=c.split("_");d=this.safeCurrencyCode(e)+"/"+this.safeCurrencyCode(t)}const h=this.safeFloat(e,"amount"),l=this.safeFloat(e,"executed_amount"),u=this.safeFloat(e,"price"),f=this.safeFloat(e,"avg_price");let p=void 0,m=void 0;return void 0!==l&&(void 0!==f&&(m=l*f),void 0!==h&&(p=Math.max(0,h-l))),{info:e,id:i,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:r,symbol:d,type:o,side:a,price:u,amount:h,filled:l,remaining:p,cost:m,average:f,status:n,fee:void 0}}async fetchOpenOrders(e,t,i,s={}){const r=this.safeString(this.options,"defaultType","spot"),a=this.safeString(s,"type",r);s=this.omit(s,"type"),await this.loadMarkets();let o=void 0;const n={market:a};void 0!==e&&(o=this.market(e),n.symbol=o.id);const d=await this.privateGetMarketOrderCurrent(this.extend(n,s)),c=this.safeValue(d,"data",[]);return this.parseOrders(c,o,t,i)}async fetchOrders(e,t,i,s={}){const r=this.safeString(this.options,"defaultType","spot"),a=this.safeString(s,"type",r);s=this.omit(s,"type"),await this.loadMarkets();let o=void 0;const n={market:a};void 0!==e&&(o=this.market(e),n.symbol=o.id),void 0!==t&&(n.start_time=parseInt(t/1e3)),void 0!==i&&(n.limit=i);const d=await this.privateGetMarketOrderHistory(this.extend(n,s)),c=this.safeValue(d,"data",[]);return this.parseOrders(c,o,t,i)}async fetchOrder(e,t,i={}){const s=this.safeString(this.options,"defaultType","spot"),r=this.safeString(i,"type",s);i=this.omit(i,"type"),await this.loadMarkets();const a={market:r,order_id:e},o=await this.privateGetMarketOrder(this.extend(a,i));return this.parseOrder(o)}async fetchMyTrades(e,t,i,s={}){const r=this.safeString(this.options,"defaultType","spot"),a=this.safeString(s,"type",r);s=this.omit(s,"type"),await this.loadMarkets();let o=void 0;const n={market:a};void 0!==e&&(o=this.market(e),n.symbol=o.id),void 0!==t&&(n.start_time=parseInt(t/1e3)),void 0!==i&&(n.limit=i);const d=await this.privateGetMarketMytrades(this.extend(n,s)),c=this.safeValue(d,"list",[]);return this.parseTrades(c,o,t,i)}parseLedgerEntryType(e){return this.safeString({},e,e)}parseLedgerEntry(e,t){const i=this.safeString(e,"num"),s=this.parseLedgerEntryType(this.safeString(e,"type")),r=this.safeCurrencyCode(this.safeString(e,"currency_mark"),t),a=this.safeTimestamp(e,"time");return{info:e,id:i,direction:void 0,account:void 0,referenceId:void 0,referenceAccount:void 0,type:s,currency:r,amount:void 0,before:void 0,after:this.safeFloat(e,"balance"),status:"ok",timestamp:a,datetime:this.iso8601(a),fee:void 0}}async fetchLedger(e,t,i,s={}){const r=this.safeString(this.options,"defaultType","spot"),a=this.safeString(s,"type",r);s=this.omit(s,"type"),await this.loadMarkets();const o={market:a};let n=void 0;void 0!==e&&(n=this.currency(e),o.currency_mark=n.id),void 0!==t&&(o.start_time=parseInt(t/1e3)),void 0!==i&&(o.limit=i);const d=await this.privateGetMarketFinancelog(this.extend(o,s)),c=this.safeValue(d,"data",{}),h=this.safeValue(c,"finance",[]);return this.parseLedger(h,n,t,i)}sign(e,t="public",i="GET",s={},r,a){const o="v2"===t?t:this.version;let n=this.urls.api+"/"+o+"/"+this.implodeParams(e,s);const d=this.omit(s,this.extractParams(e)),c=this.urlencode(this.keysort(d));if("private"===t){const e=this.nonce().toString(),t=c,s=this.hmac(this.encode(t),this.encode(this.secret));"GET"===i?c&&(n+="?"+c):"POST"===i&&(r={"Content-Type":"application/x-www-form-urlencoded"},c&&(a=c)),r={"ACCESS-KEY":this.apiKey,"ACCESS-SIGN":s,"ACCESS-TIMESTAMP":e}}else c&&(n+="?"+c);return{url:n,method:i,body:a,headers:r}}dateUTC8(e){const t=this.safeValue(this.options,"timedelta",288e5);return this.ymd(e+t)}handleErrors(e,t,i,s,r,a,n,d,c){if(!n)return;const h=this.safeString(n,"code");if("0"===h)return;const l=this.id+" "+a;if(void 0===h)throw new o(l);const f=[u,l],[p,m]=this.safeValue(this.exceptions.exact,h,f);throw new p(m)}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,ArgumentsRequired:a,ExchangeNotAvailable:o,InvalidNonce:n,BadRequest:d,InsufficientFunds:c,PermissionDenied:h,DDoSProtection:l,InvalidOrder:u,AuthenticationError:f}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"dsx",name:"DSX",countries:["UK"],rateLimit:1500,version:"v3",has:{CORS:!1,createMarketOrder:!1,fetchOHLCV:!0,fetchOrder:!0,fetchOrders:!0,fetchOpenOrders:!0,fetchClosedOrders:!1,fetchOrderBooks:!1,createDepositAddress:!0,fetchDepositAddress:!0,fetchTransactions:!0,fetchTickers:!0,fetchMyTrades:!0,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27990275-1413158a-645a-11e7-931c-94717f7510e3.jpg",api:{public:"https://dsx.uk/mapi",private:"https://dsx.uk/tapi",dwapi:"https://dsx.uk/dwapi"},www:"https://dsx.uk",doc:["https://dsx.uk/developers/publicApi"]},fees:{trading:{tierBased:!0,percentage:!0,maker:.0015,taker:.0025}},timeframes:{"1m":"m","1h":"h","1d":"d"},api:{public:{get:["barsFromMoment/{pair}/{period}/{start}","depth/{pair}","info","lastBars/{pair}/{period}/{amount}","periodBars/{pair}/{period}/{start}/{end}","ticker/{pair}","trades/{pair}"]},private:{post:["info/account","history/transactions","history/trades","history/orders","orders","order/cancel","order/status","order/new","volume","fees"]},dwapi:{post:["deposit/cryptoaddress","withdraw/crypto","withdraw/fiat","withdraw/submit","transaction/status"]}},exceptions:{exact:{"Sign is invalid":f,"Order was rejected. Incorrect price.":u,"Order was rejected. You don't have enough money.":c,"This method is blocked for your pair of keys":h},broad:{INVALID_PARAMETER:d,"Invalid pair name":r,"invalid api key":f,"invalid sign":f,"api key dont have trade permission":f,"invalid parameter":u,"invalid order":u,"Requests too often":l,"not available":o,"data unavailable":o,"external service unavailable":o,"nonce is invalid":n}},options:{fetchTickersMaxLength:250},commonCurrencies:{DSH:"DASH"}})}async fetchMarkets(e={}){const t=await this.publicGetInfo(e),i=this.safeValue(t,"pairs"),s=Object.keys(i),r=[];for(let e=0;e<s.length;e++){const t=s[e],a=i[t],o=this.safeString(a,"base_currency"),n=this.safeString(a,"quoted_currency"),d=this.safeCurrencyCode(o),c=this.safeCurrencyCode(n),h=d+"/"+c,l={amount:this.safeInteger(a,"decimal_places"),price:this.safeInteger(a,"decimal_places")},u={amount:{min:this.safeFloat(a,"min_amount"),max:this.safeFloat(a,"max_amount")},price:{min:this.safeFloat(a,"min_price"),max:this.safeFloat(a,"max_price")},cost:{min:this.safeFloat(a,"min_total")}},f=0===this.safeInteger(a,"hidden"),p=d.toLowerCase()+c.toLowerCase();r.push({id:t,otherId:p,symbol:h,base:d,quote:c,baseId:o,quoteId:n,active:f,precision:l,limits:u,info:a})}return r}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostInfoAccount(),i=this.safeValue(t,"return"),s={info:t},r=this.safeValue(i,"funds"),a=Object.keys(r);for(let e=0;e<a.length;e++){const t=a[e],i=this.safeCurrencyCode(t),o=this.safeValue(r,t,{}),n=this.account();n.free=this.safeFloat(o,"available"),n.total=this.safeFloat(o,"total"),s[i]=n}return this.parseBalance(s)}parseTicker(e,t){const i=this.safeTimestamp(e,"updated");let s=void 0;const r=this.safeString(e,"pair");void 0!==(t=this.parseMarket(r))&&(s=t.symbol);let a=this.safeFloat(e,"avg");void 0!==a&&a>0&&(a=1/a);const o=this.safeFloat(e,"last");return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"buy"),bidVolume:void 0,ask:this.safeFloat(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:a,baseVolume:this.safeFloat(e,"vol"),quoteVolume:this.safeFloat(e,"vol_cur"),info:e}}parseTrade(e,t){const i=this.safeTimestamp(e,"timestamp");let s=this.safeString(e,"type");"ask"===s?s="sell":"bid"===s&&(s="buy");const r=this.safeFloat2(e,"rate","price"),a=this.safeString2(e,"number","id"),o=this.safeString(e,"orderId"),n=this.safeString(e,"pair");let d=void 0;void 0!==(t=this.parseMarket(n))&&(d=t.symbol);const c=this.safeFloat2(e,"amount","volume");let h=void 0,l=void 0;const u=this.safeFloat(e,"commission");if(void 0!==u){const t=this.safeString(e,"commissionCurrency");l={cost:u,currency:this.safeCurrencyCode(t)}}const f=this.safeValue(e,"is_your_order");void 0!==f&&(h="taker",f&&(h="maker"),void 0===l&&(l=this.calculateFee(d,"limit",s,c,r,h)));let p=void 0;return void 0!==r&&void 0!==c&&(p=r*c),{id:a,order:o,timestamp:i,datetime:this.iso8601(i),symbol:d,type:"limit",side:s,takerOrMaker:h,price:r,amount:c,cost:p,fee:l,info:e}}parseTrades(e,t,i,s,r={}){let a=[];if(Array.isArray(e))for(let i=0;i<e.length;i++)a.push(this.parseTrade(e[i],t));else{const i=Object.keys(e);for(let s=0;s<i.length;s++){const o=i[s],n=this.parseTrade(e[o],t);a.push(this.extend(n,{id:o},r))}}a=this.sortBy(a,"timestamp");const o=void 0!==t?t.symbol:void 0;return this.filterBySymbolSinceLimit(a,o,i,s)}calculateFee(e,t,i,s,r,a="taker",o={}){const n=this.markets[e];let d="quote";const c=n[a];let h=parseFloat(this.costToPrecision(e,s*c));return"sell"===i?h*=r:d="base",{type:a,currency:n[d],rate:c,cost:h}}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s=this.market(e),a={pair:s.id};void 0!==t&&(a.limit=t);const o=await this.publicGetDepthPair(this.extend(a,i));if(!(s.id in o))throw new r(this.id+" "+s.symbol+" order book is empty or not available");const n=o[s.id];return this.parseOrderBook(n)}async fetchOrderBooks(e,t={}){await this.loadMarkets();let i=void 0;if(void 0===e){if((i=this.ids.join("-")).length>2048){const e=this.ids.length;throw new r(this.id+" has "+e.toString()+" symbols exceeding max URL length, you are required to specify a list of symbols in the first argument to fetchOrderBooks")}}else i=(i=this.marketIds(e)).join("-");const s={pair:i},a=await this.publicGetDepthPair(this.extend(s,t)),o={};i=Object.keys(a);for(let e=0;e<i.length;e++){const t=i[e];let s=t;if(t in this.markets_by_id){s=this.markets_by_id[t].symbol}o[s]=this.parseOrderBook(a[t])}return o}async fetchTickers(e,t={}){await this.loadMarkets();let i=this.ids;if(void 0===e){const e=i.length;i=i.join("-");const t=this.safeInteger(this.options,"fetchTickersMaxLength",2048);if(i.length>this.options.fetchTickersMaxLength)throw new a(this.id+" has "+e.toString()+" markets exceeding max URL length for this endpoint ("+t.toString()+" characters), please, specify a list of symbols of interest in the first argument to fetchTickers")}else i=(i=this.marketIds(e)).join("-");const s={pair:i},r=await this.publicGetTickerPair(this.extend(s,t)),o={},n=Object.keys(r);for(let e=0;e<n.length;e++){const t=n[e],i=r[t];let s=t,a=void 0;t in this.markets_by_id&&(s=(a=this.markets_by_id[t]).symbol),o[s]=this.parseTicker(i,a)}return o}async fetchTicker(e,t={}){return(await this.fetchTickers([e],t))[e]}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={pair:r.id};void 0!==i&&(a.limit=i);const o=await this.publicGetTradesPair(this.extend(a,s));if(Array.isArray(o)){if(0===o.length)return[]}return this.parseTrades(o[r.id],r,t,i)}parseOHLCV(e,t,i="1m",s,r){return[this.safeInteger(e,"timestamp"),this.safeFloat(e,"open"),this.safeFloat(e,"high"),this.safeFloat(e,"low"),this.safeFloat(e,"close"),this.safeFloat(e,"amount")]}async fetchOHLCV(e,t="1m",i,s,r={}){await this.loadMarkets();const a=this.market(e),o={pair:a.id,period:this.timeframes[t]};let n="publicGetLastBarsPairPeriodAmount";if(void 0===i)void 0===s&&(s=100),o.amount=s;else if(n="publicGetPeriodBarsPairPeriodStartEnd",o.start=parseInt(i/1e3),void 0===s)o.end=this.seconds();else{const e=1e3*this.parseTimeframe(t),r=this.sum(i,e*s);o.end=parseInt(r/1e3)}const d=await this[n](this.extend(o,r)),c=this.safeValue(d,a.id,[]);return this.parseOHLCVs(c,a,t,i,s)}async createOrder(e,t,i,s,r,o={}){await this.loadMarkets();const n=this.market(e);if("market"===t&&void 0===r)throw new a(this.id+" createOrder requires a price argument even for market orders, that is the worst price that you agree to fill your order for");const d={pair:n.id,type:i,volume:this.amountToPrecision(e,s),rate:this.priceToPrecision(e,r),orderType:t};r=parseFloat(r),s=parseFloat(s);const c=await this.privatePostOrderNew(this.extend(d,o));let h="open",l=0,u=s;const f=this.safeValue(c,"return");let p=this.safeString2(f,"orderId","order_id");"0"===p&&(p=this.safeString(f,"initOrderId","init_order_id"),h="closed"),l=this.safeFloat(f,"received",0),u=this.safeFloat(f,"remains",s);const m=this.milliseconds();return{info:c,id:p,timestamp:m,datetime:this.iso8601(m),lastTradeTimestamp:void 0,status:h,symbol:e,type:t,side:i,price:r,cost:r*l,amount:s,remaining:u,filled:l,fee:void 0}}parseOrderStatus(e){return this.safeString({0:"open",1:"closed",2:"canceled",3:"canceling",7:"canceled"},e,e)}parseMarket(e){if(e in this.markets_by_id)return this.markets_by_id[e];{let t=this.safeValue(this.options,"markets_by_other_id");if(void 0===t&&(this.options.markets_by_other_id=this.indexBy(this.markets,"otherId"),t=this.options.markets_by_other_id),e in t)return t[e]}}parseOrder(e,t){const i=this.safeString(e,"id"),s=this.parseOrderStatus(this.safeString(e,"status")),r=this.safeTimestamp(e,"timestampCreated"),a=this.safeString(e,"pair");let o=void 0;void 0!==(t=this.parseMarket(a))&&(o=t.symbol);const n=this.safeFloat(e,"remainingVolume"),d=this.safeFloat(e,"volume"),c=this.safeFloat(e,"rate");let h=void 0,l=void 0;void 0!==d&&void 0!==n&&(l=c*(h=d-n));const u=this.safeString(e,"orderType"),f=this.safeString(e,"type");let p=void 0;const m=this.safeValue(e,"deals",[]);let y=void 0,b=void 0;if(m.length>0){y=this.parseTrades(m);let e=void 0,t=void 0;for(let i=0;i<y.length;i++){const s=y[i];void 0===e&&(e=0),e=this.sum(e,s.fee.cost),t=s.fee.currency,b=s.timestamp}void 0!==e&&(p={cost:e,currency:t})}return{info:e,id:i,symbol:o,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:b,type:u,side:f,price:c,cost:l,amount:d,remaining:n,filled:h,status:s,fee:p,trades:y}}async fetchOrder(e,t,i={}){await this.loadMarkets();const s={orderId:parseInt(e)},r=await this.privatePostOrderStatus(this.extend(s,i));return this.parseOrder(this.extend({id:e},r.return))}parseOrdersById(e,t,i,s){const r=Object.keys(e),a=[];for(let t=0;t<r.length;t++){const i=r[t],s=this.parseOrder(this.extend({id:i.toString()},e[i]));a.push(s)}return this.filterBySymbolSinceLimit(a,t,i,s)}async fetchOpenOrders(e,t,i,s={}){await this.loadMarkets();const r=await this.privatePostOrders(this.extend({},s));return this.parseOrdersById(this.safeValue(r,"return",{}),e,t,i)}async fetchOrders(e,t,i,s={}){await this.loadMarkets();const r={};void 0!==i&&(r.count=i);const a=await this.privatePostHistoryOrders(this.extend(r,s));return this.parseOrdersById(this.safeValue(a,"return",{}),e,t,i)}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={orderId:e},r=await this.privatePostOrderCancel(this.extend(s,i));return e in this.orders&&(this.orders[e].status="canceled"),r}parseOrders(e,t,i,s,r={}){const a=[],o=Object.keys(e);let n=void 0;void 0!==t&&(n=t.symbol);for(let i=0;i<o.length;i++){const s=o[i],n=this.extend({id:s},e[s]);a.push(this.extend(this.parseOrder(n,t),r))}return this.filterBySymbolSinceLimit(a,n,i,s)}async fetchClosedOrders(e,t,i,s={}){const r=await this.fetchOrders(e,t,i,s);return this.filterBy(r,"status","closed")}async fetchMyTrades(e,t,i,s={}){await this.loadMarkets();let r=void 0;const a={};void 0!==e&&(r=this.market(e),a.pair=r.id),void 0!==i&&(a.count=parseInt(i)),void 0!==t&&(a.since=parseInt(t/1e3));const o=await this.privatePostHistoryTrades(this.extend(a,s));let n=[];return"return"in o&&(n=o.return),this.parseTrades(n,r,t,i)}async fetchTransactions(e,t,i,s={}){await this.loadMarkets();let r=void 0;const a={};void 0!==e&&(r=this.currency(e),a.currency=r.id),void 0!==t&&(a.since=t),void 0!==i&&(a.count=i);const o=await this.privatePostHistoryTransactions(this.extend(a,s)),n=this.safeValue(o,"return",[]);return this.parseTransactions(n,r,t,i)}parseTransactionStatus(e){return this.safeString({1:"failed",2:"ok",3:"pending",4:"failed"},e,e)}parseTransaction(e,t){const i=this.safeTimestamp(e,"timestamp");let s=this.safeString(e,"type");void 0!==s&&("Incoming"===s?s="deposit":"Withdraw"===s&&(s="withdrawal"));const r=this.safeString(e,"currency"),a=this.safeCurrencyCode(r,t),o=this.parseTransactionStatus(this.safeString(e,"status"));return{id:this.safeString(e,"id"),txid:this.safeString(e,"txid"),timestamp:i,datetime:this.iso8601(i),address:this.safeString(e,"address"),type:s,amount:this.safeFloat(e,"amount"),currency:a,status:o,fee:{currency:a,cost:this.safeFloat(e,"commission"),rate:void 0},info:e}}async createDepositAddress(e,t={}){return await this.fetchDepositAddress(e,this.extend({new:1},t))}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},s=await this.dwapiPostDepositCryptoaddress(this.extend(i,t)),r=this.safeValue(s,"return",{}),a=this.safeString(r,"address");return this.checkAddress(a),{currency:e,address:a,tag:void 0,info:s}}async withdraw(e,t,i,s,r={}){this.checkAddress(i),await this.loadMarkets();const o=this.currency(e),n=this.safeValue(r,"commission");if(void 0===n)throw new a(this.id+" withdraw() requires a `commission` (withdrawal fee) parameter (string)");r=this.omit(r,n);const d={currency:o.id,amount:parseFloat(t),address:i,commission:n};void 0!==s&&(d.address+=":"+s);const c=await this.dwapiPostWithdrawCrypto(this.extend(d,r)),h=this.safeValue(c,"return",{});return{info:c,id:this.safeString(h,"transactionId")}}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api[t];const n=this.omit(s,this.extractParams(e));if("private"===t||"dwapi"===t){o+="/"+this.version+"/"+this.implodeParams(e,s),this.checkRequiredCredentials();const t=this.nonce();a=this.urlencode(this.extend({nonce:t},n));const i=this.decode(this.hmac(this.encode(a),this.encode(this.secret),"sha512","base64"));r={"Content-Type":"application/x-www-form-urlencoded",Key:this.apiKey,Sign:i}}else"public"===t?(o+="/"+this.implodeParams(e,s),Object.keys(n).length&&(o+="?"+this.urlencode(n))):(o+="/"+this.implodeParams(e,s),"GET"===i?Object.keys(n).length&&(o+="?"+this.urlencode(n)):Object.keys(n).length&&(a=this.json(n),r={"Content-Type":"application/json"}));return{url:o,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,o,n,d,c){if(void 0!==n&&"success"in n){let e=this.safeValue(n,"success",!1);if("string"==typeof e&&(e="true"===e||"1"===e),!e){const e=this.safeString(n,"code"),t=this.safeString(n,"error"),i=this.id+" "+this.json(n),s=this.exceptions.exact;if(e in s)throw new s[e](i);if(t in s)throw new s[t](i);const a=this.exceptions.broad,o=this.findBroadlyMatchedKey(a,t);if(void 0!==o)throw new a[o](i);throw new r(i)}}}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,BadRequest:a,AuthenticationError:o,InvalidOrder:n,InsufficientFunds:d,RequestTimeout:c}=i(0),{ROUND:h,DECIMAL_PLACES:l,NO_PADDING:u}=i(2);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"dx",name:"DX.Exchange",countries:["GB","EU"],rateLimit:1500,version:"v1",has:{cancelAllOrders:!1,cancelOrder:!0,cancelOrders:!1,CORS:!1,createDepositAddress:!1,createLimitOrder:!0,createMarketOrder:!0,createOrder:!0,deposit:!1,editOrder:!1,fetchBalance:!0,fetchBidsAsks:!1,fetchClosedOrders:!0,fetchCurrencies:!1,fetchDepositAddress:!1,fetchDeposits:!1,fetchFundingFees:!1,fetchL2OrderBook:!1,fetchLedger:!1,fetchMarkets:!0,fetchMyTrades:!1,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!1,fetchOrderBook:!0,fetchOrderBooks:!1,fetchOrders:!1,fetchTicker:!0,fetchTickers:!1,fetchTrades:!1,fetchTradingFee:!1,fetchTradingFees:!1,fetchTradingLimits:!1,fetchTransactions:!1,fetchWithdrawals:!1,privateAPI:!0,publicAPI:!0,withdraw:!1},timeframes:{"1m":"1m","5m":"5m","1h":"1h","1d":"1d"},urls:{logo:"https://user-images.githubusercontent.com/1294454/57979980-6483ff80-7a2d-11e9-9224-2aa20665703b.jpg",api:"https://acl.dx.exchange",www:"https://dx.exchange",doc:"https://apidocs.dx.exchange",fees:"https://dx.exchange/fees",referral:"https://dx.exchange/registration?dx_cid=20&dx_scname=100001100000038139"},requiredCredentials:{apiKey:!0,secret:!1},fees:{trading:{tierBased:!0,percentage:!0,taker:.0025,maker:.0025,tiers:{taker:[[0,.0025],[1e6,.002],[5e6,.0015],[1e7,.001]],maker:[[0,.0025],[1e6,.002],[5e6,.0015],[1e7,.001]]}},funding:{}},exceptions:{exact:{EOF:a},broad:{"json: cannot unmarshal object into Go value of type":a,"not allowed to cancel this order":a,"request timed out":c,"balance_freezing.freezing validation.balance_freeze":d,"order_creation.validation.validation":n}},api:{public:{post:["AssetManagement.GetInstruments","AssetManagement.GetTicker","AssetManagement.History","Authorization.LoginByToken","OrderManagement.GetOrderBook"]},private:{post:["Balance.Get","OrderManagement.Cancel","OrderManagement.Create","OrderManagement.OpenOrders","OrderManagement.OrderHistory"]}},commonCurrencies:{BCH:"Bitcoin Cash"},precisionMode:l,options:{orderTypes:{market:1,limit:2},orderSide:{buy:1,sell:2}}})}numberToObject(e){const t=this.decimalToPrecision(e,h,10,l,u),i=this.precisionFromString(t),s=t.replace(".","");return{value:this.safeInteger({a:s},"a",void 0),decimals:i}}objectToNumber(e){const t=this.decimalToPrecision(e.value,h,0,l,u),i=this.decimalToPrecision(-e.decimals,h,0,l,u);return this.safeFloat({a:t+"e"+i},"a",void 0)}async fetchMarkets(e={}){const t=(await this.publicPostAssetManagementGetInstruments(e)).result.instruments,i=[];for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"id"),a=this.safeInteger(s,"id"),o=this.safeValue(s,"asset",{}),n=this.safeString(o,"fullName");let[d,c]=n.split("/"),h=0;0!==s.meQuantityMultiplier&&(h=parseInt(Math.log10(s.meQuantityMultiplier))),d=this.safeCurrencyCode(d),c=this.safeCurrencyCode(c);const l=this.safeString(o,"baseCurrencyId"),u=this.safeString(o,"quotedCurrencyId"),f=this.safeInteger(o,"baseCurrencyId"),p=this.safeInteger(o,"quotedCurrencyId"),m=d+"/"+c;i.push({id:r,numericId:a,symbol:m,base:d,quote:c,baseId:l,quoteId:u,baseNumericId:f,quoteNumericId:p,info:s,precision:{amount:h,price:this.safeInteger(o,"tailDigits")},limits:{amount:{min:this.safeFloat(s,"minOrderQuantity"),max:this.safeFloat(s,"maxOrderQuantity")},price:{min:0,max:void 0},cost:{min:0,max:void 0}}})}return i}parseTicker(e,t){const i=Object.keys(e)[0],s=this.safeInteger({a:i},"a");e=e[i];const r=this.markets_by_id[s].symbol,a=this.safeFloat(e,"last"),o=this.safeInteger(e,"time")/1e3;return{symbol:r,timestamp:o,datetime:this.iso8601(o),high:this.safeFloat(e,"high24"),low:this.safeFloat(e,"low24"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:this.safeFloat(e,"change"),percentage:void 0,average:void 0,baseVolume:this.safeFloat(e,"volume24"),quoteVolume:this.safeFloat(e,"volume24converted"),info:e}}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={instrumentIds:[i.numericId],currencyId:i.quoteNumericId},r=await this.publicPostAssetManagementGetTicker(this.extend(s,t));return this.parseTicker(r.result.tickers,i)}parseOHLCV(e,t,i="1m",s,r){return[this.safeTimestamp(e,"date"),this.safeFloat(e,"open"),this.safeFloat(e,"high"),this.safeFloat(e,"low"),this.safeFloat(e,"close"),this.safeFloat(e,"volume")]}async fetchOHLCV(e,t="1m",i,s,r={}){await this.loadMarkets();const a=this.market(e),o={timestampFrom:i,timestampTill:void 0,instrumentId:a.numericId,type:this.timeframes[t],pagination:{limit:s,offset:0}},n=await this.publicPostAssetManagementHistory(this.extend(o,r));return this.parseOHLCVs(n.result.assets,a,t,i,s)}async fetchOpenOrders(e,t,i,s={}){await this.loadMarkets();const r={pagination:{limit:i,offset:0}};let a=void 0;void 0!==e&&(a=this.market(e),r.instrumentId=a.numericId);const o=await this.privatePostOrderManagementOpenOrders(this.extend(r,s));return this.parseOrders(o.result.orders,a,t,i)}async fetchClosedOrders(e,t,i,s={}){await this.loadMarkets();const r={pagination:{limit:i,offset:0}};let a=void 0;void 0!==e&&(a=this.market(e),r.instrumentId=a.numericId);const o=await this.privatePostOrderManagementOrderHistory(this.extend(r,s));return this.parseOrders(o.result.ordersForHistory,a,t,i)}parseOrder(e,t){let i={1:"open"};const s=this.safeValue(e,"order",void 0);void 0!==s&&(e=s,i={1:"closed",2:"canceled"});let r="buy";e.direction===this.options.orderSide.sell&&(r="sell");let a=void 0;const o=this.safeString(e,"status",void 0);o in i&&(a=i[o]);const n=this.safeString(e,"instrumentId");let d=void 0;n in this.markets_by_id&&(d=this.markets_by_id[n].symbol);let c="limit";e.orderType===this.options.orderTypes.market&&(c="market");const h=this.safeTimestamp(e,"time"),l=this.objectToNumber(e.quantity),u=this.objectToNumber(e.filledQuantity);return{info:e,id:this.safeString(e,"externalOrderId"),timestamp:h,datetime:this.iso8601(h),lastTradeTimestamp:void 0,symbol:d,type:c,side:r,price:this.objectToNumber(e.price),average:void 0,amount:l,remaining:l-u,filled:u,status:a,fee:void 0}}parseBidAsk(e,t=0,i=1){return[this.objectToNumber(e[t]),this.objectToNumber(e[i])]}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={instrumentId:this.market(e).numericId},r=await this.publicPostOrderManagementGetOrderBook(this.extend(s,i)),a=this.safeValue(r,"result");return this.parseOrderBook(a,void 0,"sell","buy","price","qty")}async signIn(e={}){this.checkRequiredCredentials();const t={token:this.apiKey,secret:this.secret},i=await this.publicPostAuthorizationLoginByToken(this.extend(t,e)),s=i.result.expiry;return this.options.expires=this.sum(this.milliseconds(),1e3*s),this.options.accessToken=i.result.token,i}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostBalanceGet(e),i={info:t},s=this.safeValue(t.result,"balance"),r=Object.keys(s);for(let e=0;e<r.length;e++){const t=r[e],a=this.safeValue(s,t,{}),o=this.safeCurrencyCode(t),n={free:this.safeFloat(a,"available"),used:this.safeFloat(a,"frozen"),total:this.safeFloat(a,"total")};i[o]=n}return this.parseBalance(i)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o={direction:this.safeInteger(this.options.orderSide,i),instrumentId:this.market(e).numericId,orderType:2,quantity:this.numberToObject(s)};o.orderType=this.options.orderTypes[t],"limit"===t&&(o.price=this.numberToObject(r));const n={order:o},d=await this.privatePostOrderManagementCreate(this.extend(n,a));return{info:d,id:d.result.externalOrderId}}async cancelOrder(e,t,i={}){const s={externalOrderId:e};return await this.privatePostOrderManagementCancel(this.extend(s,i))}sign(e,t="public",i="GET",s={},r,a){if(Array.isArray(s)){0===s.length&&(s={__associative:!0})}const n={jsonrpc:"2.0",id:this.milliseconds(),method:e,params:[s]};let d=this.urls.api;if(r={"Content-Type":"application/json-rpc"},"GET"===i?Object.keys(n).length&&(d+="?"+this.urlencode(n)):a=this.json(n),"private"===t){const t=this.safeString(this.options,"accessToken");if(void 0===t)throw new o(this.id+" "+e+" endpoint requires a prior call to signIn() method");const i=this.safeInteger(this.options,"expires");if(void 0!==i&&this.milliseconds()>=i)throw new o(this.id+" accessToken expired, call signIn() method");r.Authorization=t}return{url:d,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,o,n,d,c){if(!n)return;const h=n.error;if(h){const e=this.id+" "+this.json(n),t=this.exceptions.exact;if(h in t)throw new t[h](e);const i=this.exceptions.broad,s=this.findBroadlyMatchedKey(i,h);if(void 0!==s)throw new i[s](e);throw new r(e)}}}},function(e,t,i){"use strict";const s=i(1),{ArgumentsRequired:r,ExchangeError:a,ExchangeNotAvailable:o,OrderNotFound:n,AuthenticationError:d,InsufficientFunds:c,InvalidOrder:h,InvalidNonce:l,NotSupported:u}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"exmo",name:"EXMO",countries:["ES","RU"],rateLimit:350,version:"v1",has:{CORS:!1,fetchClosedOrders:"emulated",fetchDepositAddress:!0,fetchOpenOrders:!0,fetchOrder:"emulated",fetchOrders:"emulated",fetchOrderTrades:!0,fetchOrderBooks:!0,fetchMyTrades:!0,fetchTickers:!0,withdraw:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchFundingFees:!0,fetchCurrencies:!0,fetchTransactions:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766491-1b0ea956-5eda-11e7-9225-40d67b481b8d.jpg",api:{public:"https://api.exmo.com",private:"https://api.exmo.com",web:"https://exmo.me"},www:"https://exmo.me",referral:"https://exmo.me/?ref=131685",doc:["https://exmo.me/en/api_doc?ref=131685","https://github.com/exmo-dev/exmo_api_lib/tree/master/nodejs"],fees:"https://exmo.com/en/docs/fees"},api:{web:{get:["ctrl/feesAndLimits","en/docs/fees"]},public:{get:["currency","order_book","pair_settings","ticker","trades"]},private:{post:["user_info","order_create","order_cancel","user_open_orders","user_trades","user_cancelled_orders","order_trades","required_amount","deposit_address","withdraw_crypt","withdraw_get_txid","excode_create","excode_load","wallet_history"]}},fees:{trading:{tierBased:!1,percentage:!0,maker:.002,taker:.002},funding:{tierBased:!1,percentage:!1}},options:{useWebapiForFetchingFees:!1,feesAndLimits:{success:1,ctlr:"feesAndLimits",error:"",data:{limits:[{pair:"BTC/USD",min_q:"0.001",max_q:"1000",min_p:"1",max_p:"30000",min_a:"1",max_a:"500000"},{pair:"BTC/EUR",min_q:"0.001",max_q:"1000",min_p:"1",max_p:"30000",min_a:"1",max_a:"500000"},{pair:"BTC/RUB",min_q:"0.001",max_q:"1000",min_p:"1",max_p:"2000000",min_a:"10",max_a:"50000000"},{pair:"BTC/UAH",min_q:"0.001",max_q:"1000",min_p:"1",max_p:"1500000",min_a:"10",max_a:"15000000"},{pair:"BTC/PLN",min_q:"0.001",max_q:"1000",min_p:"0.001",max_p:"90000",min_a:"1",max_a:"2000000"},{pair:"BTC/TRY",min_q:"0.001",max_q:"1000",min_p:"1",max_p:"800000",min_a:"40",max_a:"6000000"},{pair:"ROOBEE/BTC",min_q:"1",max_q:"1000000",min_p:"0.00000001",max_p:"100",min_a:"0.0001",max_a:"10"},{pair:"ROOBEE/ETH",min_q:"1",max_q:"1000000",min_p:"0.000001",max_p:"100",min_a:"0.001",max_a:"100"},{pair:"USDC/BTC",min_q:"1",max_q:"500000",min_p:"0.00000001",max_p:"1",min_a:"0.0001",max_a:"100"},{pair:"USDC/ETH",min_q:"1",max_q:"500000",min_p:"0.0000001",max_p:"100",min_a:"0.001",max_a:"1000"},{pair:"USDC/USD",min_q:"1",max_q:"500000",min_p:"0.0001",max_p:"1000",min_a:"3",max_a:"500000"},{pair:"USDC/USDT",min_q:"1",max_q:"500000",min_p:"0.0001",max_p:"1000",min_a:"3",max_a:"500000"},{pair:"ETZ/BTC",min_q:"1",max_q:"1000000",min_p:"0.00000001",max_p:"1",min_a:"0.0001",max_a:"10"},{pair:"ETZ/ETH",min_q:"1",max_q:"1000000",min_p:"0.00000001",max_p:"100",min_a:"0.001",max_a:"100"},{pair:"ETZ/USDT",min_q:"1",max_q:"1000000",min_p:"0.000001",max_p:"1000",min_a:"0.01",max_a:"1000"},{pair:"PTI/BTC",min_q:"1",max_q:"100000000",min_p:"0.00000001",max_p:"1",min_a:"0.000001",max_a:"10"},{pair:"PTI/USDT",min_q:"1",max_q:"10000000",min_p:"0.000001",max_p:"10000",min_a:"0.01",max_a:"100000"},{pair:"PTI/EOS",min_q:"1",max_q:"10000000",min_p:"0.0000001",max_p:"5000",min_a:"0.01",max_a:"20000"},{pair:"ATMCASH/BTC",min_q:"10",max_q:"10000000",min_p:"0.00000001",max_p:"1",min_a:"0.000001",max_a:"10"},{pair:"TRX/UAH",min_q:"0.01",max_q:"10000000",min_p:"0.000001",max_p:"100000",min_a:"0.1",max_a:"50000000"},{pair:"ETH/TRY",min_q:"0.01",max_q:"5000",min_p:"0.1",max_p:"80000",min_a:"10",max_a:"6000000"},{pair:"XRP/TRY",min_q:"1",max_q:"100000",min_p:"0.0001",max_p:"1000",min_a:"0.01",max_a:"6000000"},{pair:"XLM/TRY",min_q:"0.01",max_q:"200000",min_p:"0.00001",max_p:"100000",min_a:"0.1",max_a:"6000000"},{pair:"MNC/BTC",min_q:"10",max_q:"100000000",min_p:"0.00000001",max_p:"1",min_a:"0.000001",max_a:"100"},{pair:"MNC/ETH",min_q:"10",max_q:"100000000",min_p:"0.0000001",max_p:"10",min_a:"0.00001",max_a:"1000"},{pair:"MNC/USD",min_q:"10",max_q:"100000000",min_p:"0.000001",max_p:"10000",min_a:"0.01",max_a:"100000"},{pair:"DAI/BTC",min_q:"1",max_q:"500000",min_p:"0.0000001",max_p:"0.1",min_a:"0.00001",max_a:"100"},{pair:"DAI/ETH",min_q:"1",max_q:"500000",min_p:"0.000001",max_p:"10",min_a:"0.0001",max_a:"5000"},{pair:"DAI/USD",min_q:"1",max_q:"500000",min_p:"0.001",max_p:"1000",min_a:"0.1",max_a:"500000"},{pair:"DAI/RUB",min_q:"1",max_q:"500000",min_p:"0.01",max_p:"100000",min_a:"0.5",max_a:"30000000"},{pair:"MKR/BTC",min_q:"0.001",max_q:"1000",min_p:"0.0001",max_p:"100",min_a:"0.000001",max_a:"100"},{pair:"MKR/DAI",min_q:"0.001",max_q:"1000",min_p:"0.5",max_p:"500000",min_a:"0.005",max_a:"500000"},{pair:"QTUM/BTC",min_q:"0.1",max_q:"200000",min_p:"0.00000001",max_p:"1",min_a:"0.0001",max_a:"100"},{pair:"QTUM/ETH",min_q:"0.1",max_q:"200000",min_p:"0.00000001",max_p:"100",min_a:"0.001",max_a:"5000"},{pair:"QTUM/USD",min_q:"0.1",max_q:"200000",min_p:"0.00000001",max_p:"10000",min_a:"0.1",max_a:"500000"},{pair:"HB/BTC",min_q:"10",max_q:"100000000",min_p:"0.00000001",max_p:"1",min_a:"0.000001",max_a:"100"},{pair:"SMART/BTC",min_q:"10",max_q:"10000000",min_p:"0.0000001",max_p:"1",min_a:"0.00001",max_a:"100"},{pair:"SMART/USD",min_q:"10",max_q:"10000000",min_p:"0.00001",max_p:"1000",min_a:"1",max_a:"500000"},{pair:"SMART/EUR",min_q:"10",max_q:"10000000",min_p:"0.00001",max_p:"1000",min_a:"1",max_a:"500000"},{pair:"SMART/RUB",min_q:"10",max_q:"10000000",min_p:"0.000001",max_p:"100000",min_a:"10",max_a:"50000000"},{pair:"XEM/BTC",min_q:"10",max_q:"5000000",min_p:"0.0000001",max_p:"1",min_a:"0.00015",max_a:"100"},{pair:"XEM/USD",min_q:"10",max_q:"5000000",min_p:"0.00001",max_p:"1000",min_a:"0.1",max_a:"500000"},{pair:"XEM/EUR",min_q:"10",max_q:"5000000",min_p:"0.00001",max_p:"1000",min_a:"0.1",max_a:"500000"},{pair:"GUSD/BTC",min_q:"1",max_q:"500000",min_p:"0.00000001",max_p:"1",min_a:"0.0015",max_a:"100"},{pair:"GUSD/USD",min_q:"1",max_q:"500000",min_p:"0.1",max_p:"10",min_a:"0.1",max_a:"500000"},{pair:"GUSD/RUB",min_q:"1",max_q:"500000",min_p:"0.01",max_p:"1000",min_a:"10",max_a:"50000000"},{pair:"LSK/BTC",min_q:"1",max_q:"200000",min_p:"0.0000001",max_p:"1",min_a:"0.0015",max_a:"100"},{pair:"LSK/USD",min_q:"1",max_q:"200000",min_p:"0.1",max_p:"1000",min_a:"1",max_a:"500000"},{pair:"LSK/RUB",min_q:"1",max_q:"200000",min_p:"0.001",max_p:"100000",min_a:"0.5",max_a:"50000000"},{pair:"NEO/BTC",min_q:"0.01",max_q:"200000",min_p:"0.00000001",max_p:"1",min_a:"0.001",max_a:"100"},{pair:"NEO/USD",min_q:"0.01",max_q:"200000",min_p:"0.01",max_p:"50000",min_a:"0.1",max_a:"500000"},{pair:"NEO/RUB",min_q:"0.01",max_q:"200000",min_p:"0.001",max_p:"1500000",min_a:"50",max_a:"50000000"},{pair:"ADA/BTC",min_q:"0.01",max_q:"10000000",min_p:"0.00000001",max_p:"1",min_a:"0.001",max_a:"100"},{pair:"ADA/USD",min_q:"0.01",max_q:"10000000",min_p:"0.0001",max_p:"1000",min_a:"0.01",max_a:"500000"},{pair:"ADA/ETH",min_q:"0.01",max_q:"10000000",min_p:"0.00000001",max_p:"10",min_a:"0.001",max_a:"5000"},{pair:"ZRX/BTC",min_q:"0.01",max_q:"10000000",min_p:"0.00000001",max_p:"1",min_a:"0.001",max_a:"100"},{pair:"ZRX/ETH",min_q:"0.01",max_q:"10000000",min_p:"0.00000001",max_p:"10",min_a:"0.01",max_a:"5000"},{pair:"GNT/BTC",min_q:"0.01",max_q:"10000000",min_p:"0.00000001",max_p:"1",min_a:"0.001",max_a:"100"},{pair:"GNT/ETH",min_q:"0.01",max_q:"10000000",min_p:"0.00000001",max_p:"10",min_a:"0.01",max_a:"5000"},{pair:"TRX/BTC",min_q:"0.01",max_q:"10000000",min_p:"0.00000001",max_p:"1",min_a:"0.001",max_a:"100"},{pair:"TRX/USD",min_q:"0.01",max_q:"10000000",min_p:"0.0001",max_p:"1000",min_a:"0.01",max_a:"500000"},{pair:"TRX/RUB",min_q:"0.01",max_q:"10000000",min_p:"0.000001",max_p:"100000",min_a:"0.1",max_a:"50000000"},{pair:"GAS/BTC",min_q:"0.01",max_q:"10000000",min_p:"0.00000001",max_p:"1",min_a:"0.001",max_a:"100"},{pair:"GAS/USD",min_q:"0.01",max_q:"10000000",min_p:"0.01",max_p:"50000",min_a:"0.1",max_a:"500000"},{pair:"INK/BTC",min_q:"0.01",max_q:"10000000",min_p:"0.00000001",max_p:"1",min_a:"0.001",max_a:"100"},{pair:"INK/ETH",min_q:"0.01",max_q:"10000000",min_p:"0.00000001",max_p:"10",min_a:"0.001",max_a:"5000"},{pair:"INK/USD",min_q:"0.01",max_q:"10000000",min_p:"0.00001",max_p:"1000",min_a:"0.01",max_a:"500000"},{pair:"MNX/BTC",min_q:"0.01",max_q:"10000000",min_p:"0.00000001",max_p:"1",min_a:"0.001",max_a:"100"},{pair:"MNX/ETH",min_q:"0.01",max_q:"10000000",min_p:"0.00000001",max_p:"10",min_a:"0.01",max_a:"5000"},{pair:"MNX/USD",min_q:"0.01",max_q:"10000000",min_p:"0.01",max_p:"1000",min_a:"0.5",max_a:"500000"},{pair:"OMG/BTC",min_q:"0.01",max_q:"100000",min_p:"0.00000001",max_p:"1",min_a:"0.001",max_a:"100"},{pair:"OMG/ETH",min_q:"0.01",max_q:"100000",min_p:"0.00000001",max_p:"10",min_a:"0.01",max_a:"5000"},{pair:"OMG/USD",min_q:"0.01",max_q:"100000",min_p:"0.01",max_p:"1000",min_a:"0.5",max_a:"500000"},{pair:"XLM/BTC",min_q:"0.01",max_q:"200000",min_p:"0.00000001",max_p:"1",min_a:"0.001",max_a:"100"},{pair:"XLM/USD",min_q:"0.01",max_q:"200000",min_p:"0.001",max_p:"1000",min_a:"0.01",max_a:"500000"},{pair:"XLM/RUB",min_q:"0.01",max_q:"200000",min_p:"0.00001",max_p:"100000",min_a:"0.1",max_a:"50000000"},{pair:"EOS/BTC",min_q:"0.01",max_q:"100000",min_p:"0.00000001",max_p:"1",min_a:"0.001",max_a:"100"},{pair:"EOS/USD",min_q:"0.01",max_q:"100000",min_p:"0.01",max_p:"1000",min_a:"0.5",max_a:"500000"},{pair:"BTG/BTC",min_q:"0.01",max_q:"200000",min_p:"0.00000001",max_p:"1",min_a:"0.001",max_a:"100"},{pair:"BTG/USD",min_q:"0.01",max_q:"200000",min_p:"0.001",max_p:"1000",min_a:"3",max_a:"500000"},{pair:"DXT/BTC",min_q:"100",max_q:"10000000",min_p:"0.00000001",max_p:"1",min_a:"0.0001",max_a:"100"},{pair:"DXT/USD",min_q:"100",max_q:"10000000",min_p:"0.0001",max_p:"1000",min_a:"0.1",max_a:"500000"},{pair:"BTCZ/BTC",min_q:"100",max_q:"100000000",min_p:"0.00000001",max_p:"1",min_a:"0.1",max_a:"100"},{pair:"BCH/BTC",min_q:"0.003",max_q:"10000",min_p:"0.00000001",max_p:"5",min_a:"0.0001",max_a:"100"},{pair:"BCH/USD",min_q:"0.003",max_q:"10000",min_p:"0.00000001",max_p:"30000",min_a:"0.0001",max_a:"500000"},{pair:"BCH/RUB",min_q:"0.003",max_q:"10000",min_p:"0.00000001",max_p:"2000000",min_a:"0.0001",max_a:"50000000"},{pair:"BCH/ETH",min_q:"0.003",max_q:"10000",min_p:"0.0000001",max_p:"200",min_a:"0.0001",max_a:"5000"},{pair:"DASH/BTC",min_q:"0.01",max_q:"200000",min_p:"0.001",max_p:"1",min_a:"0.001",max_a:"100"},{pair:"DASH/USD",min_q:"0.01",max_q:"200000",min_p:"0.01",max_p:"10000",min_a:"3",max_a:"500000"},{pair:"DASH/RUB",min_q:"0.01",max_q:"200000",min_p:"0.01",max_p:"100000",min_a:"150",max_a:"50000000"},{pair:"ETH/BTC",min_q:"0.001",max_q:"5000",min_p:"0.00000001",max_p:"10",min_a:"0.001",max_a:"100"},{pair:"ETH/LTC",min_q:"0.01",max_q:"5000",min_p:"0.001",max_p:"1000",min_a:"0.1",max_a:"100000"},{pair:"ETH/USD",min_q:"0.01",max_q:"5000",min_p:"0.01",max_p:"100000",min_a:"3",max_a:"500000"},{pair:"ETH/EUR",min_q:"0.01",max_q:"5000",min_p:"0.001",max_p:"10000",min_a:"1",max_a:"500000"},{pair:"ETH/RUB",min_q:"0.01",max_q:"5000",min_p:"0.001",max_p:"100000",min_a:"1",max_a:"50000000"},{pair:"ETH/UAH",min_q:"0.01",max_q:"5000",min_p:"0.01",max_p:"1000000",min_a:"90",max_a:"15000000"},{pair:"ETH/PLN",min_q:"0.001",max_q:"5000",min_p:"0.001",max_p:"8000",min_a:"1",max_a:"2000000"},{pair:"ETC/BTC",min_q:"0.2",max_q:"1000",min_p:"0.0001",max_p:"0.5",min_a:"0.001",max_a:"100"},{pair:"ETC/USD",min_q:"0.2",max_q:"1000",min_p:"0.01",max_p:"10000",min_a:"0.01",max_a:"500000"},{pair:"ETC/RUB",min_q:"0.2",max_q:"1000",min_p:"0.01",max_p:"10000",min_a:"0.01",max_a:"50000000"},{pair:"LTC/BTC",min_q:"0.05",max_q:"1000000",min_p:"0.00000001",max_p:"1",min_a:"0.001",max_a:"100"},{pair:"LTC/USD",min_q:"0.05",max_q:"1000000",min_p:"0.01",max_p:"10000",min_a:"3",max_a:"500000"},{pair:"LTC/EUR",min_q:"0.05",max_q:"1000000",min_p:"0.01",max_p:"10000",min_a:"3",max_a:"500000"},{pair:"LTC/RUB",min_q:"0.05",max_q:"1000000",min_p:"0.01",max_p:"100000",min_a:"150",max_a:"50000000"},{pair:"ZEC/BTC",min_q:"0.01",max_q:"1000",min_p:"0.001",max_p:"10",min_a:"0.001",max_a:"100"},{pair:"ZEC/USD",min_q:"0.01",max_q:"1000",min_p:"0.001",max_p:"5000",min_a:"0.1",max_a:"500000"},{pair:"ZEC/EUR",min_q:"0.01",max_q:"1000",min_p:"0.001",max_p:"5000",min_a:"0.1",max_a:"500000"},{pair:"ZEC/RUB",min_q:"0.01",max_q:"1000",min_p:"0.001",max_p:"100000",min_a:"0.1",max_a:"50000000"},{pair:"XRP/BTC",min_q:"1",max_q:"100000",min_p:"0.0000001",max_p:"1",min_a:"0.00001",max_a:"100"},{pair:"XRP/USD",min_q:"1",max_q:"100000",min_p:"0.001",max_p:"1000",min_a:"0.001",max_a:"500000"},{pair:"XRP/RUB",min_q:"1",max_q:"100000",min_p:"0.000001",max_p:"1000",min_a:"0.01",max_a:"50000000"},{pair:"XMR/BTC",min_q:"0.03",max_q:"1000",min_p:"0.001",max_p:"1",min_a:"0.001",max_a:"100"},{pair:"XMR/USD",min_q:"0.03",max_q:"1000",min_p:"0.001",max_p:"1000",min_a:"0.1",max_a:"500000"},{pair:"XMR/EUR",min_q:"0.03",max_q:"1000",min_p:"0.001",max_p:"1000",min_a:"0.1",max_a:"500000"},{pair:"BTC/USDT",min_q:"0.001",max_q:"1000",min_p:"0.01",max_p:"30000",min_a:"3",max_a:"500000"},{pair:"ETH/USDT",min_q:"0.01",max_q:"5000",min_p:"0.01",max_p:"100000",min_a:"3",max_a:"500000"},{pair:"USDT/USD",min_q:"1",max_q:"500000",min_p:"0.5",max_p:"10",min_a:"0.1",max_a:"500000"},{pair:"USDT/RUB",min_q:"1",max_q:"500000",min_p:"0.01",max_p:"1000",min_a:"10",max_a:"50000000"},{pair:"USD/RUB",min_q:"1",max_q:"500000",min_p:"0.01",max_p:"1000",min_a:"10",max_a:"50000000"},{pair:"DOGE/BTC",min_q:"100",max_q:"100000000",min_p:"0.0000001",max_p:"1",min_a:"0.0001",max_a:"100"},{pair:"WAVES/BTC",min_q:"0.5",max_q:"10000",min_p:"0.0001",max_p:"1",min_a:"0.0001",max_a:"100"},{pair:"WAVES/RUB",min_q:"0.5",max_q:"10000",min_p:"1",max_p:"10000",min_a:"1",max_a:"50000000"},{pair:"KICK/BTC",min_q:"100",max_q:"10000000",min_p:"0.0000001",max_p:"0.1",min_a:"0.00001",max_a:"100"},{pair:"KICK/ETH",min_q:"100",max_q:"10000000",min_p:"0.000001",max_p:"1",min_a:"0.0001",max_a:"5000"},{pair:"KICK/USDT",min_q:"100",max_q:"10000000",min_p:"0.00000001",max_p:"1000",min_a:"0.01",max_a:"100000"},{pair:"EOS/EUR",min_q:"0.01",max_q:"100000",min_p:"0.001",max_p:"1000",min_a:"0.5",max_a:"500000"},{pair:"BCH/EUR",min_q:"0.003",max_q:"100000",min_p:"0.01",max_p:"300000",min_a:"3",max_a:"500000"},{pair:"XRP/EUR",min_q:"1",max_q:"100000",min_p:"0.001",max_p:"1000",min_a:"0.001",max_a:"500000"},{pair:"XRP/UAH",min_q:"1",max_q:"100000",min_p:"0.0001",max_p:"1000",min_a:"0.01",max_a:"15000000"},{pair:"XEM/UAH",min_q:"1",max_q:"5000000",min_p:"0.0001",max_p:"30000",min_a:"10",max_a:"15000000"},{pair:"BCH/USDT",min_q:"0.003",max_q:"100000",min_p:"0.01",max_p:"5000",min_a:"3",max_a:"500000"},{pair:"DASH/USDT",min_q:"0.01",max_q:"100000",min_p:"0.01",max_p:"5000",min_a:"3",max_a:"500000"},{pair:"BCH/UAH",min_q:"0.003",max_q:"100000",min_p:"0.1",max_p:"30000",min_a:"10",max_a:"15000000"},{pair:"XRP/USDT",min_q:"1",max_q:"100000",min_p:"0.001",max_p:"1000",min_a:"0.001",max_a:"500000"},{pair:"USDT/UAH",min_q:"0.01",max_q:"100000",min_p:"1",max_p:"3000",min_a:"2",max_a:"15000000"},{pair:"USDT/EUR",min_q:"0.01",max_q:"100000",min_p:"0.1",max_p:"10",min_a:"0.1",max_a:"500000"},{pair:"ZRX/USD",min_q:"0.01",max_q:"10000000",min_p:"0.00001",max_p:"1000",min_a:"0.1",max_a:"500000"},{pair:"BTG/ETH",min_q:"0.01",max_q:"200000",min_p:"0.0001",max_p:"100",min_a:"0.01",max_a:"5000"},{pair:"WAVES/USD",min_q:"0.5",max_q:"10000",min_p:"0.001",max_p:"3500",min_a:"0.5",max_a:"500000"},{pair:"DOGE/USD",min_q:"100",max_q:"1000000000",min_p:"0.0000001",max_p:"1000",min_a:"0.01",max_a:"500000"},{pair:"XRP/ETH",min_q:"1",max_q:"100000",min_p:"0.00000001",max_p:"10",min_a:"0.00001",max_a:"5000"},{pair:"DASH/UAH",min_q:"0.01",max_q:"200000",min_p:"0.01",max_p:"200000",min_a:"10",max_a:"15000000"},{pair:"XMR/ETH",min_q:"0.03",max_q:"1000",min_p:"0.00000001",max_p:"100",min_a:"0.001",max_a:"5000"},{pair:"WAVES/ETH",min_q:"0.5",max_q:"10000",min_p:"0.00001",max_p:"30",min_a:"0.0035",max_a:"3500"},{pair:"DCR/BTC",min_q:"0.01",max_q:"50000",min_p:"0.00000001",max_p:"1",min_a:"0.001",max_a:"100"},{pair:"DCR/RUB",min_q:"0.01",max_q:"50000",min_p:"0.00001",max_p:"100000",min_a:"0.5",max_a:"3000000"},{pair:"DCR/UAH",min_q:"0.01",max_q:"50000",min_p:"0.00001",max_p:"100000",min_a:"0.25",max_a:"1000000"},{pair:"ZAG/BTC",min_q:"1",max_q:"10000000",min_p:"0.00000001",max_p:"0.1",min_a:"0.00001",max_a:"100"},{pair:"EXM/BTC",min_q:"1",max_q:"157022513",min_p:"0.0000009",max_p:"0.0000009",min_a:"0.000001",max_a:"141"}],fees:[{group:"crypto",title:"",items:[{prov:"EXM",dep:"0%",wd:"-"},{prov:"BTC",dep:"0%",wd:"0.0005 BTC"},{prov:"LTC",dep:"0%",wd:"0.01 LTC"},{prov:"DOGE",dep:"0%",wd:"1 DOGE"},{prov:"DASH",dep:"0%",wd:"0.01 DASH"},{prov:"ETH",dep:"0%",wd:"0.01 ETH"},{prov:"WAVES",dep:"0%",wd:"0.001 WAVES"},{prov:"ZEC",dep:"0%",wd:"0.001 ZEC"},{prov:"USDT",dep:"0%",wd:"5 USDT"},{prov:"XMR",dep:"0%",wd:"0.05 XMR"},{prov:"XRP",dep:"0%",wd:"0.02 XRP"},{prov:"KICK",dep:"0 KICK",wd:"50 KICK"},{prov:"ETC",dep:"0%",wd:"0.01 ETC"},{prov:"BCH",dep:"0%",wd:"0.001 BCH"},{prov:"BTG",dep:"0%",wd:"0.001 BTG"},{prov:"EOS",dep:"0%",wd:"0.05 EOS"},{prov:"BTCZ",dep:"0%",wd:"5 BTCZ"},{prov:"DXT",dep:"20 DXT",wd:"20 DXT"},{prov:"XLM",dep:"0%",wd:"0.01 XLM"},{prov:"MNX",dep:"0%",wd:"0.01 MNX"},{prov:"OMG",dep:"0.1 OMG",wd:"0.5 OMG"},{prov:"TRX",dep:"0%",wd:"1 TRX"},{prov:"ADA",dep:"0%",wd:"1 ADA"},{prov:"INK",dep:"10 INK",wd:"50 INK"},{prov:"NEO",dep:"0%",wd:"0%"},{prov:"GAS",dep:"0%",wd:"0%"},{prov:"ZRX",dep:"0%",wd:"1 ZRX"},{prov:"GNT",dep:"0%",wd:"1 GNT"},{prov:"GUSD",dep:"0%",wd:"0.5 GUSD"},{prov:"LSK",dep:"0%",wd:"0.1 LSK"},{prov:"XEM",dep:"0%",wd:"5 XEM"},{prov:"SMART",dep:"0%",wd:"0.5 SMART"},{prov:"QTUM",dep:"0%",wd:"0.01 QTUM"},{prov:"HB",dep:"0%",wd:"10 HB"},{prov:"DAI",dep:"0%",wd:"1 DAI"},{prov:"MKR",dep:"0%",wd:"0.005 MKR"},{prov:"MNC",dep:"0%",wd:"15 MNC"},{prov:"PTI",dep:"0%",wd:"10 PTI"},{prov:"ATMCASH",dep:"0%",wd:"5 ATMCASH"},{prov:"ETZ",dep:"0%",wd:"1 ETZ"},{prov:"USDC",dep:"0%",wd:"0.5 USDC"},{prov:"ROOBEE",dep:"0%",wd:"0%"},{prov:"DCR",dep:"0%",wd:"0.01 DCR"},{prov:"ZAG",dep:"0%",wd:"0%"}]},{group:"usd",title:"USD",items:[{prov:"Payeer",dep:"3.95%",wd:"-"},{prov:"EX-CODE",dep:"",wd:"0.2%"},{prov:"Perfect Money",dep:"-",wd:"0.5%"},{prov:"AdvCash",dep:"3.45%",wd:"2.95%"},{prov:"Visa",dep:"3.45%",wd:"-"},{prov:"CryptoCapital",dep:"-",wd:"0.45%"},{prov:"Visa/MasterCard (Simplex)",dep:"4.5%",wd:"-"}]},{group:"eur",title:"EUR",items:[{prov:"Visa",dep:"3.45%",wd:"-"},{prov:"CryptoCapital",dep:"-",wd:"0.45%"},{prov:"AdvCash",dep:"0.45%",wd:"-"},{prov:"Wire Transfer",dep:"6.95 EUR",wd:"-"},{prov:"SEPA",dep:"6.95 EUR",wd:"-"},{prov:"Visa/MasterCard (Simplex)",dep:"4.5%",wd:"-"},{prov:"Payeer",dep:"3.95%",wd:"-"},{prov:"EX-CODE",dep:"",wd:"0.2%"}]},{group:"rub",title:"RUB",items:[{prov:"Yandex Money",dep:"2.95%",wd:"1.95%"},{prov:"Payeer",dep:"3.95%",wd:"-"},{prov:"AdvCash",dep:"3.95%",wd:"0.95%"},{prov:"Qiwi",dep:"3.95%",wd:"2.95%"},{prov:"Visa/MasterCard",dep:"3.95%",wd:"4.95% + 60 RUB"},{prov:"WebMoney",dep:"-",wd:"3.5%"},{prov:"EX-CODE",dep:"",wd:"0.2%"}]},{group:"pln",title:"PLN",items:[{prov:"CryptoCapital",dep:"-",wd:"0.45%"},{prov:"Visa/MasterCard (Simplex)",dep:"4.5%",wd:"-"},{prov:"EX-CODE",dep:"",wd:"0.2%"}]},{group:"try",title:"TRY",items:[{prov:"QR ile yatrma",dep:"5.95%",wd:"-"},{prov:"Visa",dep:"3.45%",wd:"-"},{prov:"EX-CODE",dep:"",wd:"0.2%"}]},{group:"uah",title:"UAH",items:[{prov:"Terminal",dep:"2.6%",wd:"-"},{prov:"EX-CODE",dep:"",wd:"0.2%"},{prov:"AdvCash",dep:"-",wd:"2.95%"},{prov:"Visa/MasterCard",dep:"2.6%",wd:"3.95% + 20 UAH"},{prov:"Enfins",dep:"0%",wd:"1.95%"}]}]}}},exceptions:{40005:d,40009:l,40015:a,40016:o,40017:d,50052:c,50054:c,50304:n,50173:n,50319:h,50321:h}})}async fetchTradingFees(e={}){if(this.options.useWebapiForFetchingFees){let t=(await this.webGetEnDocsFees(e)).split('<td class="th_fees_2" colspan="2">'),i=t.length;if(2!==i)throw new u(this.id+" fetchTradingFees format has changed");if((i=(t=t[1].split("</td>")).length)<2)throw new u(this.id+" fetchTradingFees format has changed");const s=.01*parseFloat(t[0].replace("%",""));return{maker:s,taker:s}}return{maker:this.fees.trading.maker,taker:this.fees.trading.taker}}parseFixedFloatValue(e){if(void 0===e||"-"===e)return;const t=e.indexOf("%")>=0,i=e.split(" ")[0].replace("%",""),s=parseFloat(i);if(s>0&&t)throw new a(this.id+" parseFixedFloatValue detected an unsupported non-zero percentage-based fee "+e);return s}async fetchFundingFees(e={}){let t=void 0;t=this.options.useWebapiForFetchingFees?await this.webGetCtrlFeesAndLimits(e):this.options.feesAndLimits;const i={},s={},r=this.safeValue(t.data,"fees"),a=this.indexBy(r,"group"),o=a.crypto.items;for(let e=0;e<o.length;e++){const t=o[e],r=this.safeCurrencyCode(this.safeString(t,"prov")),a=this.safeString(t,"wd"),n=this.safeString(t,"dep");void 0!==a&&a.length>0&&(i[r]=this.parseFixedFloatValue(a)),void 0!==n&&n.length>0&&(s[r]=this.parseFixedFloatValue(n))}const n=this.toArray(this.omit(a,"crypto"));for(let e=0;e<n.length;e++){const t=this.safeCurrencyCode(this.safeString(n[e],"title"));i[t]=void 0,s[t]=void 0}const d={info:t,withdraw:i,deposit:s};return this.options.fundingFees=d,d}async fetchCurrencies(e={}){const t=await this.fetchFundingFees(e),i=Object.keys(t.withdraw),s=this.indexBy(t.info.data.limits,"pair"),r=Object.keys(s),a={},o={},n={},d={},c={},h={};for(let e=0;e<r.length;e++){const t=r[e],i=s[t],[l,u]=t.split("/"),f=this.safeCurrencyCode(l),p=this.safeCurrencyCode(u),m=this.safeFloat(i,"max_q"),y=this.safeFloat(i,"max_p"),b=this.safeFloat(i,"max_a"),v=this.safeFloat(i,"min_q"),g=this.safeFloat(i,"min_p"),w=this.safeFloat(i,"min_a");a[f]=Math.min(this.safeFloat(a,f,v),v),d[f]=Math.max(this.safeFloat(d,f,m),m),o[p]=Math.min(this.safeFloat(o,p,g),g),n[p]=Math.min(this.safeFloat(n,p,w),w),c[p]=Math.max(this.safeFloat(c,p,y),y),h[p]=Math.max(this.safeFloat(h,p,b),b)}const l={};for(let e=0;e<i.length;e++){const s=i[e],r=this.safeCurrencyCode(s),u=this.safeValue(t.withdraw,r),f=!0;l[r]={id:s,code:r,name:r,active:f,fee:u,precision:8,limits:{amount:{min:this.safeFloat(a,r),max:this.safeFloat(d,r)},price:{min:this.safeFloat(o,r),max:this.safeFloat(c,r)},cost:{min:this.safeFloat(n,r),max:this.safeFloat(h,r)}},info:s}}return l}async fetchMarkets(e={}){const t=await this.fetchTradingFees(),i=await this.publicGetPairSettings(e),s=Object.keys(i),r=[];for(let e=0;e<s.length;e++){const a=s[e],o=i[a],n=a.replace("_","/"),[d,c]=n.split("/"),h=this.safeCurrencyCode(d),l=this.safeCurrencyCode(c);r.push({id:a,symbol:n,base:h,quote:l,baseId:d,quoteId:c,active:!0,taker:t.taker,maker:t.maker,limits:{amount:{min:this.safeFloat(o,"min_quantity"),max:this.safeFloat(o,"max_quantity")},price:{min:this.safeFloat(o,"min_price"),max:this.safeFloat(o,"max_price")},cost:{min:this.safeFloat(o,"min_amount"),max:this.safeFloat(o,"max_amount")}},precision:{amount:8,price:8},info:o})}return r}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostUserInfo(e),i={info:t},s=Object.keys(this.currencies);for(let e=0;e<s.length;e++){const r=s[e],a=this.currencyId(r),o=this.account();a in t.balances&&(o.free=this.safeFloat(t.balances,a)),a in t.reserved&&(o.used=this.safeFloat(t.reserved,a)),i[r]=o}return this.parseBalance(i)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s=this.market(e),r={pair:s.id};void 0!==t&&(r.limit=t);const a=await this.publicGetOrderBook(this.extend(r,i)),o=this.safeValue(a,s.id);return this.parseOrderBook(o,void 0,"bid","ask")}async fetchOrderBooks(e,t={}){await this.loadMarkets();let i=void 0;if(void 0===e){if((i=this.ids.join(",")).length>2048){const e=this.ids.length;throw new a(this.id+" has "+e.toString()+" symbols exceeding max URL length, you are required to specify a list of symbols in the first argument to fetchOrderBooks")}}else i=(i=this.marketIds(e)).join(",");const s={pair:i},r=await this.publicGetOrderBook(this.extend(s,t)),o={};i=Object.keys(r);for(let e=0;e<i.length;e++){const t=i[e];o[this.findSymbol(t)]=this.parseOrderBook(r[t],void 0,"bid","ask")}return o}parseTicker(e,t){const i=this.safeTimestamp(e,"updated");let s=void 0;void 0!==t&&(s=t.symbol);const r=this.safeFloat(e,"last_trade");return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"buy_price"),bidVolume:void 0,ask:this.safeFloat(e,"sell_price"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:this.safeFloat(e,"avg"),baseVolume:this.safeFloat(e,"vol"),quoteVolume:this.safeFloat(e,"vol_curr"),info:e}}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetTicker(t),s={},r=Object.keys(i);for(let e=0;e<r.length;e++){const t=r[e],a=this.markets_by_id[t],o=a.symbol,n=i[t];s[o]=this.parseTicker(n,a)}return s}async fetchTicker(e,t={}){await this.loadMarkets();const i=await this.publicGetTicker(t),s=this.market(e);return this.parseTicker(i[s.id],s)}parseTrade(e,t){const i=this.safeTimestamp(e,"date");let s=void 0,r=void 0;const o=this.safeString(e,"trade_id"),n=this.safeString(e,"order_id"),d=this.safeFloat(e,"price"),c=this.safeFloat(e,"quantity"),h=this.safeFloat(e,"amount"),l=this.safeString(e,"type");if(void 0!==t){if(r=t.symbol,t.taker!==t.maker)throw new a(this.id+" parseTrade can not deduce proper fee costs, taker and maker fees now differ");"buy"===l&&void 0!==c?s={currency:t.base,cost:c*t.taker,rate:t.taker}:"sell"===l&&void 0!==h&&(s={currency:t.quote,cost:h*t.taker,rate:t.taker})}return{id:o,info:e,timestamp:i,datetime:this.iso8601(i),symbol:r,order:n,type:void 0,side:l,takerOrMaker:void 0,price:d,amount:c,cost:h,fee:s}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={pair:r.id},o=await this.publicGetTrades(this.extend(a,s)),n=this.safeValue(o,r.id,[]);return this.parseTrades(n,r,t,i)}async fetchMyTrades(e,t,i,s={}){if(void 0===e)throw new r(this.id+" fetchMyTrades() requires a symbol argument (a single symbol or an array)");await this.loadMarkets();let a=void 0,o=void 0;if(Array.isArray(e)){if(e.length<1)throw new r(this.id+" fetchMyTrades() requires a non-empty symbol array");a=this.marketIds(e).join(",")}else a=(o=this.market(e)).id;const n={pair:a};void 0!==i&&(n.limit=i);const d=await this.privatePostUserTrades(this.extend(n,s));let c=[];const h=Object.keys(d);for(let e=0;e<h.length;e++){const s=h[e];let r=void 0;if(s in this.markets_by_id)r=(o=this.markets_by_id[s]).symbol;else{const[e,t]=s.split("_");r=this.safeCurrencyCode(e)+"/"+this.safeCurrencyCode(t)}const a=d[s],n=this.parseTrades(a,o,t,i,{symbol:r});c=this.arrayConcat(c,n)}return this.filterBySinceLimit(c,t,i)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o="market"===t?t+"_":"";"market"===t&&void 0===r&&(r=0);const n={pair:this.market(e).id,quantity:this.amountToPrecision(e,s),type:o+i,price:this.priceToPrecision(e,r)},d=await this.privatePostOrderCreate(this.extend(n,a)),c=this.safeString(d,"order_id"),h=this.milliseconds();s=parseFloat(s),r=parseFloat(r);const l={id:c,info:d,timestamp:h,datetime:this.iso8601(h),lastTradeTimestamp:void 0,status:"open",symbol:e,type:t,side:i,price:r,cost:r*s,amount:s,remaining:s,filled:0,fee:void 0,trades:void 0};return this.orders[c]=l,l}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={order_id:e},r=await this.privatePostOrderCancel(this.extend(s,i));return e in this.orders&&(this.orders[e].status="canceled"),r}async fetchOrder(e,t,i={}){await this.loadMarkets();try{const t={order_id:e.toString()},s=await this.privatePostOrderTrades(this.extend(t,i)),r=this.parseOrder(s);return this.extend(r,{id:e.toString()})}catch(t){if(t instanceof n&&e in this.orders)return this.orders[e]}throw new n(this.id+" fetchOrder order id "+e.toString()+" not found in cache.")}async fetchOrderTrades(e,t,i,s,r={}){let a=void 0;void 0!==t&&(a=this.market(t));const o={order_id:e.toString()},n=await this.privatePostOrderTrades(this.extend(o,r)),d=this.safeValue(n,"trades");return this.parseTrades(d,a,i,s)}updateCachedOrders(e,t){for(let t=0;t<e.length;t++){const i=e[t].id;this.orders[i]=e[t]}const i=this.indexBy(e,"id"),s=Object.keys(this.orders);for(let e=0;e<s.length;e++){const r=s[e];let a=this.orders[r];if(!(r in i)){if(void 0!==t&&t!==a.symbol)continue;"open"===a.status&&(void 0===(a=this.extend(a,{status:"closed",cost:void 0,filled:a.amount,remaining:0})).cost&&void 0!==a.filled&&(a.cost=a.filled*a.price),this.orders[r]=a)}}return this.toArray(this.orders)}async fetchOrders(e,t,i,s={}){await this.loadMarkets();const r=await this.privatePostUserOpenOrders(s),a=Object.keys(r);let o=[];for(let e=0;e<a.length;e++){const t=a[e];let i=void 0;t in this.markets_by_id&&(i=this.markets_by_id[t]);const s=this.parseOrders(r[t],i);o=this.arrayConcat(o,s)}return this.updateCachedOrders(o,e),this.filterBySymbolSinceLimit(this.toArray(this.orders),e,t,i)}async fetchOpenOrders(e,t,i,s={}){await this.fetchOrders(e,t,i,s);const r=this.filterBy(this.orders,"status","open");return this.filterBySymbolSinceLimit(r,e,t,i)}async fetchClosedOrders(e,t,i,s={}){await this.fetchOrders(e,t,i,s);const r=this.filterBy(this.orders,"status","closed");return this.filterBySymbolSinceLimit(r,e,t,i)}parseOrder(e,t){let i=this.safeString(e,"order_id"),s=this.safeTimestamp(e,"created"),r=void 0;const a=this.safeString(e,"type");if(void 0===t){let i=void 0;"pair"in e?i=e.pair:"in_currency"in e&&"out_currency"in e&&(i="buy"===a?e.in_currency+"_"+e.out_currency:e.out_currency+"_"+e.in_currency),void 0!==i&&i in this.markets_by_id&&(t=this.markets_by_id[i])}let o=this.safeFloat(e,"quantity");if(void 0===o){const t="buy"===a?"in_amount":"out_amount";o=this.safeFloat(e,t)}let n=this.safeFloat(e,"price"),d=this.safeFloat(e,"amount"),c=0;const h=[],l=this.safeValue(e,"trades",[]);let u=void 0,f=void 0,p=void 0;const m=l.length;if(m>0){u=0;for(let e=0;e<m;e++){const r=this.parseTrade(l[e],t);void 0===i&&(i=r.order),void 0===s&&(s=r.timestamp),s>r.timestamp&&(s=r.timestamp),c=this.sum(c,r.amount),u=this.sum(u,r.fee.cost),h.push(r)}f=h[m-1].timestamp}let y=void 0;void 0!==o&&(y=o-c);let b=this.safeString(e,"status");b=c>=o?"closed":"open",void 0===t&&(t=this.getMarketFromTrades(h));let v=void 0;void 0!==t&&(r=t.symbol,v=t.quote),void 0===d?void 0!==n&&(d=n*c):c>0&&(void 0===p&&(p=d/c),void 0===n&&(n=d/c));const g={cost:u,currency:v};return{id:i,datetime:this.iso8601(s),timestamp:s,lastTradeTimestamp:f,status:b,symbol:r,type:"limit",side:a,price:n,cost:d,amount:o,filled:c,remaining:y,average:p,trades:h,fee:g,info:e}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i=await this.privatePostDepositAddress(t),s=this.safeString(i,e);let r=void 0,a=void 0;if(s){const e=s.split(",");r=e[0],e.length>1&&(a=e[1])}return this.checkAddress(r),{currency:e,address:r,tag:a,info:i}}getMarketFromTrades(e){const t=this.indexBy(e,"pair"),i=Object.keys(t);if(1===i.length)return this.markets[i[0]]}calculateFee(e,t,i,s,r,a="taker",o={}){const n=this.markets[e],d=n[a];let c=parseFloat(this.costToPrecision(e,s*d)),h="quote";return"sell"===i?c*=r:h="base",{type:a,currency:n[h],rate:d,cost:parseFloat(this.feeToPrecision(e,c))}}async withdraw(e,t,i,s,r={}){await this.loadMarkets();const a={amount:t,currency:this.currency(e).id,address:i};void 0!==s&&(a.invoice=s);const o=await this.privatePostWithdrawCrypt(this.extend(a,r));return{info:o,id:o.task_id}}parseTransactionStatus(e){return this.safeString({transferred:"ok",paid:"ok",pending:"pending",processing:"pending"},e,e)}parseTransaction(e,t){const i=this.safeTimestamp(e,"dt");let s=this.safeFloat(e,"amount");void 0!==s&&(s=Math.abs(s));const r=this.parseTransactionStatus(this.safeString(e,"status")),a=this.safeString(e,"txid"),o=this.safeString(e,"type"),n=this.safeString(e,"curr"),d=this.safeCurrencyCode(n,t);let c=this.safeString(e,"account");if(void 0!==c){const e=c.split(":");2===e.length&&(c=e[1].replace(" ",""))}let h=void 0;if(!this.fees.funding.percentage){const t="withdrawal"===o?"withdraw":"deposit";let i=this.safeFloat(this.options.fundingFees[t],d);"cashback"===this.safeString(e,"provider")&&(i=0),void 0!==i&&("withdrawal"===o&&(s-=i),h={cost:i,currency:d,rate:void 0})}return{info:e,id:void 0,currency:d,amount:s,address:c,tag:void 0,status:r,type:o,updated:void 0,txid:a,timestamp:i,datetime:this.iso8601(i),fee:h}}async fetchTransactions(e,t,i,s={}){await this.loadMarkets();const r={};void 0!==t&&(r.date=parseInt(t/1e3));let a=void 0;void 0!==e&&(a=this.currency(e));const o=await this.privatePostWalletHistory(this.extend(r,s));return this.parseTransactions(o.history,a,t,i)}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api[t]+"/";if("web"!==t&&(o+=this.version+"/"),o+=e,"public"===t||"web"===t)Object.keys(s).length&&(o+="?"+this.urlencode(s));else if("private"===t){this.checkRequiredCredentials();const e=this.nonce();a=this.urlencode(this.extend({nonce:e},s)),r={"Content-Type":"application/x-www-form-urlencoded",Key:this.apiKey,Sign:this.hmac(this.encode(a),this.encode(this.secret),"sha512")}}return{url:o,method:i,body:a,headers:r}}nonce(){return this.milliseconds()}handleErrors(e,t,i,s,r,o,n,d,c){if(void 0!==n&&"result"in n){let e=this.safeValue(n,"result",!1);if("string"==typeof e&&(e="true"===e||"1"===e),!e){let e=void 0;const t=this.safeString(n,"error").split(":");if(t.length>1){const i=t[0].split(" ");e=i.length>1?i[1]:i[0]}const i=this.id+" "+this.json(n),s=this.exceptions;throw e in s?new s[e](i):new a(i)}}}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,AuthenticationError:a,ExchangeNotAvailable:o}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"exx",name:"EXX",countries:["CN"],rateLimit:100,userAgent:this.userAgents.chrome,has:{fetchOrder:!0,fetchTickers:!0,fetchOpenOrders:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/37770292-fbf613d0-2de4-11e8-9f79-f2dc451b8ccb.jpg",api:{public:"https://api.exx.com/data/v1",private:"https://trade.exx.com/api"},www:"https://www.exx.com/",doc:"https://www.exx.com/help/restApi",fees:"https://www.exx.com/help/rate",referral:"https://www.exx.com/r/fde4260159e53ab8a58cc9186d35501f?recommQd=1"},api:{public:{get:["markets","tickers","ticker","depth","trades"]},private:{get:["order","cancel","getOrder","getOpenOrders","getBalance"]}},fees:{trading:{maker:.001,taker:.001},funding:{withdraw:{BCC:3e-4,BCD:0,BOT:10,BTC:.001,BTG:0,BTM:25,BTS:3,EOS:1,ETC:.01,ETH:.01,ETP:.012,HPY:0,HSR:.001,INK:20,LTC:.005,MCO:.6,MONA:.01,QASH:5,QCASH:5,QTUM:.01,USDT:5}}},commonCurrencies:{TV:"TIV"},exceptions:{103:a}})}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),i=Object.keys(t),s=[];for(let e=0;e<i.length;e++){const r=i[e],a=t[r],[o,n]=r.split("_"),d=this.safeCurrencyCode(o),c=this.safeCurrencyCode(n),h=d+"/"+c,l=!0===a.isOpen,u={amount:parseInt(a.amountScale),price:parseInt(a.priceScale)};s.push({id:r,symbol:h,base:d,quote:c,baseId:o,quoteId:n,active:l,precision:u,limits:{amount:{min:Math.pow(10,-u.amount),max:Math.pow(10,u.amount)},price:{min:Math.pow(10,-u.price),max:Math.pow(10,u.price)},cost:{min:void 0,max:void 0}},info:a})}return s}parseTicker(e,t){const i=t.symbol,s=this.safeInteger(e,"date");e=e.ticker;const r=this.safeFloat(e,"last");return{symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"buy"),bidVolume:void 0,ask:this.safeFloat(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:this.safeFloat(e,"riseRate"),percentage:void 0,average:void 0,baseVolume:this.safeFloat(e,"vol"),quoteVolume:void 0,info:e}}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={currency:i.id},r=await this.publicGetTicker(this.extend(s,t));return this.parseTicker(r,i)}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetTickers(t),s={},r=this.milliseconds(),a=Object.keys(i);for(let e=0;e<a.length;e++){const t=a[e];if(!(t in this.marketsById))continue;const o=this.marketsById[t],n=o.symbol,d={date:r,ticker:i[t]};s[n]=this.parseTicker(d,o)}return s}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={currency:this.marketId(e)},r=await this.publicGetDepth(this.extend(s,i));return this.parseOrderBook(r,r.timestamp)}parseTrade(e,t){const i=this.safeTimestamp(e,"date"),s=this.safeFloat(e,"price"),r=this.safeFloat(e,"amount");let a=void 0;void 0!==s&&void 0!==r&&(a=s*r);let o=void 0;void 0!==t&&(o=t.symbol);const n=this.safeString(e,"type");return{id:this.safeString(e,"tid"),info:e,timestamp:i,datetime:this.iso8601(i),symbol:o,order:void 0,type:"limit",side:n,takerOrMaker:void 0,price:s,amount:r,cost:a,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={currency:r.id},o=await this.publicGetTrades(this.extend(a,s));return this.parseTrades(o,r,t,i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetGetBalance(e),i={info:t},s=this.safeValue(t,"funds"),r=Object.keys(s);for(let e=0;e<r.length;e++){const t=r[e],a=s[t],o=this.safeCurrencyCode(t),n={free:this.safeFloat(a,"balance"),used:this.safeFloat(a,"freeze"),total:this.safeFloat(a,"total")};i[o]=n}return this.parseBalance(i)}parseOrder(e,t){const i=t.symbol,s=parseInt(e.trade_date),r=this.safeFloat(e,"price"),a=this.safeFloat(e,"trade_money"),o=this.safeFloat(e,"total_amount"),n=this.safeFloat(e,"trade_amount",0),d=parseFloat(this.amountToPrecision(i,o-n));let c=this.safeInteger(e,"status");c=1===c?"canceled":2===c?"closed":"open";let h=void 0;return"fees"in e&&(h={cost:this.safeFloat(e,"fees"),currency:t.quote}),{id:this.safeString(e,"id"),datetime:this.iso8601(s),timestamp:s,lastTradeTimestamp:void 0,status:c,symbol:i,type:"limit",side:e.type,price:r,cost:a,amount:o,filled:n,remaining:d,trades:void 0,fee:h,info:e}}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o=this.market(e),n={currency:o.id,type:i,price:r,amount:s},d=await this.privateGetOrder(this.extend(n,a)),c=this.safeString(d,"id"),h=this.parseOrder({id:c,trade_date:this.milliseconds(),total_amount:s,price:r,type:i,info:d},o);return this.orders[c]=h,h}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={id:e,currency:this.market(t).id};return await this.privateGetCancel(this.extend(s,i))}async fetchOrder(e,t,i={}){await this.loadMarkets();const s=this.market(t),r={id:e,currency:s.id},a=await this.privateGetGetOrder(this.extend(r,i));return this.parseOrder(a,s)}async fetchOpenOrders(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={currency:r.id},o=await this.privateGetGetOpenOrders(this.extend(a,s));return Array.isArray(o)?this.parseOrders(o,r,t,i):[]}nonce(){return this.milliseconds()}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api[t]+"/"+e;if("public"===t)Object.keys(s).length&&(o+="?"+this.urlencode(s));else{this.checkRequiredCredentials();const e=this.urlencode(this.keysort(this.extend({accesskey:this.apiKey,nonce:this.nonce()},s)));o+="?"+e+"&signature="+this.hmac(this.encode(e),this.encode(this.secret),"sha512"),r={"Content-Type":"application/x-www-form-urlencoded"}}return{url:o,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,n,d,c,h){if(void 0===d)return;const l=this.safeString(d,"code"),u=this.safeString(d,"message"),f=this.id+" "+this.json(d);if("100"===l)return;if(void 0!==l){const e=this.exceptions;if(l in e)throw new e[l](f);if("308"===l)return;throw new r(f)}const p=this.safeValue(d,"result");if(void 0!==p&&!p)throw""===u?new o(f):new r(f)}}},function(e,t,i){"use strict";const s=i(36);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"fcoinjp",name:"FCoinJP",countries:["JP"],hostname:"fcoinjp.com",urls:{logo:"https://user-images.githubusercontent.com/1294454/54219174-08b66b00-4500-11e9-862d-f522d0fe08c6.jpg",fees:"https://fcoinjp.zendesk.com/hc/en-us/articles/360018727371",www:"https://www.fcoinjp.com",referral:void 0}})}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"flowbtc",name:"flowBTC",countries:["BR"],version:"v1",rateLimit:1e3,has:{CORS:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/28162465-cd815d4c-67cf-11e7-8e57-438bea0523a2.jpg",api:"https://publicapi.flowbtc.com.br",www:"https://www.flowbtc.com.br",doc:"https://www.flowbtc.com.br/api.html"},requiredCredentials:{apiKey:!0,secret:!0,uid:!0},api:{public:{post:["GetTicker","GetTrades","GetTradesByDate","GetOrderBook","GetProductPairs","GetProducts"]},private:{post:["CreateAccount","GetUserInfo","SetUserInfo","GetAccountInfo","GetAccountTrades","GetDepositAddresses","Withdraw","CreateOrder","ModifyOrder","CancelOrder","CancelAllOrders","GetAccountOpenOrders","GetOrderFee"]}},fees:{trading:{tierBased:!1,percentage:!0,maker:.0025,taker:.005}}})}async fetchMarkets(e={}){const t=await this.publicPostGetProductPairs(e),i=this.safeValue(t,"productPairs"),s={};for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"name"),a=this.safeString(t,"product1Label"),o=this.safeString(t,"product2Label"),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o),c={amount:this.safeInteger(t,"product1DecimalPlaces"),price:this.safeInteger(t,"product2DecimalPlaces")},h=n+"/"+d;s[h]={id:r,symbol:h,base:n,quote:d,baseId:a,quoteId:o,precision:c,limits:{amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:t}}return s}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGetAccountInfo(e),i=this.safeValue(t,"currencies"),s={info:t};for(let e=0;e<i.length;e++){const t=i[e],r=t.name,a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeFloat(t,"balance"),o.total=this.safeFloat(t,"hold"),s[a]=o}return this.parseBalance(s)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={productPair:this.market(e).id},r=await this.publicPostGetOrderBook(this.extend(s,i));return this.parseOrderBook(r,void 0,"bids","asks","px","qty")}async fetchTicker(e,t={}){await this.loadMarkets();const i={productPair:this.market(e).id},s=await this.publicPostGetTicker(this.extend(i,t)),r=this.milliseconds(),a=this.safeFloat(s,"last");return{symbol:e,timestamp:r,datetime:this.iso8601(r),high:this.safeFloat(s,"high"),low:this.safeFloat(s,"low"),bid:this.safeFloat(s,"bid"),bidVolume:void 0,ask:this.safeFloat(s,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeFloat(s,"volume24hr"),quoteVolume:this.safeFloat(s,"volume24hrProduct2"),info:s}}parseTrade(e,t){const i=this.safeTimestamp(e,"unixtime"),s=0===e.incomingOrderSide?"buy":"sell",r=this.safeString(e,"tid"),a=this.safeFloat(e,"px"),o=this.safeFloat(e,"qty");let n=void 0;return void 0!==a&&void 0!==o&&(n=a*o),{info:e,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,id:r,order:void 0,type:void 0,side:s,price:a,amount:o,cost:n}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={ins:r.id,startIndex:-1},o=await this.publicPostGetTrades(this.extend(a,s));return this.parseTrades(o.trades,r,t,i)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o="market"===t?1:0,n={ins:this.marketId(e),side:i,orderType:o,qty:s,px:this.priceToPrecision(e,r)},d=await this.privatePostCreateOrder(this.extend(n,a));return{info:d,id:d.serverOrderId}}async cancelOrder(e,t,i={}){if(await this.loadMarkets(),"ins"in i){const t={serverOrderId:e};return await this.privatePostCancelOrder(this.extend(t,i))}throw new r(this.id+" requires `ins` symbol parameter for cancelling an order")}sign(e,t="public",i="GET",s={},r,a){const o=this.urls.api+"/"+this.version+"/"+e;if("public"===t)Object.keys(s).length&&(a=this.json(s));else{this.checkRequiredCredentials();const e=this.nonce(),t=e.toString()+this.uid+this.apiKey,i=this.hmac(this.encode(t),this.encode(this.secret));a=this.json(this.extend({apiKey:this.apiKey,apiNonce:e,apiSig:i.toUpperCase()},s)),r={"Content-Type":"application/json"}}return{url:o,method:i,body:a,headers:r}}async request(e,t="public",i="GET",s={},a,o){const n=await this.fetch2(e,t,i,s,a,o);if("isAccepted"in n&&n.isAccepted)return n;throw new r(this.id+" "+this.json(n))}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"fybse",name:"FYB-SE",countries:["SE"],has:{CORS:!1},rateLimit:1500,urls:{logo:"https://user-images.githubusercontent.com/1294454/27766512-31019772-5edb-11e7-8241-2e675e6797f1.jpg",api:"https://www.fybse.se/api/SEK",www:"https://www.fybse.se",doc:"https://fyb.docs.apiary.io"},api:{public:{get:["ticker","tickerdetailed","orderbook","trades"]},private:{post:["test","getaccinfo","getpendingorders","getorderhistory","cancelpendingorder","placeorder","withdraw"]}},markets:{"BTC/SEK":{id:"SEK",symbol:"BTC/SEK",base:"BTC",quote:"SEK"}}})}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGetaccinfo(e),i=this.safeFloat(t,"btcBal"),s=this.symbols[0],r=this.markets[s].quote,a=r.toLowerCase()+"Bal",o=this.safeFloat(t,a),n=this.account();n.total=i;const d={BTC:n};return d[r]=this.account(),d[r].total=o,d.info=t,this.parseBalance(d)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s=await this.publicGetOrderbook(i);return this.parseOrderBook(s)}async fetchTicker(e,t={}){await this.loadMarkets();const i=await this.publicGetTickerdetailed(t),s=this.milliseconds(),r=this.safeFloat(i,"last"),a=this.safeFloat(i,"vol");return{symbol:e,timestamp:s,datetime:this.iso8601(s),high:void 0,low:void 0,bid:this.safeFloat(i,"bid"),bidVolume:void 0,ask:this.safeFloat(i,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:a,quoteVolume:void 0,info:i}}parseTrade(e,t){const i=this.safeTimestamp(e,"date"),s=this.safeString(e,"tid");let r=void 0;void 0!==t&&(r=t.symbol);const a=this.safeFloat(e,"price"),o=this.safeFloat(e,"amount");let n=void 0;return void 0!==a&&void 0!==o&&(n=a*o),{id:s,info:e,order:void 0,timestamp:i,datetime:this.iso8601(i),symbol:r,type:void 0,side:void 0,takerOrMaker:void 0,price:a,amount:o,cost:n,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a=await this.publicGetTrades(s);return this.parseTrades(a,r,t,i)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o={qty:s,price:r,type:i[0].toUpperCase()},n=await this.privatePostPlaceorder(this.extend(o,a));return{info:n,id:n.pending_oid}}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={orderNo:e};return await this.privatePostCancelpendingorder(this.extend(s,i))}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api+"/"+e;if("public"===t)o+=".json";else{this.checkRequiredCredentials();const e=this.nonce();a=this.urlencode(this.extend({timestamp:e},s)),r={"Content-Type":"application/x-www-form-urlencoded",key:this.apiKey,sig:this.hmac(this.encode(a),this.encode(this.secret),"sha1")}}return{url:o,method:i,body:a,headers:r}}async request(e,t="public",i="GET",s={},a,o){const n=await this.fetch2(e,t,i,s,a,o);if("private"===t&&"error"in n&&n.error)throw new r(this.id+" "+this.json(n));return n}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,ArgumentsRequired:a,InvalidAddress:o,OrderNotFound:n,NotSupported:d,DDoSProtection:c,InsufficientFunds:h}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"gateio",name:"Gate.io",countries:["CN"],version:"2",rateLimit:1e3,has:{CORS:!1,createMarketOrder:!1,fetchTickers:!0,withdraw:!0,fetchDeposits:!0,fetchWithdrawals:!0,fetchTransactions:!0,createDepositAddress:!0,fetchDepositAddress:!0,fetchClosedOrders:!1,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrderTrades:!0,fetchOrders:!0,fetchOrder:!0,fetchMyTrades:!0},timeframes:{"1m":"60","5m":"300","10m":"600","15m":"900","30m":"1800","1h":"3600","2h":"7200","4h":"14400","6h":"21600","12h":"43200","1d":"86400","1w":"604800"},urls:{logo:"https://user-images.githubusercontent.com/1294454/31784029-0313c702-b509-11e7-9ccc-bc0da6a0e435.jpg",api:{public:"https://data.gate.io/api",private:"https://data.gate.io/api"},www:"https://gate.io/",doc:"https://gate.io/api2",fees:["https://gate.io/fee","https://support.gate.io/hc/en-us/articles/115003577673"],referral:"https://www.gate.io/signup/2436035"},api:{public:{get:["candlestick2/{id}","pairs","marketinfo","marketlist","tickers","ticker/{id}","orderBook/{id}","trade/{id}","tradeHistory/{id}","tradeHistory/{id}/{tid}"]},private:{post:["balances","depositAddress","newAddress","depositsWithdrawals","buy","sell","cancelOrder","cancelAllOrders","getOrder","openOrders","tradeHistory","withdraw"]}},fees:{trading:{tierBased:!0,percentage:!0,maker:.002,taker:.002}},exceptions:{4:c,7:d,8:d,9:d,15:c,16:n,17:n,21:h},errorCodeNames:{1:"Invalid request",2:"Invalid version",3:"Invalid request",4:"Too many attempts",5:"Invalid sign",6:"Invalid sign",7:"Currency is not supported",8:"Currency is not supported",9:"Currency is not supported",10:"Verified failed",11:"Obtaining address failed",12:"Empty params",13:"Internal error, please report to administrator",14:"Invalid user",15:"Cancel order too fast, please wait 1 min and try again",16:"Invalid order id or order is already closed",17:"Invalid orderid",18:"Invalid amount",19:"Not permitted or trade is disabled",20:"Your order size is too small",21:"You don't have enough fund"},options:{fetchTradesMethod:"public_get_tradehistory_id",limits:{cost:{min:{BTC:1e-4,ETH:.001,USDT:1}}}}})}async fetchMarkets(e={}){const t=await this.publicGetMarketinfo(e),i=this.safeValue(t,"pairs");if(!i)throw new r(this.id+" fetchMarkets got an unrecognized response");const s=[];for(let e=0;e<i.length;e++){const t=i[e],r=Object.keys(t)[0],a=t[r],o=r.split("_"),n=o.length;let d=o[0],c=o[1];n>2&&(d=o[0]+"_"+o[1],c=o[2]);const h=this.safeCurrencyCode(d),l=this.safeCurrencyCode(c),u=h+"/"+l,f={amount:8,price:a.decimal_places},p={min:a.min_amount,max:void 0},m={min:Math.pow(10,-a.decimal_places),max:void 0},y=p.min*m.min,b={amount:p,price:m,cost:{min:this.safeFloat(this.options.limits.cost.min,l,y),max:void 0}},v=!0;s.push({id:r,symbol:u,base:h,quote:l,baseId:d,quoteId:c,info:t,active:v,maker:a.fee/100,taker:a.fee/100,precision:f,limits:b})}return s}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostBalances(e),i={info:t};let s=this.safeValue(t,"available",{});Array.isArray(s)&&(s={});const r=this.safeValue(t,"locked",{}),a=Object.keys(s);for(let e=0;e<a.length;e++){const t=a[e],o=this.safeCurrencyCode(t),n=this.account();n.free=this.safeFloat(s,t),n.used=this.safeFloat(r,t),i[o]=n}return this.parseBalance(i)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={id:this.marketId(e)},r=await this.publicGetOrderBookId(this.extend(s,i));return this.parseOrderBook(r)}parseOHLCV(e,t,i="1m",s,r){return[parseInt(e[0]),parseFloat(e[5]),parseFloat(e[3]),parseFloat(e[4]),parseFloat(e[2]),parseFloat(e[1])]}async fetchOHLCV(e,t="1m",i,s,r={}){await this.loadMarkets();const a=this.market(e),o={id:a.id,group_sec:this.timeframes[t]};if(void 0!==s){const e=this.parseTimeframe(t),i=parseInt(e*s/3600);o.range_hour=Math.max(0,i-1)}const n=await this.publicGetCandlestick2Id(this.extend(o,r)),d=this.safeValue(n,"data",[]);return this.parseOHLCVs(d,a,t,i,s)}parseTicker(e,t){const i=this.milliseconds();let s=void 0;t&&(s=t.symbol);const r=this.safeFloat(e,"last"),a=this.safeFloat(e,"percentChange");let o=void 0,n=void 0,d=void 0;if(void 0!==r&&void 0!==a){const e=a/100;n=r-(o=r/this.sum(1,e)),d=this.sum(r,o)/2}return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high24hr"),low:this.safeFloat(e,"low24hr"),bid:this.safeFloat(e,"highestBid"),bidVolume:void 0,ask:this.safeFloat(e,"lowestAsk"),askVolume:void 0,vwap:void 0,open:o,close:r,last:r,previousClose:void 0,change:n,percentage:a,average:d,baseVolume:this.safeFloat(e,"quoteVolume"),quoteVolume:this.safeFloat(e,"baseVolume"),info:e}}handleErrors(e,t,i,s,r,a,o,n,d){if(void 0===o)return;if("false"!==this.safeString(o,"result",""))return;const c=this.safeString(o,"code");if(void 0!==c){const e=this.exceptions,t=this.errorCodeNames;if(c in e){let i="";throw i=c in t?t[c]:this.safeString(o,"message","(unknown)"),new e[c](i)}}}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetTickers(t),s={},r=Object.keys(i);for(let e=0;e<r.length;e++){const t=r[e],[a,o]=t.split("_");let n=a.toUpperCase(),d=o.toUpperCase();const c=(n=this.safeCurrencyCode(n))+"/"+(d=this.safeCurrencyCode(d));let h=void 0;c in this.markets&&(h=this.markets[c]),t in this.markets_by_id&&(h=this.markets_by_id[t]),s[c]=this.parseTicker(i[t],h)}return s}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s=await this.publicGetTickerId(this.extend({id:i.id},t));return this.parseTicker(s,i)}parseTrade(e,t){const i=this.safeTimestamp2(e,"timestamp","time_unix"),s=this.safeString2(e,"tradeID","id"),r=this.safeString2(e,"orderid","orderNumber"),a=this.safeFloat(e,"rate"),o=this.safeFloat(e,"amount"),n=this.safeString(e,"type");let d=void 0;void 0!==a&&void 0!==o&&(d=a*o);let c=void 0;return void 0!==t&&(c=t.symbol),{id:s,info:e,timestamp:i,datetime:this.iso8601(i),symbol:c,order:r,type:void 0,side:n,takerOrMaker:void 0,price:a,amount:o,cost:d,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={id:r.id},o=this.safeString(this.options,"fetchTradesMethod","public_get_tradehistory_id"),n=await this[o](this.extend(a,s));return this.parseTrades(n.data,r,t,i)}async fetchOrders(e,t,i,s={}){const r=await this.privatePostOpenOrders(s);return this.parseOrders(r.orders,void 0,t,i)}async fetchOrder(e,t,i={}){await this.loadMarkets();const s={orderNumber:e,currencyPair:this.marketId(t)},r=await this.privatePostGetOrder(this.extend(s,i));return this.parseOrder(r.order)}parseOrderStatus(e){return this.safeString({cancelled:"canceled"},e,e)}parseOrder(e,t){const i=this.safeString(e,"orderNumber");let s=void 0;const r=this.safeString(e,"currencyPair");r in this.markets_by_id&&(t=this.markets_by_id[r]),void 0!==t&&(s=t.symbol);const a=this.safeTimestamp(e,"timestamp"),o=this.parseOrderStatus(this.safeString(e,"status")),n=this.safeString(e,"type"),d=this.safeFloat(e,"filledRate"),c=this.safeFloat(e,"initialAmount"),h=this.safeFloat(e,"filledAmount"),l=this.safeFloat2(e,"leftAmount","left"),u=this.safeFloat(e,"feeValue"),f=this.safeString(e,"feeCurrency"),p=this.safeCurrencyCode(f);let m=this.safeFloat(e,"feePercentage");return void 0!==m&&(m/=100),{id:i,datetime:this.iso8601(a),timestamp:a,status:o,symbol:s,type:"limit",side:n,price:d,cost:void 0,amount:c,filled:h,remaining:l,trades:void 0,fee:{cost:u,currency:p,rate:m},info:e}}async createOrder(e,t,i,s,a,o={}){if("market"===t)throw new r(this.id+" allows limit orders only");await this.loadMarkets();const n="privatePost"+this.capitalize(i),d=this.market(e),c={currencyPair:d.id,rate:a,amount:s},h=await this[n](this.extend(c,o));return this.parseOrder(this.extend({status:"open",type:i,initialAmount:s},h),d)}async cancelOrder(e,t,i={}){if(void 0===t)throw new a(this.id+" cancelOrder requires symbol argument");await this.loadMarkets();const s={orderNumber:e,currencyPair:this.marketId(t)};return await this.privatePostCancelOrder(this.extend(s,i))}async queryDepositAddress(e,t,i={}){await this.loadMarkets();const s=this.currency(t);e="privatePost"+e+"Address";const r={currency:s.id},a=await this[e](this.extend(r,i));let n=this.safeString(a,"addr"),d=void 0;if(void 0!==n&&n.indexOf("address")>=0)throw new o(this.id+" queryDepositAddress "+n);if("XRP"===t){const e=n.split(" ");n=e[0],d=e[1]}return{currency:s,address:n,tag:d,info:a}}async createDepositAddress(e,t={}){return await this.queryDepositAddress("New",e,t)}async fetchDepositAddress(e,t={}){return await this.queryDepositAddress("Deposit",e,t)}async fetchOpenOrders(e,t,i,s={}){await this.loadMarkets();let r=void 0;void 0!==e&&(r=this.market(e));const a=await this.privatePostOpenOrders(s);return this.parseOrders(a.orders,r,t,i)}async fetchOrderTrades(e,t,i,s,r={}){if(void 0===t)throw new a(this.id+" fetchMyTrades requires a symbol argument");await this.loadMarkets();const o=this.market(t),n={currencyPair:o.id,orderNumber:e},d=await this.privatePostTradeHistory(this.extend(n,r));return this.parseTrades(d.trades,o,i,s)}async fetchMyTrades(e,t,i,s={}){if(void 0===e)throw new a(this.id+" fetchMyTrades requires symbol param");await this.loadMarkets();const r=this.market(e),o={currencyPair:r.id},n=await this.privatePostTradeHistory(this.extend(o,s));return this.parseTrades(n.trades,r,t,i)}async withdraw(e,t,i,s,r={}){this.checkAddress(i),await this.loadMarkets();const a={currency:this.currency(e).id,amount:t,address:i};return void 0!==s&&(a.address+=" "+s),{info:await this.privatePostWithdraw(this.extend(a,r)),id:void 0}}sign(e,t="public",i="GET",s={},r,a){const o="private"===t?t+"/":"";let n=this.urls.api[t]+this.version+"/1/"+o+this.implodeParams(e,s);const d=this.omit(s,this.extractParams(e));if("public"===t)Object.keys(d).length&&(n+="?"+this.urlencode(d));else{this.checkRequiredCredentials();const e={nonce:this.nonce()};a=this.urlencode(this.extend(e,d));const t=this.hmac(this.encode(a),this.encode(this.secret),"sha512");r={Key:this.apiKey,Sign:t,"Content-Type":"application/x-www-form-urlencoded"}}return{url:n,method:i,body:a,headers:r}}async fetchTransactionsByType(e,t,i,s,r={}){await this.loadMarkets();const a={};void 0!==i&&(a.start=i);const o=await this.privatePostDepositsWithdrawals(this.extend(a,r));let n=void 0;if(void 0===e){const e=this.safeValue(o,"deposits",[]),t=this.safeValue(o,"withdraws",[]);n=this.arrayConcat(e,t)}else n=this.safeValue(o,e,[]);let d=void 0;return void 0!==t&&(d=this.currency(t)),this.parseTransactions(n,d,i,s)}async fetchTransactions(e,t,i,s={}){return await this.fetchTransactionsByType(void 0,e,t,i,s)}async fetchDeposits(e,t,i,s={}){return await this.fetchTransactionsByType("deposits",e,t,i,s)}async fetchWithdrawals(e,t,i,s={}){return await this.fetchTransactionsByType("withdraws",e,t,i,s)}parseTransaction(e,t){const i=this.safeString(e,"currency"),s=this.safeCurrencyCode(i,t),r=this.safeString(e,"id"),a=this.safeString(e,"txid"),o=this.safeFloat(e,"amount"),n=this.safeString(e,"address"),d=this.safeTimestamp(e,"timestamp");return{info:e,id:r,txid:a,currency:s,amount:o,address:n,tag:void 0,status:this.parseTransactionStatus(this.safeString(e,"status")),type:this.parseTransactionType(r[0]),timestamp:d,datetime:this.iso8601(d),fee:void 0}}parseTransactionStatus(e){return this.safeString({PEND:"pending",REQUEST:"pending",CANCEL:"failed",DONE:"ok"},e,e)}parseTransactionType(e){return this.safeString({d:"deposit",w:"withdrawal"},e,e)}async request(e,t="public",i="GET",s={},a,o){const n=await this.fetch2(e,t,i,s,a,o);if("result"in n){const e=n.result,t=this.id+" "+this.json(n);if(void 0===e)throw new r(t);if("string"==typeof e){if("true"!==e)throw new r(t)}else if(!e)throw new r(t)}return n}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,ArgumentsRequired:a,BadRequest:o,OrderNotFound:n,InvalidOrder:d,InvalidNonce:c,DDoSProtection:h,InsufficientFunds:l,AuthenticationError:u,ExchangeNotAvailable:f,PermissionDenied:p,NotSupported:m,OnMaintenance:y}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"gemini",name:"Gemini",countries:["US"],rateLimit:1500,version:"v1",has:{fetchDepositAddress:!1,createDepositAddress:!0,CORS:!1,fetchBidsAsks:!1,fetchTickers:!1,fetchMyTrades:!0,fetchOrder:!0,fetchOrders:!1,fetchOpenOrders:!0,fetchClosedOrders:!1,createMarketOrder:!1,withdraw:!0,fetchTransactions:!0,fetchWithdrawals:!1,fetchDeposits:!1,fetchOHLCV:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27816857-ce7be644-6096-11e7-82d6-3c257263229c.jpg",api:{public:"https://api.gemini.com",private:"https://api.gemini.com",web:"https://docs.gemini.com"},www:"https://gemini.com/",doc:["https://docs.gemini.com/rest-api","https://docs.sandbox.gemini.com"],test:"https://api.sandbox.gemini.com",fees:["https://gemini.com/api-fee-schedule","https://gemini.com/trading-fees","https://gemini.com/transfer-fees"]},api:{web:{get:["rest-api"]},public:{get:["v1/symbols","v1/pubticker/{symbol}","v1/book/{symbol}","v1/trades/{symbol}","v1/auction/{symbol}","v1/auction/{symbol}/history","v2/candles/{symbol}/{timeframe}","v2/ticker/{symbol}"]},private:{post:["v1/order/new","v1/order/cancel","v1/order/cancel/session","v1/order/cancel/all","v1/order/status","v1/orders","v1/mytrades","v1/tradevolume","v1/transfers","v1/balances","v1/deposit/{currency}/newAddress","v1/withdraw/{currency}","v1/heartbeat","v1/transfers"]}},fees:{trading:{taker:.0035,maker:.001}},httpExceptions:{400:o,403:p,404:n,406:l,429:h,500:r,502:r,503:f},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1hr","6h":"6hr","1d":"1day"},exceptions:{exact:{AuctionNotOpen:o,ClientOrderIdTooLong:o,ClientOrderIdMustBeString:o,ConflictingOptions:o,EndpointMismatch:o,EndpointNotFound:o,IneligibleTiming:o,InsufficientFunds:l,InvalidJson:o,InvalidNonce:c,InvalidOrderType:d,InvalidPrice:d,InvalidQuantity:d,InvalidSide:d,InvalidSignature:u,InvalidSymbol:o,InvalidTimestampInPayload:o,Maintenance:f,MarketNotOpen:d,MissingApikeyHeader:u,MissingOrderField:d,MissingRole:u,MissingPayloadHeader:u,MissingSignatureHeader:u,NoSSL:u,OptionsMustBeArray:o,OrderNotFound:n,RateLimit:h,System:r,UnsupportedOption:o},broad:{"The Gemini Exchange is currently undergoing maintenance.":y}},options:{fetchMarketsMethod:"fetch_markets_from_web"}})}async fetchMarkets(e={}){const t=this.safeValue(this.options,"fetchMarketsMethod","fetch_markets_from_api");return await this[t](e)}async fetchMarketsFromWeb(e,t={}){const i=(await this.webGetRestApi(t)).split('<h1 id="symbols-and-minimums">Symbols and minimums</h1>'),s=i.length,r=this.id+" the "+this.name+" API doc HTML markup has changed, breaking the parser of order limits and precision info for "+this.name+" markets.";if(2!==s)throw new m(r);const a=i[1].split("tbody>");if(a.length<2)throw new m(r);const o=a[1].split("<tr>\n"),n=o.length;if(n<2)throw new m(r);const d=[];for(let e=1;e<n;e++){const t=o[e],i=t.split("</td>\n");if(i.length<7)throw new m(r);let s=i[0].replace("<td>","");s=(s=s.replace('<code class="prettyprint">',"")).replace("</code>","");let a=i[2].replace("<td>",""),n=i[1].replace("<td>","");const c=i[3].replace("<td>",""),h=i[4].replace("<td>",""),l=i[5].replace("<td>",""),u=c.split(" "),f=h.split(" "),p=l.split(" ");a=a.toLowerCase(),n=n.toLowerCase();const y=this.safeCurrencyCode(a),b=this.safeCurrencyCode(n),v=y+"/"+b,g={amount:this.precisionFromString(f[0]),price:this.precisionFromString(p[0])},w=void 0;d.push({id:s,info:t,symbol:v,base:y,quote:b,baseId:a,quoteId:n,active:w,precision:g,limits:{amount:{min:parseFloat(u[0]),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}}})}return d}async fetchMarketsFromAPI(e={}){const t=await this.publicGetV1Symbols(e),i=[];for(let e=0;e<t.length;e++){const s=t[e],r=s,a=s.slice(0,3),o=s.slice(3,6),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o),c=n+"/"+d,h={amount:void 0,price:void 0};i.push({id:s,info:r,symbol:c,base:n,quote:d,baseId:a,quoteId:o,precision:h,limits:{amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}}})}return i}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={symbol:this.marketId(e)};void 0!==t&&(s.limit_bids=t,s.limit_asks=t);const r=await this.publicGetV1BookSymbol(this.extend(s,i));return this.parseOrderBook(r,void 0,"bids","asks","price","amount")}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={symbol:i.id},r=await this.publicGetV1PubtickerSymbol(this.extend(s,t)),a=this.safeInteger(r.volume,"timestamp"),o=i.base,n=i.quote,d=this.safeFloat(r,"last");return{symbol:e,timestamp:a,datetime:this.iso8601(a),high:void 0,low:void 0,bid:this.safeFloat(r,"bid"),bidVolume:void 0,ask:this.safeFloat(r,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:d,last:d,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeFloat(r.volume,o),quoteVolume:this.safeFloat(r.volume,n),info:r}}parseTrade(e,t){const i=this.safeInteger(e,"timestampms"),s=this.safeString(e,"tid"),r=this.safeString(e,"order_id"),a=this.safeString(e,"fee_currency"),o=this.safeCurrencyCode(a),n={cost:this.safeFloat(e,"fee_amount"),currency:o},d=this.safeFloat(e,"price"),c=this.safeFloat(e,"amount");let h=void 0;void 0!==d&&void 0!==c&&(h=d*c);const l=this.safeStringLower(e,"type");let u=void 0;return void 0!==t&&(u=t.symbol),{id:s,order:r,info:e,timestamp:i,datetime:this.iso8601(i),symbol:u,type:void 0,side:l,takerOrMaker:void 0,price:d,cost:h,amount:c,fee:n}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id},o=await this.publicGetV1TradesSymbol(this.extend(a,s));return this.parseTrades(o,r,t,i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostV1Balances(e),i={info:t};for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeFloat(s,"available"),o.total=this.safeFloat(s,"amount"),i[a]=o}return this.parseBalance(i)}parseOrder(e,t){const i=this.safeInteger(e,"timestampms"),s=this.safeFloat(e,"original_amount"),r=this.safeFloat(e,"remaining_amount"),a=this.safeFloat(e,"executed_amount");let o="closed";e.is_live&&(o="open"),e.is_cancelled&&(o="canceled");const n=this.safeFloat(e,"price"),d=this.safeFloat(e,"avg_execution_price");let c=void 0;void 0!==a&&void 0!==d&&(c=a*d);let h=this.safeString(e,"type");h="exchange limit"===h?"limit":"market buy"===h||"market sell"===h?"market":e.type;let l=void 0;if(void 0===t){const i=this.safeString(e,"symbol");i in this.markets_by_id&&(t=this.markets_by_id[i])}void 0!==t&&(l=t.symbol);const u=this.safeString(e,"order_id"),f=this.safeStringLower(e,"side");return{id:u,info:e,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,status:o,symbol:l,type:h,side:f,price:n,average:d,cost:c,amount:s,filled:a,remaining:r,fee:void 0}}async fetchOrder(e,t,i={}){await this.loadMarkets();const s={order_id:e},r=await this.privatePostV1OrderStatus(this.extend(s,i));return this.parseOrder(r)}async fetchOpenOrders(e,t,i,s={}){await this.loadMarkets();const r=await this.privatePostV1Orders(s);let a=this.parseOrders(r,void 0,t,i);if(void 0!==e){const t=this.market(e);a=this.filterBySymbol(a,t.symbol)}return a}async createOrder(e,t,i,s,a,o={}){if(await this.loadMarkets(),"market"===t)throw new r(this.id+" allows limit orders only");const n={client_order_id:this.nonce().toString(),symbol:this.marketId(e),amount:s.toString(),price:a.toString(),side:i,type:"exchange limit"},d=await this.privatePostV1OrderNew(this.extend(n,o));return{info:d,id:d.order_id}}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={order_id:e};return await this.privatePostV1OrderCancel(this.extend(s,i))}async fetchMyTrades(e,t,i,s={}){if(void 0===e)throw new a(this.id+" fetchMyTrades requires a symbol argument");await this.loadMarkets();const r=this.market(e),o={symbol:r.id};void 0!==i&&(o.limit_trades=i),void 0!==t&&(o.timestamp=parseInt(t/1e3));const n=await this.privatePostV1Mytrades(this.extend(o,s));return this.parseTrades(n,r,t,i)}async withdraw(e,t,i,s,r={}){this.checkAddress(i),await this.loadMarkets();const a={currency:this.currency(e).id,amount:t,address:i},o=await this.privatePostV1WithdrawCurrency(this.extend(a,r));return{info:o,id:this.safeString(o,"txHash")}}nonce(){return this.milliseconds()}async fetchTransactions(e,t,i,s={}){await this.loadMarkets();const r={};void 0!==i&&(r.limit_transfers=i),void 0!==t&&(r.timestamp=t);const a=await this.privatePostV1Transfers(this.extend(r,s));return this.parseTransactions(a)}parseTransaction(e,t){const i=this.safeInteger(e,"timestampms"),s=this.safeString(e,"currency"),r=this.safeCurrencyCode(s,t),a=this.safeString(e,"destination"),o=this.safeStringLower(e,"type");let n="pending";e.status&&(n="ok");let d=void 0;const c=this.safeFloat(e,"feeAmount");return void 0!==c&&(d={cost:c,currency:r}),{info:e,id:this.safeString(e,"eid"),txid:this.safeString(e,"txHash"),timestamp:i,datetime:this.iso8601(i),address:a,tag:void 0,type:o,amount:this.safeFloat(e,"amount"),currency:r,status:n,updated:void 0,fee:d}}sign(e,t="public",i="GET",s={},r,a){let o="/"+this.implodeParams(e,s);const n=this.omit(s,this.extractParams(e));if("private"===t){this.checkRequiredCredentials();const e=this.nonce(),t=this.extend({request:o,nonce:e},n);let i=this.json(t);i=this.stringToBase64(this.encode(i));const s=this.hmac(i,this.encode(this.secret),"sha384");r={"Content-Type":"text/plain","X-GEMINI-APIKEY":this.apiKey,"X-GEMINI-PAYLOAD":this.decode(i),"X-GEMINI-SIGNATURE":s}}else Object.keys(n).length&&(o+="?"+this.urlencode(n));return{url:o=this.urls.api[t]+o,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,o,n,d,c){const h=this.exceptions.broad;if(void 0!==n){if("error"===this.safeString(n,"result")){const e=this.safeString(n,"reason"),t=this.safeString(n,"message"),i=this.id+" "+t,s=this.exceptions.exact;if(e in s)throw new s[e](i);if(t in s)throw new s[t](i);const a=this.findBroadlyMatchedKey(h,t);if(void 0!==a)throw new h[a](i);throw new r(i)}}else if("string"==typeof o){const e=this.findBroadlyMatchedKey(h,o),t=this.id+" "+o;if(void 0!==e)throw new h[e](t)}}async createDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},s=await this.privatePostV1DepositCurrencyNewAddress(this.extend(i,t)),r=this.safeString(s,"address");return this.checkAddress(r),{currency:e,address:r,tag:void 0,info:s}}async fetchOHLCV(e,t="5m",i,s,r={}){await this.loadMarkets();const a=this.market(e),o={timeframe:this.timeframes[t],symbol:a.id},n=await this.publicGetV2CandlesSymbolTimeframe(this.extend(o,r));return this.parseOHLCVs(n,a,t,i,s)}}},function(e,t,i){"use strict";const s=i(14);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"huobiru",name:"Huobi Russia",countries:["RU"],hostname:"www.huobi.com.ru",urls:{logo:"https://user-images.githubusercontent.com/1294454/52978816-e8552e00-33e3-11e9-98ed-845acfece834.jpg",api:{market:"https://www.huobi.com.ru/api",public:"https://www.huobi.com.ru/api",private:"https://www.huobi.com.ru/api",zendesk:"https://huobiglobal.zendesk.com/hc/en-us/articles"},www:"https://www.huobi.com.ru/ru-ru",referral:"https://www.huobi.com.ru/invite?invite_code=esc74",doc:"https://github.com/cloudapidoc/API_Docs_en",fees:"https://www.huobi.com.ru/ru-ru/about/fee/"}})}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,AuthenticationError:a}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"ice3x",name:"ICE3X",countries:["ZA"],rateLimit:1e3,version:"v1",has:{fetchCurrencies:!0,fetchTickers:!0,fetchOrder:!0,fetchOpenOrders:!0,fetchMyTrades:!0,fetchDepositAddress:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/38012176-11616c32-3269-11e8-9f05-e65cf885bb15.jpg",api:"https://ice3x.com/api",www:["https://ice3x.com","https://ice3x.co.za"],doc:"https://ice3x.co.za/ice-cubed-bitcoin-exchange-api-documentation-1-june-2017",fees:["https://help.ice3.com/support/solutions/articles/11000033293-trading-fees","https://help.ice3.com/support/solutions/articles/11000033288-fees-explained","https://help.ice3.com/support/solutions/articles/11000008131-what-are-your-fiat-deposit-and-withdrawal-fees-","https://help.ice3.com/support/solutions/articles/11000033289-deposit-fees"],referral:"https://ice3x.com?ref=14341802"},api:{public:{get:["currency/list","currency/info","pair/list","pair/info","stats/marketdepthfull","stats/marketdepthbtcav","stats/marketdepth","orderbook/info","trade/list","trade/info"]},private:{post:["balance/list","balance/info","order/new","order/cancel","order/list","order/info","trade/list","trade/info","transaction/list","transaction/info","invoice/list","invoice/info","invoice/pdf"]}},fees:{trading:{maker:.005,taker:.005}},precision:{amount:8,price:8}})}async fetchCurrencies(e={}){const t=(await this.publicGetCurrencyList(e)).response.entities,i=this.precision.amount,s={};for(let e=0;e<t.length;e++){const r=t[e],a=this.safeString(r,"currency_id"),o=this.safeString(r,"iso"),n=this.safeCurrencyCode(o);s[n]={id:a,code:n,name:r.name,active:!0,precision:i,limits:{amount:{min:void 0,max:Math.pow(10,i)},price:{min:Math.pow(10,-i),max:Math.pow(10,i)},cost:{min:void 0,max:void 0}},info:r}}return s}async fetchMarkets(e={}){void 0===this.currencies_by_id&&(this.currencies=await this.fetchCurrencies(),this.currencies_by_id=this.indexBy(this.currencies,"id"));const t=await this.publicGetPairList(e),i=this.safeValue(t.response,"entities"),s=[];for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"pair_id"),a=this.safeString(t,"currency_id_from"),o=this.safeString(t,"currency_id_to"),n=this.currencies_by_id[a],d=this.currencies_by_id[o],c=n.code,h=d.code,l=c+"/"+h;s.push({id:r,symbol:l,base:c,quote:h,baseId:a,quoteId:o,active:void 0,info:t})}return s}parseTicker(e,t){const i=this.milliseconds(),s=t.symbol,r=this.safeFloat(e,"last_price");return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"max"),low:this.safeFloat(e,"min"),bid:this.safeFloat(e,"max_bid"),bidVolume:void 0,ask:this.safeFloat(e,"min_ask"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:this.safeFloat(e,"avg"),baseVolume:void 0,quoteVolume:this.safeFloat(e,"vol"),info:e}}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={pair_id:i.id},r=await this.publicGetStatsMarketdepthfull(this.extend(s,t)),a=this.safeValue(r.response,"entity");return this.parseTicker(a,i)}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetStatsMarketdepthfull(t),s=this.safeValue(i.response,"entities"),r={};for(let e=0;e<s.length;e++){const t=s[e],i=this.safeString(t,"pair_id"),a=this.safeValue(this.marketsById,i);if(void 0!==a){r[a.symbol]=this.parseTicker(t,a)}}return r}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={pair_id:this.marketId(e)};if(void 0!==t){const e=this.safeString(i,"type");if("ask"!==e&&"bid"!==e)throw new r(this.id+" fetchOrderBook requires an exchange-specific extra 'type' param ('bid' or 'ask') when used with a limit");s.items_per_page=t}const a=await this.publicGetOrderbookInfo(this.extend(s,i)),o=this.safeValue(a.response,"entities");return this.parseOrderBook(o,void 0,"bids","asks","price","amount")}parseTrade(e,t){const i=this.safeTimestamp(e,"created"),s=this.safeFloat(e,"price"),r=this.safeFloat(e,"volume");let a=void 0;void 0!==s&&void 0!==r&&(a=s*r);let o=void 0;const n=this.safeFloat(e,"fee");void 0!==n&&(o={cost:n,currency:t.quote});const d=this.safeString(e,"type"),c=this.safeString(e,"trade_id");let h=void 0;return void 0!==t&&(h=t.symbol),{id:c,info:e,timestamp:i,datetime:this.iso8601(i),symbol:h,order:void 0,type:"limit",side:d,takerOrMaker:void 0,price:s,amount:r,cost:a,fee:o}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={pair_id:r.id},o=await this.publicGetTradeList(this.extend(a,s)),n=this.safeValue(o.response,"entities");return this.parseTrades(n,r,t,i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostBalanceList(e),i={info:t},s=this.safeValue(t.response,"entities",[]);for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"currency_id"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeFloat(t,"balance"),i[a]=o}return this.parseBalance(i)}parseOrder(e,t){const i=this.safeInteger(e,"pair_id");let s=void 0;i&&!t&&i in this.marketsById&&(s=(t=this.marketsById[i]).symbol);const r=this.safeTimestamp(e,"created"),a=this.safeFloat(e,"price"),o=this.safeFloat(e,"volume");let n=this.safeInteger(e,"active"),d=this.safeFloat(e,"remaining"),c=void 0;1===n?n="open":(n="closed",d=0,c=o);let h=void 0;const l=this.safeFloat(e,"fee");return void 0!==l&&(h={cost:l},void 0!==t&&(h.currency=t.quote)),{id:this.safeString(e,"order_id"),datetime:this.iso8601(r),timestamp:r,lastTradeTimestamp:void 0,status:n,symbol:s,type:"limit",side:this.safeStrin(e,"type"),price:a,cost:void 0,amount:o,filled:c,remaining:d,trades:void 0,fee:h,info:e}}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o=this.market(e),n={pair_id:o.id,type:i,amount:s,price:r},d=await this.privatePostOrderNew(this.extend(n,a)),c=this.parseOrder({order_id:d.response.entity.order_id,created:this.seconds(),active:1,type:i,price:r,volume:s,remaining:s,info:d},o),h=c.id;return this.orders[h]=c,c}async cancelOrder(e,t,i={}){const s={order_id:e};return await this.privatePostOrderCancel(this.extend(s,i))}async fetchOrder(e,t,i={}){await this.loadMarkets();const s={"order _id":e},r=await this.privatePostOrderInfo(this.extend(s,i)),a=this.safeValue(r.response,"entity");return this.parseOrder(a)}async fetchOpenOrders(e,t,i,s={}){await this.loadMarkets();const r=await this.privatePostOrderList(s),a=this.safeValue(r.response,"entities");return this.parseOrders(a,void 0,t,i)}async fetchMyTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={pair_id:r.id};void 0!==i&&(a.items_per_page=i),void 0!==t&&(a.date_from=parseInt(t/1e3));const o=await this.privatePostTradeList(this.extend(a,s)),n=this.safeValue(o.response,"entities");return this.parseTrades(n,r,t,i)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={currency_id:this.currency(e).id},s=await this.privatePostBalanceInfo(this.extend(i,t)),r=this.safeValue(s.response,"entity"),a=this.safeString(r,"address");return{currency:e,address:a,tag:void 0,status:a?"ok":"none",info:s}}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api+"/"+this.version+"/"+e;return"public"===t?Object.keys(s).length&&(o+="?"+this.urlencode(s)):(this.checkRequiredCredentials(),a=this.urlencode(this.extend({nonce:this.nonce()},s)),r={"Content-Type":"application/x-www-form-urlencoded",Key:this.apiKey,Sign:this.hmac(this.encode(a),this.encode(this.secret),"sha512")}),{url:o,method:i,body:a,headers:r}}async request(e,t="public",i="GET",s={},o,n){const d=await this.fetch2(e,t,i,s,o,n),c=this.safeValue(d,"errors"),h=this.safeValue(d,"response");if(c||!h){const e=["Key","user_id","Sign"];for(let t=0;t<e.length;t++){const i=e[t],s=this.safeString(c,i);if(s&&!("user_id"===i&&s.indexOf("authorization")<0))throw new a(s)}throw new r(this.json(c))}return d}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,ArgumentsRequired:a,AuthenticationError:o,InsufficientFunds:n,InvalidOrder:d}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"idex",name:"IDEX",countries:["US"],rateLimit:1500,certified:!0,requiresWeb3:!0,has:{fetchOrderBook:!0,fetchTicker:!0,fetchTickers:!0,fetchMarkets:!0,fetchBalance:!0,createOrder:!0,cancelOrder:!0,fetchOpenOrders:!0,fetchTransactions:!0,fetchTrades:!0,fetchMyTrades:!0,withdraw:!0,fetchOHLCV:!1},timeframes:{"1m":"M1","3m":"M3","5m":"M5","15m":"M15","30m":"M30","1h":"H1","4h":"H4","1d":"D1","1w":"D7","1M":"1M"},urls:{test:"https://api.idex.market",logo:"https://user-images.githubusercontent.com/1294454/63693236-3415e380-c81c-11e9-8600-ba1634f1407d.jpg",api:"https://api.idex.market",www:"https://idex.market",doc:["https://docs.idex.market/"]},api:{public:{post:["returnTicker","returnCurrenciesWithPairs","returnCurrencies","return24Volume","returnBalances","returnCompleteBalances","returnDepositsWithdrawals","returnOpenOrders","returnOrderBook","returnOrderStatus","returnOrderTrades","returnTradeHistory","returnTradeHistoryMeta","returnContractAddress","returnNextNonce"]},private:{post:["order","cancel","trade","withdraw"]}},options:{contractAddress:void 0,orderNonce:void 0},exceptions:{"Invalid order signature. Please try again.":o,"You have insufficient funds to match this order. If you believe this is a mistake please refresh and try again.":n,"Order no longer available.":d},requiredCredentials:{walletAddress:!0,privateKey:!0,apiKey:!1,secret:!1}})}async fetchMarkets(e={}){const t=await this.publicPostReturnCurrenciesWithPairs(this.extend({includeDelisted:!0},e)),i={},s=t.tokens;for(let e=0;e<s.length;e++){const t=s[e];i[t.symbol]=t}const r=[],a={amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},o=t.pairs,n=Object.keys(o);for(let e=0;e<n.length;e++){const t=n[e],s=o[t],d=this.safeCurrencyCode(t),c=i[t];for(let e=0;e<s.length;e++){const o=s[e],n=t+"_"+o,h=this.safeCurrencyCode(o),l=h+"/"+d,u=i[o],f=u.address,p=c.address,m={price:this.safeInteger(c,"decimals"),amount:this.safeInteger(u,"decimals")};r.push({symbol:l,precision:m,base:h,quote:d,baseId:f,quoteId:p,limits:a,id:n,info:u,tierBased:!1})}}return r}parseTicker(e,t){let i=void 0;t&&(i=t.symbol);const s=this.safeFloat(e,"baseVolume"),r=this.safeFloat(e,"quoteVolume"),a=this.safeFloat(e,"last"),o=this.safeFloat(e,"percentChange");return{symbol:i,timestamp:void 0,datetime:void 0,high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"highestBid"),bidVolume:void 0,ask:this.safeFloat(e,"lowestAsk"),askVolume:void 0,vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:void 0,percentage:o,average:void 0,baseVolume:s,quoteVolume:r,info:e}}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicPostReturnTicker(t),s=Object.keys(i),r={};for(let e=0;e<s.length;e++){const t=s[e];let a=void 0,o=void 0;if(t in this.markets_by_id)a=(o=this.markets_by_id[t]).symbol;else{const[e,i]=t.split("_");o={symbol:a=this.safeCurrencyCode(i)+"/"+this.safeCurrencyCode(e)}}const n=i[t];r[a]=this.parseTicker(n,o)}return r}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={market:i.id},r=await this.publicPostReturnTicker(this.extend(s,t));return this.parseTicker(r,i)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s=this.market(e),r={market:s.quote+"_"+s.base,count:100};void 0!==t&&(r.count=t);const a=await this.publicPostReturnOrderBook(this.extend(r,i));return this.parseOrderBook(a,void 0,"bids","asks","price","amount")}parseBidAsk(e,t=0,i=1){return[this.safeFloat(e,t),this.safeFloat(e,i),e]}async fetchBalance(e={}){const t={address:this.walletAddress},i=await this.publicPostReturnCompleteBalances(this.extend(t,e)),s={info:i},r=Object.keys(i);for(let e=0;e<r.length;e++){const t=r[e],a=i[t];s[this.safeCurrencyCode(t)]={free:this.safeFloat(a,"available"),used:this.safeFloat(a,"onOrders")}}return this.parseBalance(s)}async createOrder(e,t,i,s,r,o={}){this.checkRequiredDependencies(),await this.loadMarkets();const n=this.market(e);if("limit"===t){const e=1e5,t=await this.getContractAddress();let a=void 0,o=void 0,d=void 0,c=void 0;const h=parseFloat(r)*parseFloat(s);"buy"===i?(a=n.baseId,o=n.quoteId,d=this.toWei(s,"ether",n.precision.amount),c=this.toWei(h,"ether",18)):(a=n.quoteId,o=n.baseId,d=this.toWei(h,"ether",18),c=this.toWei(s,"ether",n.precision.amount));const l=await this.getNonce(),u={contractAddress:t,tokenBuy:a,amountBuy:d,tokenSell:o,amountSell:c,expires:e,nonce:l,address:this.walletAddress},f=this.getIdexCreateOrderHash(u),p=this.signMessage(f,this.privateKey),m={tokenBuy:a,amountBuy:d,tokenSell:o,amountSell:c,address:this.walletAddress,nonce:l,expires:e},y=await this.privatePostOrder(this.extend(m,p));return this.parseOrder(y,n)}if("market"===t){if(!("orderHash"in o))throw new a(this.id+" market order requires an order structure such as that in fetchOrderBook()['bids'][0][2], fetchOrder()['info'], or fetchOpenOrders()[0]['info']");const e={orderHash:o.orderHash,amount:o.params.amountBuy,address:o.params.user,nonce:o.params.nonce},t=this.getIdexMarketOrderHash(e),i=this.signMessage(t,this.privateKey),s=this.extend(e,i);s.address=this.walletAddress,s.nonce=await this.getNonce();const r=await this.privatePostTrade(s);return this.parseOrders(r,n)}}async getNonce(){if(void 0===this.options.orderNonce){const e=await this.publicPostReturnNextNonce({address:this.walletAddress});return this.safeInteger(e,"nonce")}{const e=this.options.orderNonce;return this.options.orderNonce=this.sum(this.options.orderNonce,1),e}}async getContractAddress(){if(void 0!==this.options.contractAddress)return this.options.contractAddress;const e=await this.publicPostReturnContractAddress();return this.options.contractAddress=this.safeString(e,"address"),this.options.contractAddress}async cancelOrder(e,t,i={}){const s=await this.getNonce(),a={orderHash:e,nonce:s},o=this.getIdexCancelOrderHash(a),n=this.signMessage(o,this.privateKey),d={orderHash:e,address:this.walletAddress,nonce:s},c=await this.privatePostCancel(this.extend(d,n));if("success"in c)return{info:c};throw new r(this.id+" cancel order failed "+this.json(c))}async fetchTransactions(e,t,i,s={}){await this.loadMarkets();const r=this.currency(e),a={address:this.walletAddress};void 0!==t&&(a.start=parseInt(Math.floor(t/1e3)));const o=await this.publicPostReturnDepositsWithdrawals(this.extend(a,s)),n=this.parseTransactions(o.deposits,r,t,i),d=this.parseTransactions(o.withdrawals,r,t,i);return this.arrayConcat(n,d)}parseTransaction(e,t){const i=this.safeFloat(e,"amount"),s=this.safeTimestamp(e,"timestamp"),r=this.safeString(e,"transactionHash");let a=void 0,o=void 0,n=void 0,d=void 0,c=void 0;"depositNumber"in e?(a=this.safeString(e,"depositNumber"),o="deposit",d=this.walletAddress,c=this.options.contractAddress):"withdrawalNumber"in e&&(a=this.safeString(e,"withdrawalNumber"),o="withdrawal",n=this.parseTransactionStatus(this.safeString(e,"status")),d=this.options.contractAddress,c=this.walletAddress);const h=this.safeCurrencyCode(this.safeString(e,"currency"));return{info:e,id:a,txid:r,timestamp:s,datetime:this.iso8601(s),currency:h,amount:i,status:n,type:o,updated:void 0,comment:void 0,addressFrom:d,tagFrom:void 0,addressTo:c,tagTo:void 0,fee:{currency:h,cost:void 0,rate:void 0}}}parseTransactionStatus(e){return this.safeString({COMPLETE:"ok"},e)}async fetchOpenOrders(e,t,i,s={}){if(void 0===this.walletAddress)throw new a(this.id+" fetchOpenOrders requires a walletAddress");await this.loadMarkets();const r={address:this.walletAddress};let o=void 0;void 0!==e&&(o=this.market(e),r.market=o.id);const n=await this.publicPostReturnOpenOrders(this.extend(r,s));return this.parseOrders(n,o,t,i)}async fetchOrder(e,t,i={}){await this.loadMarkets();let s=void 0;void 0!==t&&(s=this.market(t));const r={orderHash:e},a=await this.publicPostReturnOrderStatus(this.extend(r,i));return this.parseOrder(a,s)}parseOrder(e,t){const i=this.safeTimestamp(e,"timestamp"),s=this.safeString(e,"type");let r=void 0,a=void 0,o=void 0;"initialAmount"in e?(a=this.safeFloat(e,"initialAmount"),o=this.safeFloat(e,"amount")):a=this.safeFloat(e,"amount");const n=this.safeFloat(e,"filled"),d=this.safeFloat(e,"total"),c=this.safeFloat(e,"price");if("market"in e){const t=e.market;r=this.markets_by_id[t].symbol}else if(void 0!==s&&"params"in e){const t=e.params,i=this.safeCurrencyCode(this.safeString(t,"tokenBuy")),a=this.safeCurrencyCode(this.safeString(t,"tokenSell"));void 0!==i&&void 0!==a&&(r="buy"===s?i+"/"+a:a+"/"+i)}void 0===r&&void 0!==t&&(r=t.symbol);const h=this.safeString(e,"orderHash"),l=this.parseOrderStatus(this.safeString(e,"status"));return{info:e,id:h,symbol:r,timestamp:i,datetime:this.iso8601(i),side:s,amount:a,price:c,type:"limit",filled:n,remaining:o,cost:d,status:l}}parseOrderStatus(e){return this.safeString({open:"open"},e,e)}async fetchMyTrades(e,t,i,s={}){if(void 0===this.walletAddress)throw new a(this.id+" fetchOpenOrders requires a walletAddress");await this.loadMarkets();const r={address:this.walletAddress};let o=void 0;void 0!==e&&(o=this.market(e),r.market=o.id),void 0!==i&&(r.start=parseInt(Math.floor(i)));const n=await this.publicPostReturnTradeHistory(this.extend(r,s));if(Array.isArray(n))return this.parseTrades(n,o,t,i);{let e=[];const s=Object.keys(n);for(let r=0;r<s.length;r++){const a=n[s[r]],d=this.parseTrades(a,o,t,i);e=this.arrayConcat(e,d)}return e}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={market:r.id};void 0!==i&&(a.start=parseInt(Math.floor(i)));const o=await this.publicPostReturnTradeHistory(this.extend(a,s));return this.parseTrades(o,r,t,i)}parseTrade(e,t){const i=this.safeString(e,"type");let s=void 0,r=void 0;const a=this.safeString(e,"maker");let o=void 0;void 0!==a&&void 0!==this.walletAddress&&(o=a.toLowerCase()===this.walletAddress.toLowerCase()?"maker":"taker");const n=this.safeCurrencyCode(this.safeString(e,"tokenBuy")),d=this.safeCurrencyCode(this.safeString(e,"tokenSell"));let c=void 0;void 0!==n&&void 0!==d&&("buy"===i?(c="buyerFee","maker"===o?(r=n+"/"+d,s=n):(r=d+"/"+n,s=d)):(c="sellerFee","maker"===o?(r=d+"/"+n,s=n):(r=n+"/"+d,s=d))),void 0===r&&void 0!==t&&(r=t.symbol);const h=this.safeTimestamp(e,"timestamp"),l=this.safeString(e,"tid"),u=this.safeFloat(e,"amount"),f=this.safeFloat(e,"price"),p=this.safeFloat(e,"total");let m=this.safeFloat(e,c);if(m<0){const t=this.safeFloat(e,"gasFee");m=this.sum(t,m)}const y={currency:s,cost:m};if(void 0!==m&&void 0!==u){const e="ETH"===s?p:u;y.rate=m/e}const b=this.safeString(e,"orderHash");return{info:e,id:l,timestamp:h,datetime:this.iso8601(h),fee:y,price:f,amount:u,cost:p,takerOrMaker:o,side:i,order:b,symbol:r,type:"limit"}}async withdraw(e,t,i,s,r={}){this.checkRequiredDependencies(),this.checkAddress(i),await this.loadMarkets();const a=this.currency(e),o=a.id,n=await this.getNonce();t=this.toWei(t,"ether",a.precision);const d={contractAddress:await this.getContractAddress(),token:o,amount:t,address:i,nonce:n},c=this.getIdexWithdrawHash(d),h=this.signMessage(c,this.privateKey),l={address:i,amount:t,token:o,nonce:n};return{info:await this.privatePostWithdraw(this.extend(l,h)),id:void 0}}sign(e,t="public",i="GET",s={},r,a){a=this.json(s);const o=this.urls.api+"/"+e;return r={"Content-Type":"application/json",Accept:"application/json"},"private"===t&&(this.checkRequiredCredentials(),r["API-Key"]=this.apiKey),{url:o,method:i,body:a,headers:r}}getIdexCreateOrderHash(e){return this.soliditySha3([e.contractAddress,e.tokenBuy,e.amountBuy,e.tokenSell,e.amountSell,e.expires,e.nonce,e.address])}getIdexCancelOrderHash(e){return this.soliditySha3([e.orderHash,e.nonce])}getIdexMarketOrderHash(e){return this.soliditySha3([e.orderHash,e.amount,e.address,e.nonce])}getIdexWithdrawHash(e){return this.soliditySha3([e.contractAddress,e.token,e.amount,e.address,e.nonce])}handleErrors(e,t,i,s,a,o,n,d,c){if(void 0!==n&&"error"in n){if(n.error in this.exceptions)throw new this.exceptions[n.error](this.id+" "+n.error);throw new r(this.id+" "+o)}}}},function(e,t,i){"use strict";const s=i(1);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"independentreserve",name:"Independent Reserve",countries:["AU","NZ"],rateLimit:1e3,has:{CORS:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/30521662-cf3f477c-9bcb-11e7-89bc-d1ac85012eda.jpg",api:{public:"https://api.independentreserve.com/Public",private:"https://api.independentreserve.com/Private"},www:"https://www.independentreserve.com",doc:"https://www.independentreserve.com/API"},api:{public:{get:["GetValidPrimaryCurrencyCodes","GetValidSecondaryCurrencyCodes","GetValidLimitOrderTypes","GetValidMarketOrderTypes","GetValidOrderTypes","GetValidTransactionTypes","GetMarketSummary","GetOrderBook","GetAllOrders","GetTradeHistorySummary","GetRecentTrades","GetFxRates"]},private:{post:["PlaceLimitOrder","PlaceMarketOrder","CancelOrder","GetOpenOrders","GetClosedOrders","GetClosedFilledOrders","GetOrderDetails","GetAccounts","GetTransactions","GetDigitalCurrencyDepositAddress","GetDigitalCurrencyDepositAddresses","SynchDigitalCurrencyDepositAddressWithBlockchain","WithdrawDigitalCurrency","RequestFiatWithdrawal","GetTrades","GetBrokerageFees"]}},fees:{trading:{taker:.005,maker:.005,percentage:!0,tierBased:!1}}})}async fetchMarkets(e={}){const t=await this.publicGetGetValidPrimaryCurrencyCodes(e),i=await this.publicGetGetValidSecondaryCurrencyCodes(e),s=[];for(let e=0;e<t.length;e++){const r=t[e],a=this.safeCurrencyCode(r);for(let e=0;e<i.length;e++){const t=i[e],o=this.safeCurrencyCode(t),n=r+"/"+t,d=a+"/"+o;s.push({id:n,symbol:d,base:a,quote:o,baseId:r,quoteId:t,info:n})}}return s}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGetAccounts(e),i={info:t};for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"CurrencyCode"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeFloat(s,"AvailableBalance"),o.total=this.safeFloat(s,"TotalBalance"),i[a]=o}return this.parseBalance(i)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s=this.market(e),r={primaryCurrencyCode:s.baseId,secondaryCurrencyCode:s.quoteId},a=await this.publicGetGetOrderBook(this.extend(r,i)),o=this.parse8601(this.safeString(a,"CreatedTimestampUtc"));return this.parseOrderBook(a,o,"BuyOrders","SellOrders","Price","Volume")}parseTicker(e,t){const i=this.parse8601(this.safeString(e,"CreatedTimestampUtc"));let s=void 0;t&&(s=t.symbol);const r=this.safeFloat(e,"LastPrice");return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"DayHighestPrice"),low:this.safeFloat(e,"DayLowestPrice"),bid:this.safeFloat(e,"CurrentHighestBidPrice"),bidVolume:void 0,ask:this.safeFloat(e,"CurrentLowestOfferPrice"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:this.safeFloat(e,"DayAvgPrice"),baseVolume:this.safeFloat(e,"DayVolumeXbtInSecondaryCurrrency"),quoteVolume:void 0,info:e}}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={primaryCurrencyCode:i.baseId,secondaryCurrencyCode:i.quoteId},r=await this.publicGetGetMarketSummary(this.extend(s,t));return this.parseTicker(r,i)}parseOrder(e,t){let i=void 0;void 0===t?i=t.symbol:t=this.findMarket(e.PrimaryCurrencyCode+"/"+e.SecondaryCurrencyCode);let s=this.safeValue(e,"Type");s.indexOf("Market")>=0?s="market":s.indexOf("Limit")>=0&&(s="limit");let r=void 0;s.indexOf("Bid")>=0?r="buy":s.indexOf("Offer")>=0&&(r="sell");const a=this.parse8601(e.CreatedTimestampUtc);let o=this.safeFloat(e,"VolumeOrdered");void 0===o&&(o=this.safeFloat(e,"Volume"));const n=this.safeFloat(e,"VolumeFilled");let d=void 0;const c=this.safeFloat(e,"FeePercent");let h=void 0;void 0!==o&&void 0!==n&&(d=o-n,void 0!==c&&(h=c*n));let l=void 0;void 0!==t&&(i=t.symbol,l=t.base);const u={rate:c,cost:h,currency:l},f=this.safeString(e,"OrderGuid"),p=this.parseOrderStatus(this.safeString(e,"Status")),m=this.safeFloat(e,"Value"),y=this.safeFloat(e,"AvgPrice"),b=this.safeFloat(e,"Price",y);return{info:e,id:f,timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:void 0,symbol:i,type:s,side:r,price:b,cost:m,average:y,amount:o,filled:n,remaining:d,status:p,fee:u}}parseOrderStatus(e){return this.safeString({Open:"open",PartiallyFilled:"open",Filled:"closed",PartiallyFilledAndCancelled:"canceled",Cancelled:"canceled",PartiallyFilledAndExpired:"canceled",Expired:"canceled"},e,e)}async fetchOrder(e,t,i={}){await this.loadMarkets();const s=await this.privatePostGetOrderDetails(this.extend({orderGuid:e},i));let r=void 0;return void 0!==t&&(r=this.market(t)),this.parseOrder(s,r)}async fetchMyTrades(e,t,i=50,s={}){await this.loadMarkets();const r=this.safeInteger(s,"pageIndex",1);void 0===i&&(i=50);const a=this.ordered({pageIndex:r,pageSize:i}),o=await this.privatePostGetTrades(this.extend(a,s));let n=void 0;return void 0!==e&&(n=this.market(e)),this.parseTrades(o.Data,n,t,i)}parseTrade(e,t){const i=this.parse8601(e.TradeTimestampUtc),s=this.safeString(e,"TradeGuid"),r=this.safeString(e,"OrderGuid"),a=this.safeFloat2(e,"Price","SecondaryCurrencyTradePrice"),o=this.safeFloat2(e,"VolumeTraded","PrimaryCurrencyAmount");let n=void 0;void 0!==a&&void 0!==o&&(n=a*o);let d=void 0;void 0!==t&&(d=t.symbol);let c=this.safeString(e,"OrderType");return void 0!==c&&(c.indexOf("Bid")>=0?c="buy":c.indexOf("Offer")>=0&&(c="sell")),{id:s,info:e,timestamp:i,datetime:this.iso8601(i),symbol:d,order:r,type:void 0,side:c,takerOrMaker:void 0,price:a,amount:o,cost:n,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={primaryCurrencyCode:r.baseId,secondaryCurrencyCode:r.quoteId,numberOfRecentTradesToRetrieve:50},o=await this.publicGetGetRecentTrades(this.extend(a,s));return this.parseTrades(o.Trades,r,t,i)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o=this.market(e),n=this.capitalize(t),d="privatePostPlace"+n+"Order";let c=n;c+="sell"===i?"Offer":"Bid";const h=this.ordered({primaryCurrencyCode:o.baseId,secondaryCurrencyCode:o.quoteId,orderType:c});"limit"===t&&(h.price=r),h.volume=s;const l=await this[d](this.extend(h,a));return{info:l,id:l.OrderGuid}}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={orderGuid:e};return await this.privatePostCancelOrder(this.extend(s,i))}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api[t]+"/"+e;if("public"===t)Object.keys(s).length&&(o+="?"+this.urlencode(s));else{this.checkRequiredCredentials();const e=this.nonce(),t=[o,"apiKey="+this.apiKey,"nonce="+e.toString()],i=Object.keys(s);for(let e=0;e<i.length;e++){const r=i[e],a=s[r].toString();t.push(r+"="+a)}const n=t.join(","),d=this.hmac(this.encode(n),this.encode(this.secret)),c=this.ordered({});c.apiKey=this.apiKey,c.nonce=e,c.signature=d.toUpperCase();for(let e=0;e<i.length;e++){const t=i[e];c[t]=s[t]}a=this.json(c),r={"Content-Type":"application/json"}}return{url:o,method:i,body:a,headers:r}}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,ArgumentsRequired:a,InsufficientFunds:o,InvalidOrder:n,OrderNotFound:d,AuthenticationError:c,BadRequest:h}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"indodax",name:"INDODAX",countries:["ID"],has:{CORS:!1,createMarketOrder:!1,fetchTickers:!1,fetchOrder:!0,fetchOrders:!1,fetchClosedOrders:!0,fetchOpenOrders:!0,fetchMyTrades:!1,fetchCurrencies:!1,withdraw:!0},version:"1.8",urls:{logo:"https://user-images.githubusercontent.com/1294454/37443283-2fddd0e4-281c-11e8-9741-b4f1419001b5.jpg",api:{public:"https://indodax.com/api",private:"https://indodax.com/tapi"},www:"https://www.indodax.com",doc:"https://indodax.com/downloads/BITCOINCOID-API-DOCUMENTATION.pdf",referral:"https://indodax.com/ref/testbitcoincoid/1"},api:{public:{get:["{pair}/ticker","{pair}/trades","{pair}/depth"]},private:{post:["getInfo","transHistory","trade","tradeHistory","getOrder","openOrders","cancelOrder","orderHistory","withdrawCoin"]}},markets:{"BTC/IDR":{id:"btc_idr",symbol:"BTC/IDR",base:"BTC",quote:"IDR",baseId:"btc",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:1e-4,max:void 0}}},"ACT/IDR":{id:"act_idr",symbol:"ACT/IDR",base:"ACT",quote:"IDR",baseId:"act",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:void 0,max:void 0}}},"ADA/IDR":{id:"ada_idr",symbol:"ADA/IDR",base:"ADA",quote:"IDR",baseId:"ada",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:void 0,max:void 0}}},"BCD/IDR":{id:"bcd_idr",symbol:"BCD/IDR",base:"BCD",quote:"IDR",baseId:"bcd",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:void 0,max:void 0}}},"BCH/IDR":{id:"bch_idr",symbol:"BCH/IDR",base:"BCH",quote:"IDR",baseId:"bch",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:.001,max:void 0}}},"BTG/IDR":{id:"btg_idr",symbol:"BTG/IDR",base:"BTG",quote:"IDR",baseId:"btg",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:.01,max:void 0}}},"BTS/IDR":{id:"bts_idr",symbol:"BTS/IDR",base:"BTS",quote:"IDR",baseId:"bts",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:.01,max:void 0}}},"DASH/IDR":{id:"drk_idr",symbol:"DASH/IDR",base:"DASH",quote:"IDR",baseId:"drk",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:.01,max:void 0}}},"DOGE/IDR":{id:"doge_idr",symbol:"DOGE/IDR",base:"DOGE",quote:"IDR",baseId:"doge",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:1e3,max:void 0}}},"ETH/IDR":{id:"eth_idr",symbol:"ETH/IDR",base:"ETH",quote:"IDR",baseId:"eth",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:.01,max:void 0}}},"ETC/IDR":{id:"etc_idr",symbol:"ETC/IDR",base:"ETC",quote:"IDR",baseId:"etc",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:.1,max:void 0}}},"GSC/IDR":{id:"gsc_idr",symbol:"GSC/IDR",base:"GSC",quote:"IDR",baseId:"gsc",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:.1,max:void 0}}},"IGNIS/IDR":{id:"ignis_idr",symbol:"IGNIS/IDR",base:"IGNIS",quote:"IDR",baseId:"ignis",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:1,max:void 0}}},"LTC/IDR":{id:"ltc_idr",symbol:"LTC/IDR",base:"LTC",quote:"IDR",baseId:"ltc",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:.01,max:void 0}}},"NPXS/IDR":{id:"npxs_idr",symbol:"NPXS/IDR",base:"NPXS",quote:"IDR",baseId:"npxs",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:1,max:void 0}}},"NXT/IDR":{id:"nxt_idr",symbol:"NXT/IDR",base:"NXT",quote:"IDR",baseId:"nxt",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:5,max:void 0}}},"STQ/IDR":{id:"stq_idr",symbol:"STQ/IDR",base:"STQ",quote:"IDR",baseId:"stq",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:void 0,max:void 0}}},"TEN/IDR":{id:"ten_idr",symbol:"TEN/IDR",base:"TEN",quote:"IDR",baseId:"ten",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:5,max:void 0}}},"TRX/IDR":{id:"trx_idr",symbol:"TRX/IDR",base:"TRX",quote:"IDR",baseId:"trx",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:void 0,max:void 0}}},"WAVES/IDR":{id:"waves_idr",symbol:"WAVES/IDR",base:"WAVES",quote:"IDR",baseId:"waves",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:.1,max:void 0}}},"XEM/IDR":{id:"nem_idr",symbol:"XEM/IDR",base:"XEM",quote:"IDR",baseId:"nem",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:1,max:void 0}}},"XLM/IDR":{id:"str_idr",symbol:"XLM/IDR",base:"XLM",quote:"IDR",baseId:"str",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:20,max:void 0}}},"XRP/IDR":{id:"xrp_idr",symbol:"XRP/IDR",base:"XRP",quote:"IDR",baseId:"xrp",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:10,max:void 0}}},"XZC/IDR":{id:"xzc_idr",symbol:"XZC/IDR",base:"XZC",quote:"IDR",baseId:"xzc",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:.1,max:void 0}}},"BTS/BTC":{id:"bts_btc",symbol:"BTS/BTC",base:"BTS",quote:"BTC",baseId:"bts",quoteId:"btc",precision:{amount:8,price:8},limits:{amount:{min:.01,max:void 0}}},"DASH/BTC":{id:"drk_btc",symbol:"DASH/BTC",base:"DASH",quote:"BTC",baseId:"drk",quoteId:"btc",precision:{amount:8,price:6},limits:{amount:{min:.01,max:void 0}}},"DOGE/BTC":{id:"doge_btc",symbol:"DOGE/BTC",base:"DOGE",quote:"BTC",baseId:"doge",quoteId:"btc",precision:{amount:8,price:8},limits:{amount:{min:1,max:void 0}}},"ETH/BTC":{id:"eth_btc",symbol:"ETH/BTC",base:"ETH",quote:"BTC",baseId:"eth",quoteId:"btc",precision:{amount:8,price:5},limits:{amount:{min:.001,max:void 0}}},"LTC/BTC":{id:"ltc_btc",symbol:"LTC/BTC",base:"LTC",quote:"BTC",baseId:"ltc",quoteId:"btc",precision:{amount:8,price:6},limits:{amount:{min:.01,max:void 0}}},"NXT/BTC":{id:"nxt_btc",symbol:"NXT/BTC",base:"NXT",quote:"BTC",baseId:"nxt",quoteId:"btc",precision:{amount:8,price:8},limits:{amount:{min:.01,max:void 0}}},"TEN/BTC":{id:"ten_btc",symbol:"TEN/BTC",base:"TEN",quote:"BTC",baseId:"ten",quoteId:"btc",precision:{amount:8,price:8},limits:{amount:{min:.01,max:void 0}}},"XEM/BTC":{id:"nem_btc",symbol:"XEM/BTC",base:"XEM",quote:"BTC",baseId:"nem",quoteId:"btc",precision:{amount:8,price:8},limits:{amount:{min:1,max:void 0}}},"XLM/BTC":{id:"str_btc",symbol:"XLM/BTC",base:"XLM",quote:"BTC",baseId:"str",quoteId:"btc",precision:{amount:8,price:8},limits:{amount:{min:.01,max:void 0}}},"XRP/BTC":{id:"xrp_btc",symbol:"XRP/BTC",base:"XRP",quote:"BTC",baseId:"xrp",quoteId:"btc",precision:{amount:8,price:8},limits:{amount:{min:.01,max:void 0}}}},fees:{trading:{tierBased:!1,percentage:!0,maker:0,taker:.003}},exceptions:{exact:{invalid_pair:h,"Insufficient balance.":o,"invalid order.":d,"Invalid credentials. API not found or session has expired.":c,"Invalid credentials. Bad sign.":c},broad:{"Minimum price":n,"Minimum order":n}}})}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGetInfo(e),i=this.safeValue(t,"return",{}),s=this.safeValue(i,"balance",{}),r=this.safeValue(i,"balance_hold",{}),a={info:t},o=Object.keys(s);for(let e=0;e<o.length;e++){const t=o[e],i=this.safeCurrencyCode(t),n=this.account();n.free=this.safeFloat(s,t),n.used=this.safeFloat(r,t),a[i]=n}return this.parseBalance(a)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={pair:this.marketId(e)},r=await this.publicGetPairDepth(this.extend(s,i));return this.parseOrderBook(r,void 0,"buy","sell")}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={pair:i.id},r=(await this.publicGetPairTicker(this.extend(s,t))).ticker,a=this.safeTimestamp(r,"server_time"),o="vol_"+i.baseId.toLowerCase(),n="vol_"+i.quoteId.toLowerCase(),d=this.safeFloat(r,"last");return{symbol:e,timestamp:a,datetime:this.iso8601(a),high:this.safeFloat(r,"high"),low:this.safeFloat(r,"low"),bid:this.safeFloat(r,"buy"),bidVolume:void 0,ask:this.safeFloat(r,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:d,last:d,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeFloat(r,o),quoteVolume:this.safeFloat(r,n),info:r}}parseTrade(e,t){const i=this.safeTimestamp(e,"date"),s=this.safeString(e,"tid");let r=void 0;void 0!==t&&(r=t.symbol);const a=this.safeString(e,"type"),o=this.safeFloat(e,"price"),n=this.safeFloat(e,"amount");let d=void 0;return void 0!==o&&void 0!==n&&(d=o*n),{id:s,info:e,timestamp:i,datetime:this.iso8601(i),symbol:r,type:void 0,side:a,order:void 0,takerOrMaker:void 0,price:o,amount:n,cost:d,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={pair:r.id},o=await this.publicGetPairTrades(this.extend(a,s));return this.parseTrades(o,r,t,i)}parseOrder(e,t){let i=void 0;"type"in e&&(i=e.type);let s=this.safeString(e,"status","open");"filled"===s?s="closed":"calcelled"===s&&(s="canceled");let r=void 0,a=void 0;const o=this.safeFloat(e,"price");let n=void 0,d=void 0,c=void 0;if(void 0!==t){r=t.symbol;let i=t.quoteId,s=t.baseId;if("idr"===t.quoteId&&"order_rp"in e&&(i="rp"),"idr"===t.baseId&&"remain_rp"in e&&(s="rp"),a=this.safeFloat(e,"order_"+i)){n=a/o;const t=this.safeFloat(e,"remain_"+i);void 0!==t&&(c=n-(d=t/o))}else a=o*(n=this.safeFloat(e,"order_"+s)),c=n-(d=this.safeFloat(e,"remain_"+s))}let h=void 0;c&&(h=a/c);const l=this.safeInteger(e,"submit_time");return{info:e,id:this.safeString(e,"order_id"),timestamp:l,datetime:this.iso8601(l),lastTradeTimestamp:void 0,symbol:r,type:"limit",side:i,price:o,cost:a,average:h,amount:n,filled:c,remaining:d,status:s,fee:void 0}}async fetchOrder(e,t,i={}){if(void 0===t)throw new r(this.id+" fetchOrder requires a symbol");await this.loadMarkets();const s=this.market(t),a={pair:s.id,order_id:e},o=await this.privatePostGetOrder(this.extend(a,i)),n=o.return,d=this.parseOrder(this.extend({id:e},n.order),s);return this.extend({info:o},d)}async fetchOpenOrders(e,t,i,s={}){await this.loadMarkets();let r=void 0;const a={};void 0!==e&&(r=this.market(e),a.pair=r.id);const o=(await this.privatePostOpenOrders(this.extend(a,s))).return.orders;if(!o)return[];if(void 0!==e)return this.parseOrders(o,r,t,i);const n=Object.keys(o);let d=[];for(let e=0;e<n.length;e++){const s=n[e],a=o[s];r=this.markets_by_id[s];const c=this.parseOrders(a,r,t,i);d=this.arrayConcat(d,c)}return d}async fetchClosedOrders(e,t,i,s={}){if(void 0===e)throw new r(this.id+" fetchOrders requires a symbol");await this.loadMarkets();const a={};let o=void 0;void 0!==e&&(o=this.market(e),a.pair=o.id);const n=await this.privatePostOrderHistory(this.extend(a,s));let d=this.parseOrders(n.return.orders,o,t,i);return d=this.filterBy(d,"status","closed"),void 0!==e?this.filterBySymbol(d,e):d}async createOrder(e,t,i,s,a,o={}){if("limit"!==t)throw new r(this.id+" allows limit orders only");await this.loadMarkets();const n=this.market(e),d={pair:n.id,type:i,price:a},c=n.baseId;"buy"===i?d[n.quoteId]=s*a:d[n.baseId]=s,d[c]=s;const h=await this.privatePostTrade(this.extend(d,o));return{info:h,id:h.return.order_id.toString()}}async cancelOrder(e,t,i={}){if(void 0===t)throw new a(this.id+" cancelOrder requires a symbol argument");const s=this.safeValue(i,"side");if(void 0===s)throw new r(this.id+' cancelOrder requires an extra "side" param');await this.loadMarkets();const o={order_id:e,pair:this.market(t).id,type:s};return await this.privatePostCancelOrder(this.extend(o,i))}async withdraw(e,t,i,s,r={}){this.checkAddress(i),await this.loadMarkets();const a=this.currency(e),o=this.milliseconds(),n={currency:a.id,withdraw_amount:t,withdraw_address:i,request_id:o.toString()};s&&(n.withdraw_memo=s);const d=await this.privatePostWithdrawCoin(this.extend(n,r));let c=void 0;return"txid"in d&&d.txid.length>0&&(c=d.txid),{info:d,id:c}}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api[t];return"public"===t?o+="/"+this.implodeParams(e,s):(this.checkRequiredCredentials(),a=this.urlencode(this.extend({method:e,nonce:this.nonce()},s)),r={"Content-Type":"application/x-www-form-urlencoded",Key:this.apiKey,Sign:this.hmac(this.encode(a),this.encode(this.secret),"sha512")}),{url:o,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,o,n,d,c){if(void 0===n)return;if(Array.isArray(n))return;const h=this.safeValue(n,"error","");if(!("success"in n)&&""===h)return;if(1===this.safeInteger(n,"success",0)){if("return"in n)return;throw new r(this.id+": malformed response: "+this.json(n))}const l=this.id+" "+o,u=this.exceptions.exact;if(h in u)throw new u[h](l);const f=this.exceptions.broad,p=this.findBroadlyMatchedKey(f,h);if(void 0!==p)throw new f[p](l);throw new r(l)}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,AuthenticationError:a}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"itbit",name:"itBit",countries:["US"],rateLimit:2e3,version:"v1",has:{CORS:!0,createMarketOrder:!1,fetchMyTrades:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27822159-66153620-60ad-11e7-89e7-005f6d7f3de0.jpg",api:"https://api.itbit.com",www:"https://www.itbit.com",doc:["https://api.itbit.com/docs","https://www.itbit.com/api"]},api:{public:{get:["markets/{symbol}/ticker","markets/{symbol}/order_book","markets/{symbol}/trades"]},private:{get:["wallets","wallets/{walletId}","wallets/{walletId}/balances/{currencyCode}","wallets/{walletId}/funding_history","wallets/{walletId}/trades","wallets/{walletId}/orders","wallets/{walletId}/orders/{id}"],post:["wallet_transfers","wallets","wallets/{walletId}/cryptocurrency_deposits","wallets/{walletId}/cryptocurrency_withdrawals","wallets/{walletId}/orders","wire_withdrawal"],delete:["wallets/{walletId}/orders/{id}"]}},markets:{"BTC/USD":{id:"XBTUSD",symbol:"BTC/USD",base:"BTC",quote:"USD"},"BTC/SGD":{id:"XBTSGD",symbol:"BTC/SGD",base:"BTC",quote:"SGD"},"BTC/EUR":{id:"XBTEUR",symbol:"BTC/EUR",base:"BTC",quote:"EUR"},"ETH/USD":{id:"ETHUSD",symbol:"ETH/USD",base:"ETH",quote:"USD"},"ETH/EUR":{id:"ETHEUR",symbol:"ETH/EUR",base:"ETH",quote:"EUR"},"ETH/SGD":{id:"ETHSGD",symbol:"ETH/SGD",base:"ETH",quote:"SGD"}},fees:{trading:{maker:-3e-4,taker:.35/100}},commonCurrencies:{XBT:"BTC"}})}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={symbol:this.marketId(e)},r=await this.publicGetMarketsSymbolOrderBook(this.extend(s,i));return this.parseOrderBook(r)}async fetchTicker(e,t={}){await this.loadMarkets();const i={symbol:this.marketId(e)},s=await this.publicGetMarketsSymbolTicker(this.extend(i,t)),a=this.safeString(s,"serverTimeUTC");if(!a)throw new r(this.id+" fetchTicker returned a bad response: "+this.json(s));const o=this.parse8601(a),n=this.safeFloat(s,"vwap24h"),d=this.safeFloat(s,"volume24h");let c=void 0;void 0!==d&&void 0!==n&&(c=d*n);const h=this.safeFloat(s,"lastPrice");return{symbol:e,timestamp:o,datetime:this.iso8601(o),high:this.safeFloat(s,"high24h"),low:this.safeFloat(s,"low24h"),bid:this.safeFloat(s,"bid"),bidVolume:void 0,ask:this.safeFloat(s,"ask"),askVolume:void 0,vwap:n,open:this.safeFloat(s,"openToday"),close:h,last:h,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:d,quoteVolume:c,info:s}}parseTrade(e,t){const i=this.safeString2(e,"executionId","matchNumber"),s=this.parse8601(this.safeString(e,"timestamp")),r=this.safeString(e,"direction"),a=this.safeString(e,"orderId");let o=this.safeFloat(e,"commissionPaid");const n=this.safeString(e,"commissionCurrency"),d=this.safeCurrencyCode(n);let c=this.safeFloat(e,"rebatesApplied");void 0!==c&&(c=-c);const h=this.safeString(e,"rebateCurrency"),l=this.safeCurrencyCode(h),u=this.safeFloat2(e,"price","rate"),f=this.safeFloat2(e,"currency1Amount","amount");let p=void 0;void 0!==u&&void 0!==f&&(p=u*f);let m=void 0;const y=this.safeString(e,"instrument");if(void 0!==y)if(y in this.markets_by_id)t=this.markets_by_id[y];else{const t=this.safeString(e,"currency1"),i=this.safeString(e,"currency2");m=this.safeCurrencyCode(t)+"/"+this.safeCurrencyCode(i)}void 0===m&&void 0!==t&&(m=t.symbol);const b={info:e,id:i,timestamp:s,datetime:this.iso8601(s),symbol:m,order:a,type:void 0,side:r,takerOrMaker:void 0,price:u,amount:f,cost:p};return void 0!==o&&(void 0!==c?d===l?(o=this.sum(o,c),b.fee={cost:o,currency:d}):b.fees=[{cost:o,currency:d},{cost:c,currency:l}]:b.fee={cost:o,currency:d}),"fee"in b||"fees"in b||(b.fee=void 0),b}async fetchTransactions(e,t,i,s={}){await this.loadMarkets();const a=this.safeString(s,"walletId");if(void 0===a)throw new r(this.id+" fetchMyTrades requires a walletId parameter");const o={walletId:a};void 0!==i&&(o.perPage=i);const n=(await this.privateGetWalletsWalletIdFundingHistory(this.extend(o,s))).fundingHistory,d=[];for(let e=0;e<n.length;e++){const t=n[e],i=this.safeString(t,"time"),s=this.parse8601(i),r=this.safeString(t,"currency"),a=this.safeString(t,"destinationAddress"),o=this.safeString(t,"txnHash"),c=this.safeStringLower(t,"transactionType"),h=this.safeString(t,"status"),l=this.parseTransferStatus(h);d.push({id:this.safeString(t,"withdrawalId"),timestamp:s,datetime:this.iso8601(s),currency:this.safeCurrencyCode(r),address:a,tag:void 0,txid:o,type:c,status:l,amount:this.safeFloat(t,"amount"),fee:void 0,info:t})}return d}parseTransferStatus(e){return this.safeString({cancelled:"canceled",completed:"ok"},e,"pending")}async fetchMyTrades(e,t,i,s={}){await this.loadMarkets();const a=this.safeString(s,"walletId");if(void 0===a)throw new r(this.id+" fetchMyTrades requires a walletId parameter");const o={walletId:a};void 0!==t&&(o.rangeStart=this.ymdhms(t,"T")),void 0!==i&&(o.perPage=i);const n=await this.privateGetWalletsWalletIdTrades(this.extend(o,s)),d=this.safeValue(n,"tradingHistory",[]);let c=void 0;return void 0!==e&&(c=this.market(e)),this.parseTrades(d,c,t,i)}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id},o=await this.publicGetMarketsSymbolTrades(this.extend(a,s)),n=this.safeValue(o,"recentTrades",[]);return this.parseTrades(n,r,t,i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.fetchWallets(e),i=t[0].balances,s={info:t};for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeFloat(t,"availableBalance"),o.total=this.safeFloat(t,"totalBalance"),s[a]=o}return this.parseBalance(s)}async fetchWallets(e={}){if(!this.uid)throw new a(this.id+" fetchWallets requires uid API credential");const t={userId:this.uid};return await this.privateGetWallets(this.extend(t,e))}async fetchWallet(e,t={}){const i={walletId:e};return await this.privateGetWalletsWalletId(this.extend(i,t))}async fetchOpenOrders(e,t,i,s={}){return await this.fetchOrders(e,t,i,this.extend({status:"open"},s))}async fetchClosedOrders(e,t,i,s={}){return await this.fetchOrders(e,t,i,this.extend({status:"filled"},s))}async fetchOrders(e,t,i,s={}){if(!("walletId"in s))throw new r(this.id+" fetchOrders requires a walletId parameter");const a={walletId:s.walletId},o=await this.privateGetWalletsWalletIdOrders(this.extend(a,s));return this.parseOrders(o,void 0,t,i)}parseOrder(e,t){const i=e.side,s=e.type,r=this.markets_by_id[e.instrument].symbol,a=this.parse8601(e.createdTime),o=this.safeFloat(e,"amount"),n=this.safeFloat(e,"amountFilled"),d=o-n,c=this.safeFloat(e,"price"),h=this.safeFloat(e,"volumeWeightedAveragePrice"),l=n*h;return{id:e.id,info:e,timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:void 0,status:e.status,symbol:r,type:s,side:i,price:c,cost:l,average:h,amount:o,filled:n,remaining:d,fee:void 0}}nonce(){return this.milliseconds()}async createOrder(e,t,i,s,a,o={}){if("market"===t)throw new r(this.id+" allows limit orders only");if(!("walletId"in o))throw new r(this.id+" createOrder requires a walletId parameter");s=s.toString(),a=a.toString();const n=this.market(e),d={side:i,type:t,currency:n.id.replace(n.quote,""),amount:s,display:s,price:a,instrument:n.id},c=await this.privatePostWalletsWalletIdOrders(this.extend(d,o));return{info:c,id:c.id}}async fetchOrder(e,t,i={}){if(!("walletId"in i))throw new r(this.id+" fetchOrder requires a walletId parameter");const s={id:e},a=await this.privateGetWalletsWalletIdOrdersId(this.extend(s,i));return this.parseOrder(a)}async cancelOrder(e,t,i={}){if(!("walletId"in i))throw new r(this.id+" cancelOrder requires a walletId parameter");const s={id:e};return await this.privateDeleteWalletsWalletIdOrdersId(this.extend(s,i))}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api+"/"+this.version+"/"+this.implodeParams(e,s);const n=this.omit(s,this.extractParams(e));if("GET"===i&&Object.keys(n).length&&(o+="?"+this.urlencode(n)),"POST"===i&&Object.keys(n).length&&(a=this.json(n)),"private"===t){this.checkRequiredCredentials();const e=this.nonce().toString(),t=e,s=[i,o,"POST"===i?a:"",e,t],n=e+this.json(s).replace("\\/","/"),d=this.hash(this.encode(n),"sha256","binary"),c=this.stringToBinary(this.encode(o)),h=this.binaryConcat(c,d),l=this.hmac(h,this.encode(this.secret),"sha512","base64");r={Authorization:this.apiKey+":"+this.decode(l),"Content-Type":"application/json","X-Auth-Timestamp":t,"X-Auth-Nonce":e}}return{url:o,method:i,body:a,headers:r}}async request(e,t="public",i="GET",s={},a,o){const n=await this.fetch2(e,t,i,s,a,o);if("code"in n)throw new r(this.id+" "+this.json(n));return n}}},function(e,t,i){"use strict";const s=i(1),{ArgumentsRequired:r,InvalidOrder:a,OrderNotFound:o}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"kkex",name:"KKEX",countries:["CN","US","JP"],version:"v2",has:{CORS:!1,fetchBalance:!0,fetchTickers:!0,fetchOrders:!0,fetchOpenOrders:!0,fetchClosedOrders:!0,fetchMyTrades:!0,fetchOHLCV:!0,createMarketOrder:!0,fetchOrder:!0},timeframes:{"1m":"1min","5m":"5min","15m":"15min","30m":"30min","1h":"1hour","4h":"4hour","12h":"12hour","1d":"1day","1w":"1week","1M":"1month"},urls:{logo:"https://user-images.githubusercontent.com/1294454/47401462-2e59f800-d74a-11e8-814f-e4ae17b4968a.jpg",api:{public:"https://kkex.com/api/v1",private:"https://kkex.com/api/v2",v1:"https://kkex.com/api/v1"},www:"https://kkex.com",doc:"https://kkex.com/api_wiki/cn/",fees:"https://intercom.help/kkex/fee"},api:{public:{get:["exchange_rate","products","assets","tickers","ticker","depth","trades","kline"]},private:{post:["profile","trade","batch_trade","cancel_order","cancel_all_orders","order_history","userinfo","order_info","orders_info"]},v1:{post:["process_strategy"]}},fees:{trading:{tierBased:!1,percentage:!0,taker:.002,maker:.002},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{}}},options:{lastNonceTimestamp:0}})}async fetchMarkets(e={}){let t=await this.publicGetTickers(e);t=t.tickers;let i=await this.publicGetProducts(e);i=i.products;const s=[];for(let e=0;e<t.length;e++){const i=Object.keys(t[e]);s.push(i[0])}const r=[];for(let e=0;e<s.length;e++){const t=s[e],a=s[e];let o="",n="",d={},c={};for(let e=0;e<i.length;e++){const t=i[e];if(t.mark_asset+t.base_asset===a){n=t.base_asset,o=t.mark_asset;const e=t.price_scale.toString().length-1;d={price:e,amount:e},(c={amount:{min:Math.max(this.safeFloat(t,"min_bid_size"),this.safeFloat(t,"min_ask_size")),max:Math.min(this.safeFloat(t,"max_bid_size"),this.safeFloat(t,"max_ask_size"))},price:{min:this.safeFloat(t,"min_price"),max:this.safeFloat(t,"max_price")}}).cost={min:this.safeFloat(t,"min_bid_amount"),max:this.safeFloat(t,"max_bid_amount")}}}const h=this.safeCurrencyCode(o),l=this.safeCurrencyCode(n),u=h+"/"+l;r.push({id:t,symbol:u,base:h,quote:l,baseId:o,quoteId:n,active:!0,precision:d,limits:c,info:a})}return r}parseTicker(e,t){const i=this.safeTimestamp(e,"date");let s=void 0;void 0!==t&&(s=t.symbol);const r=this.safeFloat(e,"last");return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"buy"),bidVolume:void 0,ask:this.safeFloat(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeFloat(e,"vol"),quoteVolume:void 0,info:e}}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.markets[e],s={symbol:i.id},r=await this.publicGetTicker(this.extend(s,t)),a=this.extend(r.ticker,this.omit(r,"ticker"));return this.parseTicker(a,i)}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetTickers(t),s=this.safeValue(i,"tickers"),r={};for(let e=0;e<s.length;e++){const t=Object.keys(s[e])[0],a=this.safeValue(this.markets_by_id,t);if(void 0!==a){const o=a.symbol,n=this.extend(s[e][t],this.omit(i,"tickers"));r[o]=this.parseTicker(n,a)}}return r}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={symbol:this.marketId(e)};void 0!==t&&(s.size=t);const r=await this.publicGetDepth(this.extend(s,i));return this.parseOrderBook(r)}parseTrade(e,t){const i=this.safeInteger(e,"date_ms"),s=this.iso8601(i),r=this.safeFloat(e,"price"),a=this.safeFloat(e,"amount");let o=void 0;void 0!==r&&void 0!==a&&(o=a*r);let n=void 0;void 0!==t&&(n=t.symbol);return{info:e,id:this.safeString(e,"tid"),timestamp:i,datetime:s,symbol:n,order:void 0,type:void 0,side:this.safeString(e,"type"),takerOrMaker:void 0,price:r,amount:a,cost:o,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id},o=await this.publicGetTrades(this.extend(a,s));return this.parseTrades(o,r,t,i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostUserinfo(e),i=this.safeValue(t,"info"),s={info:t},r=this.safeValue(i,"funds"),a=this.safeValue(r,"free",{}),o=this.safeValue(r,"freezed",{}),n=Object.keys(a);for(let e=0;e<n.length;e++){const t=n[e],i=this.safeCurrencyCode(t),r=this.account();r.free=this.safeFloat(a,t),r.used=this.safeFloat(o,t),s[i]=r}return this.parseBalance(s)}async fetchOrder(e,t,i={}){if(!t)throw new r(this.id+" fetchOrder requires a symbol argument");await this.loadMarkets();const s=this.market(t),a={order_id:e,symbol:s.id},n=await this.privatePostOrderInfo(this.extend(a,i));if(n.result)return this.parseOrder(n.order,s);throw new o(this.id+" order "+e+" not found")}parseOHLCV(e,t,i="1m",s,r){return[parseInt(e[0]),parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3]),parseFloat(e[4]),parseFloat(e[5])]}async fetchOHLCV(e,t="1m",i,s,r={}){await this.loadMarkets();const a=this.market(e),o={symbol:a.id,type:this.timeframes[t]};void 0!==i&&(o.since=parseInt(i/1e3)),void 0!==s&&(o.size=s);const n=await this.publicGetKline(this.extend(o,r));return this.parseOHLCVs(n,a,t,i,s)}parseOrderStatus(e){return this.safeString({"-1":"canceled",0:"open",1:"open",2:"closed",3:"open",4:"canceled"},e,e)}parseOrder(e,t){let i=void 0;void 0!==t&&(i=t.symbol);let s=this.safeString(e,"side");void 0===s&&(s=this.safeString(e,"type"));const r=this.safeInteger(e,"create_date"),a=this.safeString2(e,"order_id","id"),o=this.parseOrderStatus(this.safeString(e,"status")),n=this.safeFloat(e,"price"),d=this.safeFloat(e,"amount"),c=this.safeFloat(e,"deal_amount");let h=this.safeFloat(e,"avg_price");h=this.safeFloat(e,"price_avg",h);let l=void 0,u=void 0;return void 0!==c&&(void 0!==d&&(l=d-c),void 0!==h&&(u=h*c)),{id:a,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,status:o,symbol:i,average:h,type:"limit",side:s,price:n,cost:u,amount:d,filled:c,remaining:l,fee:void 0,info:e}}async createOrder(e,t,i,s,r,o={}){await this.loadMarkets();const n={symbol:this.market(e).id,type:i};if("market"===t){if("buy"===i){if(this.options.createMarketBuyOrderRequiresPrice){if(void 0===r)throw new a(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the cost in the amount argument (the exchange-specific behaviour)");s*=r}n.price=this.amountToPrecision(e,s)}else n.amount=this.amountToPrecision(e,s);n.type+="_"+t}else n.amount=this.amountToPrecision(e,s),n.price=this.priceToPrecision(e,r);const d=await this.privatePostTrade(this.extend(n,o));return{info:d,id:this.safeString(d,"order_id"),datetime:void 0,timestamp:void 0,lastTradeTimestamp:void 0,status:"open",symbol:e,type:t,side:i,price:r,cost:void 0,amount:s,filled:void 0,remaining:void 0,trades:void 0,fee:void 0}}async cancelOrder(e,t,i={}){if(void 0===t)throw new r(this.id+" cancelOrder requires a symbol argument");await this.loadMarkets();const s={order_id:e,symbol:this.market(t).id};return await this.privatePostCancelOrder(this.extend(s,i))}async fetchOrders(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id};void 0!==i&&(a.page_length=i);const o=await this.privatePostOrderHistory(this.extend(a,s));return this.parseOrders(o.orders,r,t,i)}async fetchOpenOrders(e,t,i,s={}){return await this.fetchOrders(e,t,i,this.extend({status:0},s))}async fetchClosedOrders(e,t,i,s={}){return await this.fetchOrders(e,t,i,this.extend({status:1},s))}nonce(){return this.milliseconds()}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api[t]+"/"+e;if("public"===t)o+="?"+this.urlencode(s),r={"Content-Type":"application/json"};else{this.checkRequiredCredentials();const e=this.nonce();let t=this.extend({nonce:e,api_key:this.apiKey},s);t=this.urlencode(this.keysort(t)),t+="&secret_key="+this.secret,t=(t=this.hash(this.encode(t),"md5")).toUpperCase(),a=this.extend({api_key:this.apiKey,sign:t,nonce:e},s),a=this.urlencode(a),r={"Content-Type":"application/x-www-form-urlencoded"}}return{url:o,method:i,body:a,headers:r}}}},function(e,t,i){"use strict";const s=i(1),{ExchangeNotAvailable:r,ArgumentsRequired:a,PermissionDenied:o,AuthenticationError:n,ExchangeError:d,OrderNotFound:c,DDoSProtection:h,InvalidNonce:l,InsufficientFunds:u,CancelPending:f,InvalidOrder:p,InvalidAddress:m,NotSupported:y}=i(0),{TRUNCATE:b,DECIMAL_PLACES:v}=i(2);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"kraken",name:"Kraken",countries:["US"],version:"0",rateLimit:3e3,certified:!0,has:{createDepositAddress:!0,fetchDepositAddress:!0,fetchTradingFee:!0,fetchTradingFees:!0,CORS:!1,fetchCurrencies:!0,fetchTickers:!0,fetchOHLCV:!0,fetchOrder:!0,fetchOpenOrders:!0,fetchClosedOrders:!0,fetchMyTrades:!0,fetchWithdrawals:!0,fetchDeposits:!0,withdraw:!0,fetchLedgerEntry:!0,fetchLedger:!0},marketsByAltname:{},timeframes:{"1m":"1","5m":"5","15m":"15","30m":"30","1h":"60","4h":"240","1d":"1440","1w":"10080","2w":"21600"},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766599-22709304-5ede-11e7-9de1-9f33732e1509.jpg",api:{public:"https://api.kraken.com",private:"https://api.kraken.com",zendesk:"https://support.kraken.com/hc/en-us/articles"},www:"https://www.kraken.com",doc:"https://www.kraken.com/features/api",fees:"https://www.kraken.com/en-us/features/fee-schedule"},fees:{trading:{tierBased:!0,percentage:!0,taker:.0026,maker:.0016,tiers:{taker:[[0,.0026],[5e4,.0024],[1e5,.0022],[25e4,.002],[5e5,.0018],[1e6,.0016],[25e5,.0014],[5e6,.0012],[1e7,1e-4]],maker:[[0,.0016],[5e4,.0014],[1e5,.0012],[25e4,.001],[5e5,8e-4],[1e6,6e-4],[25e5,4e-4],[5e6,2e-4],[1e7,0]]}},funding:{tierBased:!1,percentage:!1,withdraw:{BTC:.001,ETH:.005,XRP:.02,XLM:2e-5,LTC:.02,DOGE:2,ZEC:1e-4,ICN:.02,REP:.01,ETC:.005,MLN:.003,XMR:.05,DASH:.005,GNO:.01,EOS:.5,BCH:.001,XTZ:.05,USD:5,EUR:5,CAD:10,JPY:300},deposit:{BTC:0,ETH:0,XRP:0,XLM:0,LTC:0,DOGE:0,ZEC:0,ICN:0,REP:0,ETC:0,MLN:0,XMR:0,DASH:0,GNO:0,EOS:0,BCH:0,XTZ:.05,USD:5,EUR:0,CAD:5,JPY:0}}},api:{zendesk:{get:["205893708-What-is-the-minimum-order-size-","201396777-What-are-the-deposit-fees-","201893608-What-are-the-withdrawal-fees-"]},public:{get:["Assets","AssetPairs","Depth","OHLC","Spread","Ticker","Time","Trades"]},private:{post:["AddOrder","AddExport","Balance","CancelOrder","ClosedOrders","DepositAddresses","DepositMethods","DepositStatus","ExportStatus","Ledgers","OpenOrders","OpenPositions","QueryLedgers","QueryOrders","QueryTrades","RetrieveExport","RemoveExport","TradeBalance","TradesHistory","TradeVolume","Withdraw","WithdrawCancel","WithdrawInfo","WithdrawStatus"]}},commonCurrencies:{XBT:"BTC",XDG:"DOGE"},options:{cacheDepositMethodsOnFetchDepositAddress:!0,depositMethods:{},delistedMarketsById:{},inactiveCurrencies:["CAD","USD","JPY","GBP"]},exceptions:{"EAPI:Invalid key":n,"EFunding:Unknown withdraw key":d,"EFunding:Invalid amount":u,"EService:Unavailable":r,"EDatabase:Internal error":r,"EService:Busy":r,"EQuery:Unknown asset":d,"EAPI:Rate limit exceeded":h,"EOrder:Rate limit exceeded":h,"EGeneral:Internal error":r,"EGeneral:Temporary lockout":h,"EGeneral:Permission denied":o}})}costToPrecision(e,t){return this.decimalToPrecision(t,b,this.markets[e].precision.price,v)}feeToPrecision(e,t){return this.decimalToPrecision(t,b,this.markets[e].precision.amount,v)}async fetchMinOrderAmounts(){const e=(await this.zendeskGet205893708WhatIsTheMinimumOrderSize()).split('<td class="wysiwyg-text-align-right">');if(e.length<3)throw new y(this.id+" fetchMinOrderAmounts HTML page markup has changed: https://support.kraken.com/hc/en-us/articles/205893708-What-is-the-minimum-order-size-");const t={};for(let i=2;i<e.length;i++){const s=e[i].split("</td>")[0];if("To Be Announced"!==s){const e=s.split(" ");if(2===e.length){const i=parseFloat(e[0]);t[this.safeCurrencyCode(e[1])]=i}}}return t}async fetchMarkets(e={}){const t=await this.publicGetAssetPairs(e),i=await this.fetchMinOrderAmounts(),s=Object.keys(t.result);let r=[];for(let e=0;e<s.length;e++){const a=s[e],o=t.result[a],n=o.base,d=o.quote,c=this.safeCurrencyCode(n),h=this.safeCurrencyCode(d),l=a.indexOf(".d")>=0,u=l?o.altname:c+"/"+h;let f=void 0;"fees_maker"in o&&(f=parseFloat(o.fees_maker[0][1])/100);const p={amount:o.lot_decimals,price:o.pair_decimals};let m=Math.pow(10,-p.amount);c in i&&(m=i[c]),r.push({id:a,symbol:u,base:c,quote:h,baseId:n,quoteId:d,darkpool:l,info:o,altname:o.altname,maker:f,taker:parseFloat(o.fees[0][1])/100,active:!0,precision:p,limits:{amount:{min:m,max:Math.pow(10,p.amount)},price:{min:Math.pow(10,-p.price),max:void 0},cost:{min:0,max:void 0}}})}return r=this.appendInactiveMarkets(r),this.marketsByAltname=this.indexBy(r,"altname"),r}safeCurrencyCode(e,t){return e.length>3&&(0!==e.indexOf("X")&&0!==e.indexOf("Z")||(e=e.slice(1))),super.safeCurrencyCode(e,t)}appendInactiveMarkets(e){const t={amount:8,price:8},i={min:0,max:void 0},s={min:Math.pow(10,-t.price),max:void 0},r={darkpool:!1,info:void 0,maker:void 0,taker:void 0,active:!1,precision:t,limits:{amount:{min:Math.pow(10,-t.amount),max:Math.pow(10,t.amount)},price:s,cost:i}},a=[];for(let t=0;t<a.length;t++)e.push(this.extend(r,a[t]));return e}async fetchCurrencies(e={}){const t=await this.publicGetAssets(e),i=this.safeValue(t,"result"),s=Object.keys(i),r={};for(let e=0;e<s.length;e++){const t=s[e],a=i[t],o=this.safeCurrencyCode(this.safeString(a,"altname")),n=this.safeInteger(a,"decimals"),d=!this.inArray(o,this.options.inactiveCurrencies);r[o]={id:t,code:o,info:a,name:o,active:d,fee:void 0,precision:n,limits:{amount:{min:Math.pow(10,-n),max:Math.pow(10,n)},price:{min:Math.pow(10,-n),max:Math.pow(10,n)},cost:{min:void 0,max:void 0},withdraw:{min:void 0,max:Math.pow(10,n)}}}}return r}async fetchTradingFees(e={}){await this.loadMarkets(),this.checkRequiredCredentials();const t=await this.privatePostTradeVolume(e),i=this.safeFloat(t.result,"volume"),s=this.fees.trading.tiers;let r=s.taker[1],a=s.maker[1];for(let e=0;e<s.taker.length;e++)i>=s.taker[e][0]&&(r=s.taker[e][1]);for(let e=0;e<s.maker.length;e++)i>=s.maker[e][0]&&(a=s.maker[e][1]);return{info:t,maker:a,taker:r}}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s=this.market(e);if(s.darkpool)throw new d(this.id+" does not provide an order book for darkpool symbol "+e);const r={pair:s.id};void 0!==t&&(r.count=t);const a=(await this.publicGetDepth(this.extend(r,i))).result[s.id];return this.parseOrderBook(a)}parseTicker(e,t){const i=this.milliseconds();let s=void 0;t&&(s=t.symbol);const r=parseFloat(e.v[1]),a=parseFloat(e.p[1]);let o=void 0;void 0!==r&&void 0!==a&&(o=r*a);const n=parseFloat(e.c[0]);return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:parseFloat(e.h[1]),low:parseFloat(e.l[1]),bid:parseFloat(e.b[0]),bidVolume:void 0,ask:parseFloat(e.a[0]),askVolume:void 0,vwap:a,open:this.safeFloat(e,"o"),close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:r,quoteVolume:o,info:e}}async fetchTickers(e,t={}){await this.loadMarkets(),e=void 0===e?this.symbols:e;const i=[];for(let e=0;e<this.symbols.length;e++){const t=this.symbols[e],s=this.markets[t];s.active&&!s.darkpool&&i.push(s.id)}const s={pair:i.join(",")},r=(await this.publicGetTicker(this.extend(s,t))).result,a=Object.keys(r),o={};for(let t=0;t<a.length;t++){const i=a[t],s=this.markets_by_id[i],n=s.symbol,d=r[i];this.inArray(n,e)&&(o[n]=this.parseTicker(d,s))}return o}async fetchTicker(e,t={}){if(await this.loadMarkets(),e.indexOf(".d")>=0)throw new d(this.id+" does not provide a ticker for darkpool symbol "+e);const i=this.market(e),s={pair:i.id},r=(await this.publicGetTicker(this.extend(s,t))).result[i.id];return this.parseTicker(r,i)}parseOHLCV(e,t,i="1m",s,r){return[1e3*e[0],parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3]),parseFloat(e[4]),parseFloat(e[6])]}async fetchOHLCV(e,t="1m",i,s,r={}){await this.loadMarkets();const a=this.market(e),o={pair:a.id,interval:this.timeframes[t]};void 0!==i&&(o.since=parseInt((i-1)/1e3));const n=(await this.publicGetOHLC(this.extend(o,r))).result[a.id];return this.parseOHLCVs(n,a,t,i,s)}parseLedgerEntryType(e){return this.safeString({trade:"trade",withdrawal:"transaction",deposit:"transaction",transfer:"transfer",margin:"margin"},e,e)}parseLedgerEntry(e,t){const i=this.safeString(e,"id");let s=void 0;const r=this.safeString(e,"refid"),a=this.parseLedgerEntryType(this.safeString(e,"type")),o=this.safeCurrencyCode(this.safeString(e,"asset"),t);let n=this.safeFloat(e,"amount");n<0?(s="out",n=Math.abs(n)):s="in";const d=this.safeFloat(e,"time");let c=void 0;void 0!==d&&(c=parseInt(1e3*d));const h={cost:this.safeFloat(e,"fee"),currency:o};return{info:e,id:i,direction:s,account:void 0,referenceId:r,referenceAccount:void 0,type:a,currency:o,amount:n,before:void 0,after:this.safeFloat(e,"balance"),status:"ok",timestamp:c,datetime:this.iso8601(c),fee:h}}async fetchLedger(e,t,i,s={}){await this.loadMarkets();const r={};let a=void 0;void 0!==e&&(a=this.currency(e),r.asset=a.id),void 0!==t&&(r.start=parseInt(t/1e3));const o=await this.privatePostLedgers(this.extend(r,s)),n=this.safeValue(o,"result",{}),d=this.safeValue(n,"ledger",{}),c=Object.keys(d),h=[];for(let e=0;e<c.length;e++){const t=c[e],i=d[t];i.id=t,h.push(i)}return this.parseLedger(h,a,t,i)}async fetchLedgerEntriesByIds(e,t,i={}){await this.loadMarkets(),e=e.join(",");const s=this.extend({id:e},i),r=(await this.privatePostQueryLedgers(s)).result,a=Object.keys(r),o=[];for(let e=0;e<a.length;e++){const t=a[e],i=r[t];i.id=t,o.push(i)}return this.parseLedger(o)}async fetchLedgerEntry(e,t,i={}){return(await this.fetchLedgerEntriesByIds([e],t,i))[0]}parseTrade(e,t){let i=void 0,s=void 0,r=void 0,a=void 0,o=void 0,n=void 0,d=void 0,c=void 0;const h=this.safeString(e,"pair"),l=this.findMarketByAltnameOrId(h);let u=void 0;if(void 0!==l?t=l:void 0!==h&&(t=this.getDelistedMarketById(h)),void 0!==t&&(u=t.symbol),Array.isArray(e)){i=parseInt(1e3*e[2]),s="s"===e[3]?"sell":"buy",r="l"===e[4]?"limit":"market",a=parseFloat(e[0]),o=parseFloat(e[1]),e.length>6&&(n=e[6])}else if("ordertxid"in e&&(d=e.ordertxid,n=this.safeString2(e,"id","postxid"),i=this.safeTimestamp(e,"time"),s=e.type,r=e.ordertype,a=this.safeFloat(e,"price"),o=this.safeFloat(e,"vol"),"fee"in e)){let i=void 0;t&&(i=t.quote),c={cost:this.safeFloat(e,"fee"),currency:i}}return{id:n,order:d,info:e,timestamp:i,datetime:this.iso8601(i),symbol:u,type:r,side:s,takerOrMaker:void 0,price:a,amount:o,cost:a*o,fee:c}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a=r.id,o={pair:a};if(void 0!==t&&(o.since=1e6*t,o.since=t.toString()+"000000"),void 0!==i&&1e3!==i){if(this.safeValue(this.options,"fetchTradesWarning",!0))throw new d(this.id+" fetchTrades() cannot serve "+i.toString()+" trades without breaking the pagination, see https://github.com/ccxt/ccxt/issues/5698 for more details. Set exchange.options['fetchTradesWarning'] to acknowledge this warning and silence it.")}const n=(await this.publicGetTrades(this.extend(o,s))).result,c=n[a],h=c.length;if(h<=0)return[];const l=c[h-1],u=this.safeString(n,"last");return l.push(u),this.parseTrades(c,r,t,i)}async fetchBalance(e={}){const t=await this.privatePostBalance(e),i=this.safeValue(t,"result",{}),s={info:i},r=Object.keys(i);for(let e=0;e<r.length;e++){const t=r[e],a=this.safeCurrencyCode(t),o=this.account();o.total=this.safeFloat(i,t),s[a]=o}return this.parseBalance(s)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o={pair:this.market(e).id,type:i,ordertype:t,volume:this.amountToPrecision(e,s)};("limit"===t||!("market"===t)&&void 0!==r)&&(o.price=this.priceToPrecision(e,r));const n=await this.privatePostAddOrder(this.extend(o,a));let d=this.safeValue(n.result,"txid");if(void 0!==d&&Array.isArray(d)){d=d.length>1?d:d[0]}return{id:d,info:n,timestamp:void 0,datetime:void 0,lastTradeTimestamp:void 0,symbol:e,type:t,side:i,price:r,amount:s,cost:void 0,average:void 0,filled:void 0,remaining:void 0,status:void 0,fee:void 0,trades:void 0}}findMarketByAltnameOrId(e){return e in this.marketsByAltname?this.marketsByAltname[e]:e in this.markets_by_id?this.markets_by_id[e]:void 0}getDelistedMarketById(e){if(void 0===e)return e;let t=this.safeValue(this.options.delistedMarketsById,e);if(void 0!==t)return t;let i=3,s=3,r=6;8===e.length?(i=4,s=4,r=8):7===e.length&&(i=4,s=4,r=7);const a=e.slice(0,i),o=e.slice(s,r),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o);return t={symbol:n+"/"+d,base:n,quote:d,baseId:a,quoteId:o},this.options.delistedMarketsById[e]=t,t}parseOrderStatus(e){return this.safeString({pending:"open",open:"open",closed:"closed",canceled:"canceled",expired:"expired"},e,e)}parseOrder(e,t){const i=this.safeValue(e,"descr",{}),s=this.safeString(i,"type"),r=this.safeString(i,"ordertype"),a=this.safeString(i,"pair"),o=this.findMarketByAltnameOrId(a);let n=void 0;void 0!==o?t=o:void 0!==a&&(t=this.getDelistedMarketById(a));const d=this.safeTimestamp(e,"opentm"),c=this.safeFloat(e,"vol"),h=this.safeFloat(e,"vol_exec"),l=c-h;let u=void 0;const f=this.safeFloat(e,"cost");let p=this.safeFloat(i,"price");void 0!==p&&0!==p||(p=this.safeFloat(i,"price2")),void 0!==p&&0!==p||(p=this.safeFloat(e,"price",p));const m=this.safeFloat(e,"price");if(void 0!==t&&(n=t.symbol,"fee"in e)){const i=e.oflags;u={cost:this.safeFloat(e,"fee"),rate:void 0},i.indexOf("fciq")>=0?u.currency=t.quote:i.indexOf("fcib")>=0&&(u.currency=t.base)}const y=this.parseOrderStatus(this.safeString(e,"status"));return{id:this.safeString(e,"id"),info:e,timestamp:d,datetime:this.iso8601(d),lastTradeTimestamp:void 0,status:y,symbol:n,type:r,side:s,price:p,cost:f,amount:c,filled:h,average:m,remaining:l,fee:u}}parseOrders(e,t,i,s,r={}){const a=[],o=Object.keys(e);let n=void 0;void 0!==t&&(n=t.symbol);for(let i=0;i<o.length;i++){const s=o[i],n=this.extend({id:s},e[s]);a.push(this.extend(this.parseOrder(n,t),r))}return this.filterBySymbolSinceLimit(a,n,i,s)}async fetchOrder(e,t,i={}){await this.loadMarkets();const s=await this.privatePostQueryOrders(this.extend({trades:!0,txid:e},i)),r=s.result,a=this.parseOrder(this.extend({id:e},r[e]));return this.extend({info:s},a)}async fetchOrdersByIds(e,t,i={}){await this.loadMarkets();const s=await this.privatePostQueryOrders(this.extend({trades:!0,txid:e.join(",")},i)),r=this.safeValue(s,"result",{}),a=[],o=Object.keys(r);for(let e=0;e<o.length;e++){const t=o[e],i=r[t],s=this.parseOrder(this.extend({id:t},i));a.push(s)}return a}async fetchMyTrades(e,t,i,s={}){await this.loadMarkets();const r={};void 0!==t&&(r.start=parseInt(t/1e3));const a=(await this.privatePostTradesHistory(this.extend(r,s))).result.trades,o=Object.keys(a);for(let e=0;e<o.length;e++)a[o[e]].id=o[e];const n=this.parseTrades(a,void 0,t,i);return void 0===e?n:this.filterBySymbol(n,e)}async cancelOrder(e,t,i={}){await this.loadMarkets();let s=void 0;try{s=await this.privatePostCancelOrder(this.extend({txid:e},i))}catch(e){if(this.last_http_response&&this.last_http_response.indexOf("EOrder:Unknown order")>=0)throw new c(this.id+" cancelOrder() error "+this.last_http_response);throw e}return s}async fetchOpenOrders(e,t,i,s={}){await this.loadMarkets();const r={};void 0!==t&&(r.start=parseInt(t/1e3));const a=await this.privatePostOpenOrders(this.extend(r,s)),o=this.parseOrders(a.result.open,void 0,t,i);return void 0===e?o:this.filterBySymbol(o,e)}async fetchClosedOrders(e,t,i,s={}){await this.loadMarkets();const r={};void 0!==t&&(r.start=parseInt(t/1e3));const a=await this.privatePostClosedOrders(this.extend(r,s)),o=this.parseOrders(a.result.closed,void 0,t,i);return void 0===e?o:this.filterBySymbol(o,e)}async fetchDepositMethods(e,t={}){await this.loadMarkets();const i={asset:this.currency(e).id};return(await this.privatePostDepositMethods(this.extend(i,t))).result}parseTransactionStatus(e){return this.safeString({Initial:"pending",Pending:"pending",Success:"ok",Settled:"pending",Failure:"failed",Partial:"ok"},e,e)}parseTransaction(e,t){const i=this.safeString(e,"refid"),s=this.safeString(e,"txid"),r=this.safeTimestamp(e,"time"),a=this.safeString(e,"asset"),o=this.safeCurrencyCode(a,t),n=this.safeString(e,"info"),d=this.safeFloat(e,"amount"),c=this.parseTransactionStatus(this.safeString(e,"status")),h=this.safeString(e,"type");let l=this.safeFloat(e,"fee");return void 0===l&&"deposit"===h&&(l=0),{info:e,id:i,currency:o,amount:d,address:n,tag:void 0,status:c,type:h,updated:void 0,txid:s,timestamp:r,datetime:this.iso8601(r),fee:{currency:o,cost:l}}}parseTransactionsByType(e,t,i,s,r){const a=[];for(let i=0;i<t.length;i++){const s=this.parseTransaction(this.extend({type:e},t[i]));a.push(s)}return this.filterByCurrencySinceLimit(a,i,s,r)}async fetchDeposits(e,t,i,s={}){if(await this.loadMarkets(),void 0===e)throw new a(this.id+" fetchDeposits requires a currency code argument");const r={asset:this.currency(e).id},o=await this.privatePostDepositStatus(this.extend(r,s));return this.parseTransactionsByType("deposit",o.result,e,t,i)}async fetchWithdrawals(e,t,i,s={}){if(await this.loadMarkets(),void 0===e)throw new a(this.id+" fetchWithdrawals requires a currency code argument");const r={asset:this.currency(e).id},o=await this.privatePostWithdrawStatus(this.extend(r,s));return this.parseTransactionsByType("withdrawal",o.result,e,t,i)}async createDepositAddress(e,t={}){const i=await this.fetchDepositAddress(e,this.extend({new:"true"},t)),s=this.safeString(i,"address");return this.checkAddress(s),{currency:e,address:s,info:i}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i=this.currency(e);let s=this.safeString(t,"method");if(void 0===s){if(!this.options.cacheDepositMethodsOnFetchDepositAddress)throw new d(this.id+' fetchDepositAddress() requires an extra `method` parameter. Use fetchDepositMethods ("'+e+'") to get a list of available deposit methods or enable the exchange property .options["cacheDepositMethodsOnFetchDepositAddress"] = true');e in this.options.depositMethods||(this.options.depositMethods[e]=await this.fetchDepositMethods(e)),s=this.options.depositMethods[e][0].method}const r={asset:i.id,method:s},a=await this.privatePostDepositAddresses(this.extend(r,t)),o=a.result;if(o.length<1)throw new m(this.id+" privatePostDepositAddresses() returned no addresses");const n=this.safeString(o[0],"address"),c=this.safeString2(o[0],"tag","memo");return this.checkAddress(n),{currency:e,address:n,tag:c,info:a}}async withdraw(e,t,i,s,r={}){if(this.checkAddress(i),"key"in r){await this.loadMarkets();const i={asset:this.currency(e).id,amount:t},s=await this.privatePostWithdraw(this.extend(i,r));return{info:s,id:s.result}}throw new d(this.id+" withdraw requires a 'key' parameter (withdrawal key name, as set up on your account)")}sign(e,t="public",i="GET",s={},r,a){let o="/"+this.version+"/"+t+"/"+e;if("public"===t)Object.keys(s).length&&(o+="?"+this.urlencode(s));else if("private"===t){this.checkRequiredCredentials();const e=this.nonce().toString();a=this.urlencode(this.extend({nonce:e},s));const t=this.encode(e+a),i=this.hash(t,"sha256","binary"),n=this.stringToBinary(this.encode(o)),d=this.binaryConcat(n,i),c=this.base64ToBinary(this.secret),h=this.hmac(d,c,"sha512","base64");r={"API-Key":this.apiKey,"API-Sign":this.decode(h),"Content-Type":"application/x-www-form-urlencoded"}}else o="/"+e;return{url:o=this.urls.api[t]+o,method:i,body:a,headers:r}}nonce(){return this.milliseconds()}handleErrors(e,t,i,s,a,o,n,c,h){if(520===e)throw new r(this.id+" "+e.toString()+" "+t);if(o.indexOf("Invalid order")>=0)throw new p(this.id+" "+o);if(o.indexOf("Invalid nonce")>=0)throw new l(this.id+" "+o);if(o.indexOf("Insufficient funds")>=0)throw new u(this.id+" "+o);if(o.indexOf("Cancel pending")>=0)throw new f(this.id+" "+o);if(o.indexOf("Invalid arguments:volume")>=0)throw new p(this.id+" "+o);if("{"===o[0]&&"string"!=typeof n&&"error"in n){if(n.error.length){const e=this.id+" "+this.json(n);for(let t=0;t<n.error.length;t++)if(n.error[t]in this.exceptions)throw new this.exceptions[n.error[t]](e);throw new d(e)}}}}},function(e,t,i){"use strict";const s=i(37);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"kucoin2"})}}},function(e,t,i){"use strict";const s=i(29),{ArgumentsRequired:r}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"kuna",name:"Kuna",countries:["UA"],rateLimit:1e3,version:"v2",has:{CORS:!1,fetchTickers:!0,fetchOHLCV:!1,fetchOpenOrders:!0,fetchMyTrades:!0,withdraw:!1},urls:{referral:"https://kuna.io?r=kunaid-gvfihe8az7o4",logo:"https://user-images.githubusercontent.com/1294454/31697638-912824fa-b3c1-11e7-8c36-cf9606eb94ac.jpg",api:"https://kuna.io",www:"https://kuna.io",doc:"https://kuna.io/documents/api",fees:"https://kuna.io/documents/api"},fees:{trading:{taker:.0025,maker:.0025},funding:{withdraw:{UAH:"1%",BTC:.001,BCH:.001,ETH:.01,WAVES:.01,GOL:0,GBG:0},deposit:{}}}})}async fetchMarkets(e={}){const t=["btc","eth","eurs","rub","uah","usd","usdt"],i={UAH:0},s=[],r=await this.publicGetTickers(e),a=Object.keys(r);for(let e=0;e<a.length;e++){const r=a[e];for(let e=0;e<t.length;e++){const a=t[e],o=r.indexOf(a),n=r.slice(o);if(o>0&&n===a){const e=r.replace(a,""),t=this.safeCurrencyCode(e),o=this.safeCurrencyCode(a),n=t+"/"+o,d={amount:6,price:this.safeInteger(i,o,6)};s.push({id:r,symbol:n,base:t,quote:o,baseId:e,quoteId:a,precision:d,limits:{amount:{min:Math.pow(10,-d.amount),max:Math.pow(10,d.amount)},price:{min:Math.pow(10,-d.price),max:Math.pow(10,d.price)},cost:{min:void 0,max:void 0}}});break}}}return s}async fetchL3OrderBook(e,t,i={}){return await this.fetchOrderBook(e,t,i)}async fetchOpenOrders(e,t,i,s={}){if(void 0===e)throw new r(this.id+" fetchOpenOrders requires a symbol argument");await this.loadMarkets();const a=this.market(e),o={market:a.id},n=await this.privateGetOrders(this.extend(o,s));return this.parseOrders(n,a,t,i)}parseTrade(e,t){const i=this.parse8601(this.safeString(e,"created_at"));let s=void 0;t&&(s=t.symbol);let r=this.safeString(e,"side");if(void 0!==r){const e={ask:"sell",bid:"buy"};r=this.safeString(e,r)}const a=this.safeFloat(e,"price"),o=this.safeFloat(e,"volume"),n=this.safeFloat(e,"funds"),d=this.safeString(e,"order_id");return{id:this.safeString(e,"id"),info:e,timestamp:i,datetime:this.iso8601(i),symbol:s,type:void 0,side:r,order:d,takerOrMaker:void 0,price:a,amount:o,cost:n,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={market:r.id},o=await this.publicGetTrades(this.extend(a,s));return this.parseTrades(o,r,t,i)}async fetchMyTrades(e,t,i,s={}){if(void 0===e)throw new r(this.id+" fetchOpenOrders requires a symbol argument");await this.loadMarkets();const a=this.market(e),o={market:a.id},n=await this.privateGetTradesMy(this.extend(o,s));return this.parseTrades(n,a,t,i)}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"lakebtc",name:"LakeBTC",countries:["US"],version:"api_v2",has:{CORS:!0,createMarketOrder:!1,fetchTickers:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/28074120-72b7c38a-6660-11e7-92d9-d9027502281d.jpg",api:"https://api.lakebtc.com",www:"https://www.lakebtc.com",doc:["https://www.lakebtc.com/s/api_v2","https://www.lakebtc.com/s/api"]},api:{public:{get:["bcorderbook","bctrades","ticker"]},private:{post:["buyOrder","cancelOrders","getAccountInfo","getExternalAccounts","getOrders","getTrades","openOrders","sellOrder"]}},fees:{trading:{maker:.0015,taker:.002}}})}async fetchMarkets(e={}){const t=await this.publicGetTicker(e),i=[],s=Object.keys(t);for(let e=0;e<s.length;e++){const r=s[e],a=t[r],o=r.slice(0,3),n=r.slice(3,6),d=o.toUpperCase(),c=n.toUpperCase(),h=d+"/"+c;i.push({id:r,symbol:h,base:d,quote:c,baseId:o,quoteId:n,info:a})}return i}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGetAccountInfo(e),i=this.safeValue(t,"balance",{}),s={info:t},r=Object.keys(i);for(let e=0;e<r.length;e++){const t=r[e],a=this.safeCurrencyCode(t),o=this.account();o.total=this.safeFloat(i,t),s[a]=o}return this.parseBalance(s)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={symbol:this.marketId(e)},r=await this.publicGetBcorderbook(this.extend(s,i));return this.parseOrderBook(r)}parseTicker(e,t){const i=this.milliseconds();let s=void 0;void 0!==t&&(s=t.symbol);const r=this.safeFloat(e,"last");return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"bid"),bidVolume:void 0,ask:this.safeFloat(e,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeFloat(e,"volume"),quoteVolume:void 0,info:e}}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetTicker(t),s=Object.keys(i),r={};for(let e=0;e<s.length;e++){let t=s[e];const a=i[t];let o=void 0;t in this.markets_by_id&&(t=(o=this.markets_by_id[t]).symbol),r[t]=this.parseTicker(a,o)}return r}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s=await this.publicGetTicker(t);return this.parseTicker(s[i.id],i)}parseTrade(e,t){const i=this.safeTimestamp(e,"date"),s=this.safeString(e,"tid"),r=this.safeFloat(e,"price"),a=this.safeFloat(e,"amount");let o=void 0;void 0!==r&&void 0!==a&&(o=r*a);let n=void 0;return void 0!==t&&(n=t.symbol),{id:s,info:e,timestamp:i,datetime:this.iso8601(i),symbol:n,order:void 0,type:void 0,side:void 0,takerOrMaker:void 0,price:r,amount:a,cost:o,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id},o=await this.publicGetBctrades(this.extend(a,s));return this.parseTrades(o,r,t,i)}async createOrder(e,t,i,s,a,o={}){if(await this.loadMarkets(),"market"===t)throw new r(this.id+" allows limit orders only");const n="privatePost"+this.capitalize(i)+"Order",d={params:[a,s,this.market(e).id]},c=await this[n](this.extend(d,o));return{info:c,id:this.safeString(c,"id")}}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={params:[e]};return await this.privatePostCancelOrder(this.extend(s,i))}nonce(){return this.microseconds()}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api+"/"+this.version;if("public"===t)o+="/"+e,Object.keys(s).length&&(o+="?"+this.urlencode(s));else{this.checkRequiredCredentials();const t=this.nonce();let o="";if("params"in s){o=s.params.join(",")}const n=this.urlencode({tonce:t,accesskey:this.apiKey,requestmethod:i.toLowerCase(),id:t,method:e,params:o});a=this.json({method:e,params:o,id:t});const d=this.hmac(this.encode(n),this.encode(this.secret),"sha1"),c=this.encode(this.apiKey+":"+d);r={"Json-Rpc-Tonce":t.toString(),Authorization:"Basic "+this.decode(this.stringToBase64(c)),"Content-Type":"application/json"}}return{url:o,method:i,body:a,headers:r}}async request(e,t="public",i="GET",s={},a,o){const n=await this.fetch2(e,t,i,s,a,o);if("error"in n)throw new r(this.id+" "+this.json(n));return n}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,ArgumentsRequired:a,InvalidNonce:o,OrderNotFound:n,InvalidOrder:d,DDoSProtection:c,BadRequest:h,AuthenticationError:l}=i(0),{ROUND:u}=i(2);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"latoken",name:"Latoken",countries:["KY"],version:"v1",rateLimit:2e3,certified:!1,userAgent:this.userAgents.chrome,has:{CORS:!1,publicAPI:!0,pivateAPI:!0,cancelOrder:!0,cancelAllOrders:!0,createMarketOrder:!1,createOrder:!0,fetchBalance:!0,fetchCanceledOrders:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchMyTrades:!0,fetchOpenOrders:!0,fetchOrder:!1,fetchOrdersByStatus:!0,fetchOrderBook:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/61511972-24c39f00-aa01-11e9-9f7c-471f1d6e5214.jpg",api:"https://api.latoken.com",www:"https://latoken.com",doc:["https://api.latoken.com"]},api:{public:{get:["ExchangeInfo/time","ExchangeInfo/limits","ExchangeInfo/pairs","ExchangeInfo/pairs/{currency}","ExchangeInfo/pair","ExchangeInfo/currencies","ExchangeInfo/currencies/{symbol}","MarketData/tickers","MarketData/ticker/{symbol}","MarketData/orderBook/{symbol}","MarketData/trades/{symbol}","MarketData/trades/{symbol}/{limit}"]},private:{get:["Account/balances","Account/balances/{currency}","Order/status","Order/active","Order/get_order","Order/trades"],post:["Order/new","Order/test-order","Order/cancel","Order/cancel_all"]}},fees:{trading:{tierBased:!1,percentage:!0,maker:.001,taker:.001}},commonCurrencies:{TSL:"Treasure SL"},options:{createOrderMethod:"private_post_order_new"},exceptions:{exact:{"Signature or ApiKey is not valid":l,"Request is out of time":o,"Symbol must be specified":h},broad:{"Request limit reached":c,Pair:h,"Price needs to be greater than":d,"Amount needs to be greater than":d,"The Symbol field is required":d,"OrderType is not valid":d,"Side is not valid":d,"Cancelable order whit":n,Order:n}}})}nonce(){return this.milliseconds()}async fetchTime(e={}){const t=await this.publicGetExchangeInfoTime(e);return this.safeInteger(t,"unixTimeMiliseconds")}async fetchMarkets(e={}){const t=await this.publicGetExchangeInfoPairs(e),i=[];for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"symbol"),a=this.safeString(s,"baseCurrency"),o=this.safeString(s,"quotedCurrency"),n=this.safeInteger(s,"pairId"),d=this.safeCurrencyCode(a),c=this.safeCurrencyCode(o),h=d+"/"+c,l={price:this.safeInteger(s,"pricePrecision"),amount:this.safeInteger(s,"amountPrecision")},u={amount:{min:this.safeFloat(s,"minQty"),max:void 0},price:{min:Math.pow(10,-l.price),max:void 0},cost:{min:void 0,max:void 0}};i.push({id:r,numericId:n,info:s,symbol:h,base:d,quote:c,baseId:a,quoteId:o,active:void 0,precision:l,limits:u})}return i}async fetchCurrencies(e={}){const t=await this.publicGetExchangeInfoCurrencies(e),i={};for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"symbol"),a=this.safeInteger(s,"currencyId"),o=this.safeCurrencyCode(r),n=this.safeInteger(s,"precission"),d=this.safeFloat(s,"fee"),c=void 0;i[o]={id:r,numericId:a,code:o,info:s,name:o,active:c,fee:d,precision:n,limits:{amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}}}}return i}calculateFee(e,t,i,s,r,a="taker",o={}){const n=this.markets[e];let d="quote";const c=n[a];let h=s*c,l=n.precision.price;return"sell"===i?h*=r:(d="base",l=n.precision.amount),h=this.decimalToPrecision(h,u,l,this.precisionMode),{type:a,currency:n[d],rate:c,cost:parseFloat(h)}}async fetchBalance(e,t={}){await this.loadMarkets();const i=await this.privateGetAccountBalances(t),s={info:i};for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"symbol"),a=this.safeCurrencyCode(r),o=this.safeFloat(t,"frozen"),n=this.safeFloat(t,"pending"),d=this.sum(o,n),c={free:this.safeFloat(t,"available"),used:d,total:this.safeFloat(t,"amount")};s[a]=c}return this.parseBalance(s)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={symbol:this.market(e).id},r=await this.publicGetMarketDataOrderBookSymbol(this.extend(s,i));return this.parseOrderBook(r,void 0,"bids","asks","price","amount")}parseTicker(e,t){const i=this.findSymbol(this.safeString(e,"symbol"),t),s=this.safeFloat(e,"open"),r=this.safeFloat(e,"close");let a=void 0;void 0!==s&&void 0!==r&&(a=r-s);const o=this.safeFloat(e,"priceChange"),n=this.nonce();return{symbol:i,timestamp:n,datetime:this.iso8601(n),low:this.safeFloat(e,"low"),high:this.safeFloat(e,"high"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:s,close:r,last:r,previousClose:void 0,change:a,percentage:o,average:void 0,baseVolume:void 0,quoteVolume:this.safeFloat(e,"volume"),info:e}}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={symbol:i.id},r=await this.publicGetMarketDataTickerSymbol(this.extend(s,t));return this.parseTicker(r,i)}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetMarketDataTickers(t),s={};for(let t=0;t<i.length;t++){const r=this.parseTicker(i[t]),a=r.symbol;(void 0===e||this.inArray(a,e))&&(s[a]=r)}return s}parseTrade(e,t){let i=this.safeInteger2(e,"timestamp","time");void 0!==i&&i<12309408e5&&(i*=1e3);const s=this.safeFloat(e,"price"),r=this.safeFloat(e,"amount"),a=this.safeString(e,"side");let o=void 0;void 0!==r&&void 0!==s&&(o=r*s);let n=void 0;void 0!==t&&(n=t.symbol);const d=this.safeString(e,"id"),c=this.safeString(e,"orderId"),h=this.safeFloat(e,"commission");let l=void 0;return void 0!==h&&(l={cost:h,currency:void 0}),{info:e,timestamp:i,datetime:this.iso8601(i),symbol:n,id:d,order:c,type:void 0,takerOrMaker:void 0,side:a,price:s,amount:r,cost:o,fee:l}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id};void 0!==i&&(a.limit=i);const o=await this.publicGetMarketDataTradesSymbol(this.extend(a,s)),n=this.safeValue(o,"trades",[]);return this.parseTrades(n,r,t,i)}async fetchMyTrades(e,t,i,s={}){if(void 0===e)throw new a(this.id+" fetchMyTrades requires a symbol argument");await this.loadMarkets();const r=this.market(e),o={symbol:r.id},n=await this.privateGetOrderTrades(this.extend(o,s)),d=this.safeValue(n,"trades",[]);return this.parseTrades(d,r,t,i)}parseOrderStatus(e){return this.safeString({active:"open",partiallyFilled:"open",filled:"closed",cancelled:"canceled"},e,e)}parseOrder(e,t){const i=this.safeString(e,"orderId"),s=this.safeTimestamp(e,"timeCreated"),r=this.safeString(e,"symbol");let a=r;r in this.markets_by_id&&(t=this.markets_by_id[r]),void 0!==t&&(a=t.symbol);const o=this.safeString(e,"side"),n=this.safeString(e,"orderType"),d=this.safeFloat(e,"price"),c=this.safeFloat(e,"amount"),h=this.safeFloat(e,"executedAmount");let l=void 0;void 0!==c&&void 0!==h&&(l=c-h);const u=this.parseOrderStatus(this.safeString(e,"orderStatus"));let f=void 0;void 0!==h&&void 0!==d&&(f=h*d);const p=this.safeTimestamp(e,"timeFilled");let m=void 0;return void 0!==p&&p>0&&(m=p),{id:i,info:e,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:m,status:u,symbol:a,type:n,side:o,price:d,cost:f,amount:c,filled:h,average:void 0,remaining:l,fee:void 0}}async fetchOpenOrders(e,t,i,s={}){return this.fetchOrdersWithMethod("private_get_order_active",e,t,i,s)}async fetchClosedOrders(e,t,i,s={}){return this.fetchOrdersByStatus("filled",e,t,i,s)}async fetchCanceledOrders(e,t,i,s={}){return this.fetchOrdersByStatus("cancelled",e,t,i,s)}async fetchOrdersByStatus(e,t,i,s,r={}){const a={status:e};return this.fetchOrdersWithMethod("private_get_order_status",t,i,s,this.extend(a,r))}async fetchOrdersWithMethod(e,t,i,s,r={}){if(void 0===t)throw new a(this.id+" fetchOrdersWithMethod requires a symbol argument");await this.loadMarkets();const o=this.market(t),n={symbol:o.id};void 0!==s&&(n.limit=s);const d=await this[e](this.extend(n,r));return this.parseOrders(d,o,i,s)}async fetchOrder(e,t,i={}){await this.loadMarkets();const s={orderId:e},r=await this.privateGetOrderGetOrder(this.extend(s,i));return this.parseOrder(r)}async createOrder(e,t,i,s,a,o={}){if(await this.loadMarkets(),"limit"!==t)throw new r(this.id+" allows limit orders only");const n={symbol:this.marketId(e),side:i,price:this.priceToPrecision(e,a),amount:this.amountToPrecision(e,s),orderType:t},d=this.safeString(this.options,"createOrderMethod","private_post_order_new"),c=await this[d](this.extend(n,o));return this.parseOrder(c)}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={orderId:e},r=await this.privatePostOrderCancel(this.extend(s,i));return this.parseOrder(r)}async cancelAllOrders(e,t={}){if(void 0===e)throw new a(this.id+" cancelAllOrders requires a symbol argument");await this.loadMarkets();const i=this.marketId(e),s={symbol:i},r=await this.privatePostOrderCancelAll(this.extend(s,t)),o=[],n=this.safeValue(r,"cancelledOrders",[]);for(let e=0;e<n.length;e++){const t=this.parseOrder({symbol:i,orderId:n[e],orderStatus:"canceled"});o.push(t)}return o}sign(e,t="public",i="GET",s,r,a){let o="/api/"+this.version+"/"+this.implodeParams(e,s),n=this.omit(s,this.extractParams(e));if("private"===t){const e=this.nonce();n=this.extend({timestamp:e},n)}const d=this.urlencode(n);if(Object.keys(n).length&&(o+="?"+d),"private"===t){this.checkRequiredCredentials();const e=this.hmac(this.encode(o),this.encode(this.secret));r={"X-LA-KEY":this.apiKey,"X-LA-SIGNATURE":e},"POST"===i&&(r["Content-Type"]="application/x-www-form-urlencoded",a=d)}return{url:this.urls.api+o,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,o,n,d,c){if(!n)return;const h=this.safeString(n,"message"),l=this.exceptions.exact,u=this.exceptions.broad,f=this.id+" "+o;if(void 0!==h){if(h in l)throw new l[h](f);const e=this.findBroadlyMatchedKey(u,h);if(void 0!==e)throw new u[e](f)}const p=this.safeValue(n,"error",{}),m=this.safeString(p,"message");if(void 0!==m){if(m in l)throw new l[m](f);const e=this.findBroadlyMatchedKey(u,m);if(void 0!==e)throw new u[e](f);throw new r(f)}}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,DDoSProtection:a,AuthenticationError:o,InvalidOrder:n}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"lbank",name:"LBank",countries:["CN"],version:"v1",has:{fetchTickers:!0,fetchOHLCV:!0,fetchOrder:!0,fetchOrders:!0,fetchOpenOrders:!1,fetchClosedOrders:!0},timeframes:{"1m":"minute1","5m":"minute5","15m":"minute15","30m":"minute30","1h":"hour1","2h":"hour2","4h":"hour4","6h":"hour6","8h":"hour8","12h":"hour12","1d":"day1","1w":"week1"},urls:{logo:"https://user-images.githubusercontent.com/1294454/38063602-9605e28a-3302-11e8-81be-64b1e53c4cfb.jpg",api:"https://api.lbank.info",www:"https://www.lbank.info",doc:"https://github.com/LBank-exchange/lbank-official-api-docs",fees:"https://lbankinfo.zendesk.com/hc/en-gb/articles/360012072873-Trading-Fees",referral:"https://www.lbex.io/invite?icode=7QCY"},api:{public:{get:["currencyPairs","ticker","depth","trades","kline","accuracy"]},private:{post:["user_info","create_order","cancel_order","orders_info","orders_info_history","withdraw","withdrawCancel","withdraws","withdrawConfigs"]}},fees:{trading:{maker:.001,taker:.001},funding:{withdraw:{BTC:void 0,ZEC:.01,ETH:.01,ETC:.01,VEN:10,BCH:2e-4,SC:50,BTM:20,NAS:1,EOS:1,XWC:5,BTS:1,INK:10,BOT:3,YOYOW:15,TGC:10,NEO:0,CMT:20,SEER:2e3,FIL:void 0,BTG:void 0}}},commonCurrencies:{VET_ERC20:"VEN"},options:{cacheSecretAsPem:!0}})}async fetchMarkets(e={}){const t=await this.publicGetAccuracy(e),i=[];for(let e=0;e<t.length;e++){const s=t[e],r=s.symbol,a=r.split("_");let o=void 0,n=void 0;a.length>2?(o=a[0]+"_"+a[1],n=a[2]):(o=a[0],n=a[1]);const d=this.safeCurrencyCode(o),c=this.safeCurrencyCode(n),h=d+"/"+c,l={amount:this.safeInteger(s,"quantityAccuracy"),price:this.safeInteger(s,"priceAccuracy")};i.push({id:r,symbol:h,base:d,quote:c,baseId:o,quoteId:n,active:!0,precision:l,limits:{amount:{min:Math.pow(10,-l.amount),max:void 0},price:{min:Math.pow(10,-l.price),max:Math.pow(10,l.price)},cost:{min:void 0,max:void 0}},info:r})}return i}parseTicker(e,t){let i=void 0;if(void 0===t){const t=this.safeString(e,"symbol");if(t in this.markets_by_id){i=this.marketsById[t].symbol}else{const e=t.split("_");let s=void 0,r=void 0;e.length>2?(s=e[0]+"_"+e[1],r=e[2]):(s=e[0],r=e[1]),i=this.safeCurrencyCode(s)+"/"+this.safeCurrencyCode(r)}}const s=this.safeInteger(e,"timestamp"),r=e;e=r.ticker;const a=this.safeFloat(e,"latest"),o=this.safeFloat(e,"change");let n=void 0;if(void 0!==o){const e=this.sum(1,o/100);e>0&&(n=a/this.sum(1,e))}let d=void 0,c=void 0;return void 0!==a&&void 0!==n&&(d=a-n,c=this.sum(a,n)/2),void 0!==t&&(i=t.symbol),{symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:d,percentage:o,average:c,baseVolume:this.safeFloat(e,"vol"),quoteVolume:this.safeFloat(e,"turnover"),info:r}}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={symbol:i.id},r=await this.publicGetTicker(this.extend(s,t));return this.parseTicker(r,i)}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetTicker(this.extend({symbol:"all"},t)),s={};for(let e=0;e<i.length;e++){const t=this.parseTicker(i[e]);s[t.symbol]=t}return s}async fetchOrderBook(e,t=60,i={}){await this.loadMarkets();let s=60;void 0!==t&&(s=Math.min(t,s));const r={symbol:this.marketId(e),size:s},a=await this.publicGetDepth(this.extend(r,i));return this.parseOrderBook(a)}parseTrade(e,t){let i=void 0;void 0!==t&&(i=t.symbol);const s=this.safeInteger(e,"date_ms"),r=this.safeFloat(e,"price"),a=this.safeFloat(e,"amount");let o=void 0;void 0!==r&&void 0!==a&&(o=parseFloat(this.costToPrecision(i,r*a)));const n=this.safeString(e,"tid"),d=this.safeString(e,"type");return{id:n,info:this.safeValue(e,"info",e),timestamp:s,datetime:this.iso8601(s),symbol:i,order:void 0,type:void 0,side:d,takerOrMaker:void 0,price:r,amount:a,cost:o,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,size:100};void 0!==t&&(a.time=parseInt(t)),void 0!==i&&(a.size=i);const o=await this.publicGetTrades(this.extend(a,s));return this.parseTrades(o,r,t,i)}parseOHLCV(e,t,i="1m",s,r){return[1e3*e[0],e[1],e[2],e[3],e[4],e[5]]}async fetchOHLCV(e,t="5m",i,s=1e3,a={}){await this.loadMarkets();const o=this.market(e);if(void 0===i)throw new r(this.id+" fetchOHLCV requires a `since` argument");if(void 0===s)throw new r(this.id+" fetchOHLCV requires a `limit` argument");const n={symbol:o.id,type:this.timeframes[t],size:s,time:parseInt(i/1e3)},d=await this.publicGetKline(this.extend(n,a));return this.parseOHLCVs(d,o,t,i,s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostUserInfo(e),i={info:t},s=this.safeValue(t,"info",{}),r=this.safeValue(s,"free",{}),a=this.safeValue(s,"freeze",{}),o=this.safeValue(s,"asset",{}),n=Object.keys(r);for(let e=0;e<n.length;e++){const t=n[e],s=this.safeCurrencyCode(t),d=this.account();d.free=this.safeFloat(r,t),d.used=this.safeFloat(a,t),d.total=this.safeFloat(o,t),i[s]=d}return this.parseBalance(i)}parseOrderStatus(e){return this.safeString({"-1":"cancelled",0:"open",1:"open",2:"closed",4:"closed"},e)}parseOrder(e,t){let i=void 0;const s=this.safeValue(this.marketsById,e.symbol);void 0!==s?i=s.symbol:void 0!==t&&(i=t.symbol);const r=this.safeInteger(e,"create_time"),a=this.safeFloat(e,"price"),o=this.safeFloat(e,"amount",0),n=this.safeFloat(e,"deal_amount",0),d=this.safeFloat(e,"avg_price");let c=void 0;void 0!==d&&(c=n*d);const h=this.parseOrderStatus(this.safeString(e,"status")),l=this.safeString(e,"order_id"),u=this.safeString(e,"order_type"),f=this.safeString(e,"type");let p=void 0;return void 0!==o&&void 0!==n&&(p=o-n),{id:l,datetime:this.iso8601(r),timestamp:r,lastTradeTimestamp:void 0,status:h,symbol:i,type:u,side:f,price:a,cost:c,amount:o,filled:n,remaining:p,trades:void 0,fee:void 0,info:this.safeValue(e,"info",e)}}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o=this.market(e);let n={symbol:o.id,type:i,amount:s};"market"===t?n.type+="_market":n.price=r;const d=await this.privatePostCreateOrder(this.extend(n,a));(n=this.omit(n,"type")).order_id=d.order_id,n.type=i,n.order_type=t,n.create_time=this.milliseconds(),n.info=d;const c=(n=this.parseOrder(n,o)).id;return this.orders[c]=n,n}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={symbol:this.market(t).id,order_id:e};return await this.privatePostCancelOrder(this.extend(s,i))}async fetchOrder(e,t,i={}){await this.loadMarkets();const s=this.market(t),r={symbol:s.id,order_id:e},a=await this.privatePostOrdersInfo(this.extend(r,i)),o=this.parseOrders(a.orders,s);return 1===o.length?o[0]:o}async fetchOrders(e,t,i,s={}){await this.loadMarkets(),void 0===i&&(i=100);const r={symbol:this.market(e).id,current_page:1,page_length:i},a=await this.privatePostOrdersInfoHistory(this.extend(r,s));return this.parseOrders(a.orders,void 0,t,i)}async fetchClosedOrders(e,t,i,s={}){const r=await this.fetchOrders(e,t,i,s),a=this.filterBy(r,"status","closed"),o=this.filterBy(r,"status","cancelled"),n=this.arrayConcat(a,o);return this.filterBySymbolSinceLimit(n,e,t,i)}async withdraw(e,t,i,s,r={}){this.checkAddress(i),await this.loadMarkets();const a={assetCode:this.currency(e).id,amount:t,account:i};void 0!==s&&(a.memo=s);const o=this.privatePostWithdraw(this.extend(a,r));return{id:o.id,info:o}}convertSecretToPem(e){const t=e.length-0;let i=parseInt(t/64);i=this.sum(i,1);let s="-----BEGIN PRIVATE KEY-----\n";for(let e=0;e<i;e++){const t=64*e,i=this.sum(t,64);s+=this.secret.slice(t,i)+"\n"}return s+"-----END PRIVATE KEY-----"}sign(e,t="public",i="GET",s={},r,a){const o=this.omit(s,this.extractParams(e));let n=this.urls.api+"/"+this.version+"/"+this.implodeParams(e,s);if(n+=".do","public"===t)Object.keys(o).length&&(n+="?"+this.urlencode(o));else{this.checkRequiredCredentials();const e=this.keysort(this.extend({api_key:this.apiKey},s)),t=this.rawencode(e),i=this.hash(this.encode(t)).toUpperCase();let o=void 0;this.safeValue(this.options,"cacheSecretAsPem",!0)?void 0===(o=this.safeValue(this.options,"pem"))&&(o=this.convertSecretToPem(this.secret),this.options.pem=o):o=this.convertSecretToPem(this.secret);const n=this.binaryToBase64(this.rsa(i,this.encode(o),"RS256"));e.sign=n,a=this.urlencode(e),r={"Content-Type":"application/x-www-form-urlencoded"}}return{url:n,method:i,body:a,headers:r}}async request(e,t="public",i="GET",s={},d,c){const h=await this.fetch2(e,t,i,s,d,c);if("false"===this.safeString(h,"result")){const e=this.safeString(h,"error_code"),t=this.safeString({10000:"Internal error",10001:"The required parameters can not be empty",10002:"verification failed",10003:"Illegal parameters",10004:"User requests are too frequent",10005:"Key does not exist",10006:"user does not exist",10007:"Invalid signature",10008:"This currency pair is not supported",10009:"Limit orders can not be missing orders and the number of orders",10010:"Order price or order quantity must be greater than 0",10011:"Market orders can not be missing the amount of the order",10012:"market sell orders can not be missing orders",10013:"is less than the minimum trading position 0.001",10014:"Account number is not enough",10015:"The order type is wrong",10016:"Account balance is not enough",10017:"Abnormal server",10018:"order inquiry can not be more than 50 less than one",10019:"withdrawal orders can not be more than 3 less than one",10020:"less than the minimum amount of the transaction limit of 0.001",10022:"Insufficient key authority"},e,this.json(h));throw new(this.safeValue({10002:o,10004:a,10005:o,10006:o,10007:o,10009:n,10010:n,10011:n,10012:n,10013:n,10014:n,10015:n,10016:n,10022:o},e,r))(t)}return h}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,ArgumentsRequired:a,InvalidNonce:o,OrderNotFound:n,InvalidOrder:d,InsufficientFunds:c,AuthenticationError:h,DDoSProtection:l,NotSupported:u}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"liquid",name:"Liquid",countries:["JP","CN","TW"],version:"2",rateLimit:1e3,has:{CORS:!1,fetchCurrencies:!0,fetchTickers:!0,fetchOrder:!0,fetchOrders:!0,fetchOpenOrders:!0,fetchClosedOrders:!0,fetchMyTrades:!0,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/45798859-1a872600-bcb4-11e8-8746-69291ce87b04.jpg",api:"https://api.liquid.com",www:"https://www.liquid.com",doc:["https://developers.liquid.com"],fees:"https://help.liquid.com/getting-started-with-liquid/the-platform/fee-structure",referral:"https://www.liquid.com?affiliate=SbzC62lt30976"},api:{public:{get:["currencies","products","products/{id}","products/{id}/price_levels","executions","ir_ladders/{currency}","fees"]},private:{get:["accounts/balance","accounts/main_asset","accounts/{id}","accounts/{currency}/reserved_balance_details","crypto_accounts","crypto_withdrawals","executions/me","fiat_accounts","fund_infos","loan_bids","loans","orders","orders/{id}","orders/{id}/trades","trades","trades/{id}/loans","trading_accounts","trading_accounts/{id}","transactions","withdrawals"],post:["crypto_withdrawals","fund_infos","fiat_accounts","loan_bids","orders","withdrawals"],put:["crypto_withdrawal/{id}/cancel","loan_bids/{id}/close","loans/{id}","orders/{id}","orders/{id}/cancel","trades/{id}","trades/{id}/adjust_margin","trades/{id}/close","trades/close_all","trading_accounts/{id}","withdrawals/{id}/cancel"]}},exceptions:{"API rate limit exceeded. Please retry after 300s":l,"API Authentication failed":h,"Nonce is too small":o,"Order not found":n,"Can not update partially filled order":d,"Can not update non-live order":n,not_enough_free_balance:c,must_be_positive:d,less_than_order_size:d},commonCurrencies:{WIN:"WCOIN",HOT:"HOT Token"},options:{cancelOrderException:!0}})}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),i={};for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"currency"),a=this.safeCurrencyCode(r),o=s.depositable&&s.withdrawable,n=this.safeInteger(s,"display_precision"),d=this.safeInteger(s,"quoting_precision"),c=Math.max(n,d);i[a]={id:r,code:a,info:s,name:a,active:o,fee:this.safeFloat(s,"withdrawal_fee"),precision:c,limits:{amount:{min:Math.pow(10,-n),max:Math.pow(10,n)},price:{min:Math.pow(10,-d),max:Math.pow(10,d)},cost:{min:void 0,max:void 0},withdraw:{min:this.safeFloat(s,"minimum_withdrawal"),max:void 0}}}}return i}async fetchMarkets(e={}){const t=await this.publicGetProducts(),i=await this.fetchCurrencies(),s=this.indexBy(i,"code"),r=[];for(let e=0;e<t.length;e++){const i=t[e],a=i.id.toString(),o=i.base_currency,n=i.quoted_currency,d=this.safeCurrencyCode(o),c=this.safeCurrencyCode(n),h=d+"/"+c,l=this.safeFloat(i,"maker_fee"),u=this.safeFloat(i,"taker_fee"),f=!i.disabled,p=this.safeValue(s,d),m=this.safeValue(s,c),y={amount:8,price:8};let b=void 0;void 0!==p&&(b=this.safeFloat(p.info,"minimum_order_quantity"));let v=void 0;void 0!==m&&(y.price=this.safeInteger(m.info,"quoting_precision"),v=Math.pow(10,-y.price));let g=void 0;void 0!==v&&void 0!==b&&(g=v*b);const w={amount:{min:b,max:void 0},price:{min:v,max:void 0},cost:{min:g,max:void 0}};r.push({id:a,symbol:h,base:d,quote:c,baseId:o,quoteId:n,maker:l,taker:u,limits:w,precision:y,active:f,info:i})}return r}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccountsBalance(e),i={info:t};for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeFloat(s,"balance"),i[a]=o}return this.parseBalance(i)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={id:this.marketId(e)},r=await this.publicGetProductsIdPriceLevels(this.extend(s,i));return this.parseOrderBook(r,void 0,"buy_price_levels","sell_price_levels")}parseTicker(e,t){const i=this.milliseconds();let s=void 0;if("last_traded_price"in e&&e.last_traded_price){e.last_traded_price.length>0&&(s=this.safeFloat(e,"last_traded_price"))}let r=void 0;if(void 0===t){const i=this.safeString(e,"id");if(i in this.markets_by_id)t=this.markets_by_id[i];else{const i=this.safeString(e,"base_currency"),s=this.safeString(e,"quoted_currency");r in this.markets?t=this.markets[r]:r=this.safeCurrencyCode(i)+"/"+this.safeCurrencyCode(s)}}void 0!==t&&(r=t.symbol);let a=void 0,o=void 0,n=void 0;const d=this.safeFloat(e,"last_price_24h");return void 0!==d&&void 0!==s&&(a=s-d,n=this.sum(s,d)/2,d>0&&(o=a/d*100)),{symbol:r,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high_market_ask"),low:this.safeFloat(e,"low_market_bid"),bid:this.safeFloat(e,"market_bid"),bidVolume:void 0,ask:this.safeFloat(e,"market_ask"),askVolume:void 0,vwap:void 0,open:d,close:s,last:s,previousClose:void 0,change:a,percentage:o,average:n,baseVolume:this.safeFloat(e,"volume_24h"),quoteVolume:void 0,info:e}}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetProducts(t),s={};for(let e=0;e<i.length;e++){const t=this.parseTicker(i[e]);s[t.symbol]=t}return s}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={id:i.id},r=await this.publicGetProductsId(this.extend(s,t));return this.parseTicker(r,i)}parseTrade(e,t){const i=this.safeTimestamp(e,"created_at"),s=this.safeString(e,"order_id"),r=this.safeString(e,"taker_side"),a=this.safeString(e,"my_side"),o=void 0!==a?a:r;let n=void 0;void 0!==a&&(n=r===a?"taker":"maker");let d=void 0;const c=this.safeFloat(e,"price"),h=this.safeFloat(e,"quantity");return void 0!==c&&void 0!==h&&(d=c*h),{info:e,id:this.safeString(e,"id"),order:s,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,type:void 0,side:o,takerOrMaker:n,price:c,amount:h,cost:d,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={product_id:r.id};void 0!==i&&(a.limit=i),void 0!==t&&(a.timestamp=parseInt(t/1e3));const o=await this.publicGetExecutions(this.extend(a,s)),n=void 0!==t?o:o.models;return this.parseTrades(n,r,t,i)}async fetchMyTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={product_id:r.id,with_details:!0};void 0!==i&&(a.limit=i);const o=await this.privateGetExecutionsMe(this.extend(a,s));return this.parseTrades(o.models,r,t,i)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o={order_type:t,product_id:this.marketId(e),side:i,quantity:this.amountToPrecision(e,s)};"limit"===t&&(o.price=this.priceToPrecision(e,r));const n=await this.privatePostOrders(this.extend(o,a));return this.parseOrder(n)}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={id:e},r=await this.privatePutOrdersIdCancel(this.extend(s,i)),a=this.parseOrder(r);if("closed"===a.status&&this.options.cancelOrderException)throw new n(this.id+" order closed already: "+this.json(r));return a}async editOrder(e,t,i,s,r,o,n={}){if(await this.loadMarkets(),void 0===o)throw new a(this.id+" editOrder requires the price argument");const d={order:{quantity:this.amountToPrecision(t,r),price:this.priceToPrecision(t,o)},id:e},c=await this.privatePutOrdersId(this.extend(d,n));return this.parseOrder(c)}parseOrderStatus(e){return this.safeString({live:"open",filled:"closed",cancelled:"canceled"},e,e)}parseOrder(e,t){const i=this.safeString(e,"id"),s=this.safeTimestamp(e,"created_at"),r=this.safeString(e,"product_id");t=this.safeValue(this.markets_by_id,r);const a=this.parseOrderStatus(this.safeString(e,"status")),o=this.safeFloat(e,"quantity");let n=this.safeFloat(e,"filled_quantity");const d=this.safeFloat(e,"price");let c=void 0,h=void 0;void 0!==t&&(c=t.symbol,h=t.quote);const l=this.safeString(e,"order_type");let u=0,f=0,p=this.safeFloat(e,"average_price");const m=this.parseTrades(this.safeValue(e,"executions",[]),t,void 0,void 0,{order:i,type:l}),y=m.length;for(let e=0;e<y;e++){const t=m[e];t.order=i,t.type=l,f=this.sum(f,t.amount),u=this.sum(u,t.cost)}let b=void 0,v=void 0;y>0&&(v=m[y-1].timestamp,!p&&f>0&&(p=u/f),void 0===b&&(b=u),void 0===n&&(n=f));let g=void 0;void 0!==o&&void 0!==n&&(g=o-n);const w=this.safeString(e,"side");return{id:i,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:v,type:l,status:a,symbol:c,side:w,price:d,amount:o,filled:n,cost:b,remaining:g,average:p,trades:m,fee:{currency:h,cost:this.safeFloat(e,"order_fee")},info:e}}async fetchOrder(e,t,i={}){await this.loadMarkets();const s={id:e},r=await this.privateGetOrdersId(this.extend(s,i));return this.parseOrder(r)}async fetchOrders(e,t,i,s={}){await this.loadMarkets();let r=void 0;const a={with_details:1};void 0!==e&&(r=this.market(e),a.product_id=r.id),void 0!==i&&(a.limit=i);const o=await this.privateGetOrders(this.extend(a,s)),n=this.safeValue(o,"models",[]);return this.parseOrders(n,r,t,i)}async fetchOpenOrders(e,t,i,s={}){return await this.fetchOrders(e,t,i,this.extend({status:"live"},s))}async fetchClosedOrders(e,t,i,s={}){return await this.fetchOrders(e,t,i,this.extend({status:"filled"},s))}async withdraw(e,t,i,s,r={}){this.checkAddress(i),await this.loadMarkets();const a=this.currency(e),o={currency:a.id,address:i,amount:this.currencyToPrecision(e,t)};if(void 0!==s)if("XRP"===e)o.payment_id=s;else{if("XLM"!==e)throw new u(this.id+" withdraw() only supports a tag along the address for XRP or XLM");o.memo_type="text",o.memo_value=s}const n=await this.privatePostCryptoWithdrawals(this.extend(o,r));return this.parseTransaction(n,a)}parseTransactionStatus(e){return this.safeString({pending:"pending",cancelled:"canceled",approved:"ok"},e,e)}parseTransaction(e,t){const i=this.safeString(e,"id"),s=this.safeString(e,"address"),r=this.safeString2(e,"payment_id","memo_value"),a=this.safeString(e,"asset"),o=this.safeCurrencyCode(a,t),n=this.safeTimestamp(e,"created_at"),d=this.safeTimestamp(e,"updated_at"),c=this.parseTransactionStatus(this.safeString(e,"state")),h=this.safeFloat(e,"amount");return{info:e,id:i,txid:void 0,timestamp:n,datetime:this.iso8601(n),address:s,tag:r,type:"withdrawal",amount:h,currency:o,status:c,updated:d,fee:void 0}}nonce(){return this.milliseconds()}sign(e,t="public",i="GET",s={},r,a){let o="/"+this.implodeParams(e,s);const n=this.omit(s,this.extractParams(e));if(r={"X-Quoine-API-Version":this.version,"Content-Type":"application/json"},"private"===t){this.checkRequiredCredentials(),"GET"===i?Object.keys(n).length&&(o+="?"+this.urlencode(n)):Object.keys(n).length&&(a=this.json(n));const e=this.nonce(),t={path:o,nonce:e,token_id:this.apiKey,iat:Math.floor(e/1e3)};r["X-Quoine-Auth"]=this.jwt(t,this.encode(this.secret))}else Object.keys(n).length&&(o+="?"+this.urlencode(n));return{url:o=this.urls.api+o,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,o,n,d,c){if(e>=200&&e<300)return;const h=this.exceptions;if(401===e){if(o in h)throw new h[o](this.id+" "+o);return}if(429===e)throw new l(this.id+" "+o);if(void 0===n)return;const u=this.id+" "+o,f=this.safeString(n,"message"),p=this.safeValue(n,"errors");if(void 0!==f){if(f in h)throw new h[f](u)}else{if(void 0===p)throw new r(u);{const e=Object.keys(p);for(let t=0;t<e.length;t++){const i=p[e[t]];for(let e=0;e<i.length;e++){const t=i[e];if(t in h)throw new h[t](u)}}}}}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,ArgumentsRequired:a,AuthenticationError:o,NotSupported:n,InvalidOrder:d,OrderNotFound:c,ExchangeNotAvailable:h,DDoSProtection:l,InsufficientFunds:u}=i(0),{TRUNCATE:f,DECIMAL_PLACES:p}=i(2);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"livecoin",name:"LiveCoin",countries:["US","UK","RU"],rateLimit:1e3,userAgent:this.userAgents.chrome,has:{fetchDepositAddress:!0,fetchDeposits:!0,CORS:!1,fetchTickers:!0,fetchCurrencies:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchOrders:!0,fetchOrder:!0,fetchOpenOrders:!0,fetchClosedOrders:!0,fetchMyTrades:!0,fetchWithdrawals:!0,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27980768-f22fc424-638a-11e7-89c9-6010a54ff9be.jpg",api:"https://api.livecoin.net",www:"https://www.livecoin.net",doc:"https://www.livecoin.net/api?lang=en",referral:"https://livecoin.net/?from=Livecoin-CQ1hfx44"},api:{public:{get:["exchange/all/order_book","exchange/last_trades","exchange/maxbid_minask","exchange/order_book","exchange/restrictions","exchange/ticker","info/coinInfo"]},private:{get:["exchange/client_orders","exchange/order","exchange/trades","exchange/commission","exchange/commissionCommonInfo","payment/balances","payment/balance","payment/get/address","payment/history/size","payment/history/transactions"],post:["exchange/buylimit","exchange/buymarket","exchange/cancellimit","exchange/selllimit","exchange/sellmarket","payment/out/capitalist","payment/out/card","payment/out/coin","payment/out/okpay","payment/out/payeer","payment/out/perfectmoney","payment/voucher/amount","payment/voucher/make","payment/voucher/redeem"]}},fees:{trading:{tierBased:!1,percentage:!0,maker:.0018,taker:.0018}},commonCurrencies:{BTCH:"Bithash",CPC:"Capricoin",EDR:"E-Dinar Coin",eETT:"EETT",FirstBlood:"1ST",FORTYTWO:"42",LEO:"LeoCoin",ORE:"Orectic",RUR:"RUB",SCT:"SpaceCoin",TPI:"ThaneCoin",wETT:"WETT",XBT:"Bricktox"},exceptions:{exact:{1:r,10:o,100:r,101:o,102:o,103:d,104:d,105:d,11:o,12:o,2:o,20:o,30:o,31:n,32:r,429:l,503:h},broad:{"insufficient funds":u,"NOT FOUND":c,"Cannot find order":c,"Minimal amount is":d}}})}async fetchMarkets(e={}){const t=await this.publicGetExchangeTicker(e),i=await this.publicGetExchangeRestrictions(),s=this.indexBy(i.restrictions,"currencyPair"),r=[];for(let e=0;e<t.length;e++){const i=t[e],a=this.safeString(i,"symbol"),[o,n]=a.split("/"),d=this.safeCurrencyCode(o),c=this.safeCurrencyCode(n),h=d+"/"+c,l=this.safeValue(s,h),u={price:5,amount:8,cost:8},f={amount:{min:Math.pow(10,-u.amount),max:Math.pow(10,u.amount)}};l&&(u.price=this.safeInteger(l,"priceScale",5),f.amount.min=this.safeFloat(l,"minLimitQuantity",f.amount.min)),f.price={min:Math.pow(10,-u.price),max:Math.pow(10,u.price)},r.push({id:a,symbol:h,base:d,quote:c,baseId:o,quoteId:n,active:!0,precision:u,limits:f,info:i})}return r}async fetchCurrencies(e={}){const t=await this.publicGetInfoCoinInfo(e),i=this.safeValue(t,"info");let s={};for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"symbol"),a=this.safeCurrencyCode(r),o=8,n="normal"===this.safeString(t,"walletStatus"),d=this.safeString(t,"name"),c=this.safeFloat(t,"withdrawFee");s[a]={id:r,code:a,info:t,name:d,active:n,fee:c,precision:o,limits:{amount:{min:this.safeFloat(t,"minOrderAmount"),max:Math.pow(10,o)},price:{min:Math.pow(10,-o),max:Math.pow(10,o)},cost:{min:this.safeFloat(t,"minOrderAmount"),max:void 0},withdraw:{min:this.safeFloat(t,"minWithdrawAmount"),max:Math.pow(10,o)},deposit:{min:this.safeFloat(t,"minDepositAmount"),max:void 0}}}}return s=this.appendFiatCurrencies(s)}appendFiatCurrencies(e){const t={info:void 0,active:!0,fee:void 0,precision:8,limits:{withdraw:{min:void 0,max:void 0},deposit:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},cost:{min:void 0,max:void 0},price:{min:Math.pow(10,-8),max:Math.pow(10,8)}}},i=[{id:"USD",code:"USD",name:"US Dollar"},{id:"EUR",code:"EUR",name:"Euro"}];i.push({id:"RUR",code:this.safeCurrencyCode("RUR"),name:"Russian ruble"});for(let s=0;s<i.length;s++){const r=i[s];e[r.code]=this.extend(t,r)}return e}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetPaymentBalances(e),i={info:t};for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"currency"),a=this.safeCurrencyCode(r);let o=void 0;o=a in i?i[a]:this.account(),"total"===s.type&&(o.total=this.safeFloat(s,"value")),"available"===s.type&&(o.free=this.safeFloat(s,"value")),"trade"===s.type&&(o.used=this.safeFloat(s,"value")),i[a]=o}return this.parseBalance(i)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetExchangeCommissionCommonInfo(e),i=this.safeFloat(t,"commission");return{info:t,maker:i,taker:i}}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={currencyPair:this.marketId(e),groupByPrice:"false"};void 0!==t&&(s.depth=t);const r=await this.publicGetExchangeOrderBook(this.extend(s,i)),a=this.safeInteger(r,"timestamp");return this.parseOrderBook(r,a)}parseTicker(e,t){const i=this.milliseconds();let s=void 0;t&&(s=t.symbol);const r=this.safeFloat(e,"vwap"),a=this.safeFloat(e,"volume");let o=void 0;void 0!==a&&void 0!==r&&(o=a*r);const n=this.safeFloat(e,"last");return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"best_bid"),bidVolume:void 0,ask:this.safeFloat(e,"best_ask"),askVolume:void 0,vwap:this.safeFloat(e,"vwap"),open:void 0,close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:a,quoteVolume:o,info:e}}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetExchangeTicker(t),s=this.indexBy(i,"symbol"),r=Object.keys(s),a={};for(let e=0;e<r.length;e++){const t=r[e],i=this.markets_by_id[t],o=i.symbol,n=s[t];a[o]=this.parseTicker(n,i)}return a}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={currencyPair:i.id},r=await this.publicGetExchangeTicker(this.extend(s,t));return this.parseTicker(r,i)}parseTrade(e,t){const i=this.safeTimestamp2(e,"time","datetime");let s=void 0;const r=this.safeFloat(e,"commission");if(void 0!==r){s={cost:r,currency:t?t.quote:void 0}}const a=this.safeString(e,"clientorderid"),o=this.safeString(e,"id"),n=this.safeStringLower(e,"type"),d=this.safeFloat(e,"quantity"),c=this.safeFloat(e,"price");let h=void 0;void 0!==d&&void 0!==c&&(h=d*c);let l=void 0;return void 0!==t&&(l=t.symbol),{id:o,info:e,timestamp:i,datetime:this.iso8601(i),symbol:l,order:a,type:void 0,side:n,takerOrMaker:void 0,price:c,amount:d,cost:h,fee:s}}async fetchMyTrades(e,t,i,s={}){if(void 0===e)throw new a(this.id+" fetchMyTrades requires a symbol argument");await this.loadMarkets();const r=this.market(e),o={currencyPair:r.id};void 0!==i&&(o.limit=i);const n=await this.privateGetExchangeTrades(this.extend(o,s));return this.parseTrades(n,r,t,i)}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={currencyPair:r.id},o=await this.publicGetExchangeLastTrades(this.extend(a,s));return this.parseTrades(o,r,t,i)}async fetchOrder(e,t,i={}){await this.loadMarkets();const s={orderId:e},r=await this.privateGetExchangeOrder(this.extend(s,i));return this.parseOrder(r)}parseOrderStatus(e){return this.safeString({OPEN:"open",PARTIALLY_FILLED:"open",EXECUTED:"closed",CANCELLED:"canceled",PARTIALLY_FILLED_AND_CANCELLED:"canceled"},e,e)}parseOrder(e,t){let i=void 0;"lastModificationTime"in e&&void 0!==(i=this.safeString(e,"lastModificationTime"))&&(i=i.indexOf("T")>=0?this.parse8601(i):this.safeInteger(e,"lastModificationTime"));const s=this.parseOrderStatus(this.safeString2(e,"status","orderStatus"));let r=void 0;if(void 0===t){let i=this.safeString(e,"currencyPair");(i=this.safeString(e,"symbol",i))in this.markets_by_id&&(t=this.markets_by_id[i])}let a=this.safeStringLower(e,"type"),o=void 0;if(void 0!==a){const e=a.split("_");a=e[0],o=e[1]}const n=this.safeFloat(e,"price");let d=this.safeFloat(e,"remainingQuantity");d=this.safeFloat(e,"remaining_quantity",d);const c=this.safeFloat(e,"quantity",d);let h=void 0;void 0!==d&&(h=c-d);let l=void 0;void 0!==h&&void 0!==n&&(l=h*n);const u=this.safeFloat(e,"commission_rate");let f=void 0;void 0!==l&&void 0!==u&&(f=l*u);let p=void 0;return void 0!==t&&(r=t.symbol,p=t.quote),{info:e,id:e.id,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,status:s,symbol:r,type:a,side:o,price:n,amount:c,cost:l,filled:h,remaining:d,trades:void 0,fee:{cost:f,currency:p,rate:u}}}async fetchOrders(e,t,i,s={}){await this.loadMarkets();let r=void 0;const a={};void 0!==e&&(r=this.market(e),a.currencyPair=r.id),void 0!==t&&(a.issuedFrom=parseInt(t)),void 0!==i&&(a.endRow=i-1);const o=await this.privateGetExchangeClientOrders(this.extend(a,s)),n=[];let d=[];o.data&&(d=o.data);for(let e=0;e<d.length;e++){const t=d[e];n.push(this.parseOrder(t,r))}return this.sortBy(n,"timestamp")}async fetchOpenOrders(e,t,i,s={}){return await this.fetchOrders(e,t,i,this.extend({openClosed:"OPEN"},s))}async fetchClosedOrders(e,t,i,s={}){return await this.fetchOrders(e,t,i,this.extend({openClosed:"CLOSED"},s))}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o="privatePostExchange"+this.capitalize(i)+t,n=this.market(e),d={quantity:this.amountToPrecision(e,s),currencyPair:n.id};"limit"===t&&(d.price=this.priceToPrecision(e,r));const c=await this[o](this.extend(d,a)),h={info:c,id:c.orderId.toString()};return this.safeValue(c,"success")&&(h.status="open"),h}async cancelOrder(e,t,i={}){if(void 0===t)throw new a(this.id+" cancelOrder requires a symbol argument");await this.loadMarkets();const s={orderId:e,currencyPair:this.market(t).id},o=await this.privatePostExchangeCancellimit(this.extend(s,i)),n=this.safeString(o,"message",this.json(o));if("success"in o){if(!o.success)throw new d(n);if("cancelled"in o){if(o.cancelled)return{status:"canceled",info:o};throw new c(n)}}throw new r(this.id+" cancelOrder() failed: "+this.json(o))}async withdraw(e,t,i,s,r={}){this.checkAddress(i),await this.loadMarkets();const a=this.currency(e);let o=i;void 0!==s&&(o+="::"+s);const n={amount:this.decimalToPrecision(t,f,a.precision,p),currency:a.id,wallet:o},d=await this.privatePostPaymentOutCoin(this.extend(n,r)),c=this.safeInteger(d,"id");if(void 0===c)throw new u(this.id+" insufficient funds to cover requested withdrawal amount post fees "+this.json(d));return{info:d,id:c}}parseTransaction(e,t){let i=void 0,s=void 0;const r=this.safeString(e,"documentId"),a=this.safeFloat(e,"amount"),o=this.safeInteger(e,"date"),n=this.safeStringLower(e,"type"),d=this.safeString(e,"fixedCurrency"),c=this.safeFloat(e,"fee"),h=this.safeCurrencyCode(d,t);"withdrawal"===n?(i=this.safeString(e,"externalKey"),s=this.safeString(e,"id")):"deposit"===n&&(s=this.safeString(e,"externalKey"),i=this.safeString(e,"id"));let l=void 0;return"deposit"===n&&(l="ok"),{info:e,id:r,currency:h,amount:a,address:s,tag:void 0,status:l,type:n,updated:void 0,txid:i,timestamp:o,datetime:this.iso8601(o),fee:{currency:h,cost:c}}}async fetchDeposits(e,t,i,s={}){await this.loadMarkets();const r=this.milliseconds(),a={types:"DEPOSIT",end:r,start:void 0!==t?parseInt(t):r-25056e5};let o=void 0;void 0!==e&&(o=this.currency(e)),void 0!==i&&(a.limit=i);const n=await this.privateGetPaymentHistoryTransactions(this.extend(a,s));return this.parseTransactions(n,o,t,i)}async fetchWithdrawals(e,t,i,s={}){await this.loadMarkets();const r=this.milliseconds(),a={types:"WITHDRAWAL",end:r,start:void 0!==t?parseInt(t):r-25056e5};let o=void 0;void 0!==e&&(o=this.currency(e)),void 0!==i&&(a.limit=i),void 0!==t&&(a.start=t);const n=await this.privateGetPaymentHistoryTransactions(this.extend(a,s));return this.parseTransactions(n,o,t,i)}async fetchDepositAddress(e,t={}){const i={currency:e},s=await this.privateGetPaymentGetAddress(this.extend(i,t));let r=this.safeString(s,"wallet"),a=void 0;if(r.indexOf(":")>=0){const e=r.split(":");r=e[0],a=e[2]}return this.checkAddress(r),{currency:e,address:r,tag:a,info:s}}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api+"/"+e;const n=this.urlencode(this.keysort(s));if("GET"===i&&Object.keys(s).length&&(o+="?"+n),"private"===t){this.checkRequiredCredentials(),"POST"===i&&(a=n);const e=this.hmac(this.encode(n),this.encode(this.secret),"sha256");r={"Api-Key":this.apiKey,Sign:e.toUpperCase(),"Content-Type":"application/x-www-form-urlencoded"}}return{url:o,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,o,n,d,c){if(void 0===n)return;if(e>=300){const e=this.id+" "+o,t=this.exceptions.exact,i=this.safeString(n,"errorCode");throw i in t?new t[i](e):new r(e)}if(!this.safeValue(n,"success",!0)){const e=this.id+" "+o,t=this.exceptions.broad,i=this.safeString2(n,"message","exception");if(void 0!==i){const s=this.findBroadlyMatchedKey(t,i);if(void 0!==s)throw new t[s](e)}throw new r(e)}}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,ArgumentsRequired:a}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"luno",name:"luno",countries:["GB","SG","ZA"],rateLimit:1e3,version:"1",has:{CORS:!1,fetchTickers:!0,fetchOrder:!0,fetchOrders:!0,fetchOpenOrders:!0,fetchClosedOrders:!0,fetchMyTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0},urls:{referral:"https://www.luno.com/invite/44893A",logo:"https://user-images.githubusercontent.com/1294454/27766607-8c1a69d8-5ede-11e7-930c-540b5eb9be24.jpg",api:"https://api.mybitx.com/api",www:"https://www.luno.com",doc:["https://www.luno.com/en/api","https://npmjs.org/package/bitx","https://github.com/bausmeier/node-bitx"]},api:{public:{get:["orderbook","orderbook_top","ticker","tickers","trades"]},private:{get:["accounts/{id}/pending","accounts/{id}/transactions","balance","fee_info","funding_address","listorders","listtrades","orders/{id}","quotes/{id}","withdrawals","withdrawals/{id}"],post:["accounts","postorder","marketorder","stoporder","funding_address","withdrawals","send","quotes","oauth2/grant"],put:["quotes/{id}"],delete:["quotes/{id}","withdrawals/{id}"]}}})}async fetchMarkets(e={}){const t=await this.publicGetTickers(e),i=[];for(let e=0;e<t.tickers.length;e++){const s=t.tickers[e],r=s.pair,a=r.slice(0,3),o=r.slice(3,6),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o),c=n+"/"+d;i.push({id:r,symbol:c,base:n,quote:d,baseId:a,quoteId:o,info:s})}return i}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalance(e),i=this.safeValue(t,"balance",[]),s={info:t};for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"asset"),a=this.safeCurrencyCode(r),o=this.safeFloat(t,"reserved"),n=this.safeFloat(t,"unconfirmed"),d=this.safeFloat(t,"balance"),c=this.account();c.used=this.sum(o,n),c.total=this.sum(d,n),s[a]=c}return this.parseBalance(s)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();let s="publicGetOrderbook";void 0!==t&&t<=100&&(s+="Top");const r={pair:this.marketId(e)},a=await this[s](this.extend(r,i)),o=this.safeInteger(a,"timestamp");return this.parseOrderBook(a,o,"bids","asks","price","volume")}parseOrder(e,t){const i=this.safeInteger(e,"creation_timestamp"),s="PENDING"===e.state?"open":"closed",r="ASK"===e.type?"sell":"buy";void 0===t&&(t=this.findMarket(e.pair));let a=void 0;void 0!==t&&(a=t.symbol);const o=this.safeFloat(e,"limit_price"),n=this.safeFloat(e,"limit_volume"),d=this.safeFloat(e,"fee_counter"),c=this.safeFloat(e,"fee_base"),h=this.safeFloat(e,"base"),l=this.safeFloat(e,"counter");let u=void 0;void 0!==n&&void 0!==h&&(u=Math.max(0,n-h));const f={currency:void 0};return d?(f.side="quote",f.cost=d):(f.side="base",f.cost=c),{id:this.safeString(e,"order_id"),datetime:this.iso8601(i),timestamp:i,lastTradeTimestamp:void 0,status:s,symbol:a,type:void 0,side:r,price:o,amount:n,filled:h,cost:l,remaining:u,trades:void 0,fee:f,info:e}}async fetchOrder(e,t,i={}){await this.loadMarkets();const s={id:e},r=await this.privateGetOrdersId(this.extend(s,i));return this.parseOrder(r)}async fetchOrdersByState(e,t,i,s,r={}){await this.loadMarkets();const a={};let o=void 0;void 0!==e&&(a.state=e),void 0!==t&&(o=this.market(t),a.pair=o.id);const n=await this.privateGetListorders(this.extend(a,r)),d=this.safeValue(n,"orders",[]);return this.parseOrders(d,o,i,s)}async fetchOrders(e,t,i,s={}){return await this.fetchOrdersByState(void 0,e,t,i,s)}async fetchOpenOrders(e,t,i,s={}){return await this.fetchOrdersByState("PENDING",e,t,i,s)}async fetchClosedOrders(e,t,i,s={}){return await this.fetchOrdersByState("COMPLETE",e,t,i,s)}parseTicker(e,t){const i=this.safeInteger(e,"timestamp");let s=void 0;t&&(s=t.symbol);const r=this.safeFloat(e,"last_trade");return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:void 0,low:void 0,bid:this.safeFloat(e,"bid"),bidVolume:void 0,ask:this.safeFloat(e,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeFloat(e,"rolling_24_hour_volume"),quoteVolume:void 0,info:e}}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetTickers(t),s=this.indexBy(i.tickers,"pair"),r=Object.keys(s),a={};for(let e=0;e<r.length;e++){const t=r[e],i=this.markets_by_id[t],o=i.symbol,n=s[t];a[o]=this.parseTicker(n,i)}return a}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={pair:i.id},r=await this.publicGetTicker(this.extend(s,t));return this.parseTicker(r,i)}parseTrade(e,t){const i=this.safeString(e,"order_id");let s=void 0,r=void 0;void 0!==i?s="sell"===(r="ASK"===e.type?"sell":"buy")&&e.is_buy?"maker":"buy"!==r||e.is_buy?"taker":"maker":r=e.is_buy?"buy":"sell";const a=this.safeFloat(e,"fee_base"),o=this.safeFloat(e,"fee_counter");let n=void 0,d=void 0;void 0!==a?0!==a&&(n=t.base,d=a):void 0!==o&&0!==o&&(n=t.quote,d=o);const c=this.safeInteger(e,"timestamp");return{info:e,id:void 0,timestamp:c,datetime:this.iso8601(c),symbol:t.symbol,order:i,type:void 0,side:r,takerOrMaker:s,price:this.safeFloat(e,"price"),amount:this.safeFloat(e,"volume"),cost:this.safeFloat(e,"counter"),fee:{cost:d,currency:n}}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={pair:r.id};void 0!==t&&(a.since=t);const o=await this.publicGetTrades(this.extend(a,s)),n=this.safeValue(o,"trades",[]);return this.parseTrades(n,r,t,i)}async fetchMyTrades(e,t,i,s={}){if(void 0===e)throw new a(this.id+" fetchMyTrades requires a symbol argument");await this.loadMarkets();const r=this.market(e),o={pair:r.id};void 0!==t&&(o.since=t),void 0!==i&&(o.limit=i);const n=await this.privateGetListtrades(this.extend(o,s)),d=this.safeValue(n,"trades",[]);return this.parseTrades(d,r,t,i)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetFeeInfo(e);return{info:t,maker:this.safeFloat(t,"maker_fee"),taker:this.safeFloat(t,"taker_fee")}}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();let o="privatePost";const n={pair:this.marketId(e)};"market"===t?(o+="Marketorder",n.type=i.toUpperCase(),"buy"===i?n.counter_volume=s:n.base_volume=s):(o+="Postorder",n.volume=s,n.price=r,n.type="buy"===i?"BID":"ASK");const d=await this[o](this.extend(n,a));return{info:d,id:d.order_id}}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={order_id:e};return await this.privatePostStoporder(this.extend(s,i))}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api+"/"+this.version+"/"+this.implodeParams(e,s);const n=this.omit(s,this.extractParams(e));if(Object.keys(n).length&&(o+="?"+this.urlencode(n)),"private"===t){this.checkRequiredCredentials();let e=this.encode(this.apiKey+":"+this.secret);e=this.stringToBase64(e),r={Authorization:"Basic "+this.decode(e)}}return{url:o,method:i,body:a,headers:r}}async request(e,t="public",i="GET",s={},a,o){const n=await this.fetch2(e,t,i,s,a,o);if("error"in n)throw new r(this.id+" "+this.json(n));return n}}},function(e,t,i){"use strict";const s=i(1);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"lykke",name:"Lykke",countries:["CH"],version:"v1",rateLimit:200,has:{CORS:!1,fetchOHLCV:!1,fetchTrades:!0,fetchOpenOrders:!0,fetchClosedOrders:!0,fetchOrder:!0,fetchOrders:!0},requiredCredentials:{apiKey:!0,secret:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/34487620-3139a7b0-efe6-11e7-90f5-e520cef74451.jpg",api:{mobile:"https://public-api.lykke.com/api",public:"https://hft-api.lykke.com/api",private:"https://hft-api.lykke.com/api"},test:{mobile:"https://public-api.lykke.com/api",public:"https://hft-service-dev.lykkex.net/api",private:"https://hft-service-dev.lykkex.net/api"},www:"https://www.lykke.com",doc:["https://hft-api.lykke.com/swagger/ui/","https://www.lykke.com/lykke_api"],fees:"https://www.lykke.com/trading-conditions"},api:{mobile:{get:["Market/{market}","Trades/{AssetPairId}"]},public:{get:["AssetPairs","AssetPairs/{id}","IsAlive","OrderBooks","OrderBooks/{AssetPairId}"]},private:{get:["Orders","Orders/{id}","Wallets"],post:["Orders/limit","Orders/market","Orders/{id}/Cancel"]}},fees:{trading:{tierBased:!1,percentage:!0,maker:0,taker:0},funding:{tierBased:!1,percentage:!1,withdraw:{BTC:.001},deposit:{BTC:0}}},commonCurrencies:{XPD:"Lykke XPD"}})}parseTrade(e,t){let i=void 0;if(void 0===t){const i=this.safeString(e,"AssetPairId");t=this.safeValue(this.markets_by_id,i)}t&&(i=t.symbol);const s=this.safeString(e,"id"),r=this.parse8601(this.safeString(e,"dateTime")),a=this.safeStringLower(e,"action"),o=this.safeFloat(e,"price"),n=this.safeFloat(e,"volume"),d=o*n;return{id:s,info:e,timestamp:r,datetime:this.iso8601(r),symbol:i,type:void 0,order:void 0,side:a,takerOrMaker:void 0,price:o,amount:n,cost:d,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e);void 0===i&&(i=100);const a={AssetPairId:r.id,skip:0,take:i},o=await this.mobileGetTradesAssetPairId(this.extend(a,s));return this.parseTrades(o,r,t,i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetWallets(e),i={info:t};for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"AssetId"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeFloat(s,"Balance"),o.used=this.safeFloat(s,"Reserved"),i[a]=o}return this.parseBalance(i)}async cancelOrder(e,t,i={}){return await this.privatePostOrdersIdCancel({id:e})}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o=this.market(e),n={AssetPairId:o.id,OrderAction:this.capitalize(i),Volume:s};"market"===t?n.Asset="buy"===i?o.base:o.quote:"limit"===t&&(n.Price=r);const d="privatePostOrders"+this.capitalize(t);return{id:void 0,info:await this[d](this.extend(n,a))}}async fetchMarkets(e={}){const t=await this.publicGetAssetPairs(),i=[];for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"Id"),a=this.safeString(s,"Name"),[o,n]=a.split("/"),d=this.safeCurrencyCode(o),c=this.safeCurrencyCode(n),h=d+"/"+c,l={amount:this.safeInteger(s,"Accuracy"),price:this.safeInteger(s,"InvertedAccuracy")};i.push({id:r,symbol:h,base:d,quote:c,active:!0,info:s,precision:l,limits:{amount:{min:Math.pow(10,-l.amount),max:Math.pow(10,l.amount)},price:{min:Math.pow(10,-l.price),max:Math.pow(10,l.price)},cost:{min:void 0,max:void 0}}})}return i}parseTicker(e,t){const i=this.milliseconds();let s=void 0;t&&(s=t.symbol);const r=this.safeFloat(e,"lastPrice");return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:void 0,low:void 0,bid:this.safeFloat(e,"bid"),bidVolume:void 0,ask:this.safeFloat(e,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:this.safeFloat(e,"volume24H"),info:e}}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={market:i.id},r=await this.mobileGetMarketMarket(this.extend(s,t));return this.parseTicker(r,i)}parseOrderStatus(e){return this.safeString({Open:"open",Pending:"open",InOrderBook:"open",Processing:"open",Matched:"closed",Cancelled:"canceled",Rejected:"rejected",Replaced:"canceled"},e,e)}parseOrder(e,t){const i=this.parseOrderStatus(this.safeString(e,"Status"));let s=void 0;if(void 0===t){const i=this.safeString(e,"AssetPairId");t=this.safeValue(this.markets_by_id,i)}t&&(s=t.symbol);const r=this.parse8601(this.safeString(e,"LastMatchTime"));let a=void 0;"Registered"in e&&e.Registered?a=this.parse8601(e.Registered):"CreatedAt"in e&&e.CreatedAt&&(a=this.parse8601(e.CreatedAt));const o=this.safeFloat(e,"Price"),n=this.safeFloat(e,"Volume"),d=this.safeFloat(e,"RemainingVolume"),c=n-d,h=c*o;return{info:e,id:this.safeString(e,"Id"),timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:r,symbol:s,type:void 0,side:void 0,price:o,cost:h,average:void 0,amount:n,filled:c,remaining:d,status:i,fee:void 0}}async fetchOrder(e,t,i={}){await this.loadMarkets();const s={id:e},r=await this.privateGetOrdersId(this.extend(s,i));return this.parseOrder(r)}async fetchOrders(e,t,i,s={}){await this.loadMarkets();const r=await this.privateGetOrders(s);return this.parseOrders(r,void 0,t,i)}async fetchOpenOrders(e,t,i,s={}){await this.loadMarkets();const r=await this.privateGetOrders(this.extend({status:"InOrderBook"},s));return this.parseOrders(r,void 0,t,i)}async fetchClosedOrders(e,t,i,s={}){await this.loadMarkets();const r=await this.privateGetOrders(this.extend({status:"Matched"},s));return this.parseOrders(r,void 0,t,i)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s=await this.publicGetOrderBooksAssetPairId(this.extend({AssetPairId:this.marketId(e)},i)),r={timestamp:void 0,bids:[],asks:[]};let a=void 0;for(let e=0;e<s.length;e++){const t=s[e];t.IsBuy?r.bids=this.arrayConcat(r.bids,t.Prices):r.asks=this.arrayConcat(r.asks,t.Prices);const i=this.parse8601(t.Timestamp);a=void 0===a?i:Math.max(a,i)}return this.parseOrderBook(r,a,"bids","asks","Price","Volume")}parseBidAsk(e,t=0,i=1){const s=this.safeFloat(e,t);let r=this.safeFloat(e,i);return r<0&&(r=-r),[s,r]}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api[t]+"/"+this.implodeParams(e,s);const n=this.omit(s,this.extractParams(e));return"mobile"===t?Object.keys(n).length&&(o+="?"+this.urlencode(n)):"public"===t?Object.keys(n).length&&(o+="?"+this.urlencode(n)):"private"===t&&("GET"===i&&Object.keys(n).length&&(o+="?"+this.urlencode(n)),this.checkRequiredCredentials(),r={"api-key":this.apiKey,Accept:"application/json","Content-Type":"application/json"},"POST"===i&&Object.keys(s).length&&(a=this.json(s))),{url:o,method:i,body:a,headers:r}}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,ExchangeNotAvailable:a,ArgumentsRequired:o,BadRequest:n,AuthenticationError:d,InvalidOrder:c,InsufficientFunds:h,PermissionDenied:l}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"mandala",name:"Mandala",countries:["MT"],version:"v2",rateLimit:1500,certified:!0,has:{cancelAllOrders:!0,CORS:!0,createDepositAddress:!0,createMarketOrder:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddresses:!0,fetchDeposits:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrders:!0,fetchClosedOrders:!0,fetchTickers:!0,fetchWithdrawals:!0,withdraw:!0},timeframes:{"1m":"1","5m":"5","1h":"60","1d":"1440"},comment:"Modulus Exchange API ",hostname:"mandalaex.com",urls:{logo:"https://user-images.githubusercontent.com/1294454/54686665-df629400-4b2a-11e9-84d3-d88856367dd7.jpg",api:"https://zapi.{hostname}",www:"https://mandalaex.com",doc:["https://apidocs.mandalaex.com"],fees:["https://mandalaex.com/trading-rules/"],referral:"https://trade.mandalaex.com/?ref=564377"},api:{settings:{get:["getCoinInfo","GetSettings","CurrencySettings","Get_Withdrawal_Limits"]},token:{post:["token"]},public:{post:["AuthenticateUser","ForgotPassword","SignUp","check_Duplicate_Mobile","check_Duplicate_Email"]},api:{get:["GAuth_Check_Status","GAuth_Enable_Request","GetProfile","Loginhistory","ListAllAddresses","Get_User_Withdrawal_Limits","GetPendingOrders","TradeHistory","GOKYC_Get_Kyc_Form","language_list","language","get_page_n_content","GetExchangeTokenDiscountEnrollmentStatus","GetDiscountTiers","My_Affiliate","Affiliate_Summary","Affiliate_Commission","List_Fiat_Manual_Deposit_Requests","List_Fiat_BanksList/YCN/","Get_Fiat_PGs","get_insta_pairs","hmac"],post:["GAuth_Set_Enable","GAuth_Disable_Request","VerifyAccount","SignUp_Resend_Email","AuthenticateUser_Resend_EmailOTP/{tempAuthToken}","Validate_BearerToken","RequestChangePasswordOT","ChangePassword","ResetPassword","GenerateAddress","GetBalance","GetDeposits","GetWithdrawals","RequestWithdraw","RequestWithdrawConfirmation","RequestTransfer_AeraPass","PlaceOrder","PlaceOrder_Priced","CancelOrder","KYC_GetSumAndSub_AccessToken","KYC_SaveSumAndSubstanceApplicationId","GOKYC_Submit_KYC_Form","SetExchangeTokenDiscountEnrollment","Dis_Enroll_ExchangeTokenDiscount","Webhook_BitGoDeposit","Add_Fiat_Manual_Deposit_Request","Add_Fiat_Manual_Withdrawal_Request","Add_Fiat_PG_Deposit_Request","ListApiKey","GenerateApiKey","DeleteApiKey","request_insta_trade","confirm_insta_trade","simplex_get_quote","simplex_payment","hmac","import_translations"]},market:{get:["get-market-summary","get-market-summary/{marketId}","get-trade-history/{marketId}","get-bid_ask-price/{marketId}","get-open-orders/{marketId}/{side}/{depth}","get-currency-price/{marketId}","get-currency-usd-rate/{currencyId}","depth","get-chart-data"]},order:{get:["my-order-history/{key}/{side}","my-order-history/{key}/{side}/{orderId}","my-order-status/{key}/{side}/{orderId}","my-trade-history","hmac"],post:["my-order-history","my-order-status","PlaceOrder","cancel-my-order","cancel-all-my-orders","get-balance","v2/PlaceOrder","v2/my-order-history","v2/my-order-status","v2/my-trade-history","v2/cancel-my-order","v2/cancel-all-my-orders","v2/GetDeposits","v2/GetWithdrawals","v2/GenerateAddress","v2/Get_User_Withdrawal_Limits","v2/ListAllAddresses","v2/RequestWithdraw","v2/RequestWithdrawConfirmation"]}},fees:{trading:{tierBased:!1,percentage:!0,maker:.005,taker:.005}},exceptions:{exact:{Failure_General:r,Exception_Insufficient_Funds:h,Exception_TimeStamp:n,Exception_HMAC_Validation:d,Exception_General:n,"Must provide the orderID param.":n,"Invalid Market_Currency pair!":r,"Invalid volume parameter.":c,"Invalid rate parameter.":c,"Invalid parameter 'side', must be 'BUY' or 'SELL'.":c,"Invalid Type":n,Exception_Invalid_CurrencyName:n,Exception_BadRequest:n,"Blacklisted IP Address":l,Trade_Invalid_Size:c},broad:{"Some error occurred, try again later.":a}},options:{symbolSeparator:"_",api:{settings:"api",public:"api"},fetchCurrencies:{expires:5e3},secret:"03c06dd7-4982-441a-910d-5fd2cbb3f1c6"}})}async signIn(e={}){if(!this.login||!this.password)throw new d(this.id+" signIn() requires this.login (email) and this.password credentials");const t={email:this.login,password:this.password},i=await this.publicPostAuthenticateUser(t),s=this.safeValue(i,"data",{}),r=this.safeString(s,"tempAuthToken");let a=void 0;if(void 0!==this.twofa&&(a=this.oath()),void 0===(a=this.safeString(e,"password",a)))throw new d(this.id+' signIn() requires this.twofa credential or a one-time 2FA "password" parameter');const o={grant_type:"password",username:r,password:a},n=await this.tokenPostToken(this.extend(o,e)),c=this.safeInteger(n,"expires_in");return this.options.expires=this.sum(this.milliseconds(),1e3*c),this.options.accessToken=this.safeString(n,"accessToken"),this.options.tokenType=this.safeString(n,"token_type"),n}async fetchCurrenciesFromCache(e={}){const t=this.safeValue(this.options,"fetchCurrencies",{}),i=this.safeInteger(t,"timestamp"),s=this.safeInteger(t,"expires",1e3),r=this.milliseconds();if(void 0===i||r-i>s){const i=await this.settingsGetCurrencySettings(e);this.options.fetchCurrencies=this.extend(t,{response:i,timestamp:r})}return this.safeValue(this.options.fetchCurrencies,"response")}async fetchCurrencies(e={}){const t=await this.fetchCurrenciesFromCache(e);this.options.currencies={timestamp:this.milliseconds(),response:t};const i=this.safeValue(t,"data",[]),s={};for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"shortName"),a=this.safeCurrencyCode(r),o=this.safeString(t,"fullName"),n=this.safeInteger(t,"decimalPrecision");let d=!0;const c=this.safeValue(t,"withdrawalEnabled"),h=this.safeValue(t,"depositEnabled");c&&h||(d=!1),s[a]={id:r,code:a,name:o,active:d,precision:n,fee:this.safeFloat(t,"withdrawalServiceCharge")/100,limits:{amount:{min:Math.pow(10,-n),max:Math.pow(10,n)},price:{min:Math.pow(10,-n),max:Math.pow(10,n)},cost:{min:void 0,max:void 0},withdraw:{min:this.safeFloat(t,"minWithdrawalLimit"),max:this.safeFloat(t,"maxWithdrawalLimit")}},info:t}}return s}async fetchMarkets(e={}){const t=await this.settingsGetGetSettings(e),i=[],s=this.safeValue(t,"data",{}),r=this.safeValue(s,"trade_setting");for(let e=0;e<r.length;e++){const t=r[e],s=this.safeString(t,"coinName"),a=this.safeString(t,"marketName"),o=a+"_"+s,n=this.safeCurrencyCode(s),d=this.safeCurrencyCode(a),c=n+"/"+d,h=this.safeFloat(t,"minTradeAmount"),l=this.safeFloat(t,"minTickSize"),u={amount:this.precisionFromString(this.numberToString(h)),price:this.precisionFromString(this.numberToString(l))},f=this.safeValue(t,"tradeEnabled",!0);i.push({id:o,symbol:c,base:n,quote:d,baseId:s,quoteId:a,active:f,info:t,precision:u,limits:{amount:{min:h,max:void 0},price:{min:l,max:void 0},cost:{min:this.safeFloat(t,"minOrderValue"),max:void 0}}})}return i}async fetchBalance(e={}){await this.loadMarkets();const t=await this.orderPostGetBalance(this.extend({currency:"ALL"},e)),i=this.safeValue(t,"data",[]),s={info:t};for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeFloat(t,"balance"),o.used=this.safeFloat(t,"balanceInTrade"),s[a]=o}return this.parseBalance(s)}async fetchOrderBook(e,t,i={}){await this.loadMarkets(),void 0===t&&(t=10);const s={symbol:this.marketId(e),limit:t},r=await this.marketGetDepth(this.extend(s,i)),a=this.safeValue(r,"data",{}),o=this.safeInteger(a,"lastUpdate");return this.parseOrderBook(a,o)}parseTicker(e,t){let i=void 0;const s=this.safeString(e,"Pair");void 0!==s&&(i=s in this.markets_by_id?(t=this.markets_by_id[s]).symbol:this.parseSymbol(s)),void 0===i&&void 0!==t&&(i=t.symbol);const r=this.safeFloat(e,"Last");return{symbol:i,timestamp:void 0,datetime:void 0,high:this.safeFloat(e,"High_24hr"),low:this.safeFloat(e,"Low_24hr"),bid:this.safeFloat(e,"HeighestBid"),bidVolume:void 0,ask:this.safeFloat(e,"LowestAsk"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:this.safeFloat(e,"PercentChange"),average:void 0,baseVolume:this.safeFloat(e,"QuoteVolume"),quoteVolume:this.safeFloat(e,"BaseVolume"),info:e}}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.marketGetGetMarketSummary(t),s=this.safeValue(i,"data",{}),r=Object.keys(s),a={};for(let e=0;e<r.length;e++){const t=r[e],i=s[t];let o=void 0,n=t;a[n=t in this.markets_by_id?(o=this.markets_by_id[t]).symbol:this.parseSymbol(t)]=this.parseTicker(i,o)}return a}async fetchTicker(e,t={}){await this.loadMarkets();const i={marketId:this.marketId(e)},s=await this.marketGetGetMarketSummaryMarketId(this.extend(i,t)),r=this.safeValue(s,"data");return this.parseTicker(r)}parseTrade(e,t){const i=this.parse8601(this.safeString2(e,"Date","date")),s=this.safeStringLower2(e,"Type","side"),r=this.safeString(e,"TradeID");let a=void 0;const o=this.safeString(e,"trade"),n=this.safeString(e,"market"),d=this.safeCurrencyCode(o),c=this.safeCurrencyCode(n);void 0!==d&&void 0!==c?a=d+"/"+c:void 0!==t&&(a=t.symbol);const h=this.safeFloat2(e,"Total","amount"),l=this.safeFloat2(e,"Rate","rate"),u=this.safeFloat2(e,"Volume","volume"),f=this.safeString(e,"orderId"),p=this.safeValue(e,"serviceCharge");let m=void 0;return void 0!==p&&(m={cost:p,currency:c}),{id:r,info:e,timestamp:i,datetime:this.iso8601(i),symbol:a,order:f,type:void 0,side:s,takerOrMaker:void 0,price:l,amount:u,cost:h,fee:m}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={marketId:r.id},o=await this.marketGetGetTradeHistoryMarketId(this.extend(a,s)),n=this.safeValue(o,"data");return this.parseTrades(n,r,t,i)}parseOHLCV(e,t,i="1m",s,r){return[this.safeInteger(e,"time"),this.safeFloat(e,"open"),this.safeFloat(e,"high"),this.safeFloat(e,"low"),this.safeFloat(e,"close"),this.safeFloat(e,"volume")]}async fetchOHLCV(e,t="1m",i,s,r={}){await this.loadMarkets();const a=this.market(e);void 0===s&&(s=100);const o=this.parseTimeframe(t)*this.sum(s,1)*1e3;void 0===i&&(i=this.milliseconds()-o);const n=this.sum(i,o),d={interval:this.timeframes[t],baseCurrency:a.baseId,quoteCurrency:a.quoteId,limit:s,timestamp:n},c=await this.marketGetGetChartData(this.extend(d,r)),h=this.safeValue(c,"data",[]);return this.parseOHLCVs(h,a,t,i,s)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o=this.market(e);let n=r;"market"===t&&(n=0);const d={market:o.quoteId,trade:o.baseId,type:t.toUpperCase(),side:i.toUpperCase(),timeInForce:"GTC",rate:this.priceToPrecision(e,n),volume:this.amountToPrecision(e,s),stop:0},c=await this.orderPostV2PlaceOrder(this.extend(d,a)),h=this.safeValue(c,"data",{}),l=this.parseOrder(h,o);return this.extend(l,{symbol:e,type:t,side:i,price:r,amount:s,status:"open"})}async cancelOrder(e,t,i={}){await this.loadMarkets();const s=this.safeString(i,"side","ALL");if(void 0===s)throw new o(this.id+" cancelOrder() requires an order `side` extra parameter");i=this.omit(i,"side");const r={orderId:e=e.toString(),side:s.toUpperCase()},a=await this.orderPostV2CancelMyOrder(this.extend(r,i));return this.extend(this.parseOrder(a),{id:e,symbol:t,status:"canceled"})}async cancelAllOrders(e,t={}){const i=this.safeString(t,"side","ALL");if(void 0===i)throw new o(this.id+" cancelAllOrders() requires an order `side` extra parameter");if(t=this.omit(t,"side"),void 0===e)throw new o(this.id+" cancelAllOrders() requires a `symbols` argument (a list containing one symbol)");if(1!==e.length)throw new o(this.id+" cancelAllOrders() requires a `symbols` argument (a list containing one symbol)");const s=e[0],r={side:i.toUpperCase(),pair:this.marketId(s)};return await this.orderPostV2CancelAllMyOrders(this.extend(r,t))}parseSymbol(e){let[t,i]=e.split(this.options.symbolSeparator);return(i=this.safeCurrencyCode(i))+"/"+(t=this.safeCurrencyCode(t))}parseOrderStatus(e){return this.safeString({Pending:"open",Filled:"closed","Paritally-Filled":"open","Partially-Filled":"open",Cancelled:"canceled"},e,e)}parseOrder(e,t){const i=this.safeString(e,"orderId"),s=this.safeString(e,"trade"),r=this.safeString(e,"market"),a=this.safeCurrencyCode(s),o=this.safeCurrencyCode(r);let n=void 0;void 0!==a&&void 0!==o&&(n=a+"/"+o);const d=this.parse8601(this.safeString(e,"completionDate")),c=this.parse8601(this.safeString2(e,"placementDate","date"));let h=this.safeFloat2(e,"rate","Price");const l=this.safeFloat2(e,"volume","Volume");let u=this.safeFloat(e,"amount");const f=this.safeFloat2(e,"pendingVolume","PendingVolume");let p=void 0;void 0!==l&&void 0!==f&&(p=Math.max(l-f,0)),u||h&&p&&(u=h*p),h||u&&p&&(h=u/p);let m=this.parseOrderStatus(this.safeString(e,"status_string"));void 0===m&&(m=(m=this.safeValue2(e,"orderStatus","Status"))?"closed":"open");let y=void 0;p>0&&(y=d),void 0!==p&&void 0!==l&&p<l&&"closed"===m&&(m="canceled");const b=this.safeValue(e,"serviceCharge");let v=void 0;void 0!==b&&(v={cost:b,currency:o});const g=this.safeStringLower(e,"side");return{info:e,id:i,timestamp:c,datetime:this.iso8601(c),lastTradeTimestamp:y,symbol:n,type:"limit",side:g,price:h,cost:u,average:void 0,amount:l,filled:p,remaining:f,status:m,fee:v}}async fetchOrders(e,t,i,s={}){await this.loadMarkets();const r=this.safeString(s,"side");if(void 0===r)throw new o(this.id+" fetchOrders() requires an order `side` extra parameter");s=this.omit(s,"side");const a={key:this.apiKey,side:r.toUpperCase()},n=await this.orderGetMyOrderHistoryKeySide(this.extend(a,s)),d=this.safeValue(n,"data",[]),c=void 0!==e?this.market(e):void 0;return this.parseOrders(d,c,t,i,{side:r.toLowerCase()})}async fetchClosedOrders(e,t,i,s={}){await this.loadMarkets();const r=this.safeString(s,"side","ALL");s=this.omit(s,"side");let a=void 0;const o={openOrders:!1,side:r.toUpperCase()};void 0!==e&&(a=this.market(e),o.pair=a.baseId+"-"+a.quoteId);const n=await this.orderPostV2MyOrderHistory(this.extend(o,s)),d=this.safeValue(n,"data");return this.parseOrders(d,a,t,i)}async fetchOpenOrders(e,t,i,s={}){await this.loadMarkets();const r=this.safeString(s,"side","ALL");s=this.omit(s,"side");let a=void 0;const o={openOrders:!0,side:r.toUpperCase()};void 0!==e&&(a=this.market(e),o.pair=a.baseId+"-"+a.quoteId);const n=await this.orderPostV2MyOrderHistory(this.extend(o,s)),d=this.safeValue(n,"data");return this.parseOrders(d,a,t,i)}async fetchOrder(e,t,i={}){await this.loadMarkets();const s=this.safeString(i,"side","ALL");if(void 0===s)throw new o(this.id+" fetchOrder() requires an order `side` extra parameter");i=this.omit(i,"side"),e=e.toString();const r={side:s.toUpperCase(),orderId:e},a=await this.orderPostV2MyOrderStatus(this.extend(r,i)),n=this.safeValue(a,"data");return this.extend(this.parseOrder(n),{id:e,side:s.toLowerCase()})}async fetchMyTrades(e,t,i,s={}){await this.loadMarkets();let r=void 0,a="ALL";void 0!==e&&(a=(r=this.market(e)).id);const o={pair:a,orderID:-1,apiKey:this.apiKey},n=await this.orderPostV2MyTradeHistory(this.extend(o,s)),d=this.safeValue(n,"data");return this.parseTrades(d,r,t,i)}async fetchDeposits(e,t,i,s={}){await this.loadMarkets();let r=void 0,a="ALL";void 0!==e&&(a=(r=this.currency(e)).id);const o={currency:a},n=await this.orderPostV2GetDeposits(this.extend(o,s)),d=this.safeValue(n,"data",{}),c=this.safeValue(d,"Deposits",[]);return this.parseTransactions(c,r,t,i)}async fetchWithdrawals(e,t,i,s={}){await this.loadMarkets();let r=void 0,a="ALL";void 0!==e&&(a=(r=this.currency(e)).id);const o={currency:a},n=await this.orderPostV2GetWithdrawals(this.extend(o,s)),d=this.safeValue(n,"data",{}),c=this.safeValue(d,"Withdrawals",[]);return this.parseTransactions(c,r,t,i)}parseTransactionStatus(e){return this.safeString({Pending:"pending"},e,e)}parseTransaction(e,t){const i=this.safeFloat2(e,"WithdrawalAmount","DepositAmount"),s=this.safeString(e,"TXNHash"),r=this.parse8601(this.safeString2(e,"WithdrawalConfirmDate","DepositConfirmDate")),a=this.parse8601(this.safeString2(e,"WithdrawalReqDate","DepositReqDate",r)),o="WithdrawalReqDate"in e?"withdrawal":"deposit",n=this.safeString(e,"WithdrawalType","DepositType"),d=this.safeCurrencyCode(n,t);t=this.currency(d);const c=this.safeString2(e,"WithdrawalAddress","DepositAddress"),h=this.parseAddress(c,t),l=h.address,u=l,f=h.tag,p=f;let m=this.parseTransactionStatus(this.safeString(e,"WithdrawalStatus")),y=void 0;"deposit"===o&&(m="ok",y=0);let b=void 0;return void 0!==y&&(b={cost:y,currency:d}),{info:e,id:void 0,currency:d,amount:i,address:l,addressFrom:void 0,addressTo:u,tag:f,tagFrom:void 0,tagTo:p,status:m,type:o,updated:r,txid:s,timestamp:a,datetime:this.iso8601(a),fee:b}}parseAddresses(e){const t=[],i=Object.keys(e);for(let s=0;s<i.length;s++){const r=i[s],a=e[r],o=r.toUpperCase(),n=this.safeValue(this.currencies_by_id,o);t.push(this.parseAddress(a,n))}return t}parseAddress(e,t){const i=this.safeValue(t,"info",{});let s=e;const r=this.safeValue(i,"addressSeparator","?dt=");let a=void 0;if(r.length>0){const t=e.split(r);s=t[0],this.checkAddress(s),t.length>1&&(a=t[1])}let o=void 0;return void 0!==t&&(o=t.code),{currency:o,address:s,tag:a,info:e}}async fetchDepositAddresses(e,t={}){await this.loadMarkets();const i=await this.orderPostV2ListAllAddresses(t),s=this.safeValue(i,"data");return this.parseAddresses(s)}async generateDepositAddress(e,t={}){await this.loadMarkets();const i=this.currency(e),s={currency:i.id},r=await this.orderPostV2GenerateAddress(this.extend(s,t)),a=this.safeValue(r,"data",{}),o=this.safeString(a,"Address");return this.parseAddress(o,i)}async fetchDepositAddress(e,t={}){return await this.generateDepositAddress(e,t)}async createDepositAddress(e,t={}){return await this.generateDepositAddress(e,t)}async withdraw(e,t,i,s,r={}){this.checkAddress(i),await this.loadMarkets();const a=this.currency(e);let n=void 0;if(void 0!==this.twofa&&(n=this.oath()),void 0===(n=this.safeString(r,"gauth_code",n)))throw new o(this.id+" withdraw () requires a `this.twofa` key or a 2FA code in the `gauth_code` parameter as a string.");r=this.omit(r,"gauth_code");const d={currency:a.id,amount:parseFloat(t),address:i,gauth_code:n};void 0!==s&&(d.addressTag=s);const c=await this.apiPostRequestWithdraw(this.extend(d,r)),h=this.safeValue(c,"data",{});return{info:c,id:this.safeString(h,"withdrawalId"),timestamp:void 0,datetime:this.iso8601(void 0),currency:e,amount:t,address:i,tag:s,addressFrom:void 0,tagFrom:void 0,addressTo:i,tagTo:s,type:"withdrawal",updated:void 0,txid:void 0,status:"pending",fee:void 0}}sign(e,t="api",i="GET",s={},r,a){let o=this.implodeParams(this.urls.api,{hostname:this.hostname});"token"!==t&&(o+="/"+this.safeString(this.options.api,t,t)),o+="/"+this.implodeParams(e,s);let n=this.omit(s,this.extractParams(e));if("market"===t||"settings"===t||"public"===t)"POST"===i?(a=this.json(n),r={"Content-Type":"application/json"}):Object.keys(n).length&&(o+="?"+this.urlencode(n));else if("token"===t)a=this.urlencode(n),r={"Content-Type":"application/x-www-form-urlencoded"};else{this.checkRequiredCredentials(),n=this.keysort(this.extend({timestamp:this.seconds()},n));const s=this.urlencode(n),c="api"===t?this.options.secret:this.secret;if(r={HMAC:this.hmac(this.encode(s),this.encode(c),"sha512").toUpperCase()},"api"===t){const t=this.safeString(this.options,"accessToken");if(void 0===t)throw new d(this.id+" "+e+" endpoint requires an `accessToken` option or a prior call to signIn() method");const i=this.safeInteger(this.options,"expires");if(void 0!==i&&this.milliseconds()>=i)throw new d(this.id+" accessToken expired, supply a new `accessToken` or call signIn() method");const s=this.safeString(this.options,"tokenType","bearer");r.Authorization=s+" "+t}"POST"===i?(a=this.json(n),r["Content-Type"]="application/json",r.apiKey=this.apiKey):"GET"===i&&Object.keys(n).length&&(o+="?"+this.urlencode(n))}return{url:o,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,o,n,d,c){if(!n)return;const h=this.safeString2(n,"status","Status");if(void 0!==h&&"Success"!==h){let e=this.safeString2(n,"errorMessage","Message");e=this.safeString(n,"message",e);const t=this.id+" "+this.json(n),i=this.exceptions.exact;if(e in i)throw new i[e](t);const s=this.exceptions.broad,a=this.findBroadlyMatchedKey(s,e);if(void 0!==a)throw new s[a](t);throw new r(t)}}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,ArgumentsRequired:a,InvalidOrder:o}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"mercado",name:"Mercado Bitcoin",countries:["BR"],rateLimit:1e3,version:"v3",has:{CORS:!0,createMarketOrder:!0,fetchOrder:!0,withdraw:!0,fetchOHLCV:!0,fetchOrders:!0,fetchOpenOrders:!0,fetchTicker:!0,fetchTickers:!1},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","6h":"6h","12h":"12h","1d":"1d","3d":"3d","1w":"1w","2w":"2w"},urls:{logo:"https://user-images.githubusercontent.com/1294454/27837060-e7c58714-60ea-11e7-9192-f05e86adb83f.jpg",api:{public:"https://www.mercadobitcoin.net/api",private:"https://www.mercadobitcoin.net/tapi",v4Public:"https://www.mercadobitcoin.com.br/v4"},www:"https://www.mercadobitcoin.com.br",doc:["https://www.mercadobitcoin.com.br/api-doc","https://www.mercadobitcoin.com.br/trade-api"]},api:{public:{get:["{coin}/orderbook/","{coin}/ticker/","{coin}/trades/","{coin}/trades/{from}/","{coin}/trades/{from}/{to}","{coin}/day-summary/{year}/{month}/{day}/"]},private:{post:["cancel_order","get_account_info","get_order","get_withdrawal","list_system_messages","list_orders","list_orderbook","place_buy_order","place_sell_order","place_market_buy_order","place_market_sell_order","withdraw_coin"]},v4Public:{get:["{coin}/candle/"]}},markets:{"BTC/BRL":{id:"BRLBTC",symbol:"BTC/BRL",base:"BTC",quote:"BRL",precision:{amount:8,price:5},suffix:"Bitcoin"},"LTC/BRL":{id:"BRLLTC",symbol:"LTC/BRL",base:"LTC",quote:"BRL",precision:{amount:8,price:5},suffix:"Litecoin"},"BCH/BRL":{id:"BRLBCH",symbol:"BCH/BRL",base:"BCH",quote:"BRL",precision:{amount:8,price:5},suffix:"BCash"},"XRP/BRL":{id:"BRLXRP",symbol:"XRP/BRL",base:"XRP",quote:"BRL",precision:{amount:8,price:5},suffix:"Ripple"},"ETH/BRL":{id:"BRLETH",symbol:"ETH/BRL",base:"ETH",quote:"BRL",precision:{amount:8,price:5},suffix:"Ethereum"}},fees:{trading:{maker:.003,taker:.7/100}}})}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={coin:this.market(e).base},r=await this.publicGetCoinOrderbook(this.extend(s,i));return this.parseOrderBook(r)}async fetchTicker(e,t={}){await this.loadMarkets();const i={coin:this.market(e).base},s=await this.publicGetCoinTicker(this.extend(i,t)),r=this.safeValue(s,"ticker",{}),a=this.safeTimestamp(r,"date"),o=this.safeFloat(r,"last");return{symbol:e,timestamp:a,datetime:this.iso8601(a),high:this.safeFloat(r,"high"),low:this.safeFloat(r,"low"),bid:this.safeFloat(r,"buy"),bidVolume:void 0,ask:this.safeFloat(r,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeFloat(r,"vol"),quoteVolume:void 0,info:r}}parseTrade(e,t){const i=this.safeTimestamp(e,"date");let s=void 0;void 0!==t&&(s=t.symbol);const r=this.safeString(e,"tid"),a=this.safeString(e,"type"),o=this.safeFloat(e,"price"),n=this.safeFloat(e,"amount");let d=void 0;return void 0!==o&&void 0!==n&&(d=o*n),{id:r,info:e,timestamp:i,datetime:this.iso8601(i),symbol:s,order:void 0,type:void 0,side:a,takerOrMaker:void 0,price:o,amount:n,cost:d,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e);let a="publicGetCoinTrades";const o={coin:r.base};void 0!==t&&(a+="From",o.from=parseInt(t/1e3)),void 0!==this.safeInteger(s,"to")&&(a+="To");const n=await this[a](this.extend(o,s));return this.parseTrades(n,r,t,i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGetAccountInfo(e),i=this.safeValue(t,"response_data",{}),s=this.safeValue(i,"balance",{}),r={info:t},a=Object.keys(s);for(let e=0;e<a.length;e++){const t=a[e],i=this.safeCurrencyCode(t);if(t in s){const e=this.safeValue(s,t,{}),a=this.account();a.free=this.safeFloat(e,"available"),a.total=this.safeFloat(e,"total"),r[i]=a}}return this.parseBalance(r)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const n={coin_pair:this.marketId(e)};let d=this.capitalize(i)+"Order";if("limit"===t)d="privatePostPlace"+d,n.limit_price=this.priceToPrecision(e,r),n.quantity=this.amountToPrecision(e,s);else if(d="privatePostPlaceMarket"+d,"buy"===i){if(void 0===r)throw new o(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount");n.cost=this.priceToPrecision(e,s*r)}else n.quantity=this.amountToPrecision(e,s);const c=await this[d](this.extend(n,a));return{info:c,id:c.response_data.order.order_id.toString()}}async cancelOrder(e,t,i={}){if(void 0===t)throw new a(this.id+" cancelOrder () requires a symbol argument");await this.loadMarkets();const s=this.market(t),r={coin_pair:s.id,order_id:e},o=await this.privatePostCancelOrder(this.extend(r,i)),n=this.safeValue(o,"response_data",{}),d=this.safeValue(n,"order",{});return this.parseOrder(d,s)}parseOrderStatus(e){return this.safeString({2:"open",3:"canceled",4:"closed"},e,e)}parseOrder(e,t){const i=this.safeString(e,"order_id");let s=void 0;"order_type"in e&&(s=1===e.order_type?"buy":"sell");const r=this.parseOrderStatus(this.safeString(e,"status"));let a=void 0;if(void 0===t){const i=this.safeString(e,"coin_pair");t=this.safeValue(this.markets_by_id,i)}void 0!==t&&(a=t.symbol);const o=this.safeTimestamp(e,"created_timestamp"),n={cost:this.safeFloat(e,"fee"),currency:t.quote},d=this.safeFloat(e,"limit_price"),c=this.safeFloat(e,"executed_price_avg"),h=this.safeFloat(e,"quantity"),l=this.safeFloat(e,"executed_quantity"),u=h-l,f=l*c,p=this.safeTimestamp(e,"updated_timestamp");return{info:e,id:i,timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:p,symbol:a,type:"limit",side:s,price:d,cost:f,average:c,amount:h,filled:l,remaining:u,status:r,fee:n,trades:void 0}}async fetchOrder(e,t,i={}){if(void 0===t)throw new a(this.id+" fetchOrder () requires a symbol argument");await this.loadMarkets();const s=this.market(t),r={coin_pair:s.id,order_id:parseInt(e)},o=await this.privatePostGetOrder(this.extend(r,i)),n=this.safeValue(o,"response_data",{}),d=this.safeValue(n,"order");return this.parseOrder(d,s)}async withdraw(e,t,i,s,a={}){this.checkAddress(i),await this.loadMarkets();const o={coin:this.currency(e).id,quantity:t.toFixed(10),address:i};if("BRL"===e){if(!("account_ref"in a))throw new r(this.id+" requires account_ref parameter to withdraw "+e)}else if("LTC"!==e){if(!("tx_fee"in a))throw new r(this.id+" requires tx_fee parameter to withdraw "+e);if("XRP"===e)if(void 0===s){if(!("destination_tag"in a))throw new r(this.id+" requires a tag argument or destination_tag parameter to withdraw "+e)}else o.destination_tag=s}const n=await this.privatePostWithdrawCoin(this.extend(o,a));return{info:n,id:n.response_data.withdrawal.id}}parseOHLCV(e,t,i="1m",s,r){return[this.safeTimestamp(e,"timestamp"),this.safeFloat(e,"open"),this.safeFloat(e,"high"),this.safeFloat(e,"low"),this.safeFloat(e,"close"),this.safeFloat(e,"volume")]}async fetchOHLCV(e,t="5m",i,s,r={}){await this.loadMarkets();const a=this.market(e),o={precision:this.timeframes[t],coin:a.id.toLowerCase()};void 0!==s&&void 0!==i?(o.from=parseInt(i/1e3),o.to=this.sum(o.from,s*this.parseTimeframe(t))):void 0!==i?(o.from=parseInt(i/1e3),o.to=this.sum(this.seconds(),1)):void 0!==s&&(o.to=this.seconds(),o.from=o.to-s*this.parseTimeframe(t));const n=await this.v4PublicGetCoinCandle(this.extend(o,r)),d=this.safeValue(n,"candles",[]);return this.parseOHLCVs(d,a,t,i,s)}async fetchOrders(e,t,i,s={}){if(void 0===e)throw new a(this.id+" fetchOrders () requires a symbol argument");await this.loadMarkets();const r=this.market(e),o={coin_pair:r.id},n=await this.privatePostListOrders(this.extend(o,s)),d=this.safeValue(n,"response_data",{}),c=this.safeValue(d,"orders",[]);return this.parseOrders(c,r,t,i)}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api[t]+"/";const n=this.omit(s,this.extractParams(e));if("public"===t||"v4Public"===t)o+=this.implodeParams(e,s),Object.keys(n).length&&(o+="?"+this.urlencode(n));else{this.checkRequiredCredentials(),o+=this.version+"/";const t=this.nonce();a=this.urlencode(this.extend({tapi_method:e,tapi_nonce:t},s));const i="/tapi/"+this.version+"/?"+a;r={"Content-Type":"application/x-www-form-urlencoded","TAPI-ID":this.apiKey,"TAPI-MAC":this.hmac(this.encode(i),this.encode(this.secret),"sha512")}}return{url:o,method:i,body:a,headers:r}}async request(e,t="public",i="GET",s={},a,o){const n=await this.fetch2(e,t,i,s,a,o);if("error_message"in n)throw new r(this.id+" "+this.json(n));return n}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"mixcoins",name:"MixCoins",countries:["GB","HK"],rateLimit:1500,version:"v1",userAgent:this.userAgents.chrome,has:{CORS:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/30237212-ed29303c-9535-11e7-8af8-fcd381cfa20c.jpg",api:"https://mixcoins.com/api",www:"https://mixcoins.com",doc:"https://mixcoins.com/help/api/"},api:{public:{get:["ticker/","trades/","depth/"]},private:{post:["cancel","info","orders","order","transactions","trade"]}},markets:{"BTC/USDT":{id:"btc_usdt",symbol:"BTC/USDT",base:"BTC",quote:"USDT",baseId:"btc",quoteId:"usdt",maker:.0015,taker:.0025},"ETH/BTC":{id:"eth_btc",symbol:"ETH/BTC",base:"ETH",quote:"BTC",baseId:"eth",quoteId:"btc",maker:.001,taker:.0015},"BCH/BTC":{id:"bch_btc",symbol:"BCH/BTC",base:"BCH",quote:"BTC",baseId:"bch",quoteId:"btc",maker:.001,taker:.0015},"LSK/BTC":{id:"lsk_btc",symbol:"LSK/BTC",base:"LSK",quote:"BTC",baseId:"lsk",quoteId:"btc",maker:.0015,taker:.0025},"BCH/USDT":{id:"bch_usdt",symbol:"BCH/USDT",base:"BCH",quote:"USDT",baseId:"bch",quoteId:"usdt",maker:.001,taker:.0015},"ETH/USDT":{id:"eth_usdt",symbol:"ETH/USDT",base:"ETH",quote:"USDT",baseId:"eth",quoteId:"usdt",maker:.001,taker:.0015}}})}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostInfo(e),i=this.safeValue(t.result,"wallet"),s={info:t},r=Object.keys(i);for(let e=0;e<r.length;e++){const t=r[e],a=this.safeCurrencyCode(t),o=this.safeValue(i,t,{}),n=this.account();n.free=this.safeFloat(o,"avail"),n.used=this.safeFloat(o,"lock"),s[a]=n}return this.parseBalance(s)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={market:this.marketId(e)},r=await this.publicGetDepth(this.extend(s,i));return this.parseOrderBook(r.result)}async fetchTicker(e,t={}){await this.loadMarkets();const i={market:this.marketId(e)},s=await this.publicGetTicker(this.extend(i,t)),r=this.safeValue(s,"result"),a=this.milliseconds(),o=this.safeFloat(r,"last");return{symbol:e,timestamp:a,datetime:this.iso8601(a),high:this.safeFloat(r,"high"),low:this.safeFloat(r,"low"),bid:this.safeFloat(r,"buy"),bidVolume:void 0,ask:this.safeFloat(r,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeFloat(r,"vol"),quoteVolume:void 0,info:r}}parseTrade(e,t){const i=this.safeTimestamp(e,"date");let s=void 0;void 0!==t&&(s=t.symbol);const r=this.safeString(e,"id"),a=this.safeFloat(e,"price"),o=this.safeFloat(e,"amount");let n=void 0;return void 0!==a&&void 0!==o&&(n=a*o),{id:r,info:e,timestamp:i,datetime:this.iso8601(i),symbol:s,type:void 0,side:void 0,order:void 0,takerOrMaker:void 0,price:a,amount:o,cost:n,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={market:r.id},o=await this.publicGetTrades(this.extend(a,s));return this.parseTrades(o.result,r,t,i)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o={market:this.marketId(e),op:i,amount:s};"market"===t?(o.order_type=1,o.price=r):o.order_type=0;const n=await this.privatePostTrade(this.extend(o,a));return{info:n,id:n.result.id.toString()}}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={id:e};return await this.privatePostCancel(this.extend(s,i))}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api+"/"+this.version+"/"+e;if("public"===t)Object.keys(s).length&&(o+="?"+this.urlencode(s));else{this.checkRequiredCredentials();const e=this.nonce();a=this.urlencode(this.extend({nonce:e},s)),r={"Content-Type":"application/x-www-form-urlencoded",Key:this.apiKey,Sign:this.hmac(this.encode(a),this.secret,"sha512")}}return{url:o,method:i,body:a,headers:r}}async request(e,t="public",i="GET",s={},a,o){const n=await this.fetch2(e,t,i,s,a,o);if("status"in n&&200===n.status)return n;throw new r(this.id+" "+this.json(n))}}},function(e,t,i){"use strict";const s=i(1),{ArgumentsRequired:r}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"negociecoins",name:"NegocieCoins",countries:["BR"],rateLimit:1e3,version:"v3",has:{createMarketOrder:!1,fetchOrder:!0,fetchOrders:!0,fetchOpenOrders:!0,fetchClosedOrders:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/38008571-25a6246e-3258-11e8-969b-aeb691049245.jpg",api:{public:"https://broker.negociecoins.com.br/api/v3",private:"https://broker.negociecoins.com.br/tradeapi/v1"},www:"https://www.negociecoins.com.br",doc:["https://www.negociecoins.com.br/documentacao-tradeapi","https://www.negociecoins.com.br/documentacao-api"],fees:"https://www.negociecoins.com.br/comissoes"},api:{public:{get:["{PAR}/ticker","{PAR}/orderbook","{PAR}/trades","{PAR}/trades/{timestamp_inicial}","{PAR}/trades/{timestamp_inicial}/{timestamp_final}"]},private:{get:["user/balance","user/order/{orderId}"],post:["user/order","user/orders"],delete:["user/order/{orderId}"]}},markets:{"B2X/BRL":{id:"b2xbrl",symbol:"B2X/BRL",base:"B2X",quote:"BRL"},"BCH/BRL":{id:"bchbrl",symbol:"BCH/BRL",base:"BCH",quote:"BRL"},"BTC/BRL":{id:"btcbrl",symbol:"BTC/BRL",base:"BTC",quote:"BRL"},"BTG/BRL":{id:"btgbrl",symbol:"BTG/BRL",base:"BTG",quote:"BRL"},"DASH/BRL":{id:"dashbrl",symbol:"DASH/BRL",base:"DASH",quote:"BRL"},"LTC/BRL":{id:"ltcbrl",symbol:"LTC/BRL",base:"LTC",quote:"BRL"}},fees:{trading:{maker:.005,taker:.005},funding:{withdraw:{BTC:.001,BCH:3e-5,BTG:9e-5,LTC:.005}}},limits:{amount:{min:.001,max:void 0}},precision:{amount:8,price:8}})}parseTicker(e,t){const i=this.safeTimestamp(e,"date"),s=void 0!==t?t.symbol:void 0,r=this.safeFloat(e,"last");return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"buy"),bidVolume:void 0,ask:this.safeFloat(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeFloat(e,"vol"),quoteVolume:void 0,info:e}}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={PAR:i.id},r=await this.publicGetPARTicker(this.extend(s,t));return this.parseTicker(r,i)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={PAR:this.marketId(e)},r=await this.publicGetPAROrderbook(this.extend(s,i));return this.parseOrderBook(r,void 0,"bid","ask","price","quantity")}parseTrade(e,t){const i=this.safeTimestamp(e,"date"),s=this.safeFloat(e,"price"),r=this.safeFloat(e,"amount");let a=void 0;void 0!==s&&void 0!==r&&(a=s*r);let o=void 0;void 0!==t&&(o=t.symbol);const n=this.safeString(e,"tid"),d=this.safeStringLower(e,"type");return{timestamp:i,datetime:this.iso8601(i),symbol:o,id:n,order:void 0,type:"limit",side:d,price:s,amount:r,cost:a,fee:void 0,info:e}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e);void 0===t&&(t=0);const a={PAR:r.id,timestamp_inicial:parseInt(t/1e3)},o=await this.publicGetPARTradesTimestampInicial(this.extend(a,s));return this.parseTrades(o,r,t,i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetUserBalance(e),i={info:t},s=this.safeValue(t,"coins");for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"name"),a=this.safeCurrencyCode(r),o=this.safeFloat(t,"openOrders"),n=this.safeFloat(t,"withdraw"),d={free:this.safeFloat(t,"total"),used:this.sum(o,n),total:this.safeFloat(t,"available")};i[a]=d}return this.parseBalance(i)}parseOrderStatus(e){return this.safeString({filled:"closed",cancelled:"canceled","partially filled":"open",pending:"open",rejected:"rejected"},e,e)}parseOrder(e,t){let i=void 0;if(void 0===t){const s=this.safeString(e,"pair");(t=this.safeValue(this.marketsById,s))&&(i=t.symbol)}const s=this.parse8601(this.safeString(e,"created")),r=this.safeFloat(e,"price"),a=this.safeFloat(e,"quantity"),o=this.safeFloat(e,"total"),n=this.safeFloat(e,"pending_quantity"),d=this.safeFloat(e,"executed_quantity"),c=this.parseOrderStatus(this.safeString(e,"status"));return{id:e.id.toString(),datetime:this.iso8601(s),timestamp:s,lastTradeTimestamp:void 0,status:c,symbol:i,type:"limit",side:e.type,price:r,cost:o,amount:a,filled:d,remaining:n,trades:void 0,fee:{currency:t.quote,cost:this.safeFloat(e,"fee")},info:e}}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o=this.market(e),n={pair:o.id,price:this.priceToPrecision(e,r),volume:this.amountToPrecision(e,s),type:i},d=await this.privatePostUserOrder(this.extend(n,a)),c=this.parseOrder(d[0],o),h=c.id;return this.orders[h]=c,c}async cancelOrder(e,t,i={}){await this.loadMarkets();const s=this.markets[t],r={orderId:e},a=await this.privateDeleteUserOrderOrderId(this.extend(r,i));return this.parseOrder(a[0],s)}async fetchOrder(e,t,i={}){await this.loadMarkets();const s={orderId:e},r=await this.privateGetUserOrderOrderId(this.extend(s,i));return this.parseOrder(r[0])}async fetchOrders(e,t,i,s={}){if(await this.loadMarkets(),void 0===e)throw new r(this.id+" fetchOrders () requires a symbol argument");const a=this.market(e),o={pair:a.id};void 0!==t&&(o.startDate=this.ymd(t)),void 0!==i&&(o.pageSize=i);const n=await this.privatePostUserOrders(this.extend(o,s));return this.parseOrders(n,a)}async fetchOpenOrders(e,t,i,s={}){return await this.fetchOrders(e,t,i,this.extend({status:"pending"},s))}async fetchClosedOrders(e,t,i,s={}){return await this.fetchOrders(e,t,i,this.extend({status:"filled"},s))}nonce(){return this.milliseconds()}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api[t]+"/"+this.implodeParams(e,s);const n=this.omit(s,this.extractParams(e)),d=this.urlencode(n);if("public"===t)d.length&&(o+="?"+d);else{this.checkRequiredCredentials();const e=this.seconds().toString(),t=this.nonce().toString();let s="";d.length?(a=this.json(n),s=this.hash(this.encode(a),"md5","base64")):a="";const c=this.encodeURIComponent(o).toLowerCase(),h=[this.apiKey,i,c,e,t,s].join(""),l=this.base64ToBinary(this.secret);let u=this.hmac(this.encode(h),l,"sha256","base64");u=this.decode(u),r={Authorization:"amx "+[this.apiKey,u,t,e].join(":")},"POST"===i?(r["Content-Type"]="application/json; charset=UTF-8",r["Content-Length"]=a.length):d.length&&(o+="?"+d,a=void 0)}return{url:o,method:i,body:a,headers:r}}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,AuthenticationError:a,ArgumentsRequired:o,BadRequest:n,InvalidOrder:d,InsufficientFunds:c,OrderNotFound:h,PermissionDenied:l}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"oceanex",name:"OceanEx",countries:["US"],version:"v1",rateLimit:3e3,urls:{logo:"https://user-images.githubusercontent.com/1294454/58385970-794e2d80-8001-11e9-889c-0567cd79b78e.jpg",api:"https://api.oceanex.pro",www:"https://www.oceanex.pro.com",doc:"https://api.oceanex.pro/doc/v1",referral:"https://oceanex.pro/signup?referral=VE24QX"},has:{fetchMarkets:!0,fetchCurrencies:!1,fetchTicker:!0,fetchTickers:!0,fetchOrderBook:!0,fetchOrderBooks:!0,fetchTrades:!0,fetchTradingLimits:!1,fetchTradingFees:!1,fetchAllTradingFees:!0,fetchFundingFees:!1,fetchTime:!0,fetchOrder:!0,fetchOrders:!0,fetchOpenOrders:!0,fetchClosedOrders:!0,fetchBalance:!0,createMarketOrder:!0,createOrder:!0,cancelOrder:!0,cancelOrders:!0,cancelAllOrders:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","4h":"4h","12h":"12h","1d":"1d","1w":"1w"},api:{public:{get:["markets","tickers/{pair}","tickers_multi","order_book","order_book/multi","fees/trading","trades","timestamp"]},private:{get:["key","members/me","orders","orders/filter"],post:["orders","orders/multi","order/delete","order/delete/multi","orders/clear"]}},fees:{trading:{tierBased:!1,percentage:!0,maker:.001,taker:.001}},exceptions:{codes:{"-1":n,"-2":n,1001:n,1004:o,1006:a,1008:a,1010:a,1011:l,2001:a,2002:d,2004:h,9003:l},exact:{"market does not have a valid value":n,"side does not have a valid value":n,"Account::AccountError: Cannot lock funds":c,"The account does not exist":a}}})}async fetchMarkets(e={}){const t=await this.publicGetMarkets(this.extend({show_details:!0},e)),i=[],s=this.safeValue(t,"data");for(let e=0;e<s.length;e++){const t=s[e],r=this.safeValue(t,"id"),a=this.safeValue(t,"name");let[o,n]=a.split("/");const d=this.safeCurrencyCode(o),c=this.safeCurrencyCode(n);o=o.toLowerCase(),n=n.toLowerCase();const h=d+"/"+c;i.push({id:r,symbol:h,base:d,quote:c,baseId:o,quoteId:n,active:!0,info:t,precision:{amount:this.safeValue(t,"amount_precision"),price:this.safeValue(t,"price_precision"),base:this.safeValue(t,"ask_precision"),quote:this.safeValue(t,"bid_precision")},limits:{amount:{min:this.safeValue(t,"minimum_trading_amount"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}}})}return i}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={pair:i.id},r=await this.publicGetTickersPair(this.extend(s,t)),a=this.safeValue(r,"data",{});return this.parseTicker(a,i)}async fetchTickers(e,t={}){await this.loadMarkets(),void 0===e&&(e=this.symbols);const i={markets:this.marketIds(e)},s=await this.publicGetTickersMulti(this.extend(i,t)),r=this.safeValue(s,"data"),a={};for(let e=0;e<r.length;e++){const t=r[e],i=this.safeString(t,"market"),s=this.markets_by_id[i];a[s.symbol]=this.parseTicker(t,s)}return a}parseTicker(e,t){const i=this.safeValue(e,"ticker",{}),s=this.safeTimestamp(e,"at");return{symbol:t.symbol,timestamp:s,datetime:this.iso8601(s),high:this.safeFloat(i,"high"),low:this.safeFloat(i,"low"),bid:this.safeFloat(i,"buy"),bidVolume:void 0,ask:this.safeFloat(i,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:this.safeFloat(i,"last"),last:this.safeFloat(i,"last"),previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeFloat(i,"volume"),quoteVolume:void 0,info:i}}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={market:this.market(e).id};void 0!==t&&(s.limit=t);const r=await this.publicGetOrderBook(this.extend(s,i)),a=this.safeValue(r,"data",{}),o=this.safeTimestamp(a,"timestamp");return this.parseOrderBook(a,o)}async fetchOrderBooks(e,t,i={}){await this.loadMarkets(),void 0===e&&(e=this.symbols);const s={markets:this.marketIds(e)};void 0!==t&&(s.limit=t);const r=await this.publicGetOrderBookMulti(this.extend(s,i)),a=this.safeValue(r,"data",[]),o={};for(let e=0;e<a.length;e++){const t=a[e],i=this.safeString(t,"market"),s=this.markets_by_id[i].symbol,r=this.safeTimestamp(t,"timestamp");o[s]=this.parseOrderBook(t,r)}return o}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={market:r.id};void 0!==i&&(a.limit=i);const o=await this.publicGetTrades(this.extend(a,s)),n=this.safeValue(o,"data");return this.parseTrades(n,r,t,i)}parseTrade(e,t){let i=this.safeValue(e,"side");"bid"===i?i="buy":"ask"===i&&(i="sell");let s=void 0;const r=this.safeValue(e,"market");void 0!==r&&(s=r in this.markets_by_id?(t=this.markets_by_id[r]).symbol:r),void 0===s&&void 0!==t&&(s=t.symbol);let a=this.safeTimestamp(e,"created_on");return void 0===a&&(a=this.parse8601(this.safeString(e,"created_at"))),{info:e,timestamp:a,datetime:this.iso8601(a),symbol:s,id:this.safeString(e,"id"),order:void 0,type:"limit",takerOrMaker:void 0,side:i,price:this.safeFloat(e,"price"),amount:this.safeFloat(e,"volume"),cost:void 0,fee:void 0}}async fetchTime(e={}){const t=await this.publicGetTimestamp(e);return this.safeTimestamp(t,"data")}async fetchAllTradingFees(e={}){const t=await this.publicGetFeesTrading(e),i=this.safeValue(t,"data"),s={};for(let e=0;e<i.length;e++){const t=i[e],r=this.safeValue(t,"ask_fee",{}),a=this.safeValue(t,"bid_fee",{}),o=this.safeString(t,"market");let n=o;o in this.markets_by_id&&(n=this.markets_by_id[o].symbol),s[n]={info:t,symbol:n,maker:this.safeFloat(r,"value"),taker:this.safeFloat(a,"value")}}return s}async fetchKey(e={}){const t=await this.privateGetKey(e);return this.safeValue(t,"data")}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetMembersMe(e),i=this.safeValue(t,"data"),s=this.safeValue(i,"accounts"),r={info:t};for(let e=0;e<s.length;e++){const t=s[e],i=this.safeValue(t,"currency"),a=this.safeCurrencyCode(i),o=this.account();o.free=this.safeFloat(t,"balance"),o.used=this.safeFloat(t,"locked"),r[a]=o}return this.parseBalance(r)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o=this.market(e),n={market:o.id,side:i,ord_type:t,volume:this.amountToPrecision(e,s)};"limit"===t&&(n.price=this.priceToPrecision(e,r));const d=await this.privatePostOrders(this.extend(n,a)),c=this.safeValue(d,"data");return this.parseOrder(c,o)}async fetchOrder(e,t,i={}){let s=e;Array.isArray(e)||(s=[e]),await this.loadMarkets();let r=void 0;void 0!==t&&(r=this.market(t));const a={ids:s},o=await this.privateGetOrders(this.extend(a,i)),n=this.safeValue(o,"data"),d=n.length;if(void 0===n)throw new h(this.id+" could not found matching order");if(Array.isArray(e))return this.parseOrders(n,r);if(0===d)throw new h(this.id+" could not found matching order");return this.parseOrder(n[0],r)}async fetchOpenOrders(e,t,i,s={}){return await this.fetchOrders(e,t,i,this.extend({states:["wait"]},s))}async fetchClosedOrders(e,t,i,s={}){return await this.fetchOrders(e,t,i,this.extend({states:["done","cancel"]},s))}async fetchOrders(e,t,i,s={}){if(void 0===e)throw new o(this.id+" fetchOrders requires a `symbol` argument");await this.loadMarkets();const r=this.market(e),a=this.safeValue(s,"states",["wait","done","cancel"]),n=this.omit(s,"states"),d={market:r.id,states:a,need_price:"True"};void 0!==i&&(d.limit=i);const c=await this.privateGetOrdersFilter(this.extend(d,n)),h=this.safeValue(c,"data",[]);let l=[];for(let e=0;e<h.length;e++){const s=this.safeValue(h[e],"orders",[]),a=this.parseOrderStatus(this.safeValue(h[e],"state")),o=this.parseOrders(s,r,t,i,{status:a});l=this.arrayConcat(l,o)}return l}parseOrder(e,t){const i=this.parseOrderStatus(this.safeValue(e,"state")),s=this.safeValue2(e,"market","market_id");let r=void 0;void 0!==s&&(r=s in this.markets_by_id?(t=this.markets_by_id[s]).symbol:s),void 0===r&&void 0!==t&&(r=t.symbol);let a=this.safeTimestamp(e,"created_on");return void 0===a&&(a=this.parse8601(this.safeString(e,"created_at"))),{info:e,id:this.safeString(e,"id"),timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:void 0,symbol:r,type:this.safeValue(e,"ord_type"),side:this.safeValue(e,"side"),price:this.safeFloat(e,"price"),average:this.safeFloat(e,"avg_price"),amount:this.safeFloat(e,"volume"),remaining:this.safeFloat(e,"remaining_volume"),filled:this.safeFloat(e,"executed_volume"),status:i,cost:void 0,trades:void 0,fee:void 0}}parseOrderStatus(e){return this.safeString({wait:"open",done:"closed",cancel:"canceled"},e,e)}async createOrders(e,t,i={}){await this.loadMarkets();const s={market:this.market(e).id,orders:t},r=(await this.privatePostOrdersMulti(this.extend(s,i))).data;return this.parseOrders(r)}async cancelOrder(e,t,i={}){await this.loadMarkets();const s=await this.privatePostOrderDelete(this.extend({id:e},i)),r=this.safeValue(s,"data");return this.parseOrder(r)}async cancelOrders(e,t,i={}){await this.loadMarkets();const s=await this.privatePostOrderDeleteMulti(this.extend({ids:e},i)),r=this.safeValue(s,"data");return this.parseOrders(r)}async cancelAllOrders(e,t={}){await this.loadMarkets();const i=await this.privatePostOrdersClear(t),s=this.safeValue(i,"data");return this.parseOrders(s)}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api+"/"+this.version+"/"+this.implodeParams(e,s);const n=this.omit(s,this.extractParams(e));if("public"===t)if("tickers_multi"===e||"order_book/multi"===e){let e="?";const t=this.safeValue(s,"markets");for(let i=0;i<t.length;i++)e+="markets[]="+t[i]+"&";const i=this.safeValue(s,"limit");void 0!==i&&(e+="limit="+i),o+=e}else Object.keys(n).length&&(o+="?"+this.urlencode(n));else if("private"===t){this.checkRequiredCredentials();const e={uid:this.apiKey,data:n};o+="?user_jwt="+this.jwt(e,this.encode(this.secret),"RS256")}return{url:o,method:i,body:a,headers:{"Content-Type":"application/json"}}}handleErrors(e,t,i,s,a,o,n,d,c){if(void 0===n)return;const h=this.safeString(n,"code"),l=this.safeString(n,"message");if(void 0!==h&&"0"!==h){const e=this.id+" "+o,t=this.exceptions.codes,i=this.exceptions.exact;if(h in t)throw new t[h](e);if(l in i)throw new i[l](e);throw new r(n)}}}},function(e,t,i){"use strict";const s=i(8);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"okcoincny",name:"OKCoin CNY",countries:["CN"],has:{CORS:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766792-8be9157a-5ee5-11e7-926c-6d69b8d3378d.jpg",api:{web:"https://www.okcoin.cn",public:"https://www.okcoin.cn/api",private:"https://www.okcoin.cn/api"},www:"https://www.okcoin.cn",doc:"https://www.okcoin.cn/rest_getStarted.html",referral:"https://www.okcoin.cn"},markets:{"BTC/CNY":{id:"btc_cny",symbol:"BTC/CNY",base:"BTC",quote:"CNY",type:"spot",spot:!0,future:!1},"LTC/CNY":{id:"ltc_cny",symbol:"LTC/CNY",base:"LTC",quote:"CNY",type:"spot",spot:!0,future:!1},"ETH/CNY":{id:"eth_cny",symbol:"ETH/CNY",base:"ETH",quote:"CNY",type:"spot",spot:!0,future:!1},"ETC/CNY":{id:"etc_cny",symbol:"ETC/CNY",base:"ETC",quote:"CNY",type:"spot",spot:!0,future:!1},"BCH/CNY":{id:"bcc_cny",symbol:"BCH/CNY",base:"BCH",quote:"CNY",type:"spot",spot:!0,future:!1}}})}}},function(e,t,i){"use strict";const s=i(8);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"okex",name:"OKEX",countries:["CN","US"],has:{CORS:!1,futures:!0,fetchTickers:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/32552768-0d6dd3c6-c4a6-11e7-90f8-c043b64756a7.jpg",api:{web:"https://www.okex.com/v2",public:"https://www.okex.com/api",private:"https://www.okex.com/api"},www:"https://www.okex.com",doc:["https://github.com/okcoin-okex/API-docs-OKEx.com","https://www.okex.com/docs/en/"],fees:"https://www.okex.com/pages/products/fees.html",referral:"https://www.okex.com"},fees:{trading:{taker:.0015,maker:.001},spot:{taker:.0015,maker:.001},future:{taker:5e-4,maker:2e-4},swap:{taker:75e-5,maker:2e-4}},commonCurrencies:{AE:"AET",HOT:"Hydro Protocol",HSR:"HC",MAG:"Maggie",YOYO:"YOYOW",WIN:"WinToken"}})}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,ExchangeNotAvailable:a,ArgumentsRequired:o,BadRequest:n,AccountSuspended:d,InvalidAddress:c,PermissionDenied:h,DDoSProtection:l,InsufficientFunds:u,InvalidNonce:f,CancelPending:p,InvalidOrder:m,OrderNotFound:y,AuthenticationError:b,RequestTimeout:v,NotSupported:g,BadSymbol:w}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"okex3",name:"OKEX",countries:["CN","US"],version:"v3",rateLimit:1e3,has:{CORS:!1,fetchOHLCV:!0,fetchOrder:!0,fetchOrders:!1,fetchOpenOrders:!0,fetchClosedOrders:!0,fetchCurrencies:!1,fetchDeposits:!0,fetchWithdrawals:!0,fetchTime:!0,fetchTransactions:!1,fetchMyTrades:!1,fetchDepositAddress:!0,fetchOrderTrades:!0,fetchTickers:!0,fetchLedger:!0,withdraw:!0,futures:!0},timeframes:{"1m":"60","3m":"180","5m":"300","15m":"900","30m":"1800","1h":"3600","2h":"7200","4h":"14400","6h":"21600","12h":"43200","1d":"86400","1w":"604800"},urls:{logo:"https://user-images.githubusercontent.com/1294454/32552768-0d6dd3c6-c4a6-11e7-90f8-c043b64756a7.jpg",api:"https://www.okex.com",www:"https://www.okex.com",doc:"https://www.okex.com/docs/en/",fees:"https://www.okex.com/pages/products/fees.html"},api:{general:{get:["time"]},account:{get:["currencies","wallet","wallet/{currency}","withdrawal/fee","withdrawal/history","withdrawal/history/{currency}","ledger","deposit/address","deposit/history","deposit/history/{currency}"],post:["transfer","withdrawal"]},spot:{get:["accounts","accounts/{currency}","accounts/{currency}/ledger","orders","orders_pending","orders/{order_id}","orders/{client_oid}","fills","instruments","instruments/{instrument_id}/book","instruments/ticker","instruments/{instrument_id}/ticker","instruments/{instrument_id}/trades","instruments/{instrument_id}/candles"],post:["orders","batch_orders","cancel_orders/{order_id}","cancel_orders/{client_oid}","cancel_batch_orders"]},margin:{get:["accounts","accounts/{instrument_id}","accounts/{instrument_id}/ledger","accounts/availability","accounts/{instrument_id}/availability","accounts/borrowed","accounts/{instrument_id}/borrowed","orders","orders/{order_id}","orders/{client_oid}","orders_pending","fills"],post:["accounts/borrow","accounts/repayment","orders","batch_orders","cancel_orders","cancel_orders/{order_id}","cancel_orders/{client_oid}","cancel_batch_orders"]},futures:{get:["position","{instrument_id}/position","accounts","accounts/{currency}","accounts/{currency}/leverage","accounts/{currency}/ledger","order_algo/{instrument_id}","orders/{instrument_id}","orders/{instrument_id}/{order_id}","orders/{instrument_id}/{client_oid}","fills","instruments","instruments/{instrument_id}/book","instruments/ticker","instruments/{instrument_id}/ticker","instruments/{instrument_id}/trades","instruments/{instrument_id}/candles","accounts/{instrument_id}/holds","instruments/{instrument_id}/index","rate","instruments/{instrument_id}/estimated_price","instruments/{instrument_id}/open_interest","instruments/{instrument_id}/price_limit","instruments/{instrument_id}/liquidation","instruments/{instrument_id}/mark_price"],post:["accounts/{currency}/leverage","accounts/margin_mode","order","orders","order_algo","cancel_algos","cancel_order/{instrument_id}/{order_id}","cancel_order/{instrument_id}/{client_oid}","cancel_batch_orders/{instrument_id}","close_position","cancel_all"]},swap:{get:["position","{instrument_id}/position","accounts","{instrument_id}/accounts","accounts/{instrument_id}/settings","accounts/{instrument_id}/ledger","accounts/{instrument_id}/holds","order_algo/{instrument_id}","orders/{instrument_id}","orders/{instrument_id}/{order_id}","orders/{instrument_id}/{client_oid}","fills","instruments","instruments/{instrument_id}/depth","instruments/ticker","instruments/{instrument_id}/ticker","instruments/{instrument_id}/trades","instruments/{instrument_id}/candles","instruments/{instrument_id}/index","rate","instruments/{instrument_id}/open_interest","instruments/{instrument_id}/price_limit","instruments/{instrument_id}/liquidation","instruments/{instrument_id}/funding_time","instruments/{instrument_id}/mark_price","instruments/{instrument_id}/historical_funding_rate"],post:["accounts/{instrument_id}/leverage","order","order_algo","orders","cancel_algos","cancel_order/{instrument_id}/{order_id}","cancel_order/{instrument_id}/{client_oid}","cancel_batch_orders/{instrument_id}"]},ett:{get:["accounts","accounts/{currency}","accounts/{currency}/ledger","orders","constituents/{ett}","define-price/{ett}"],post:["orders","orders/{order_id}"]}},fees:{trading:{taker:.0015,maker:.001},spot:{taker:.0015,maker:.001},futures:{taker:5e-4,maker:2e-4},swap:{taker:75e-5,maker:2e-4}},requiredCredentials:{apiKey:!0,secret:!0,password:!0},exceptions:{exact:{1:r,"failure to get a peer from the ring-balancer":r,'"instrument_id" is an invalid parameter':w,4010:h,30001:b,30002:b,30003:b,30004:b,30005:f,30006:b,30007:n,30008:v,30009:r,30010:b,30011:h,30012:b,30013:b,30014:l,30015:b,30016:r,30017:r,30018:r,30019:a,30020:n,30021:n,30022:h,30023:n,30024:n,30025:n,30026:l,30027:b,30028:h,30029:d,30030:r,30031:n,30032:r,30033:n,30034:r,30035:r,30036:r,30038:b,30037:a,32001:d,32002:h,32003:p,32004:r,32005:m,32006:m,32007:m,32008:m,32009:m,32010:r,32011:r,32012:r,32013:r,32014:r,32015:r,32016:r,32017:r,32018:r,32019:r,32020:r,32021:r,32022:r,32023:r,32024:r,32025:r,32026:r,32029:r,32028:r,32027:r,32044:r,33001:h,33002:d,33003:u,33004:r,33005:r,33006:r,33007:r,33008:r,33009:r,33010:r,33011:r,33012:r,33013:m,33014:y,33015:m,33016:r,33017:u,33018:r,33020:r,33021:n,33022:m,33023:r,33024:m,33025:m,33026:r,33027:m,33028:m,33029:m,33034:r,33059:n,33060:n,34001:h,34002:c,34003:r,34004:r,34005:r,34006:r,34007:r,34008:u,34009:r,34010:r,34011:r,34012:r,34013:r,34014:r,34015:r,34016:h,34017:d,34018:b,34019:h,34020:h,34021:c,34022:r,34023:h,35001:r,35002:r,35003:r,35004:r,35005:b,35008:m,35010:m,35012:m,35014:m,35015:m,35017:r,35019:m,35020:m,35021:m,35022:r,35024:r,35025:u,35026:r,35029:y,35030:m,35031:m,35032:r,35039:r,35040:m,35044:r,35046:u,35047:u,35048:r,35049:m,35050:m,35052:u,35053:r,35055:u,35057:r,35058:r,35059:n,35060:n,35061:n,35062:m,35063:m,35064:m},broad:{}},options:{fetchMarkets:["spot","futures","swap"],defaultType:"spot",auth:{time:"public",currencies:"private",instruments:"public",rate:"public","constituents/{ett}":"public","define-price/{ett}":"public"}},commonCurrencies:{AE:"AET",HOT:"Hydro Protocol",HSR:"HC",MAG:"Maggie",YOYO:"YOYOW",WIN:"WinToken"}})}async fetchTime(e={}){const t=await this.generalGetTime(e);return this.parse8601(this.safeString(t,"iso"))}async fetchMarkets(e={}){const t=this.safeValue(this.options,"fetchMarkets");let i=[];for(let s=0;s<t.length;s++){const r=await this.fetchMarketsByType(t[s],e);i=this.arrayConcat(i,r)}return i}parseMarkets(e){const t=[];for(let i=0;i<e.length;i++)t.push(this.parseMarket(e[i]));return t}parseMarket(e){const t=this.safeString(e,"instrument_id");let i="spot",s=!0,r=!1,a=!1,o=this.safeString(e,"base_currency");void 0===o&&(i="swap",s=!1,a=!0,void 0===(o=this.safeString(e,"coin"))&&(a=!1,r=!0,i="futures",o=this.safeString(e,"underlying_index")));const n=this.safeString(e,"quote_currency"),d=this.safeCurrencyCode(o),c=this.safeCurrencyCode(n),h=s?d+"/"+c:t;let l=this.safeString(e,"size_increment");void 0!==l&&(l=this.precisionFromString(l));let u=this.safeString(e,"tick_size");void 0!==u&&(u=this.precisionFromString(u));const f={amount:l,price:u},p=this.safeFloat2(e,"min_size","base_min_size");let m=this.safeFloat(e,"tick_size");void 0!==f.price&&(m=Math.pow(10,-f.price));let y=void 0;void 0!==p&&void 0!==m&&(y=p*m);const b=this.safeValue2(this.fees,i,"trading",{});return this.extend(b,{id:t,symbol:h,base:d,quote:c,baseId:o,quoteId:n,info:e,type:i,spot:s,futures:r,swap:a,active:!0,precision:f,limits:{amount:{min:p,max:void 0},price:{min:m,max:void 0},cost:{min:y,max:void 0}}})}async fetchMarketsByType(e,t={}){const i=e+"GetInstruments",s=await this[i](t);return this.parseMarkets(s)}async fetchCurrencies(e={}){const t=await this.accountGetCurrencies(e),i={};for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"currency"),a=this.safeCurrencyCode(r),o=8,n=this.safeString(s,"name"),d=this.safeInteger(s,"can_deposit"),c=this.safeInteger(s,"can_withdraw"),h=d&&c;i[a]={id:r,code:a,info:s,type:void 0,name:n,active:h,fee:void 0,precision:o,limits:{amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0},withdraw:{min:this.safeFloat(s,"min_withdrawal"),max:void 0}}}}return i}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s=this.market(e);let r=s.type+"GetInstrumentsInstrumentId";r+="swap"===s.type?"Depth":"Book";const a={instrument_id:s.id};void 0!==t&&(a.size=t);const o=await this[r](this.extend(a,i)),n=this.parse8601(this.safeString(o,"timestamp"));return this.parseOrderBook(o,n)}parseTicker(e,t){const i=this.parse8601(this.safeString(e,"timestamp"));let s=void 0;const r=this.safeString(e,"instrument_id");if(r in this.markets_by_id)t=this.markets_by_id[r];else if(void 0!==r){const e=r.split("-");if(2===e.length){const[t,i]=e;s=this.safeCurrencyCode(t)+"/"+this.safeCurrencyCode(i)}else s=r}void 0!==t&&(s=t.symbol);const a=this.safeFloat(e,"last"),o=this.safeFloat(e,"open_24h");return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high_24h"),low:this.safeFloat(e,"low_24h"),bid:this.safeFloat(e,"best_bid"),bidVolume:void 0,ask:this.safeFloat(e,"best_ask"),askVolume:void 0,vwap:void 0,open:o,close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeFloat(e,"base_volume_24h"),quoteVolume:this.safeFloat(e,"quote_volume_24h"),info:e}}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s=i.type+"GetInstrumentsInstrumentIdTicker",r={instrument_id:i.id},a=await this[s](this.extend(r,t));return this.parseTicker(a)}async fetchTickersByType(e,t,i={}){await this.loadMarkets();const s=e+"GetInstrumentsTicker",r=await this[s](i),a={};for(let e=0;e<r.length;e++){const t=this.parseTicker(r[e]);a[t.symbol]=t}return a}async fetchTickers(e,t={}){const i=this.safeString2(this.options,"fetchTickers","defaultType"),s=this.safeString(t,"type",i);return await this.fetchTickersByType(s,e,this.omit(t,"type"))}parseTrade(e,t){let i=void 0;void 0!==t&&(i=t.symbol);const s=this.parse8601(this.safeString2(e,"timestamp","created_at")),r=this.safeFloat(e,"price");let a=this.safeFloat2(e,"size","qty");a=this.safeFloat(e,"order_qty",a);let o=this.safeString2(e,"exec_type","liquidity");"M"===o?o="maker":"T"===o&&(o="taker");const n=this.safeString(e,"side");let d=void 0;void 0!==a&&void 0!==r&&(d=a*r);const c=this.safeFloat(e,"fee");let h=void 0;if(void 0!==c){h={cost:-c,currency:void 0}}const l=this.safeString(e,"order_id");return{info:e,timestamp:s,datetime:this.iso8601(s),symbol:i,id:this.safeString2(e,"trade_id","ledger_id"),order:l,type:void 0,takerOrMaker:o,side:n,price:r,amount:a,cost:d,fee:h}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a=r.type+"GetInstrumentsInstrumentIdTrades";(void 0===i||i>100)&&(i=100);const o={instrument_id:r.id,limit:i},n=await this[a](this.extend(o,s));return this.parseTrades(n,r,t,i)}parseOHLCV(e,t,i="1m",s,r){if(Array.isArray(e)){const t=e.length>6?6:5;let i=e[0];return"string"==typeof i&&(i=this.parse8601(i)),[i,parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3]),parseFloat(e[4]),parseFloat(e[t])]}return[this.parse8601(this.safeString(e,"time")),this.safeFloat(e,"open"),this.safeFloat(e,"high"),this.safeFloat(e,"low"),this.safeFloat(e,"close"),this.safeFloat(e,"volume")]}async fetchOHLCV(e,t="1m",i,s,r={}){await this.loadMarkets();const a=this.market(e),o=a.type+"GetInstrumentsInstrumentIdCandles",n={instrument_id:a.id,granularity:this.timeframes[t]};void 0!==i&&(n.start=this.iso8601(i));const d=await this[o](this.extend(n,r));return this.parseOHLCVs(d,a,t,i,s)}parseAccountBalance(e){const t={info:e};for(let i=0;i<e.length;i++){const s=e[i],r=this.safeString(s,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeFloat(s,"balance"),o.used=this.safeFloat(s,"hold"),o.free=this.safeFloat(s,"available"),t[a]=o}return this.parseBalance(t)}parseMarginBalance(e){const t={info:e};for(let i=0;i<e.length;i++){const s=e[i],r=this.safeString(s,"instrument_id"),a=this.safeValue(this.markets_by_id,r);let o=void 0;if(void 0===a){const[e,t]=r.split("-");o=this.safeCurrencyCode(e)+"/"+this.safeCurrencyCode(t)}else o=a.symbol;const n=this.omit(s,["instrument_id","liquidation_price","product_id","risk_rate","margin_ratio"]),d=Object.keys(n),c={};for(let e=0;e<d.length;e++){const t=d[e],i=s[t];if(!(t.indexOf(":")>=0))throw new g(this.id+" margin balance response format has changed!");{const e=t.split(":")[1],s=this.safeCurrencyCode(e),r=this.account();r.total=this.safeFloat(i,"balance"),r.used=this.safeFloat(i,"hold"),r.free=this.safeFloat(i,"available"),c[s]=r}}t[o]=this.parseBalance(c)}return t}parseFuturesBalance(e){const t={info:e},i=this.safeValue(e,"info",{}),s=Object.keys(i);for(let e=0;e<s.length;e++){const r=s[e],a=this.safeCurrencyCode(r),o=this.safeValue(i,r,{}),n=this.account();n.total=this.safeFloat(o,"equity"),n.free=this.safeFloat(o,"total_avail_balance"),t[a]=n}return this.parseBalance(t)}parseSwapBalance(e){const t={info:e},i=this.safeValue(e,"info",[]);for(let e=0;e<i.length;e++){const s=i[e],r=this.safeString(s,"instrument_id");let a=r;r in this.markets_by_id&&(a=this.markets_by_id[r].symbol);const o=this.account();o.total=this.safeFloat(s,"equity"),o.free=this.safeFloat(s,"total_avail_balance"),t[a]=o}return this.parseBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString2(this.options,"fetchBalance","defaultType"),i=this.safeString(e,"type",t);if(void 0===i)throw new o(this.id+" fetchBalance requires a type parameter (one of 'account', 'spot', 'margin', 'futures', 'swap')");const s=i+"Get"+("account"===i?"Wallet":"Accounts"),r=this.omit(e,"type"),a=await this[s](r);if("account"===i||"spot"===i)return this.parseAccountBalance(a);if("margin"===i)return this.parseMarginBalance(a);if("futures"===i)return this.parseFuturesBalance(a);if("swap"===i)return this.parseSwapBalance(a);throw new g(this.id+" fetchBalance does not support the '"+i+"' type (the type must be one of 'account', 'spot', 'margin', 'futures', 'swap')")}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o=this.market(e);let n={instrument_id:o.id},d=void 0;if(o.futures||o.swap){const i=o.futures?this.numberToString(s):this.amountToPrecision(e,s);n=this.extend(n,{type:t,size:i,price:this.priceToPrecision(e,r)}),o.futures&&(n.leverage="10"),d=o.type+"PostOrder"}else{const o=this.safeString(a,"margin_trading","1");if(n=this.extend(n,{side:i,type:t,margin_trading:o}),"limit"===t)n.price=this.priceToPrecision(e,r),n.size=this.amountToPrecision(e,s);else if("market"===t)if("buy"===i){let t=this.safeFloat(a,"notional");if(this.safeValue(this.options,"createMarketBuyOrderRequiresPrice",!0))if(void 0!==r)void 0===t&&(t=s*r);else if(void 0===t)throw new m(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false and supply the total cost value in the 'notional' extra parameter (the exchange-specific behaviour)");n.notional=this.costToPrecision(e,t)}else n.size=this.amountToPrecision(e,s);d="2"===o?"marginPostOrders":"spotPostOrders"}const c=await this[d](this.extend(n,a)),h=this.milliseconds();return{info:c,id:this.safeString(c,"order_id"),timestamp:h,datetime:this.iso8601(h),lastTradeTimestamp:void 0,status:void 0,symbol:e,type:t,side:i,price:r,amount:s,filled:void 0,remaining:void 0,cost:void 0,trades:void 0,fee:void 0}}async cancelOrder(e,t,i={}){if(void 0===t)throw new o(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const s=this.market(t);let r=s.type+"PostCancelOrder";const a={instrument_id:s.id};s.futures||s.swap?r+="InstrumentId":r+="s";const n=this.safeString(i,"client_oid");void 0!==n?(r+="ClientOid",a.client_oid=n):(r+="OrderId",a.order_id=e);const d=this.omit(i,"type"),c=await this[r](this.extend(a,d)),h="result"in c?c:this.safeValue(c,s.id,{});return this.parseOrder(h,s)}parseOrderStatus(e){return this.safeString({"-2":"failed","-1":"canceled",0:"open",1:"open",2:"closed",3:"open",4:"canceled"},e,e)}parseOrderSide(e){return this.safeString({1:"buy",2:"sell",3:"sell",4:"buy"},e,e)}parseOrder(e,t){const i=this.safeString(e,"order_id"),s=this.parse8601(this.safeString(e,"timestamp"));let r=this.safeString(e,"side"),a=this.safeString(e,"type");"buy"!==r&&"sell"!==r&&(r=this.parseOrderSide(a)),"limit"!==a&&"market"!==a&&(a="pnl"in e?"futures":"swap");let o=void 0;const n=this.safeString(e,"instrument_id");o=n in this.markets_by_id?(t=this.markets_by_id[n]).symbol:n,void 0!==t&&void 0===o&&(o=t.symbol);let d=this.safeFloat(e,"size");const c=this.safeFloat2(e,"filled_size","filled_qty");let h=void 0;void 0!==d&&void 0!==c&&(d=Math.max(d,c),h=Math.max(0,d-c)),"market"===a&&(h=0);let l=this.safeFloat2(e,"filled_notional","funds");const u=this.safeFloat(e,"price");let f=this.safeFloat(e,"price_avg");void 0===l?void 0!==c&&void 0!==f&&(l=f*c):void 0===f&&void 0!==c&&c>0&&(f=l/c);const p=this.parseOrderStatus(this.safeString(e,"state")),m=this.safeFloat(e,"fee");let y=void 0;if(void 0!==m){y={cost:m,currency:void 0}}return{info:e,id:i,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,symbol:o,type:a,side:r,price:u,average:f,cost:l,amount:d,filled:c,remaining:h,status:p,fee:y}}async fetchOrder(e,t,i={}){if(void 0===t)throw new o(this.id+" fetchOrder requires a symbol argument");await this.loadMarkets();const s=this.market(t),r=this.safeString2(this.options,"fetchOrder","defaultType",s.type),a=this.safeString(i,"type",r);if(void 0===a)throw new o(this.id+" fetchOrder requires a type parameter (one of 'spot', 'margin', 'futures', 'swap').");let n=a+"GetOrders"+(s.futures||s.swap?"InstrumentId":"");const d={instrument_id:s.id},c=this.safeString(i,"client_oid");void 0!==c?(n+="ClientOid",d.client_oid=c):(n+="OrderId",d.order_id=e);const h=this.omit(i,"type"),l=await this[n](this.extend(d,h));return this.parseOrder(l)}async fetchOrdersByState(e,t,i,s,r={}){if(void 0===t)throw new o(this.id+" fetchOrdersByState requires a symbol argument");await this.loadMarkets();const a=this.market(t),n=a.type,d={instrument_id:a.id,state:e};let c=n+"GetOrders";(a.futures||a.swap)&&(c+="InstrumentId");const h=this.omit(r,"type"),l=await this[c](this.extend(d,h));let u=void 0;if("swap"===a.type||"futures"===a.type)u=this.safeValue(l,"order_info",[]);else{u=l;const e=l.length;if(e<1)return[];if(e>1){void 0!==this.safeValue(l[1],"before")&&(u=l[0])}}return this.parseOrders(u,a,i,s)}async fetchOpenOrders(e,t,i,s={}){return await this.fetchOrdersByState("6",e,t,i,s)}async fetchClosedOrders(e,t,i,s={}){return await this.fetchOrdersByState("7",e,t,i,s)}parseDepositAddresses(e){const t=[];for(let i=0;i<e.length;i++)t.push(this.parseDepositAddress(e[i]));return t}parseDepositAddress(e,t){const i=this.safeString(e,"address");let s=this.safeString2(e,"tag","payment_id");s=this.safeString(e,"memo",s);const r=this.safeString(e,"currency"),a=this.safeCurrencyCode(r);return this.checkAddress(i),{currency:a,address:i,tag:s,info:e}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},s=await this.accountGetDepositAddress(this.extend(i,t)),r=this.parseDepositAddresses(s);if(r.length<1)throw new c(this.id+" fetchDepositAddress cannot return nonexistent addresses, you should create withdrawal addresses with the exchange website first");return r[0]}async withdraw(e,t,i,s,a={}){this.checkAddress(i),await this.loadMarkets();const o=this.currency(e);s&&(i=i+":"+s);const n=this.safeString(a,"fee");if(void 0===n)throw new r(this.id+" withdraw() requires a `fee` string parameter, network transaction fee must be  0. Withdrawals to OKCoin or OKEx are fee-free, please set '0'. Withdrawing to external digital asset address requires network transaction fee.");const d={currency:o.id,to_address:i,destination:"4",amount:this.numberToString(t),fee:n};this.password?d.trade_pwd=this.password:"password"in a?d.trade_pwd=a.password:"trade_pwd"in a&&(d.trade_pwd=a.trade_pwd);const c=this.omit(a,["fee","password","trade_pwd"]);if(!("trade_pwd"in d))throw new r(this.id+" withdraw() requires this.password set on the exchange instance or a password / trade_pwd parameter");const h=await this.accountPostWithdrawal(this.extend(d,c));return{info:h,id:this.safeString(h,"withdrawal_id")}}async fetchDeposits(e,t,i,s={}){await this.loadMarkets();const r={};let a="accountGetDepositHistory",o=void 0;void 0!==e&&(o=this.currency(e),r.code=o.code,a+="Currency");const n=await this[a](this.extend(r,s));return this.parseTransactions(n,o,t,i,s)}async fetchWithdrawals(e,t,i,s={}){await this.loadMarkets();const r={};let a="accountGetWithdrawalHistory",o=void 0;void 0!==e&&(o=this.currency(e),r.code=o.code,a+="Currency");const n=await this[a](this.extend(r,s));return this.parseTransactions(n,o,t,i,s)}parseTransactionStatus(e){return this.safeString({"-3":"pending","-2":"pending","-1":"failed",0:"pending",1:"pending",2:"ok",3:"pending",4:"pending",5:"pending"},e,e)}parseTransaction(e,t){let i=void 0,s=void 0,r=void 0;const a=this.safeString(e,"withdrawal_id"),o=this.safeString(e,"from"),n=this.safeString(e,"to");void 0!==a?(i="withdrawal",s=a,r=n):(s=this.safeString(e,"payment_id"),i="deposit",r=n);const d=this.safeString(e,"currency"),c=this.safeCurrencyCode(d),h=this.safeFloat(e,"amount"),l=this.parseTransactionStatus(this.safeString(e,"status")),u=this.safeString(e,"txid"),f=this.parse8601(this.safeString(e,"timestamp"));let p=void 0;if("deposit"===i)p=0;else if(void 0!==d){const t=this.safeString(e,"fee");if(void 0!==t){const e=d.toLowerCase(),i=t.replace(e,"");p=parseFloat(i)}}return{info:e,id:s,currency:c,amount:h,addressFrom:o,addressTo:n,address:r,tagFrom:void 0,tagTo:void 0,tag:void 0,status:l,type:i,updated:void 0,txid:u,timestamp:f,datetime:this.iso8601(f),fee:{currency:c,cost:p}}}async fetchOrderTrades(e,t,i,s,r={}){if(void 0===t)throw new o(this.id+" fetchOrderTrades requires a symbol argument");await this.loadMarkets();const a=this.market(t);(void 0===s||s>100)&&(s=100);const n={instrument_id:a.id,order_id:e,limit:s},d=this.safeString2(this.options,"fetchMyTrades","defaultType"),c=this.safeString(r,"type",d),h=this.omit(r,"type"),l=c+"GetFills",u=await this[l](this.extend(n,h));return this.parseTrades(u,a,i,s)}async fetchLedger(e,t,i,s={}){await this.loadMarkets();const r=this.safeString2(this.options,"fetchLedger","defaultType"),a=this.safeString(s,"type",r),n=this.omit(s,"type"),d="account"===a?"":"Accounts";let c="";const h={};void 0!==i&&(h.limit=i);let l=void 0;if("spot"===a||"futures"===a){if(void 0===e)throw new o(this.id+" fetchLedger requires a currency code argument for '"+a+"' markets");c="Currency",l=this.currency(e),h.currency=l.id}else if("margin"===a||"swap"===a){if(void 0===e)throw new o(this.id+" fetchLedger requires a code argument (a market symbol) for '"+a+"' markets");c="InstrumentId";const t=this.market(e);l=this.currency(t.base),h.instrument_id=t.id}else{if("account"!==a)throw new g(this.id+" fetchLedger does not support the '"+a+"' type (the type must be one of 'account', 'spot', 'margin', 'futures', 'swap')");void 0!==e&&(l=this.currency(e),h.currency=l.id)}const u=a+"Get"+d+c+"Ledger",f=await this[u](this.extend(h,n)),p="margin"===a?f[0]:f;return this.parseLedger(p,l,t,i)}parseLedgerEntryType(e){return this.safeString({transfer:"transfer",trade:"trade",rebate:"rebate",match:"trade",fee:"fee",settlement:"trade",liquidation:"trade",funding:"fee",margin:"margin"},e,e)}parseLedgerEntry(e,t){const i=this.safeString(e,"ledger_id"),s=this.safeValue(e,"details",{}),r=this.safeString(s,"order_id"),a=this.parseLedgerEntryType(this.safeString(e,"type")),o=this.safeCurrencyCode(this.safeString(e,"currency"),t),n=this.safeFloat(e,"amount"),d=this.parse8601(this.safeString(e,"timestamp")),c={cost:this.safeFloat(e,"fee"),currency:o};return{info:e,id:i,account:void 0,referenceId:r,referenceAccount:void 0,type:a,currency:o,amount:n,before:void 0,after:this.safeFloat(e,"balance"),status:"ok",timestamp:d,datetime:this.iso8601(d),fee:c}}sign(e,t="public",i="GET",s={},r,a){const o=Array.isArray(s);let n="/api/"+t+"/"+this.version+"/";n+=o?e:this.implodeParams(e,s);const d=o?s:this.omit(s,this.extractParams(e));let c=this.urls.api+n;const h=this.getPathAuthenticationType(e);if("public"===h)Object.keys(d).length&&(c+="?"+this.urlencode(d));else if("private"===h){this.checkRequiredCredentials();const e=this.iso8601(this.milliseconds());r={"OK-ACCESS-KEY":this.apiKey,"OK-ACCESS-PASSPHRASE":this.password,"OK-ACCESS-TIMESTAMP":e};let t=e+i+n;if("GET"===i){if(Object.keys(d).length){const e="?"+this.urlencode(d);c+=e,t+=e}}else(o||Object.keys(d).length)&&(t+=a=this.json(d)),r["Content-Type"]="application/json";const s=this.hmac(this.encode(t),this.encode(this.secret),"sha256","base64");r["OK-ACCESS-SIGN"]=this.decode(s)}return{url:c,method:i,body:a,headers:r}}getPathAuthenticationType(e){const t=this.safeValue(this.options,"auth",{}),i=this.findBroadlyMatchedKey(t,e);return this.safeString(t,i,"private")}handleErrors(e,t,i,s,a,o,n,d,c){const h=this.id+" "+o;if(503===e)throw new r(h);if(!n)return;const l=this.exceptions.exact,u=this.safeString(n,"message"),f=this.safeString2(n,"code","error_code");if(void 0!==u){if(u in l)throw new l[u](h);const e=this.exceptions.broad,t=this.findBroadlyMatchedKey(e,u);if(void 0!==t)throw new e[t](h)}if(f in l)throw new l[f](h);if(void 0!==u)throw new r(h)}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"paymium",name:"Paymium",countries:["FR","EU"],rateLimit:2e3,version:"v1",has:{CORS:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27790564-a945a9d4-5ff9-11e7-9d2d-b635763f2f24.jpg",api:"https://paymium.com/api",www:"https://www.paymium.com",fees:"https://www.paymium.com/page/help/fees",doc:["https://github.com/Paymium/api-documentation","https://www.paymium.com/page/developers"]},api:{public:{get:["countries","data/{id}/ticker","data/{id}/trades","data/{id}/depth","bitcoin_charts/{id}/trades","bitcoin_charts/{id}/depth"]},private:{get:["merchant/get_payment/{UUID}","user","user/addresses","user/addresses/{btc_address}","user/orders","user/orders/{UUID}","user/price_alerts"],post:["user/orders","user/addresses","user/payment_requests","user/price_alerts","merchant/create_payment"],delete:["user/orders/{UUID}/cancel","user/price_alerts/{id}"]}},markets:{"BTC/EUR":{id:"eur",symbol:"BTC/EUR",base:"BTC",quote:"EUR",baseId:"btc",quoteId:"eur"}},fees:{trading:{maker:.002,taker:.002}}})}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetUser(e),i={info:t},s=Object.keys(this.currencies);for(let e=0;e<s.length;e++){const r=s[e],a=this.currencyId(r),o="balance_"+a;if(o in t){const e=this.account(),s="locked_"+a;e.free=this.safeFloat(t,o),e.used=this.safeFloat(t,s),i[r]=e}}return this.parseBalance(i)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={id:this.marketId(e)},r=await this.publicGetDataIdDepth(this.extend(s,i));return this.parseOrderBook(r,void 0,"bids","asks","price","amount")}async fetchTicker(e,t={}){const i={id:this.marketId(e)},s=await this.publicGetDataIdTicker(this.extend(i,t)),r=this.safeTimestamp(s,"at"),a=this.safeFloat(s,"vwap"),o=this.safeFloat(s,"volume");let n=void 0;void 0!==o&&void 0!==a&&(n=o*a);const d=this.safeFloat(s,"price");return{symbol:e,timestamp:r,datetime:this.iso8601(r),high:this.safeFloat(s,"high"),low:this.safeFloat(s,"low"),bid:this.safeFloat(s,"bid"),bidVolume:void 0,ask:this.safeFloat(s,"ask"),askVolume:void 0,vwap:a,open:this.safeFloat(s,"open"),close:d,last:d,previousClose:void 0,change:void 0,percentage:this.safeFloat(s,"variation"),average:void 0,baseVolume:o,quoteVolume:n,info:s}}parseTrade(e,t){const i=this.safeTimestamp(e,"created_at_int"),s=this.safeString(e,"uuid");let r=void 0;void 0!==t&&(r=t.symbol);const a=this.safeString(e,"side"),o=this.safeFloat(e,"price"),n="traded_"+t.base.toLowerCase(),d=this.safeFloat(e,n);let c=void 0;return void 0!==o&&void 0!==d&&(c=d*o),{info:e,id:s,order:void 0,timestamp:i,datetime:this.iso8601(i),symbol:r,type:void 0,side:a,takerOrMaker:void 0,price:o,amount:d,cost:c,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={id:r.id},o=await this.publicGetDataIdTrades(this.extend(a,s));return this.parseTrades(o,r,t,i)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o={type:this.capitalize(t)+"Order",currency:this.marketId(e),direction:i,amount:s};"market"!==t&&(o.price=r);const n=await this.privatePostUserOrders(this.extend(o,a));return{info:n,id:n.uuid}}async cancelOrder(e,t,i={}){const s={UUID:e};return await this.privateDeleteUserOrdersUUIDCancel(this.extend(s,i))}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api+"/"+this.version+"/"+this.implodeParams(e,s);const n=this.omit(s,this.extractParams(e));if("public"===t)Object.keys(n).length&&(o+="?"+this.urlencode(n));else{this.checkRequiredCredentials();const e=this.nonce().toString();let t=e+o;"POST"===i&&Object.keys(n).length&&(t+=a=this.json(n)),r={"Api-Key":this.apiKey,"Api-Signature":this.hmac(this.encode(t),this.encode(this.secret)),"Api-Nonce":e,"Content-Type":"application/json"}}return{url:o,method:i,body:a,headers:r}}async request(e,t="public",i="GET",s={},a,o){const n=await this.fetch2(e,t,i,s,a,o);if("errors"in n)throw new r(this.id+" "+this.json(n));return n}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,ExchangeNotAvailable:a,RequestTimeout:o,AuthenticationError:n,PermissionDenied:d,DDoSProtection:c,InsufficientFunds:h,OrderNotFound:l,OrderNotCached:u,InvalidOrder:f,AccountSuspended:p,CancelPending:m,InvalidNonce:y}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"poloniex",name:"Poloniex",countries:["US"],rateLimit:1e3,certified:!0,has:{CORS:!1,createDepositAddress:!0,createMarketOrder:!1,editOrder:!0,fetchClosedOrders:"emulated",fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrder:!0,fetchOpenOrders:!0,fetchOrder:"emulated",fetchOrderBooks:!0,fetchOrders:"emulated",fetchOrderStatus:"emulated",fetchOrderTrades:!0,fetchTickers:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchTransactions:!0,fetchWithdrawals:!0,cancelAllOrders:!0,withdraw:!0},timeframes:{"5m":300,"15m":900,"30m":1800,"2h":7200,"4h":14400,"1d":86400},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766817-e9456312-5ee6-11e7-9b3c-b628ca5626a5.jpg",api:{public:"https://poloniex.com/public",private:"https://poloniex.com/tradingApi"},www:"https://www.poloniex.com",doc:"https://docs.poloniex.com",fees:"https://poloniex.com/fees",referral:"https://www.poloniex.com/?utm_source=ccxt&utm_medium=web"},api:{public:{get:["return24hVolume","returnChartData","returnCurrencies","returnLoanOrders","returnOrderBook","returnTicker","returnTradeHistory"]},private:{post:["buy","cancelLoanOffer","cancelOrder","cancelAllOrders","closeMarginPosition","createLoanOffer","generateNewAddress","getMarginPosition","marginBuy","marginSell","moveOrder","returnActiveLoans","returnAvailableAccountBalances","returnBalances","returnCompleteBalances","returnDepositAddresses","returnDepositsWithdrawals","returnFeeInfo","returnLendingHistory","returnMarginAccountSummary","returnOpenLoanOffers","returnOpenOrders","returnOrderTrades","returnOrderStatus","returnTradableBalances","returnTradeHistory","sell","toggleAutoRenew","transferBalance","withdraw"]}},fees:{trading:{maker:.0015,taker:.0025},funding:{}},limits:{amount:{min:1e-6,max:1e9},price:{min:1e-8,max:1e9},cost:{min:0,max:1e9}},precision:{amount:8,price:8},commonCurrencies:{AIR:"AirCoin",APH:"AphroditeCoin",BCC:"BTCtalkcoin",BDG:"Badgercoin",BTM:"Bitmark",CON:"Coino",GOLD:"GoldEagles",GPUC:"GPU",HOT:"Hotcoin",ITC:"Information Coin",PLX:"ParallaxCoin",KEY:"KEYCoin",STR:"XLM",SOC:"SOCC",XAP:"API Coin"},options:{limits:{cost:{min:{BTC:1e-4,ETH:1e-4,XMR:1e-4,USDT:1}}}},exceptions:{exact:{"You may only place orders that reduce your position.":f,"Invalid order number, or you are not the person who placed the order.":l,"Permission denied":d,"Connection timed out. Please try again.":o,"Internal error. Please try again.":a,"Order not found, or you are not the person who placed it.":l,"Invalid API key/secret pair.":n,"Please do not make more than 8 API calls per second.":c,"Rate must be greater than zero.":f},broad:{"Total must be at least":f,"This account is frozen.":p,"Not enough":h,"Nonce must be greater":y,"You have already called cancelOrder or moveOrder on this order.":m,"Amount must be at least":f,"is either completed or does not exist":f}}})}calculateFee(e,t,i,s,r,a="taker",o={}){const n=this.markets[e];let d="quote";const c=n[a];let h=parseFloat(this.costToPrecision(e,s*c));return"sell"===i?h*=r:d="base",{type:a,currency:n[d],rate:c,cost:parseFloat(this.feeToPrecision(e,h))}}parseOHLCV(e,t,i="5m",s,r){return[this.safeTimestamp(e,"date"),this.safeFloat(e,"open"),this.safeFloat(e,"high"),this.safeFloat(e,"low"),this.safeFloat(e,"close"),this.safeFloat(e,"quoteVolume")]}async fetchOHLCV(e,t="5m",i,s,r={}){await this.loadMarkets();const a=this.market(e);void 0===i&&(i=0);const o={currencyPair:a.id,period:this.timeframes[t],start:parseInt(i/1e3)};o.end=void 0!==s?this.sum(o.start,s*this.timeframes[t]):this.sum(this.seconds(),1);const n=await this.publicGetReturnChartData(this.extend(o,r));return this.parseOHLCVs(n,a,t,i,s)}async fetchMarkets(e={}){const t=await this.publicGetReturnTicker(),i=Object.keys(t),s=[];for(let e=0;e<i.length;e++){const r=i[e],a=t[r],[o,n]=r.split("_"),d=this.safeCurrencyCode(n),c=this.safeCurrencyCode(o),h=d+"/"+c,l=this.extend(this.limits,{cost:{min:this.safeValue(this.options.limits.cost.min,c)}}),u="1"!==this.safeString(a,"isFrozen");s.push(this.extend(this.fees.trading,{id:r,symbol:h,baseId:n,quoteId:o,base:d,quote:c,active:u,limits:l,info:a}))}return s}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostReturnCompleteBalances(this.extend({account:"all"},e)),i={info:t},s=Object.keys(t);for(let e=0;e<s.length;e++){const r=s[e],a=this.safeValue(t,r,{}),o=this.safeCurrencyCode(r),n=this.account();n.free=this.safeFloat(a,"available"),n.used=this.safeFloat(a,"onOrders"),i[o]=n}return this.parseBalance(i)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privatePostReturnFeeInfo(e);return{info:t,maker:this.safeFloat(t,"makerFee"),taker:this.safeFloat(t,"takerFee"),withdraw:{},deposit:{}}}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={currencyPair:this.marketId(e)};void 0!==t&&(s.depth=t);const r=await this.publicGetReturnOrderBook(this.extend(s,i)),a=this.parseOrderBook(r);return a.nonce=this.safeInteger(r,"seq"),a}async fetchOrderBooks(e,t={}){await this.loadMarkets();const i=await this.publicGetReturnOrderBook(this.extend({currencyPair:"all"},t)),s=Object.keys(i),r={};for(let e=0;e<s.length;e++){const t=s[e];let a=void 0;if(t in this.markets_by_id)a=this.markets_by_id[t].symbol;else{const[e,i]=t.split("_");a=this.safeCurrencyCode(i)+"/"+this.safeCurrencyCode(e)}const o=this.parseOrderBook(i[t]);o.nonce=this.safeInteger(i[t],"seq"),r[a]=o}return r}parseTicker(e,t){const i=this.milliseconds();let s=void 0;t&&(s=t.symbol);let r=void 0,a=void 0,o=void 0;const n=this.safeFloat(e,"last"),d=this.safeFloat(e,"percentChange");return-1!==d&&(a=n-(r=n/this.sum(1,d)),o=this.sum(n,r)/2),{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high24hr"),low:this.safeFloat(e,"low24hr"),bid:this.safeFloat(e,"highestBid"),bidVolume:void 0,ask:this.safeFloat(e,"lowestAsk"),askVolume:void 0,vwap:void 0,open:r,close:n,last:n,previousClose:void 0,change:a,percentage:100*d,average:o,baseVolume:this.safeFloat(e,"quoteVolume"),quoteVolume:this.safeFloat(e,"baseVolume"),info:e}}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetReturnTicker(t),s=Object.keys(i),r={};for(let e=0;e<s.length;e++){const t=s[e];let a=void 0,o=void 0;if(t in this.markets_by_id)a=(o=this.markets_by_id[t]).symbol;else{const[e,i]=t.split("_");o={symbol:a=this.safeCurrencyCode(i)+"/"+this.safeCurrencyCode(e)}}const n=i[t];r[a]=this.parseTicker(n,o)}return r}async fetchCurrencies(e={}){const t=await this.publicGetReturnCurrencies(e),i=Object.keys(t),s={};for(let e=0;e<i.length;e++){const r=i[e],a=t[r],o=8,n=this.safeCurrencyCode(r),d=0===a.delisted&&!a.disabled;s[n]={id:r,code:n,info:a,name:a.name,active:d,fee:this.safeFloat(a,"txFee"),precision:o,limits:{amount:{min:Math.pow(10,-o),max:Math.pow(10,o)},price:{min:Math.pow(10,-o),max:Math.pow(10,o)},cost:{min:void 0,max:void 0},withdraw:{min:a.txFee,max:Math.pow(10,o)}}}}return s}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s=(await this.publicGetReturnTicker(t))[i.id];return this.parseTicker(s,i)}parseTrade(e,t){const i=this.safeString(e,"globalTradeID"),s=this.safeString(e,"orderNumber"),r=this.parse8601(this.safeString(e,"date"));let a=void 0,o=void 0,n=void 0;if(!t&&"currencyPair"in e){const i=e.currencyPair;if(i in this.markets_by_id)t=this.markets_by_id[i];else{const e=i.split("_");n=e[0],a=(o=e[1])+"/"+n}}void 0!==t&&(a=t.symbol,o=t.base,n=t.quote);const d=this.safeString(e,"type");let c=void 0;const h=this.safeFloat(e,"rate"),l=this.safeFloat(e,"total"),u=this.safeFloat(e,"amount");if("fee"in e){const t=this.safeFloat(e,"fee");let i=void 0,s=void 0;"buy"===d?(s=o,i=u*t):(s=n,void 0!==l&&(i=l*t)),c={type:void 0,rate:t,cost:i,currency:s}}return{id:i,info:e,timestamp:r,datetime:this.iso8601(r),symbol:a,order:s,type:"limit",side:d,takerOrMaker:void 0,price:h,amount:u,cost:l,fee:c}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={currencyPair:r.id};void 0!==t&&(a.start=parseInt(t/1e3),a.end=this.seconds());const o=await this.publicGetReturnTradeHistory(this.extend(a,s));return this.parseTrades(o,r,t,i)}async fetchMyTrades(e,t,i,s={}){await this.loadMarkets();let r=void 0;void 0!==e&&(r=this.market(e));const a={currencyPair:r?r.id:"all"};void 0!==t&&(a.start=parseInt(t/1e3),a.end=this.seconds()+1),void 0!==i&&(a.limit=parseInt(i));const o=await this.privatePostReturnTradeHistory(this.extend(a,s));let n=[];if(void 0!==r)n=this.parseTrades(o,r);else if(o){const e=Object.keys(o);for(let t=0;t<e.length;t++){const i=e[t];let s=void 0;if(i in this.markets_by_id){s=this.markets_by_id[i];const e=this.parseTrades(o[i],s);for(let t=0;t<e.length;t++)n.push(e[t])}else{const[e,t]=i.split("_"),s=this.safeCurrencyCode(t)+"/"+this.safeCurrencyCode(e),r=o[i];for(let e=0;e<r.length;e++)n.push(this.extend(this.parseTrade(r[e]),{symbol:s}))}}}return this.filterBySinceLimit(n,t,i)}parseOrderStatus(e){return this.safeString({Open:"open","Partially filled":"open"},e,e)}parseOrder(e,t){let i=this.safeInteger(e,"timestamp");i||(i=this.parse8601(e.date));let s=void 0;"resultingTrades"in e&&(s=this.parseTrades(e.resultingTrades,t));let r=void 0;const a=this.safeString(e,"currencyPair");void 0!==(t=this.safeValue(this.markets_by_id,a,t))&&(r=t.symbol);const o=this.safeFloat2(e,"price","rate"),n=this.safeFloat(e,"amount"),d=this.safeFloat(e,"startingAmount",n);let c=void 0,h=0;if(void 0!==d&&void 0!==n&&(c=d-n,void 0!==o&&(h=c*o)),void 0===c&&void 0!==s){c=0,h=0;for(let e=0;e<s.length;e++){const t=s[e],i=t.amount,r=t.price;c=this.sum(c,i),h+=r*i}}const l=this.parseOrderStatus(this.safeString(e,"status"));let u=this.safeString(e,"type");const f=this.safeString(e,"side",u);return u===f&&(u=void 0),{info:e,id:this.safeString(e,"orderNumber"),timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,status:l,symbol:r,type:u,side:f,price:o,cost:h,amount:d,filled:c,remaining:n,trades:s,fee:void 0}}parseOpenOrders(e,t,i){for(let s=0;s<e.length;s++){const r=e[s],a=this.extend(r,{status:"open",type:"limit",side:r.type,price:r.rate});i.push(this.parseOrder(a,t))}return i}async fetchOrders(e,t,i,s={}){await this.loadMarkets();let r=void 0;void 0!==e&&(r=this.market(e));const a={currencyPair:r?r.id:"all"},o=await this.privatePostReturnOpenOrders(this.extend(a,s));let n=[];if(void 0!==r)n=this.parseOpenOrders(o,r,n);else{const e=Object.keys(o);for(let t=0;t<e.length;t++){const i=e[t],s=o[i],r=this.markets_by_id[i];n=this.parseOpenOrders(s,r,n)}}for(let e=0;e<n.length;e++)this.orders[n[e].id]=n[e];const d=this.indexBy(n,"id"),c=Object.keys(this.orders),h=[];for(let t=0;t<c.length;t++){const i=c[t];if(i in d)this.orders[i]=this.extend(this.orders[i],d[i]);else{let e=this.orders[i];"open"===e.status&&(void 0===(e=this.extend(e,{status:"closed",cost:void 0,filled:e.amount,remaining:0})).cost&&void 0!==e.filled&&(e.cost=e.filled*e.price),this.orders[i]=e)}const s=this.orders[i];void 0!==r?s.symbol===e&&h.push(s):h.push(s)}return this.filterBySinceLimit(h,t,i)}async fetchOrder(e,t,i={}){const s=this.safeValue(i,"since"),r=this.safeValue(i,"limit"),a=this.omit(i,["since","limit"]),o=await this.fetchOrders(t,s,r,a);for(let t=0;t<o.length;t++)if(o[t].id===e)return o[t];throw new u(this.id+" order id "+e.toString()+' is not in "open" state and not found in cache')}filterOrdersByStatus(e,t){const i=[];for(let s=0;s<e.length;s++)e[s].status===t&&i.push(e[s]);return i}async fetchOpenOrders(e,t,i,s={}){const r=await this.fetchOrders(e,t,i,s);return this.filterOrdersByStatus(r,"open")}async fetchClosedOrders(e,t,i,s={}){const r=await this.fetchOrders(e,t,i,s);return this.filterOrdersByStatus(r,"closed")}async createOrder(e,t,i,s,a,o={}){if("market"===t)throw new r(this.id+" allows limit orders only");await this.loadMarkets();const n="privatePost"+this.capitalize(i),d=this.market(e),c={currencyPair:d.id,rate:this.priceToPrecision(e,a),amount:this.amountToPrecision(e,s)},h=await this[n](this.extend(c,o)),l=this.milliseconds(),u=this.parseOrder(this.extend({timestamp:l,status:"open",type:t,side:i,price:a,amount:s},h),d),f=u.id;return this.orders[f]=u,this.extend({info:h},u)}async editOrder(e,t,i,s,r,a,o={}){await this.loadMarkets(),a=parseFloat(a);const n={orderNumber:e,rate:this.priceToPrecision(t,a)};void 0!==r&&(n.amount=this.amountToPrecision(t,r));const d=await this.privatePostMoveOrder(this.extend(n,o));let c=void 0;if(e in this.orders){this.orders[e].status="canceled";const t=d.orderNumber;this.orders[t]=this.extend(this.orders[e],{id:t,price:a,status:"open"}),void 0!==r&&(this.orders[t].amount=r),c=this.extend(this.orders[t],{info:d})}else{let e=void 0;void 0!==t&&(e=this.market(t)),c=this.parseOrder(d,e),this.orders[c.id]=c}return c}async cancelOrder(e,t,i={}){await this.loadMarkets();let s=void 0;try{s=await this.privatePostCancelOrder(this.extend({orderNumber:e},i))}catch(t){throw t instanceof m&&e in this.orders&&(this.orders[e].status="canceled"),t}return e in this.orders&&(this.orders[e].status="canceled"),s}async cancelAllOrders(e,t={}){const i={};let s=void 0;void 0!==e&&(s=this.market(e),i.currencyPair=s.id);const r=await this.privatePostCancelAllOrders(this.extend(i,t)),a=this.safeValue(r,"orderNumbers",[]);for(let e=0;e<a.length;e++){const t=a[e].toString();t in this.orders&&(this.orders[t].status="canceled")}return r}async fetchOpenOrder(e,t,i={}){await this.loadMarkets(),e=e.toString();const s=await this.privatePostReturnOrderStatus(this.extend({orderNumber:e},i)),r=this.safeValue(s.result,e);if(void 0===r)throw new l(this.id+" order id "+e+" not found");const a=this.parseOrder(r);return a.id=e,this.orders[e]=a,a}async fetchOrderStatus(e,t,i={}){await this.loadMarkets();const s=await this.fetchOpenOrders(t,void 0,void 0,i);return e in this.indexBy(s,"id")?"open":"closed"}async fetchOrderTrades(e,t,i,s,r={}){await this.loadMarkets();const a={orderNumber:e},o=await this.privatePostReturnOrderTrades(this.extend(a,r));return this.parseTrades(o)}async createDepositAddress(e,t={}){await this.loadMarkets();const i=this.currency(e),s={currency:i.id},r=await this.privatePostGenerateNewAddress(this.extend(s,t));let a=void 0,o=void 0;1===r.success&&(a=this.safeString(r,"response")),this.checkAddress(a);const n=this.safeString(i.info,"depositAddress");return void 0!==n&&(o=a,a=n),{currency:e,address:a,tag:o,info:r}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i=this.currency(e),s=await this.privatePostReturnDepositAddresses(t),r=i.id;let a=this.safeString(s,r),o=void 0;this.checkAddress(a);const n=this.safeString(i.info,"depositAddress");return void 0!==n&&(o=a,a=n),{currency:e,address:a,tag:o,info:s}}async withdraw(e,t,i,s,r={}){this.checkAddress(i),await this.loadMarkets();const a={currency:this.currency(e).id,amount:t,address:i};s&&(a.paymentId=s);const o=await this.privatePostWithdraw(this.extend(a,r));return{info:o,id:this.safeString(o,"withdrawalNumber")}}async fetchTransactionsHelper(e,t,i,s={}){await this.loadMarkets();const r=this.seconds(),a={start:void 0!==t?parseInt(t/1e3):r-31104e4,end:r};return void 0!==i&&(a.limit=i),await this.privatePostReturnDepositsWithdrawals(this.extend(a,s))}async fetchTransactions(e,t,i,s={}){await this.loadMarkets();const r=await this.fetchTransactionsHelper(e,t,i,s);for(let e=0;e<r.deposits.length;e++)r.deposits[e].type="deposit";for(let e=0;e<r.withdrawals.length;e++)r.withdrawals[e].type="withdrawal";let a=void 0;void 0!==e&&(a=this.currency(e));const o=this.parseTransactions(r.withdrawals,a,t,i),n=this.parseTransactions(r.deposits,a,t,i),d=this.arrayConcat(n,o);return this.filterByCurrencySinceLimit(this.sortBy(d,"timestamp"),e,t,i)}async fetchWithdrawals(e,t,i,s={}){const r=await this.fetchTransactionsHelper(e,t,i,s);for(let e=0;e<r.withdrawals.length;e++)r.withdrawals[e].type="withdrawal";let a=void 0;void 0!==e&&(a=this.currency(e));const o=this.parseTransactions(r.withdrawals,a,t,i);return this.filterByCurrencySinceLimit(o,e,t,i)}async fetchDeposits(e,t,i,s={}){const r=await this.fetchTransactionsHelper(e,t,i,s);for(let e=0;e<r.deposits.length;e++)r.deposits[e].type="deposit";let a=void 0;void 0!==e&&(a=this.currency(e));const o=this.parseTransactions(r.deposits,a,t,i);return this.filterByCurrencySinceLimit(o,e,t,i)}parseTransactionStatus(e){return this.safeString({COMPLETE:"ok"},e,e)}parseTransaction(e,t){const i=this.safeTimestamp(e,"timestamp"),s=this.safeString(e,"currency"),r=this.safeCurrencyCode(s);let a=this.safeString(e,"status","pending"),o=this.safeString(e,"txid");if(void 0!==a){const e=a.split(": "),t=e.length;a=e[0],t>1&&void 0===o&&(o=e[1]),a=this.parseTransactionStatus(a)}const n=this.safeString(e,"type"),d=this.safeString2(e,"withdrawalNumber","depositNumber");let c=this.safeFloat(e,"amount");const h=this.safeString(e,"address");let l=this.safeFloat(e,"fee");return void 0===l&&(l=0),"withdrawal"===n&&(c-=l),{info:e,id:d,currency:r,amount:c,address:h,tag:void 0,status:a,type:n,updated:void 0,txid:o,timestamp:i,datetime:this.iso8601(i),fee:{currency:r,cost:l}}}nonce(){return this.milliseconds()}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api[t];const n=this.extend({command:e},s);return"public"===t?o+="?"+this.urlencode(n):(this.checkRequiredCredentials(),n.nonce=this.nonce(),a=this.urlencode(n),r={"Content-Type":"application/x-www-form-urlencoded",Key:this.apiKey,Sign:this.hmac(this.encode(a),this.encode(this.secret),"sha512")}),{url:o,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,o,n,d,c){if(void 0!==n&&"error"in n){const e=n.error,t=this.id+" "+this.json(n),i=this.exceptions.exact;if(e in i)throw new i[e](t);const s=this.exceptions.broad,a=this.findBroadlyMatchedKey(s,e);if(void 0!==a)throw new s[a](t);throw new r(t)}}}},function(e,t,i){"use strict";const s=i(1),{ROUND:r}=i(2),{ExchangeError:a,ArgumentsRequired:o,AuthenticationError:n,InsufficientFunds:d,InvalidOrder:c,OrderNotFound:h}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"rightbtc",name:"RightBTC",countries:["AE"],has:{privateAPI:!1,fetchTickers:!0,fetchOHLCV:!0,fetchOrders:!0,fetchOpenOrders:!0,fetchClosedOrders:!1,fetchOrder:"emulated",fetchMyTrades:!0},timeframes:{"1m":"min1","5m":"min5","15m":"min15","30m":"min30","1h":"hr1","1d":"day1","1w":"week"},urls:{logo:"https://user-images.githubusercontent.com/1294454/42633917-7d20757e-85ea-11e8-9f53-fffe9fbb7695.jpg",api:"https://www.rightbtc.com/api",www:"https://www.rightbtc.com",doc:["https://docs.rightbtc.com/api/"]},api:{public:{get:["trading_pairs","ticker/{trading_pair}","tickers","depth/{trading_pair}","depth/{trading_pair}/{count}","trades/{trading_pair}","trades/{trading_pair}/{count}","candlestick/latest/{trading_pair}","candlestick/{timeSymbol}/{trading_pair}","candlestick/{timeSymbol}/{trading_pair}/{count}"]},trader:{get:["balance/{symbol}","balances","deposits/{asset}/{page}","withdrawals/{asset}/{page}","orderpage/{trading_pair}/{cursor}","orders/{trading_pair}/{ids}","history/{trading_pair}/{ids}","historys/{trading_pair}/{page}","trading_pairs"],post:["order"],delete:["order/{trading_pair}/{ids}"]}},fees:{trading:{maker:.002,taker:.002},funding:{withdraw:{ETP:.01,BTC:.001,ETH:.01,ETC:.01,STORJ:3,LTC:.001,ZEC:.001,BCC:.001,XRB:0,NXS:.1}}},commonCurrencies:{XRB:"NANO"},exceptions:{ERR_USERTOKEN_NOT_FOUND:n,ERR_ASSET_NOT_EXISTS:a,ERR_ASSET_NOT_AVAILABLE:a,ERR_BALANCE_NOT_ENOUGH:d,ERR_CREATE_ORDER:c,ERR_CANDLESTICK_DATA:a}})}async fetchMarkets(e={}){const t=await this.publicGetTradingPairs(e),i=Object.keys(t),s=[];for(let e=0;e<i.length;e++){const r=i[e],a=t[r],o=this.safeString(a,"bid_asset_symbol"),n=this.safeString(a,"ask_asset_symbol"),d=this.safeCurrencyCode(o),c=this.safeCurrencyCode(n),h=d+"/"+c,l={amount:this.safeInteger(a,"bid_asset_decimals"),price:this.safeInteger(a,"ask_asset_decimals")};s.push({id:r,symbol:h,base:d,quote:c,baseId:o,quoteId:n,active:!0,precision:l,limits:{amount:{min:Math.pow(10,-l.amount),max:Math.pow(10,l.price)},price:{min:Math.pow(10,-l.price),max:Math.pow(10,l.price)},cost:{min:void 0,max:void 0}},info:a})}return s}divideSafeFloat(e,t,i){const s=this.safeFloat(e,t);return void 0!==s?s/i:s}parseTicker(e,t){const i=t.symbol,s=this.safeInteger(e,"date"),r=this.divideSafeFloat(e,"last",1e8),a=this.divideSafeFloat(e,"high",1e8),o=this.divideSafeFloat(e,"low",1e8),n=this.divideSafeFloat(e,"buy",1e8),d=this.divideSafeFloat(e,"sell",1e8),c=this.divideSafeFloat(e,"vol24h",1e8);return{symbol:i,timestamp:s,datetime:this.iso8601(s),high:a,low:o,bid:n,bidVolume:void 0,ask:d,askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:c,quoteVolume:void 0,info:e}}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={trading_pair:i.id},r=await this.publicGetTickerTradingPair(this.extend(s,t)),o=this.safeValue(r,"result");if(void 0===o)throw new a(this.id+" fetchTicker returned an empty response for symbol "+e);return this.parseTicker(o,i)}async fetchTickers(e,t={}){await this.loadMarkets();const i=(await this.publicGetTickers(t)).result,s={};for(let e=0;e<i.length;e++){const t=i[e],r=t.market;if(!(r in this.marketsById))continue;const a=this.marketsById[r];s[a.symbol]=this.parseTicker(t,a)}return s}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={trading_pair:this.marketId(e)};let r="publicGetDepthTradingPair";void 0!==t&&(r+="Count",s.count=t);const a=await this[r](this.extend(s,i)),o={},n=["bid","ask"];for(let e=0;e<n.length;e++){const t=n[e];o[t]=[];for(let e=0;e<a.result[t].length;e++){const[i,s,r]=a.result[t][e];o[t].push([i/1e8,s/1e8,r/1e8])}}return this.parseOrderBook(o,void 0,"bid","ask")}parseTrade(e,t){let i=this.safeInteger(e,"date");void 0===i&&(i=this.parse8601(this.safeString(e,"created_at")));let s=this.safeString(e,"tid");s=this.safeString(e,"trade_id",s);const r=this.safeString(e,"order_id"),a=this.divideSafeFloat(e,"price",1e8);let o=this.safeFloat(e,"amount");void 0!==(o=this.safeFloat(e,"quantity",o))&&(o/=1e8);let n=void 0;if(void 0===t){const i=this.safeString(e,"trading_pair");i in this.markets_by_id&&(t=this.markets_by_id[i])}void 0!==t&&(n=t.symbol);let d=this.costToPrecision(n,a*o);d=parseFloat(d);let c=this.safeStringLower(e,"side");return"b"===c?c="buy":"s"===c&&(c="sell"),{id:s,info:e,timestamp:i,datetime:this.iso8601(i),symbol:n,order:r,type:"limit",side:c,takerOrMaker:void 0,price:a,amount:o,cost:d,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={trading_pair:r.id},o=await this.publicGetTradesTradingPair(this.extend(a,s));return this.parseTrades(o.result,r,t,i)}parseOHLCV(e,t,i="5m",s,r){return[parseInt(e[0]),parseFloat(e[2])/1e8,parseFloat(e[3])/1e8,parseFloat(e[4])/1e8,parseFloat(e[5])/1e8,parseFloat(e[1])/1e8]}async fetchOHLCV(e,t="5m",i,s,r={}){await this.loadMarkets();const a=this.market(e),o={trading_pair:a.id,timeSymbol:this.timeframes[t]},n=await this.publicGetCandlestickTimeSymbolTradingPair(this.extend(o,r));return this.parseOHLCVs(n.result,a,t,i,s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.traderGetBalances(e),i={info:t},s=this.safeValue(t,"result",[]);for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"asset"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.divideSafeFloat(t,"balance",1e8),o.used=this.divideSafeFloat(t,"frozen",1e8),i[a]=o}return this.parseBalance(i)}async createOrder(e,t,i,s,a,o={}){await this.loadMarkets();const n={trading_pair:this.market(e).id,quantity:parseInt(this.decimalToPrecision(1e8*s,r,0,this.precisionMode)),limit:parseInt(this.decimalToPrecision(1e8*a,r,0,this.precisionMode)),type:t.toUpperCase(),side:i.toUpperCase()},d=await this.traderPostOrder(this.extend(n,o));return this.parseOrder(d)}async cancelOrder(e,t,i={}){if(void 0===t)throw new o(this.id+" cancelOrder requires a symbol argument");await this.loadMarkets();const s={trading_pair:this.market(t).id,ids:e};return await this.traderDeleteOrderTradingPairIds(this.extend(s,i))}parseOrderStatus(e){return this.safeString({NEW:"open",TRADE:"closed",CANCEL:"canceled"},e,e)}parseOrder(e,t){const i=this.safeString(e,"id"),s=this.parseOrderStatus(this.safeString(e,"status")),r=this.safeString(e,"trading_pair");void 0===t&&r in this.markets_by_id&&(t=this.markets_by_id[r]);let a=r;void 0!==t&&(a=t.symbol);let o=this.safeInteger(e,"created");void 0===o&&(o=this.parse8601(this.safeString(e,"created_at"))),"time"in e?o=e.time:"transactTime"in e&&(o=e.transactTime);let n=this.safeFloat2(e,"limit","price");void 0!==n&&(n/=1e8);const d=this.divideSafeFloat(e,"quantity",1e8);let c=this.divideSafeFloat(e,"filled_quantity",1e8),h=this.divideSafeFloat(e,"rest",1e8);const l=this.divideSafeFloat(e,"cost",1e8);void 0!==d&&(void 0===h&&void 0!==c&&(h=Math.max(0,d-c)),void 0===c&&void 0!==h&&(c=Math.max(0,d-h)));const u=this.safeStringLower(e,"side"),f=this.divideSafeFloat(e,"min_fee",1e8);let p=void 0;if(void 0!==f){let i=void 0;void 0!==t&&(i=t.quote),p={rate:this.safeFloat(e,"fee"),cost:f,currency:i}}return{info:e,id:i,timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:void 0,symbol:a,type:"limit",side:u,price:n,amount:d,cost:l,filled:c,remaining:h,status:s,fee:p,trades:void 0}}async fetchOrder(e,t,i={}){if(void 0===t)throw new o(this.id+" fetchOrder requires a symbol argument");await this.loadMarkets();const s=this.market(t),r={trading_pair:s.id,ids:e},a=await this.traderGetOrdersTradingPairIds(this.extend(r,i)),n=this.parseOrders(a.result,s),d=this.indexBy(n,"id");if(!(e in d))throw new h(this.id+" fetchOrder could not find order "+e.toString()+" in open orders.");return d[e]}async fetchOpenOrders(e,t,i,s={}){if(void 0===e)throw new o(this.id+" fetchOpenOrders requires a symbol argument");await this.loadMarkets();const r=this.market(e),a={trading_pair:r.id,cursor:0},n=await this.traderGetOrderpageTradingPairCursor(this.extend(a,s));return this.parseOrders(n.result.orders,r,t,i)}async fetchOrders(e,t,i,s={}){let r=this.safeString(s,"ids");if(void 0===e||void 0===r)throw new o(this.id+" fetchOrders requires a 'symbol' argument and an extra 'ids' parameter. The 'ids' should be an array or a string of one or more order ids separated with slashes.");Array.isArray(r)&&(r=r.join("/")),await this.loadMarkets();const a={trading_pair:this.market(e).id,ids:r},n=await this.traderGetHistoryTradingPairIds(this.extend(a,s));return this.parseOrders(n.result,void 0,t,i)}async fetchMyTrades(e,t,i,s={}){if(void 0===e)throw new o(this.id+" fetchMyTrades requires a symbol argument");await this.loadMarkets();const r={trading_pair:this.market(e).id,page:0},a=await this.traderGetHistorysTradingPairPage(this.extend(r,s));return this.parseTrades(a.result,void 0,t,i)}sign(e,t="public",i="GET",s={},r,a){const o=this.omit(s,this.extractParams(e));let n=this.urls.api+"/"+t+"/"+this.implodeParams(e,s);return"public"===t?Object.keys(o).length&&(n+="?"+this.urlencode(o)):(this.checkRequiredCredentials(),r={apikey:this.apiKey,signature:this.secret},"GET"===i?Object.keys(o).length&&(n+="?"+this.urlencode(o)):(a=this.json(o),r["Content-Type"]="application/json")),{url:n,method:i,body:a,headers:r}}handleErrors(e,t,i,s,r,o,n,d,c){if(void 0===n)return;const h=this.safeValue(n,"status");if(void 0!==h){if("1"!==this.safeString(h,"success")){const e=this.safeString(h,"message"),t=this.id+" "+this.json(n),i=this.exceptions;if(e in i)throw new i[e](t);throw new a(t)}}}}},function(e,t,i){"use strict";const s=i(1);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"southxchange",name:"SouthXchange",countries:["AR"],rateLimit:1e3,has:{CORS:!0,createDepositAddress:!0,fetchOpenOrders:!0,fetchTickers:!0,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27838912-4f94ec8a-60f6-11e7-9e5d-bbf9bd50a559.jpg",api:"https://www.southxchange.com/api",www:"https://www.southxchange.com",doc:"https://www.southxchange.com/Home/Api"},api:{public:{get:["markets","price/{symbol}","prices","book/{symbol}","trades/{symbol}"]},private:{post:["cancelMarketOrders","cancelOrder","getOrder","generatenewaddress","listOrders","listBalances","listTransactions","placeOrder","withdraw"]}},fees:{trading:{tierBased:!1,percentage:!0,maker:.002,taker:.002}},commonCurrencies:{SMT:"SmartNode",MTC:"Marinecoin"}})}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),i=[];for(let e=0;e<t.length;e++){const s=t[e],r=s[0],a=s[1],o=this.safeCurrencyCode(r),n=this.safeCurrencyCode(a),d=o+"/"+n,c=d;i.push({id:c,symbol:d,base:o,quote:n,baseId:r,quoteId:a,active:void 0,info:s})}return i}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostListBalances(e),i={info:t};for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"Currency"),a=this.safeCurrencyCode(r),o=this.safeFloat(s,"Deposited"),n=this.safeFloat(s,"Unconfirmed"),d=this.account();d.free=this.safeFloat(s,"Available"),d.total=this.sum(o,n),i[a]=d}return this.parseBalance(i)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={symbol:this.marketId(e)},r=await this.publicGetBookSymbol(this.extend(s,i));return this.parseOrderBook(r,void 0,"BuyOrders","SellOrders","Price","Amount")}parseTicker(e,t){const i=this.milliseconds();let s=void 0;t&&(s=t.symbol);const r=this.safeFloat(e,"Last");return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:void 0,low:void 0,bid:this.safeFloat(e,"Bid"),bidVolume:void 0,ask:this.safeFloat(e,"Ask"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:this.safeFloat(e,"Variation24Hr"),average:void 0,baseVolume:this.safeFloat(e,"Volume24Hr"),quoteVolume:void 0,info:e}}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetPrices(t),s=this.indexBy(i,"Market"),r=Object.keys(s),a={};for(let e=0;e<r.length;e++){const t=r[e];let i=t,o=void 0;t in this.markets_by_id&&(i=(o=this.markets_by_id[t]).symbol);const n=s[t];a[i]=this.parseTicker(n,o)}return a}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={symbol:i.id},r=await this.publicGetPriceSymbol(this.extend(s,t));return this.parseTicker(r,i)}parseTrade(e,t){const i=this.safeTimestamp(e,"At"),s=this.safeFloat(e,"Price"),r=this.safeFloat(e,"Amount");let a=void 0;void 0!==s&&void 0!==r&&(a=s*r);const o=this.safeString(e,"Type");let n=void 0;return void 0!==t&&(n=t.symbol),{info:e,timestamp:i,datetime:this.iso8601(i),symbol:n,id:void 0,order:void 0,type:void 0,side:o,price:s,takerOrMaker:void 0,amount:r,cost:a,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id},o=await this.publicGetTradesSymbol(this.extend(a,s));return this.parseTrades(o,r,t,i)}parseOrder(e,t){const i=this.safeString(e,"ListingCurrency"),s=this.safeString(e,"ReferenceCurrency"),r=this.safeCurrencyCode(i)+"/"+this.safeCurrencyCode(s),a=this.safeFloat(e,"LimitPrice"),o=this.safeFloat(e,"OriginalAmount"),n=this.safeFloat(e,"Amount");let d=void 0,c=void 0;void 0!==o&&(c=a*o,void 0!==n&&(d=o-n));const h=this.safeStringLower(e,"Type");return{info:e,id:this.safeString(e,"Code"),timestamp:void 0,datetime:this.iso8601(void 0),lastTradeTimestamp:void 0,symbol:r,type:"limit",side:h,price:a,amount:o,cost:c,filled:d,remaining:n,status:"open",fee:void 0}}async fetchOpenOrders(e,t,i,s={}){await this.loadMarkets();let r=void 0;void 0!==e&&(r=this.market(e));const a=await this.privatePostListOrders(s);return this.parseOrders(a,r,t,i)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o=this.market(e),n={listingCurrency:o.base,referenceCurrency:o.quote,type:i,amount:s};"limit"===t&&(n.limitPrice=r);const d=await this.privatePostPlaceOrder(this.extend(n,a));return{info:d,id:d.toString()}}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={orderCode:e};return await this.privatePostCancelOrder(this.extend(s,i))}async createDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},s=await this.privatePostGeneratenewaddress(this.extend(i,t)),r=s.split("|"),a=r.length,o=r[0];this.checkAddress(o);let n=void 0;return a>1&&(n=r[1]),{currency:e,address:o,tag:n,info:s}}async withdraw(e,t,i,s,r={}){this.checkAddress(i),await this.loadMarkets();const a={currency:this.currency(e).id,address:i,amount:t};return void 0!==s&&(a.address=i+"|"+s),{info:await this.privatePostWithdraw(this.extend(a,r)),id:void 0}}sign(e,t="public",i="GET",s={},r,a){const o=this.urls.api+"/"+this.implodeParams(e,s);let n=this.omit(s,this.extractParams(e));if("private"===t){this.checkRequiredCredentials();const e=this.nonce();n=this.extend({key:this.apiKey,nonce:e},n),a=this.json(n),r={"Content-Type":"application/json",Hash:this.hmac(this.encode(a),this.encode(this.secret),"sha512")}}return{url:o,method:i,body:a,headers:r}}}},function(e,t,i){"use strict";const s=i(1),{InvalidNonce:r,AuthenticationError:a,AccountSuspended:o,InsufficientFunds:n,ExchangeError:d,ArgumentsRequired:c,NotSupported:h}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"stronghold",name:"Stronghold",country:["US"],rateLimit:1e3,version:"v1",comment:"This comment is optional",urls:{logo:"https://user-images.githubusercontent.com/1294454/52160042-98c1f300-26be-11e9-90dd-da8473944c83.jpg",api:{public:"https://api.stronghold.co",private:"https://api.stronghold.co"},www:"https://stronghold.co",doc:["https://docs.stronghold.co"]},requiredCredentials:{apiKey:!0,secret:!0,password:!0},has:{fetchMarkets:!0,fetchCurrencies:!0,fetchOrderBook:!0,fetchOpenOrders:!0,fetchTime:!0,fetchTrades:!0,fetchMyTrades:!0,fetchDepositAddress:!1,createDepositAddress:!0,withdraw:!0,fetchTicker:!1,fetchTickers:!1,fetchAccounts:!0,fetchTransactions:!0},api:{public:{get:["utilities/time","utilities/uuid","venues","venues/{venueId}/assets","venues/{venueId}/markets","venues/{venueId}/markets/{marketId}/orderbook","venues/{venueId}/markets/{marketId}/trades"],post:["venues/{venueId}/assets","iam/credentials","identities"],patch:["identities"],put:["iam/credentials/{credentialId}"],delete:["iam/credentials/{credentialId}"]},private:{get:["venues","venues/{venueId}/accounts","venues/{venueId}/accounts/{accountId}","venues/{venueId}/accounts/{accountId}/payments/{paymentId}","venues/{venueId}/accounts/{accountId}/orders","venues/{venueId}/accounts/{accountId}/trades","venues/{venueId}/accounts/{accountId}/transactions"],post:["venues/{venueId}/accounts","venues/{venueId}/accounts/{accountId}/orders","venues/{venueId}/accounts/{accountId}/deposit","venues/{venueId}/accounts/{accountId}/withdrawal","venues/{venueId}/accounts/{accountId}/payments","venues/{venueId}/accounts/{accountId}/payments/{paymentId}/stop","venues/{venueId}/custody/accounts/{accountId}/operations/{operationId}/signatures","venues/{venueId}/anchor/withdrawal","venues/{venueId}/testing/friendbot"],delete:["venues/{venueId}/accounts/{accountId}/orders/{orderId}"]}},options:{accountId:void 0,venueId:"trade-public",venues:{trade:"trade-public",sandbox:"sandbox-public"},paymentMethods:{ETH:"ethereum",BTC:"bitcoin",XLM:"stellar",XRP:"ripple",LTC:"litecoin",SHX:"stellar"}},exceptions:{CREDENTIAL_MISSING:a,CREDENTIAL_INVALID:a,CREDENTIAL_REVOKED:o,CREDENTIAL_NO_IDENTITY:a,PASSPHRASE_INVALID:a,SIGNATURE_INVALID:a,TIME_INVALID:r,BYPASS_INVALID:a,INSUFFICIENT_FUNDS:n}})}async getActiveAccount(){if(void 0!==this.options.accountId)return this.options.accountId;if(await this.loadAccounts(),this.accounts.length>0)return this.accounts[0].id;throw new d(this.id+" requires an accountId.")}async fetchAccounts(e={}){const t={venueId:this.options.venueId};return(await this.privateGetVenuesVenueIdAccounts(this.extend(t,e))).result}async fetchTime(e={}){const t=await this.publicGetUtilitiesTime(e);return this.parse8601(this.safeString(t.result,"timestamp"))}async fetchMarkets(e={}){const t={venueId:this.options.venueId},i=(await this.publicGetVenuesVenueIdMarkets(this.extend(t,e))).result,s={};for(let e=0;e<i.length;e++){const t=i[e],r=t.id,a=this.safeString(t,"baseAssetId"),o=this.safeString(t,"counterAssetId"),n=a.split("/")[0],d=o.split("/")[0],c=this.safeCurrencyCode(n),h=this.safeCurrencyCode(d),l=c+"/"+h,u={amount:{min:this.safeFloat(t,"minimumOrderSize"),max:void 0}},f={price:this.safeInteger(t,"displayDecimalsPrice"),amount:this.safeInteger(t,"displayDecimalsAmount")};s[l]={symbol:l,id:r,base:c,quote:h,baseId:a,quoteId:o,precision:f,info:t,limits:u}}return s}async fetchCurrencies(e={}){const t={venueId:this.options.venueId},i=(await this.publicGetVenuesVenueIdAssets(this.extend(t,e))).result,s={},r={amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}};for(let e=0;e<i.length;e++){const t=i[e],a=this.safeString(t,"id"),o=this.safeString(t,"code"),n=this.safeCurrencyCode(o),d=this.safeInteger(t,"displayDecimalsFull");s[n]={code:n,id:a,precision:d,info:t,active:void 0,name:void 0,limits:r}}return s}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={marketId:this.marketId(e),venueId:this.options.venueId},r=await this.publicGetVenuesVenueIdMarketsMarketIdOrderbook(this.extend(s,i)),a=r.result,o=this.parse8601(this.safeString(r,"timestamp"));return this.parseOrderBook(a,o)}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={marketId:r.id,venueId:this.options.venueId},o=await this.publicGetVenuesVenueIdMarketsMarketIdTrades(this.extend(a,s));return this.parseTrades(o.result.trades,r,t,i)}parseTrade(e,t){let i=void 0,s=void 0,r=void 0,a=void 0,o=void 0,n=void 0,d=void 0,c=void 0;if(Array.isArray(e))r=parseFloat(e[0]),a=parseFloat(e[1]),n=e[2],d=this.parse8601(e[3]);else{i=this.safeString(e,"id"),r=this.safeFloat(e,"price"),a=this.safeFloat(e,"size"),n=this.safeString(e,"side"),d=this.parse8601(this.safeString(e,"executedAt")),c=this.safeString(e,"orderId");const o=this.safeString(e,"marketId");t=this.safeValue(this.markets_by_id,o),s=this.safeValue(e,"maker")?"maker":"taker"}void 0!==a&&void 0!==r&&(o=a*r);let h=void 0;return void 0!==t&&(h=t.symbol),{id:i,info:e,timestamp:d,datetime:this.iso8601(d),symbol:h,type:void 0,order:c,side:n,price:r,amount:a,cost:o,takerOrMaker:s,fee:{cost:void 0,currency:void 0,rate:void 0}}}async fetchTransactions(e,t,i,s={}){await this.loadMarkets();const r=this.extend({venueId:this.options.venueId,accountId:await this.getActiveAccount()},s);if(!r.accountId)throw new c(this.id+" fetchTransactions requires either the 'accountId' extra parameter or exchange.options['accountId'] = 'YOUR_ACCOUNT_ID'.");const a=await this.privateGetVenuesVenueIdAccountsAccountIdTransactions(r);let o=void 0;return void 0!==e&&(o=this.currency(e)),this.parseTransactions(a.result,o,t,i)}parseTransactionStatus(e){return this.safeString({queued:"pending",settling:"pending"},e,e)}parseTransaction(e,t){const i=this.safeString(e,"id"),s=this.safeString(e,"assetId");let r=void 0;if(void 0!==s){const e=s.split("/")[0];r=this.safeCurrencyCode(e)}else void 0!==t&&(r=t.code);const a=this.safeFloat(e,"amount"),o=this.parseTransactionStatus(this.safeString(e,"status")),n=this.safeFloat(e,"feeAmount");let d=void 0;void 0!==n&&(d=n/a);const c=this.safeString(e,"direction"),h=this.safeString(e,"requestedAt"),l=this.parse8601(h);return{id:i,info:e,currency:r,amount:a,status:o,fee:{cost:n,rate:d},tag:void 0,type:"outgoing"===c||"withdrawal"===c?"withdrawal":"deposit",updated:this.parse8601(this.safeString(e,"updatedAt")),address:void 0,txid:void 0,timestamp:l,datetime:h}}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o=this.market(e),n=this.extend({venueId:this.options.venueId,accountId:await this.getActiveAccount(),marketID:o.id,type:t,side:i,size:this.amountToPrecision(e,s),price:this.priceToPrecision(e,r)},a);if(!n.accountId)throw new c(this.id+" createOrder requires either the 'accountId' extra parameter or exchange.options['accountId'] = 'YOUR_ACCOUNT_ID'.");const d=await this.privatePostVenuesVenueIdAccountsAccountIdOrders(n);return this.parseOrder(d,o)}async cancelOrder(e,t,i={}){const s=this.extend({venueId:this.options.venueId,accountId:await this.getActiveAccount(),orderId:e},i);if(!s.accountId)throw new c(this.id+" cancelOrder requires either the 'accountId' extra parameter or exchange.options['accountId'] = 'YOUR_ACCOUNT_ID'.");const r=await this.privateDeleteVenuesVenueIdAccountsAccountIdOrdersOrderId(s);return this.parseOrder(r)}async fetchOpenOrders(e,t,i,s={}){await this.loadMarkets();let r=void 0;void 0!==e&&(r=this.market(e));const a=this.extend({venueId:this.options.venueId,accountId:await this.getActiveAccount()},s);if(!a.accountId)throw new c(this.id+" cancelOrder requires either the 'accountId' extra parameter or exchange.options['accountId'] = 'YOUR_ACCOUNT_ID'.");const o=await this.privateGetVenuesVenueIdAccountsAccountIdOrders(a);return this.parseOrders(o.result,r,t,i)}parseOrder(e,t){const i=this.safeString(e,"marketId");void 0!==i&&(t=this.safeValue(this.marketsById,i));let s=void 0;void 0!==t&&(s=t.symbol);const r=this.safeString(e,"id"),a=this.safeString(e,"placedAt"),o=this.safeFloat(e,"size"),n=this.safeFloat(e,"price"),d=this.safeFloat(e,"sizeFilled");let c=void 0,h=void 0;return void 0!==o&&(void 0!==d&&(h=o-d),void 0!==n&&(c=o*n)),{id:r,info:e,symbol:s,datetime:a,timestamp:this.parse8601(a),side:this.safeString(e,"side"),amount:o,filled:d,remaining:h,price:n,cost:c,trades:[],lastTradeTimestamp:void 0,status:void 0,type:void 0,average:void 0}}nonce(){return this.seconds()}setSandboxMode(e){this.options.venueId=e?this.options.venues.sandbox:this.options.venues.trade}async fetchBalance(e={}){const t=this.extend({venueId:this.options.venueId,accountId:await this.getActiveAccount()},e);if(!("accountId"in t))throw new c(this.id+" fetchBalance requires either the 'accountId' extra parameter or exchange.options['accountId'] = 'YOUR_ACCOUNT_ID'.");const i=await this.privateGetVenuesVenueIdAccountsAccountId(t),s=this.safeValue(i.result,"balances"),r={info:i};for(let e=0;e<s.length;e++){const t=s[e],i=this.safeString(t,"assetId");if(void 0!==i){const e=i.split("/")[0],s=this.safeCurrencyCode(e),a={};a.total=this.safeFloat(t,"amount"),a.free=this.safeFloat(t,"availableForTrade"),r[s]=a}}return this.parseBalance(r)}async fetchMyTrades(e,t,i,s={}){await this.loadMarkets();const r=this.extend({venueId:this.options.venueId,accountId:await this.getActiveAccount()},s);if(!r.accountId)throw new c(this.id+" fetchMyTrades requires either the 'accountId' extra parameter or exchange.options['accountId'] = 'YOUR_ACCOUNT_ID'.");const a=await this.privateGetVenuesVenueIdAccountsAccountIdTrades(r);let o=void 0;return void 0!==e&&(o=this.market(e)),this.parseTrades(a.result,o,t,i)}async createDepositAddress(e,t={}){await this.loadMarkets();const i=this.safeString(this.options.paymentMethods,e);if(void 0===i)throw new h(this.id+" createDepositAddress requires code to be BTC, ETH, or XLM");const s=this.extend({venueId:this.options.venueId,accountId:await this.getActiveAccount(),assetId:this.currencyId(e),paymentMethod:i},t);if(!s.accountId)throw new c(this.id+" createDepositAddress requires either the 'accountId' extra parameter or exchange.options['accountId'] = 'YOUR_ACCOUNT_ID'.");const r=await this.privatePostVenuesVenueIdAccountsAccountIdDeposit(s),a=r.result.paymentMethodInstructions,o=a.deposit_address,n=this.safeString(a,"reference");return{currency:e,address:this.checkAddress(o),tag:n,info:r}}async withdraw(e,t,i,s,r={}){await this.loadMarkets();const a=this.safeString(this.options.paymentMethods,e);if(void 0===a)throw new h(this.id+" withdraw requires code to be BTC, ETH, or XLM");const o=this.extend({venueId:this.options.venueId,accountId:await this.getActiveAccount(),assetId:this.currencyId(e),amount:t,paymentMethod:a,paymentMethodDetails:{withdrawal_address:i}},r);if(void 0!==s&&(o.paymentMethodDetails.reference=s),!o.accountId)throw new c(this.id+" withdraw requires either the 'accountId' extra parameter or exchange.options['accountId'] = 'YOUR_ACCOUNT_ID'.");const n=await this.privatePostVenuesVenueIdAccountsAccountIdWithdrawal(o),d=n.result;return{id:this.safeString(d,"id"),info:n}}handleErrors(e,t,i,s,r,a,o,n,c){if(!o)return;const h=this.safeString(o,"errorCode");if(h in this.exceptions){throw new(0,this.exceptions[h])(this.id+" "+a)}if(!this.safeValue(o,"success"))throw new d(this.id+" "+a)}sign(e,t="public",i="GET",s={},r,a){const o="/"+this.version+"/"+this.implodeParams(e,s),n=this.omit(s,this.extractParams(e));let d=this.urls.api[t]+o;if(Object.keys(n).length&&("GET"===i?d+="?"+this.urlencode(n):a=this.json(n)),"private"===t){this.checkRequiredCredentials();const e=this.nonce().toString();let t=e+i+o;void 0!==a&&(t+=a);const s=this.base64ToBinary(this.secret);r={"SH-CRED-ID":this.apiKey,"SH-CRED-SIG":this.hmac(this.encode(t),s,"sha256","base64"),"SH-CRED-TIME":e,"SH-CRED-PASS":this.password,"Content-Type":"application/json"}}return{url:d,method:i,body:a,headers:r}}}},function(e,t,i){"use strict";const s=i(9);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"surbitcoin",name:"SurBitcoin",countries:["VE"],has:{CORS:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/27991511-f0a50194-6481-11e7-99b5-8f02932424cc.jpg",api:{public:"https://api.blinktrade.com/api",private:"https://api.blinktrade.com/tapi"},www:"https://surbitcoin.com",doc:"https://blinktrade.com/docs"},options:{brokerId:"1"}})}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,ExchangeNotAvailable:a,ArgumentsRequired:o,BadRequest:n,AuthenticationError:d,InvalidOrder:c,OrderNotFound:h,NotSupported:l,OrderNotFillable:u,InvalidAddress:f,InsufficientFunds:p}=i(0);e.exports=class extends s{describe(){return this.checkRequiredDependencies(),this.deepExtend(super.describe(),{id:"theocean",name:"The Ocean",countries:["US"],rateLimit:3e3,version:"v1",requiresWeb3:!0,timeframes:{"5m":"300","15m":"900","1h":"3600","6h":"21600","1d":"86400"},has:{cancelAllOrders:!0,CORS:!1,fetchClosedOrders:!0,fetchOHLCV:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrders:!0,fetchTickers:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/43103756-d56613ce-8ed7-11e8-924e-68f9d4bcacab.jpg",api:"https://api.theocean.trade",www:"https://theocean.trade",doc:"https://docs.theocean.trade",fees:"https://theocean.trade/fees"},api:{public:{get:["fee_components","token_pairs","ticker","tickers","candlesticks","candlesticks/intervals","trade_history","order_book","order/{orderHash}","version"]},private:{get:["balance","available_balance","order_history","order/unsigned","order/unsigned/market"],post:["order"],delete:["order/{orderHash}","order"]}},exceptions:{exact:{"Order not found":h},broad:{"Price can't exceed 8 digits in precision.":c,"Order cannot be canceled":c,"Greater than available wallet balance.":p,"Fillable amount under minimum":c,"Fillable amount over maximum":c,"Schema validation failed for 'params'":n,"Service Temporarily Unavailable":a}},options:{decimals:{},fetchOrderMethod:"fetch_order_from_history"}})}async fetchMarkets(e={}){const t=await this.publicGetTokenPairs(e),i=[];for(let e=0;e<t.length;e++){const s=t[e],r=this.safeValue(s,"baseToken",{}),a=this.safeValue(s,"quoteToken",{}),o=this.safeString(r,"address"),n=this.safeString(a,"address"),d=this.safeCurrencyCode(this.safeString(r,"symbol")),c=this.safeCurrencyCode(this.safeString(a,"symbol")),h=d+"/"+c,l=o+"/"+n,u=this.safeInteger(r,"decimals"),f=this.safeInteger(a,"decimals");this.options.decimals[d]=u,this.options.decimals[c]=f;const p={amount:-parseInt(r.precision),price:-parseInt(a.precision)},m={amount:{min:this.fromWei(this.safeString(r,"minAmount"),"ether",u),max:this.fromWei(this.safeString(r,"maxAmount"),"ether",u)},price:{min:void 0,max:void 0},cost:{min:this.fromWei(this.safeString(a,"minAmount"),"ether",f),max:this.fromWei(this.safeString(a,"maxAmount"),"ether",f)}},y=!0;i.push({id:l,symbol:h,base:d,quote:c,baseId:o,quoteId:n,active:y,precision:p,limits:m,info:s})}return i}parseOHLCV(e,t,i="5m",s,r){const a=this.safeInteger(this.options.decimals,t.base,18);return[this.safeTimestamp(e,"startTime"),this.safeFloat(e,"open"),this.safeFloat(e,"high"),this.safeFloat(e,"low"),this.safeFloat(e,"close"),this.fromWei(this.safeString(e,"baseVolume"),"ether",a)]}async fetchOHLCV(e,t="5m",i,s,a={}){await this.loadMarkets();const o=this.market(e),n={baseTokenAddress:o.baseId,quoteTokenAddress:o.quoteId,interval:this.timeframes[t]};if(void 0===i)throw new r(this.id+" fetchOHLCV requires a since argument");i=parseInt(i),n.startTime=i;const d=await this.publicGetCandlesticks(this.extend(n,a));return this.parseOHLCVs(d,o,t,i,s)}async fetchBalanceByCode(e,t={}){if(!this.walletAddress||0!==this.walletAddress.indexOf("0x"))throw new f(this.id+' fetchBalanceByCode() requires the .walletAddress to be a "0x"-prefixed hexstring like "0xbF2d65B3b2907214EEA3562f21B80f6Ed7220377"');await this.loadMarkets();const i=this.currency(e),s={walletAddress:this.walletAddress.toLowerCase(),tokenAddress:i.id},r=await this.privateGetBalance(this.extend(s,t)),a=this.safeInteger(this.options.decimals,e,18);return{free:this.fromWei(this.safeString(r,"available"),"ether",a),used:this.fromWei(this.safeString(r,"committed"),"ether",a),total:this.fromWei(this.safeString(r,"total"),"ether",a)}}async fetchBalance(e={}){if(!this.walletAddress||0!==this.walletAddress.indexOf("0x"))throw new f(this.id+' fetchBalance() requires the .walletAddress to be a "0x"-prefixed hexstring like "0xbF2d65B3b2907214EEA3562f21B80f6Ed7220377"');let t=this.safeValue(this.options,"fetchBalanceCurrencies");if(void 0===t&&(t=this.safeValue(e,"codes")),void 0===t||!Array.isArray(t))throw new r(this.id+" fetchBalance() requires a `codes` parameter (an array of currency codes)");await this.loadMarkets();const i={};for(let e=0;e<t.length;e++){const s=t[e];i[s]=await this.fetchBalanceByCode(s)}return this.parseBalance(i)}parseBidAsk(e,t=0,i=1,s){if(void 0===s)throw new o(this.id+" parseBidAsk requires a market argument");const r=parseFloat(e[t]),a=this.safeInteger(this.options.decimals,s.base,18);return[r,this.fromWei(e[i],"ether",a)]}parseOrderBook(e,t,i="bids",s="asks",r=0,a=1,o){const n={timestamp:t,datetime:this.iso8601(t),nonce:void 0},d=[i,s];for(let t=0;t<d.length;t++){const i=d[t],s=[],c=this.safeValue(e,i);for(let e=0;e<c.length;e++)s.push(this.parseBidAsk(c[e],r,a,o));n[i]=s}return n[i]=this.sortBy(n[i],0,!0),n[s]=this.sortBy(n[s],0),n}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s=this.market(e),r={baseTokenAddress:s.baseId,quoteTokenAddress:s.quoteId};void 0!==t&&(r.depth=t);const a=await this.publicGetOrderBook(this.extend(r,i));return this.parseOrderBook(a,void 0,"bids","asks","price","availableAmount",s)}parseTicker(e,t){const i=parseInt(this.safeInteger(e,"timestamp")/1e3);let s=void 0,r=void 0;void 0!==t&&(s=t.symbol,r=t.base);const a=this.safeInteger(this.options.decimals,r,18),o=this.fromWei(this.safeString(e,"volume"),"ether",a),n=this.safeFloat(e,"last");return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:void 0,low:void 0,bid:this.safeFloat(e,"bid"),bidVolume:void 0,ask:this.safeFloat(e,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:n,last:n,previousClose:void 0,change:void 0,percentage:this.safeFloat(e,"priceChange"),average:void 0,baseVolume:o,quoteVolume:void 0,info:e}}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetTickers(t),s={};for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"baseTokenAddress")+"/"+this.safeString(t,"quoteTokenAddress");let a=void 0,o=r;r in this.markets_by_id&&(o=(a=this.markets_by_id[r]).symbol),s[o]=this.parseTicker(t.ticker,a)}return s}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={baseTokenAddress:i.baseId,quoteTokenAddress:i.quoteId},r=await this.publicGetTicker(this.extend(s,t));return this.parseTicker(r,i)}parseTrade(e,t){let i=this.safeInteger(e,"lastUpdated");void 0!==i&&(i/=1e3);const s=this.safeFloat(e,"price"),r=this.safeString(e,"id"),a=this.safeString(e,"side");let o=void 0,n=void 0;void 0!==t&&(o=t.symbol,n=t.base);const d=this.safeInteger(this.options.decimals,n,18),c=this.fromWei(this.safeString(e,"amount"),"ether",d);let h=void 0;void 0!==c&&void 0!==s&&(h=c*s);return{id:r,order:r,timestamp:i,datetime:this.iso8601(i),symbol:o,type:void 0,side:a,takerOrMaker:"taker",price:s,amount:c,cost:h,fee:void 0,info:e}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={baseTokenAddress:r.baseId,quoteTokenAddress:r.quoteId},o=await this.publicGetTradeHistory(this.extend(a,s));return this.parseTrades(o,r,t,i)}async createOrder(e,t,i,s,r,a={}){const o=this.id+' createOrder() requires `exchange.walletAddress` and `exchange.privateKey`. The .walletAddress should be a "0x"-prefixed hexstring like "0xbF2d65B3b2907214EEA3562f21B80f6Ed7220377". The .privateKey for that wallet should be a "0x"-prefixed hexstring like "0xe4f40d465efa94c98aec1a51f574329344c772c1bce33be07fa20a56795fdd09".';if(!this.walletAddress||0!==this.walletAddress.indexOf("0x"))throw new f(o);if(!this.privateKey||0!==this.privateKey.indexOf("0x"))throw new f(o);const n=await this.fetchOrderParamsToSign(e,t,i,s,r,a),d=n.unsignedZeroExOrder;if(void 0===d)throw new u(this.id+" "+t+" order to "+i+" "+e+" is not fillable at the moment");const c=await this.signZeroExOrderV2(d,this.privateKey),h=this.safeString(c,"orderHash");await this.postSignedOrder(c,n,a);const l=await this.fetchOrder(h);return l.type=t,l}async fetchOrderParamsToSign(e,t,i,s,a,o={}){if("buy"!==i&&"sell"!==i)throw new r(i+" is not valid side param. Use 'buy' or 'sell'");if("market"!==t&&"limit"!==t)throw new r(t+" is not valid type param. Use 'market' or 'limit'");if("limit"===t&&void 0===a)throw new r("Price is not provided for limit order");await this.loadMarkets();const n=this.market(e),d=this.safeInteger(this.options.decimals,n.base,18),c={walletAddress:this.walletAddress.toLowerCase(),baseTokenAddress:n.baseId,quoteTokenAddress:n.quoteId,side:i,amount:this.toWei(this.amountToPrecision(e,s),"ether",d)};let h=void 0;if("limit"===t)h="privateGetOrderUnsigned",c.price=this.priceToPrecision(e,a);else{if("market"!==t)throw new r("Unsupported order type: "+t);h="privateGetOrderUnsignedMarket"}return await this[h](this.extend(c,o))}async postSignedOrder(e,t,i={}){let s=t;return s.signedZeroExOrder=e,s=this.omit(s,"unsignedZeroExOrder"),await this.privatePostOrder(this.extend(s,i))}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={orderHash:e},r=await this.privateDeleteOrderOrderHash(this.extend(s,i));let a=void 0;return void 0!==t&&(a=this.market(t)),this.extend(this.parseOrder(r.canceledOrder,a),{status:"canceled"})}async cancelAllOrders(e,t={}){return await this.privateDeleteOrder(t)}parseOrder(e,t){const i=this.safeValue(e,"zeroExOrder");let s=this.safeString(e,"orderHash");void 0===s&&void 0!==i&&(s=this.safeString(i,"orderHash"));const r=this.safeString(e,"side"),a=this.safeString(e,"type");let o=this.safeInteger(e,"creationTimestamp");"undefined"!==o&&(o=parseInt(o/1e3));let n=void 0;const d=this.safeString(e,"baseTokenAddress"),c=this.safeString(e,"quoteTokenAddress");let h=void 0;void 0!==d&&void 0!==c&&(h=d+"/"+c);let u=void 0;void 0!==(t=this.safeValue(this.markets_by_id,h,t))&&(n=t.symbol,u=t.base);const f=this.safeInteger(this.options.decimals,u,18),p=this.safeFloat(e,"price"),m=this.fromWei(this.safeString(e,"filledAmount"),"ether",f),y=this.fromWei(this.safeString(e,"settledAmount"),"ether",f),b=this.fromWei(this.safeString(e,"confirmedAmount"),"ether",f),v=this.fromWei(this.safeString(e,"failedAmount"),"ether",f),g=this.fromWei(this.safeString(e,"deadAmount"),"ether",f),w=this.fromWei(this.safeString(e,"prunedAmount"),"ether",f),k=this.fromWei(this.safeString(e,"initialAmount"),"ether",f),T=this.sum(m,y,b);let O=void 0,_=void 0;const C=this.safeValue(e,"timeline");let S=void 0,x=void 0;if(void 0!==C){if(C.length>0){const e=this.groupBy(C,"action");if("error"in e&&(x="failed"),"filled"in e){const i=this.safeValue(e,"filled"),o=i.length;_=_=this.safeInteger(i[o-1],"timestamp"),S=[];for(let e=0;e<o;e++){const o=this.parseTrade(this.extend(i[e],{price:p}),t);S.push(this.extend(o,{order:s,type:a,side:r}))}}}}let M=void 0;void 0!==T&&(void 0===O&&void 0!==k&&(O=k-T),void 0!==p&&(M=T*p));let I=void 0;const F=this.safeString(e,"feeAmount");if(void 0!==F){const i=this.safeString(e,"feeOption");let s=void 0;if("feeInNative"===i)void 0!==t&&(s=t.base);else{if("feeInZRX"!==i)throw new l(this.id+" encountered an unsupported order fee option: "+i);s="ZRX"}const r=this.safeInteger(this.options.decimals,s,18);I={cost:this.fromWei(F,"ether",r),currency:s}}const B=t?t.precision.amount:8;if(void 0!==O&&void 0===x){x="open",O-v-g-w<Math.pow(10,-B)&&(x=T<k?"canceled":"closed")}return{info:e,id:s,symbol:n,timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:_,type:a,side:r,price:p,cost:M,amount:k,remaining:O,filled:T,status:x,fee:I,trades:S}}async fetchOpenOrder(e,t,i={}){const s=this.options.fetchOrderMethod;return await this[s](e,t,this.extend({openAmount:1},i))}async fetchClosedOrder(e,t,i={}){const s=this.options.fetchOrderMethod;return await this[s](e,t,this.extend(i))}async fetchOrderFromHistory(e,t,i={}){const s={orderHash:e},r=await this.fetchOrders(t,void 0,void 0,this.extend(s,i)),a=this.indexBy(r,"id");if(e in a)return a[e];throw new h(this.id+" could not find order "+e+" in order history")}async fetchOrderById(e,t,i={}){await this.loadMarkets();const s={orderHash:e},r=await this.publicGetOrderOrderHash(this.extend(s,i));return this.parseOrder(r)}async fetchOrder(e,t,i={}){const s={orderHash:e},r=await this.fetchOrders(t,void 0,void 0,this.extend(s,i));if(1!==r.length)throw new h(this.id+" order "+e+" not found");return r[0]}async fetchOrders(e,t,i,s={}){await this.loadMarkets();const r={};let a=void 0;void 0!==e&&(a=this.market(e),r.baseTokenAddress=a.baseId,r.quoteTokenAddress=a.quoteId),void 0!==i&&(r.limit=i);const o=await this.privateGetOrderHistory(this.extend(r,s));return this.parseOrders(o,void 0,t,i)}async fetchOpenOrders(e,t,i,s={}){return await this.fetchOrders(e,t,i,this.extend({openAmount:1},s))}async fetchClosedOrders(e,t,i,s={}){return await this.fetchOrders(e,t,i,this.extend({openAmount:0},s))}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api+"/"+this.version+"/"+this.implodeParams(e,s);const n=this.omit(s,this.extractParams(e));if("private"===t){this.checkRequiredCredentials();const e=this.seconds().toString();let t=this.apiKey+e+i;"POST"===i?t+=a=this.json(n):(Object.keys(n).length&&(o+="?"+this.urlencode(n)),t+=this.json({}));const s=this.hmac(this.encode(t),this.encode(this.secret),"sha256","base64");r={"TOX-ACCESS-KEY":this.apiKey,"TOX-ACCESS-SIGN":s,"TOX-ACCESS-TIMESTAMP":e,"Content-Type":"application/json"}}else"public"===t&&Object.keys(n).length&&(o+="?"+this.urlencode(n));return{url:o,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,o,n,c,h){if(void 0!==n){if("'Authentication failed'"===o)throw new d(this.id+" "+o);if("{"===o[0]||"["===o[0]){const e=this.safeString(n,"message");if(void 0!==e){const t=this.id+" "+this.json(n),i=this.exceptions.exact;if(e in i)throw new i[e](t);const s=this.exceptions.broad,a=this.findBroadlyMatchedKey(s,o);if(void 0!==a)throw new s[a](t);throw new r(t)}}}}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,ArgumentsRequired:a,BadRequest:o,OrderNotFound:n,InvalidAddress:d}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"therock",name:"TheRockTrading",countries:["MT"],rateLimit:1e3,version:"v1",has:{CORS:!1,fetchTickers:!0,fetchMyTrades:!0,fetchLedger:!0,fetchDeposits:!0,fetchWithdrawals:!0,fetchTransactions:"emulated",fetchOrders:!0,fetchOpenOrders:!0,fetchClosedOrders:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766869-75057fa2-5ee9-11e7-9a6f-13e641fa4707.jpg",api:"https://api.therocktrading.com",www:"https://therocktrading.com",doc:["https://api.therocktrading.com/doc/v1/index.html","https://api.therocktrading.com/doc/"]},api:{public:{get:["funds","funds/{id}/orderbook","funds/{id}/ticker","funds/{id}/trades","funds/tickers"]},private:{get:["balances","balances/{id}","discounts","discounts/{id}","funds","funds/{id}","funds/{id}/trades","funds/{fund_id}/orders","funds/{fund_id}/orders/{id}","funds/{fund_id}/position_balances","funds/{fund_id}/positions","funds/{fund_id}/positions/{id}","transactions","transactions/{id}","withdraw_limits/{id}","withdraw_limits"],post:["atms/withdraw","funds/{fund_id}/orders"],delete:["funds/{fund_id}/orders/{id}","funds/{fund_id}/orders/remove_all"]}},fees:{trading:{maker:.002,taker:.002},funding:{tierBased:!1,percentage:!1,withdraw:{BTC:5e-4,BCH:5e-4,PPC:.02,ETH:.001,ZEC:.001,LTC:.002,EUR:2.5},deposit:{BTC:0,BCH:0,PPC:0,ETH:0,ZEC:0,LTC:0,EUR:0}}},exceptions:{exact:{"Request already running":o,"cannot specify multiple address types":o,"Currency is not included in the list":o,"Record not found":n},broad:{"before must be greater than after param":o,"must be shorter than 60 days":o,"must be a multiple of (period param) in minutes":o,"Address allocation limit reached for currency":d,"is not a valid value for param currency":o," is invalid":d}}})}async fetchMarkets(e={}){const t=await this.publicGetFunds(e),i=this.safeValue(t,"funds"),s=[];if(void 0===i)throw new r(this.id+" fetchMarkets got an unexpected response");for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"id"),a=this.safeString(t,"trade_currency"),o=this.safeString(t,"base_currency"),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o),c=n+"/"+d,h=this.safeFloat(t,"buy_fee"),l=this.safeFloat(t,"sell_fee");let u=Math.max(h,l);const f=u/=100;s.push({id:r,symbol:c,base:n,quote:d,baseId:a,quoteId:o,info:t,active:!0,maker:f,taker:u,precision:{amount:this.safeInteger(t,"trade_currency_decimals"),price:this.safeInteger(t,"base_currency_decimals")},limits:{amount:{min:this.safeFloat(t,"minimum_quantity_offer"),max:void 0},price:{min:this.safeFloat(t,"minimum_price_offer"),max:void 0},cost:{min:void 0,max:void 0}}})}return s}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalances(e),i=this.safeValue(t,"balances",[]),s={info:t};for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeFloat(t,"trading_balance"),o.total=this.safeFloat(t,"balance"),s[a]=o}return this.parseBalance(s)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={id:this.marketId(e)},r=await this.publicGetFundsIdOrderbook(this.extend(s,i)),a=this.parse8601(this.safeString(r,"date"));return this.parseOrderBook(r,a,"bids","asks","price","amount")}parseTicker(e,t){const i=this.parse8601(e.date);let s=void 0;void 0!==t&&(s=t.symbol);const r=this.safeFloat(e,"last");return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"bid"),bidVolume:void 0,ask:this.safeFloat(e,"ask"),askVolume:void 0,vwap:void 0,open:this.safeFloat(e,"open"),close:r,last:r,previousClose:this.safeFloat(e,"close"),change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeFloat(e,"volume_traded"),quoteVolume:this.safeFloat(e,"volume"),info:e}}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetFundsTickers(t),s=this.indexBy(i.tickers,"fund_id"),r=Object.keys(s),a={};for(let e=0;e<r.length;e++){const t=r[e],i=this.markets_by_id[t],o=i.symbol,n=s[t];a[o]=this.parseTicker(n,i)}return a}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s=await this.publicGetFundsIdTicker(this.extend({id:i.id},t));return this.parseTicker(s,i)}parseTrade(e,t){t||(t=this.markets_by_id[e.fund_id]);const i=this.parse8601(this.safeString(e,"date")),s=this.safeString(e,"id"),r=this.safeString(e,"order_id"),a=this.safeString(e,"side"),o=this.safeFloat(e,"price"),n=this.safeFloat(e,"amount");let d=void 0;void 0!==o&&void 0!==n&&(d=o*n);let c=void 0,h=void 0;const l=this.safeValue(e,"transactions",[]),u=this.groupBy(l,"type"),f=this.safeValue(u,"paid_commission",[]);for(let e=0;e<f.length;e++)void 0===h&&(h=0),h=this.sum(h,this.safeFloat(f[e],"price"));void 0!==h&&(c={cost:h,currency:t.quote});let p=void 0;return void 0!==t&&(p=t.symbol),{info:e,id:s,order:r,timestamp:i,datetime:this.iso8601(i),symbol:p,type:void 0,side:a,takerOrMaker:void 0,price:o,amount:n,cost:d,fee:c}}parseLedgerEntryDirection(e){return this.safeString({affiliate_earnings:"in",atm_payment:"in",bought_currency_from_fund:"out",bought_shares:"out",paid_commission:"out",paypal_payment:"in",pos_payment:"in",released_currency_to_fund:"out",rollover_commission:"out",sold_currency_to_fund:"in",sold_shares:"in",transfer_received:"in",transfer_sent:"out",withdraw:"out"},e,e)}parseLedgerEntryType(e){return this.safeString({affiliate_earnings:"referral",atm_payment:"transaction",bought_currency_from_fund:"trade",bought_shares:"trade",paid_commission:"fee",paypal_payment:"transaction",pos_payment:"transaction",released_currency_to_fund:"trade",rollover_commission:"fee",sold_currency_to_fund:"trade",sold_shares:"trade",transfer_received:"transfer",transfer_sent:"transfer",withdraw:"transaction"},e,e)}parseLedgerEntry(e,t){const i=this.safeString(e,"id");let s=void 0,r=this.safeString(e,"type");const a=this.parseLedgerEntryDirection(r);"trade"!==(r=this.parseLedgerEntryType(r))&&"fee"!==r||(s=this.safeString(e,"trade_id"));const o=this.safeString(e,"currency"),n=this.safeCurrencyCode(o),d=this.safeFloat(e,"price"),c=this.parse8601(this.safeString(e,"date"));return{info:e,id:i,direction:a,account:void 0,referenceId:s,referenceAccount:void 0,type:r,currency:n,amount:d,before:void 0,after:void 0,status:"ok",timestamp:c,datetime:this.iso8601(c),fee:void 0}}async fetchLedger(e,t,i,s={}){await this.loadMarkets();const r={};let a=void 0;void 0!==e&&(a=this.currency(e),r.currency=a.id),void 0!==t&&(r.after=this.iso8601(t));const o=await this.privateGetTransactions(this.extend(r,s)),n=this.safeValue(o,"transactions",[]);return this.parseLedger(n,a,t,i)}parseTransactionType(e){return this.safeString({withdraw:"withdrawal",atm_payment:"deposit"},e,e)}parseTransaction(e,t){const i=this.safeString(e,"id"),s=this.parseTransactionType(this.safeString(e,"type")),r=this.safeValue(e,"transfer_detail",{}),a=this.safeString(r,"method");let o=void 0,n=void 0;void 0!==a&&"wire_transfer"!==a&&(o=this.safeString(r,"id"),n=this.safeString(r,"recipient"));const d=this.safeString(e,"currency"),c=this.safeCurrencyCode(d),h=this.safeFloat(e,"price"),l=this.parse8601(this.safeString(e,"date"));return{info:e,id:i,currency:c,amount:h,addressFrom:void 0,addressTo:n,address:n,tagFrom:void 0,tagTo:void 0,tag:void 0,status:"ok",type:s,updated:void 0,txid:o,timestamp:l,datetime:this.iso8601(l),fee:void 0}}async fetchWithdrawals(e,t,i,s={}){return await this.fetchTransactions(e,t,i,this.extend({type:"withdraw"},s))}async fetchDeposits(e,t,i,s={}){return await this.fetchTransactions(e,t,i,this.extend({type:"atm_payment"},s))}async fetchTransactions(e,t,i,s={}){await this.loadMarkets();const r={};let a=void 0;void 0!==e&&(a=this.currency(e),r.currency=a.id),void 0!==t&&(r.after=this.iso8601(t)),s=this.extend(r,s);const o=await this.privateGetTransactions(s),n=this.safeValue(o,"transactions",[]),d=this.filterByArray(n,"type",["withdraw","atm_payment"],!1);return this.parseTransactions(d,a,t,i)}parseOrderStatus(e){return this.safeString({active:"open",executed:"closed",deleted:"canceled"},e,e)}parseOrder(e,t){const i=this.safeString(e,"id");let s=void 0;const r=this.safeString(e,"fund_id");r in this.markets_by_id&&(s=(t=this.markets_by_id[r]).symbol);const a=this.parseOrderStatus(this.safeString(e,"status")),o=this.parse8601(this.safeString(e,"date")),n=this.safeString(e,"type"),d=this.safeString(e,"side"),c=this.safeFloat(e,"amount"),h=this.safeFloat(e,"amount_unfilled");let l=void 0;void 0!==c&&void 0!==h&&(l=c-h);const u=this.safeFloat(e,"price");let f=this.safeValue(e,"trades"),p=void 0,m=void 0,y=void 0;if(void 0!==f){const e=f.length;if(e>0){f=this.parseTrades(f,t,void 0,void 0,{orderId:i}),p=0,l=0;for(let t=0;t<e;t++){const e=f[t];p=this.sum(p,e.cost),l=this.sum(l,e.amount)}l>0&&(m=p/l),y=f[e-1].timestamp}else p=0}return{id:i,info:e,timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:y,status:a,symbol:s,type:n,side:d,price:u,cost:p,amount:c,filled:l,average:m,remaining:h,fee:void 0,trades:f}}async fetchOpenOrders(e,t,i,s={}){return await this.fetchOrders(e,t,i,this.extend({status:"active"},s))}async fetchClosedOrders(e,t,i,s={}){return await this.fetchOrders(e,t,i,this.extend({status:"executed"},s))}async fetchOrders(e,t,i,s={}){if(void 0===e)throw new a(this.id+" fetchOrders requires a symbol argument");await this.loadMarkets();const r=this.market(e),o={fund_id:r.id};void 0!==t&&(o.after=this.iso8601(t));const n=await this.privateGetFundsFundIdOrders(this.extend(o,s)),d=this.safeValue(n,"orders",[]);return this.parseOrders(d,r,t,i)}async fetchOrder(e,t,i={}){if(void 0===t)throw new a(this.id+" fetchOrder requires a symbol argument");await this.loadMarkets();const s={id:e,fund_id:this.market(t).id},r=await this.privatePostFundsFundIdOrdersId(this.extend(s,i));return this.parseOrder(r)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets(),"market"===t&&(r=0);const o={fund_id:this.marketId(e),side:i,amount:s,price:r},n=await this.privatePostFundsFundIdOrders(this.extend(o,a));return this.parseOrder(n)}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={id:e,fund_id:this.marketId(t)},r=await this.privateDeleteFundsFundIdOrdersId(this.extend(s,i));return this.parseOrder(r)}async fetchMyTrades(e,t,i,s={}){if(void 0===e)throw new a(this.id+" fetchMyTrades requires a symbol argument");await this.loadMarkets();const r=this.market(e),o={id:r.id};void 0!==i&&(o.per_page=i),void 0!==t&&(o.after=this.iso8601(t));const n=await this.privateGetFundsIdTrades(this.extend(o,s));return this.parseTrades(n.trades,r,t,i)}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={id:r.id};void 0!==i&&(a.per_page=i),void 0!==t&&(a.after=this.iso8601(t));const o=await this.publicGetFundsIdTrades(this.extend(a,s));return this.parseTrades(o.trades,r,t,i)}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api+"/"+this.version+"/"+this.implodeParams(e,s);const n=this.omit(s,this.extractParams(e));if(r=void 0===r?{}:r,"private"===t){if(this.checkRequiredCredentials(),Object.keys(n).length)if("POST"===i)a=this.json(n),r["Content-Type"]="application/json";else{const e=this.rawencode(n);e.length&&(o+="?"+e)}const e=this.nonce().toString(),t=e+o;r["X-TRT-KEY"]=this.apiKey,r["X-TRT-NONCE"]=e,r["X-TRT-SIGN"]=this.hmac(this.encode(t),this.encode(this.secret),"sha512")}else"public"===t&&Object.keys(n).length&&(o+="?"+this.rawencode(n));return{url:o,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,o,n,d,c){if(void 0===n)return;const h=this.safeValue(n,"errors",[]),l=h.length;if(l>0){const e=this.id+" "+o,t=this.exceptions.exact,i=this.exceptions.broad;for(let s=0;s<l;s++){const r=h[s],a=this.safeString(r,"message");if(a in t)throw new t[a](e);const o=this.findBroadlyMatchedKey(i,a);if(void 0!==o)throw new i[o](e)}throw new r(e)}}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,InsufficientFunds:a,OrderNotFound:o}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"tidebit",name:"TideBit",countries:["HK"],rateLimit:1e3,version:"v2",has:{fetchDepositAddress:!0,CORS:!0,fetchTickers:!0,fetchOHLCV:!0,withdraw:!0},timeframes:{"1m":"1","5m":"5","15m":"15","30m":"30","1h":"60","2h":"120","4h":"240","12h":"720","1d":"1440","3d":"4320","1w":"10080"},urls:{logo:"https://user-images.githubusercontent.com/1294454/39034921-e3acf016-4480-11e8-9945-a6086a1082fe.jpg",api:"https://www.tidebit.com",www:"https://www.tidebit.com",doc:["https://www.tidebit.com/documents/api/guide","https://www.tidebit.com/swagger/#/default"],referral:"http://bit.ly/2IX0LrM"},api:{public:{get:["markets","tickers","tickers/{market}","timestamp","trades","trades/{market}","order_book","order","k_with_pending_trades","k","depth"],post:[]},private:{get:["addresses/{address}","deposits/history","deposits/get_deposit","deposits/deposit_address","historys/orders","historys/vouchers","historys/accounts","historys/snapshots","linkage/get_status","members/me","order","orders","partners/orders/{id}/trades","referral_commissions/get_undeposited","referral_commissions/get_graph_data","trades/my","withdraws/bind_account_list","withdraws/get_withdraw_account","withdraws/fetch_bind_info"],post:["deposits/deposit_cash","favorite_markets/update","order/delete","orders","orders/multi","orders/clear","referral_commissions/deposit","withdraws/apply","withdraws/bind_bank","withdraws/bind_address"]}},fees:{trading:{tierBased:!1,percentage:!0,maker:.002,taker:.002},funding:{tierBased:!1,percentage:!0,withdraw:{}}},exceptions:{2002:a,2003:o}})}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},s=await this.privateGetDepositAddress(this.extend(i,t));if("success"in s&&s.success){const t=this.safeString(s,"address"),i=this.safeString(s,"addressTag");return{currency:e,address:this.checkAddress(t),tag:i,info:s}}}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),i=[];for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"id"),a=this.safeString(s,"name"),[o,n]=a.split("/"),d=this.safeCurrencyCode(o),c=this.safeCurrencyCode(n);i.push({id:r,symbol:a,base:d,quote:c,baseId:o,quoteId:n,info:s})}return i}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetMembersMe(e),i=this.safeValue(t,"accounts"),s={info:i};for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeFloat(t,"balance"),o.used=this.safeFloat(t,"locked"),s[a]=o}return this.parseBalance(s)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s=this.market(e),r={market:s.id};void 0!==t&&(r.limit=t),r.market=s.id;const a=await this.publicGetDepth(this.extend(r,i)),o=this.safeTimestamp(a,"timestamp");return this.parseOrderBook(a,o)}parseTicker(e,t){const i=this.safeTimestamp(e,"at");e=this.safeValue(e,"ticker",{});let s=void 0;void 0!==t&&(s=t.symbol);const r=this.safeFloat(e,"last");return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"buy"),ask:this.safeFloat(e,"sell"),bidVolume:void 0,askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,change:void 0,percentage:void 0,previousClose:void 0,average:void 0,baseVolume:this.safeFloat(e,"vol"),quoteVolume:void 0,info:e}}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetTickers(t),s=Object.keys(i),r={};for(let e=0;e<s.length;e++){const t=s[e];let a=void 0,o=t;if(t in this.markets_by_id)o=(a=this.markets_by_id[t]).symbol;else{const e=t.slice(0,3),i=t.slice(3,6);o=this.safeCurrencyCode(e)+"/"+this.safeCurrencyCode(i)}const n=i[t];r[o]=this.parseTicker(n,a)}return r}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={market:i.id},r=await this.publicGetTickersMarket(this.extend(s,t));return this.parseTicker(r,i)}parseTrade(e,t){const i=this.parse8601(this.safeString(e,"created_at")),s=this.safeString(e,"id"),r=this.safeFloat(e,"price"),a=this.safeFloat(e,"volume"),o=this.safeFloat(e,"funds");let n=void 0;return void 0!==t&&(n=t.symbol),{id:s,info:e,timestamp:i,datetime:this.iso8601(i),symbol:n,type:void 0,side:void 0,order:void 0,takerOrMaker:void 0,price:r,amount:a,cost:o,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={market:r.id},o=await this.publicGetTrades(this.extend(a,s));return this.parseTrades(o,r,t,i)}parseOHLCV(e,t,i="1m",s,r){return[1e3*e[0],e[1],e[2],e[3],e[4],e[5]]}async fetchOHLCV(e,t="1m",i,s,r={}){await this.loadMarkets();const a=this.market(e);void 0===s&&(s=30);const o={market:a.id,period:this.timeframes[t],limit:s};o.timestamp=void 0!==i?parseInt(i/1e3):18e5;const n=await this.publicGetK(this.extend(o,r));return"null"===n?[]:this.parseOHLCVs(n,a,t,i,s)}parseOrderStatus(e){return this.safeString({done:"closed",wait:"open",cancel:"canceled"},e,e)}parseOrder(e,t){let i=void 0;if(void 0!==t)i=t.symbol;else{const t=e.market;i=this.markets_by_id[t].symbol}const s=this.parse8601(this.safeString(e,"created_at")),r=this.parseOrderStatus(this.safeString(e,"state")),a=this.safeString(e,"id"),o=this.safeString(e,"ord_type"),n=this.safeString(e,"side"),d=this.safeFloat(e,"price"),c=this.safeFloat(e,"volume"),h=this.safeFloat(e,"executed_volume"),l=this.safeFloat(e,"remaining_volume");let u=void 0;return void 0!==d&&void 0!==h&&(u=d*h),{id:a,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,status:r,symbol:i,type:o,side:n,price:d,amount:c,filled:h,remaining:l,cost:u,trades:void 0,fee:void 0,info:e}}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o={market:this.marketId(e),side:i,volume:s.toString(),ord_type:t};"limit"===t&&(o.price=r.toString());const n=await this.privatePostOrders(this.extend(o,a)),d=this.markets_by_id[n.market];return this.parseOrder(n,d)}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={id:e},r=await this.privatePostOrderDelete(this.extend(s,i)),a=this.parseOrder(r),n=this.safeString(a,"status");if("closed"===n||"canceled"===n)throw new o(this.id+" "+this.json(a));return a}async withdraw(e,t,i,s,a={}){this.checkAddress(i),await this.loadMarkets();const o=this.currency(e),n=this.safeString(a,"id");if(void 0===n)throw new r(this.id+" withdraw() requires an extra `id` param (withdraw account id according to withdraws/bind_account_list endpoint");const d={id:n,currency_type:"coin",currency:o.id,body:t};return void 0!==s&&(d.memo=s),{info:await this.privatePostWithdrawsApply(this.extend(d,a)),id:void 0}}nonce(){return this.milliseconds()}encodeParams(e){return this.urlencode(this.keysort(e))}sign(e,t="public",i="GET",s={},r,a){const o="/api/"+this.version+"/"+this.implodeParams(e,s)+".json",n=this.omit(s,this.extractParams(e));let d=this.urls.api+o;if("public"===t)Object.keys(n).length&&(d+="?"+this.urlencode(n));else{this.checkRequiredCredentials();const e=this.nonce().toString(),t=this.keysort(this.extend({access_key:this.apiKey,tonce:e},s)),n=this.urlencode(t),c=i+"|"+o+"|"+n,h=n+"&signature="+this.hmac(this.encode(c),this.encode(this.secret));"GET"===i?d+="?"+h:(a=h,r={"Content-Type":"application/x-www-form-urlencoded"})}return{url:d,method:i,body:a,headers:r}}handleErrors(e,t,i,s,r,a,o,n,d){if(400===e){const e=this.safeValue(o,"error"),t=this.safeString(e,"code"),i=this.id+" "+this.json(o),s=this.exceptions;if(t in s)throw new s[t](i)}}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,ArgumentsRequired:a,ExchangeNotAvailable:o,InsufficientFunds:n,OrderNotFound:d,DDoSProtection:c,InvalidOrder:h,AuthenticationError:l}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"tidex",name:"Tidex",countries:["UK"],rateLimit:2e3,version:"3",userAgent:this.userAgents.chrome,has:{CORS:!1,createMarketOrder:!1,fetchOrderBooks:!0,fetchOrder:!0,fetchOrders:"emulated",fetchOpenOrders:!0,fetchClosedOrders:"emulated",fetchTickers:!0,fetchMyTrades:!0,withdraw:!0,fetchCurrencies:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/30781780-03149dc4-a12e-11e7-82bb-313b269d24d4.jpg",api:{web:"https://gate.tidex.com/api",public:"https://api.tidex.com/api/3",private:"https://api.tidex.com/tapi"},www:"https://tidex.com",doc:"https://tidex.com/exchange/public-api",fees:["https://tidex.com/exchange/assets-spec","https://tidex.com/exchange/pairs-spec"]},api:{web:{get:["currency","pairs","tickers","orders","ordershistory","trade-data","trade-data/{id}"]},public:{get:["info","ticker/{pair}","depth/{pair}","trades/{pair}"]},private:{post:["getInfoExt","getInfo","Trade","ActiveOrders","OrderInfo","CancelOrder","TradeHistory","CoinDepositAddress","WithdrawCoin","CreateCoupon","RedeemCoupon"]}},fees:{trading:{tierBased:!1,percentage:!0,taker:.001,maker:.001}},commonCurrencies:{DSH:"DASH",EMGO:"MGO",MGO:"WMGO"},exceptions:{exact:{803:h,804:h,805:h,806:h,807:h,831:n,832:n,833:d},broad:{"Invalid pair name":r,"invalid api key":l,"invalid sign":l,"api key dont have trade permission":l,"invalid parameter":h,"invalid order":h,"Requests too often":c,"not available":o,"data unavailable":o,"external service unavailable":o}},options:{fetchTickersMaxLength:2048}})}async fetchCurrencies(e={}){const t=await this.webGetCurrency(e),i={};for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"symbol"),a=s.amountPoint,o=this.safeCurrencyCode(r);let n=!0===s.visible;const d=!0===s.withdrawEnable,c=!0===s.depositEnable;d&&c||(n=!1);const h=this.safeString(s,"name");i[o]={id:r,code:o,name:h,active:n,precision:a,funding:{withdraw:{active:d,fee:s.withdrawFee},deposit:{active:c,fee:0}},limits:{amount:{min:void 0,max:Math.pow(10,a)},price:{min:Math.pow(10,-a),max:Math.pow(10,a)},cost:{min:void 0,max:void 0},withdraw:{min:s.withdrawMinAmout,max:void 0},deposit:{min:s.depositMinAmount,max:void 0}},info:s}}return i}calculateFee(e,t,i,s,r,a="taker",o={}){const n=this.markets[e];let d="quote";const c=n[a];let h=parseFloat(this.costToPrecision(e,s*c));return"sell"===i?h*=r:d="base",{type:a,currency:n[d],rate:c,cost:h}}async fetchMarkets(e={}){const t=(await this.publicGetInfo(e)).pairs,i=Object.keys(t),s=[];for(let e=0;e<i.length;e++){const r=i[e],a=t[r],[o,n]=r.split("_"),d=this.safeCurrencyCode(o),c=this.safeCurrencyCode(n),h=d+"/"+c,l={amount:this.safeInteger(a,"decimal_places"),price:this.safeInteger(a,"decimal_places")},u={amount:{min:this.safeFloat(a,"min_amount"),max:this.safeFloat(a,"max_amount")},price:{min:this.safeFloat(a,"min_price"),max:this.safeFloat(a,"max_price")},cost:{min:this.safeFloat(a,"min_total")}},f=0===this.safeInteger(a,"hidden");s.push({id:r,symbol:h,base:d,quote:c,baseId:o,quoteId:n,active:f,taker:a.fee/100,precision:l,limits:u,info:a})}return s}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGetInfoExt(e),i=this.safeValue(t,"return"),s={info:i},r=this.safeValue(i,"funds",{}),a=Object.keys(r);for(let e=0;e<a.length;e++){const t=a[e],i=this.safeCurrencyCode(t),o=this.safeValue(r,t,{}),n=this.account();n.free=this.safeFloat(o,"value"),n.used=this.safeFloat(o,"inOrders"),s[i]=n}return this.parseBalance(s)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s=this.market(e),a={pair:s.id};void 0!==t&&(a.limit=t);const o=await this.publicGetDepthPair(this.extend(a,i));if(!(s.id in o))throw new r(this.id+" "+s.symbol+" order book is empty or not available");const n=o[s.id];return this.parseOrderBook(n)}async fetchOrderBooks(e,t={}){await this.loadMarkets();let i=void 0;if(void 0===e){if((i=this.ids.join("-")).length>2048){const e=this.ids.length;throw new r(this.id+" has "+e.toString()+" symbols exceeding max URL length, you are required to specify a list of symbols in the first argument to fetchOrderBooks")}}else i=(i=this.marketIds(e)).join("-");const s={pair:i},a=await this.publicGetDepthPair(this.extend(s,t)),o={};i=Object.keys(a);for(let e=0;e<i.length;e++){const t=i[e];let s=t;t in this.markets_by_id&&(s=this.markets_by_id[t].symbol),o[s]=this.parseOrderBook(a[t])}return o}parseTicker(e,t){const i=this.safeTimestamp(e,"updated");let s=void 0;void 0!==t&&(s=t.symbol);const r=this.safeFloat(e,"last");return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"buy"),bidVolume:void 0,ask:this.safeFloat(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:this.safeFloat(e,"avg"),baseVolume:this.safeFloat(e,"vol_cur"),quoteVolume:this.safeFloat(e,"vol"),info:e}}async fetchTickers(e,t={}){await this.loadMarkets();let i=this.ids;if(void 0===e){const e=i.length;if((i=i.join("-")).length>this.options.fetchTickersMaxLength){const t=this.safeInteger(this.options,"fetchTickersMaxLength",2048);throw new a(this.id+" has "+e.toString()+" markets exceeding max URL length for this endpoint ("+t.toString()+" characters), please, specify a list of symbols of interest in the first argument to fetchTickers")}}else i=(i=this.marketIds(e)).join("-");const s={pair:i},r=await this.publicGetTickerPair(this.extend(s,t)),o={},n=Object.keys(r);for(let e=0;e<n.length;e++){const t=n[e];let i=t,s=void 0;t in this.markets_by_id&&(i=(s=this.markets_by_id[t]).symbol),o[i]=this.parseTicker(r[t],s)}return o}async fetchTicker(e,t={}){return(await this.fetchTickers([e],t))[e]}parseTrade(e,t){const i=this.safeTimestamp(e,"timestamp");let s=this.safeString(e,"type");"ask"===s?s="sell":"bid"===s&&(s="buy");const r=this.safeFloat2(e,"rate","price"),a=this.safeString2(e,"trade_id","tid"),o=this.safeString(e,"order_id");if("pair"in e){const i=this.safeString(e,"pair");t=this.safeValue(this.markets_by_id,i,t)}let n=void 0;void 0!==t&&(n=t.symbol);const d=this.safeFloat(e,"amount");let c=void 0,h=void 0;const l=this.safeFloat(e,"commission");if(void 0!==l){const t=this.safeString(e,"commissionCurrency");h={cost:l,currency:this.safeCurrencyCode(t)}}const u=this.safeValue(e,"is_your_order");void 0!==u&&(c="taker",u&&(c="maker"),void 0===h&&(h=this.calculateFee(n,"limit",s,d,r,c)));let f=void 0;return void 0!==d&&void 0!==r&&(f=d*r),{id:a,order:o,timestamp:i,datetime:this.iso8601(i),symbol:n,type:"limit",side:s,takerOrMaker:c,price:r,amount:d,cost:f,fee:h,info:e}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={pair:r.id};void 0!==i&&(a.limit=i);const o=await this.publicGetTradesPair(this.extend(a,s));if(Array.isArray(o)){if(0===o.length)return[]}return this.parseTrades(o[r.id],r,t,i)}async createOrder(e,t,i,s,a,o={}){if("market"===t)throw new r(this.id+" allows limit orders only");await this.loadMarkets();const n={pair:this.market(e).id,type:i,amount:this.amountToPrecision(e,s),rate:this.priceToPrecision(e,a)};a=parseFloat(a),s=parseFloat(s);const d=await this.privatePostTrade(this.extend(n,o));let c=void 0,h="open",l=0,u=s;"return"in d&&("0"===(c=this.safeString(d.return,"order_id"))&&(c=this.safeString(d.return,"init_order_id"),h="closed"),l=this.safeFloat(d.return,"received",0),u=this.safeFloat(d.return,"remains",s));const f=this.milliseconds(),p={id:c,timestamp:f,datetime:this.iso8601(f),lastTradeTimestamp:void 0,status:h,symbol:e,type:t,side:i,price:a,cost:a*l,amount:s,remaining:u,filled:l,fee:void 0};return this.orders[c]=p,this.extend({info:d},p)}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={order_id:parseInt(e)},r=await this.privatePostCancelOrder(this.extend(s,i));return e in this.orders&&(this.orders[e].status="canceled"),r}parseOrderStatus(e){return this.safeString({0:"open",1:"closed",2:"canceled",3:"canceled"},e,e)}parseOrder(e,t){const i=this.safeString(e,"id"),s=this.parseOrderStatus(this.safeString(e,"status")),r=this.safeTimestamp(e,"timestamp_created");let a=void 0;if(void 0===t){const i=this.safeString(e,"pair");i in this.markets_by_id&&(t=this.markets_by_id[i])}void 0!==t&&(a=t.symbol);let o=void 0,n=void 0;const d=this.safeFloat(e,"rate");let c=void 0,h=void 0;"start_amount"in e?(n=this.safeFloat(e,"start_amount"),o=this.safeFloat(e,"amount")):(o=this.safeFloat(e,"amount"),i in this.orders&&(n=this.orders[i].amount)),void 0!==n&&void 0!==o&&(h=d*(c=n-o));return{info:e,id:i,symbol:a,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,type:"limit",side:e.type,price:d,cost:h,amount:n,remaining:o,filled:c,status:s,fee:void 0}}parseOrders(e,t,i,s,r={}){const a=[],o=Object.keys(e);let n=void 0;void 0!==t&&(n=t.symbol);for(let i=0;i<o.length;i++){const s=o[i],n=this.extend({id:s},e[s]);a.push(this.extend(this.parseOrder(n,t),r))}return this.filterBySymbolSinceLimit(a,n,i,s)}async fetchOrder(e,t,i={}){await this.loadMarkets();const s={order_id:parseInt(e)},r=await this.privatePostOrderInfo(this.extend(s,i));e=e.toString();const a=this.parseOrder(this.extend({id:e},r.return[e])),o=e in this.orders?this.orders[e]:{};return this.orders[e]=this.extend(o,a),this.orders[e]}updateCachedOrders(e,t){for(let t=0;t<e.length;t++){const i=e[t].id;this.orders[i]=e[t]}const i=this.indexBy(e,"id"),s=Object.keys(this.orders);for(let e=0;e<s.length;e++){const r=s[e];let a=this.orders[r];if(!(r in i)){if(void 0!==t&&t!==a.symbol)continue;"open"===a.status&&(void 0===(a=this.extend(a,{status:"closed",cost:void 0,filled:a.amount,remaining:0})).cost&&void 0!==a.filled&&(a.cost=a.filled*a.price),this.orders[r]=a)}}return this.toArray(this.orders)}async fetchOrders(e,t,i,s={}){if("fetchOrdersRequiresSymbol"in this.options&&this.options.fetchOrdersRequiresSymbol&&void 0===e)throw new a(this.id+" fetchOrders requires a `symbol` argument");await this.loadMarkets();const r={};let o=void 0;void 0!==e&&(o=this.market(e),r.pair=o.id);const n=await this.privatePostActiveOrders(this.extend(r,s)),d=this.safeValue(n,"return",[]),c=this.parseOrders(d,o),h=this.updateCachedOrders(c,e),l=this.filterBySymbol(h,e);return this.filterBySinceLimit(l,t,i)}async fetchOpenOrders(e,t,i,s={}){const r=await this.fetchOrders(e,t,i,s);return this.filterBy(r,"status","open")}async fetchClosedOrders(e,t,i,s={}){const r=await this.fetchOrders(e,t,i,s);return this.filterBy(r,"status","closed")}async fetchMyTrades(e,t,i,s={}){await this.loadMarkets();let r=void 0;const a={};void 0!==e&&(r=this.market(e),a.pair=r.id),void 0!==i&&(a.count=parseInt(i)),void 0!==t&&(a.since=parseInt(t/1e3));const o=await this.privatePostTradeHistory(this.extend(a,s)),n=this.safeValue(o,"return",[]);return this.parseTrades(n,r,t,i)}async withdraw(e,t,i,s,a={}){this.checkAddress(i),await this.loadMarkets();const o={coinName:this.currency(e).id,amount:parseFloat(t),address:i};if(void 0!==s)throw new r(this.id+" withdraw() does not support the tag argument yet due to a lack of docs on withdrawing with tag/memo on behalf of the exchange.");const n=await this.privatePostWithdrawCoin(this.extend(o,a));return{info:n,id:n.return.tId}}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api[t];const n=this.omit(s,this.extractParams(e));if("private"===t){this.checkRequiredCredentials();const t=this.nonce();a=this.urlencode(this.extend({nonce:t,method:e},n));const i=this.hmac(this.encode(a),this.encode(this.secret),"sha512");r={"Content-Type":"application/x-www-form-urlencoded",Key:this.apiKey,Sign:i}}else"public"===t?(o+="/"+this.implodeParams(e,s),Object.keys(n).length&&(o+="?"+this.urlencode(n))):(o+="/"+this.implodeParams(e,s),"GET"===i?Object.keys(n).length&&(o+="?"+this.urlencode(n)):Object.keys(n).length&&(a=this.json(n),r={"Content-Type":"application/json"}));return{url:o,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,o,n,d,c){if(void 0!==n&&"success"in n){let e=this.safeValue(n,"success",!1);if("string"==typeof e&&(e="true"===e||"1"===e),!e){const e=this.safeString(n,"code"),t=this.safeString(n,"error"),i=this.id+" "+this.json(n),s=this.exceptions.exact;if(e in s)throw new s[e](i);if(t in s)throw new s[t](i);const a=this.exceptions.broad,o=this.findBroadlyMatchedKey(a,t);if(void 0!==o)throw new a[o](i);throw new r(i)}}}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,BadRequest:a,AuthenticationError:o,InvalidOrder:n,InsufficientFunds:d,OrderNotFound:c,PermissionDenied:h}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"upbit",name:"Upbit",countries:["KR"],version:"v1",rateLimit:1e3,certified:!0,has:{CORS:!0,createDepositAddress:!0,createMarketOrder:!0,fetchDepositAddress:!0,fetchClosedOrders:!0,fetchMyTrades:!1,fetchOHLCV:!0,fetchOrder:!0,fetchOrderBooks:!0,fetchOpenOrders:!0,fetchOrders:!1,fetchTickers:!0,withdraw:!0,fetchDeposits:!0,fetchWithdrawals:!0,fetchTransactions:!1},timeframes:{"1m":"minutes","3m":"minutes","5m":"minutes","15m":"minutes","30m":"minutes","1h":"minutes","4h":"minutes","1d":"days","1w":"weeks","1M":"months"},urls:{logo:"https://user-images.githubusercontent.com/1294454/49245610-eeaabe00-f423-11e8-9cba-4b0aed794799.jpg",api:"https://api.upbit.com",www:"https://upbit.com",doc:"https://docs.upbit.com/docs/%EC%9A%94%EC%B2%AD-%EC%88%98-%EC%A0%9C%ED%95%9C",fees:"https://upbit.com/service_center/guide"},api:{public:{get:["market/all","candles/{timeframe}","candles/{timeframe}/{unit}","candles/minutes/{unit}","candles/minutes/1","candles/minutes/3","candles/minutes/5","candles/minutes/15","candles/minutes/30","candles/minutes/60","candles/minutes/240","candles/days","candles/weeks","candles/months","trades/ticks","ticker","orderbook"]},private:{get:["accounts","orders/chance","order","orders","withdraws","withdraw","withdraws/chance","deposits","deposit","deposits/coin_addresses","deposits/coin_address"],post:["orders","withdraws/coin","withdraws/krw","deposits/generate_coin_address"],delete:["order"]}},fees:{trading:{tierBased:!1,percentage:!0,maker:.0025,taker:.0025},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{}}},exceptions:{exact:{"Missing request parameter error. Check the required parameters!":a,"side is missing, side does not have a valid value":n},broad:{thirdparty_agreement_required:h,out_of_scope:h,order_not_found:c,insufficient_funds:d,invalid_access_key:o,jwt_verification:o,create_ask_error:r,create_bid_error:r,volume_too_large:n,invalid_funds:n}},options:{createMarketBuyOrderRequiresPrice:!0,fetchTickersMaxLength:4096,fetchOrderBooksMaxLength:4096,symbolSeparator:"-",tradingFeesByQuoteCurrency:{KRW:5e-4}},commonCurrencies:{CPT:"Contents Protocol"}})}async fetchCurrency(e,t={}){await this.loadMarkets();const i=this.currency(e);return await this.fetchCurrencyById(i.id,t)}async fetchCurrencyById(e,t={}){const i={currency:e},s=await this.privateGetWithdrawsChance(this.extend(i,t)),r=this.safeValue(s,"member_level",{}),a=this.safeValue(s,"currency",{}),o=this.safeValue(s,"withdraw_limit",{}),n=this.safeValue(o,"can_withdraw"),d=this.safeString(a,"wallet_state"),c=this.safeValue(r,"wallet_locked"),h=this.safeValue(r,"locked");let l=!0;void 0!==n&&n?l=!1:"working"!==d?l=!1:void 0!==c&&c?l=!1:void 0!==h&&h&&(l=!1);const u=this.safeFloat(o,"onetime"),f=this.safeFloat(o,"daily",u),p=this.safeFloat(o,"remaining_daily",f);let m=void 0;m=p>0?p:f;const y=this.safeString(a,"code"),b=this.safeCurrencyCode(y);return{info:s,id:y,code:b,name:b,active:l,fee:this.safeFloat(a,"withdraw_fee"),precision:void 0,limits:{withdraw:{min:this.safeFloat(o,"minimum"),max:m}}}}async fetchMarket(e,t={}){await this.loadMarkets();const i=this.market(e);return await this.fetchMarketById(i.id,t)}async fetchMarketById(e,t={}){const i={market:e},s=await this.privateGetOrdersChance(this.extend(i,t)),r=this.safeValue(s,"market"),a=this.safeValue(r,"bid"),o=this.safeValue(r,"ask"),n=this.safeString(r,"id"),d=this.safeString(o,"currency"),c=this.safeString(a,"currency"),h=this.safeCurrencyCode(d),l=this.safeCurrencyCode(c),u=h+"/"+l,f={amount:8,price:8},p="active"===this.safeString(r,"state"),m=this.safeFloat(s,"bid_fee"),y=this.safeFloat(s,"ask_fee"),b=Math.max(m,y);return{info:s,id:n,symbol:u,base:h,quote:l,baseId:d,quoteId:c,active:p,precision:f,maker:b,taker:b,limits:{amount:{min:this.safeFloat(o,"min_total"),max:void 0},price:{min:Math.pow(10,-f.price),max:void 0},cost:{min:this.safeFloat(a,"min_total"),max:this.safeFloat(r,"max_total")}}}}async fetchMarkets(e={}){const t=await this.publicGetMarketAll(e),i=[];for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"market"),[a,o]=r.split("-"),n=this.safeCurrencyCode(o),d=this.safeCurrencyCode(a),c=n+"/"+d,h={amount:8,price:8},l=!0,u=this.safeFloat(this.options.tradingFeesByQuoteCurrency,d,this.fees.trading.maker),f=this.safeFloat(this.options.tradingFeesByQuoteCurrency,d,this.fees.trading.taker);i.push({id:r,symbol:c,base:n,quote:d,baseId:o,quoteId:a,active:l,info:s,precision:h,maker:u,taker:f,limits:{amount:{min:Math.pow(10,-h.amount),max:void 0},price:{min:Math.pow(10,-h.price),max:void 0},cost:{min:void 0,max:void 0}}})}return i}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccounts(e),i={info:t};for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeFloat(s,"balance"),o.used=this.safeFloat(s,"locked"),i[a]=o}return this.parseBalance(i)}getSymbolFromMarketId(e,t){if(void 0===e)return;if(void 0!==(t=this.safeValue(this.markets_by_id,e,t)))return t.symbol;const[i,s]=e.split(this.options.symbolSeparator);return this.safeCurrencyCode(i)+"/"+this.safeCurrencyCode(s)}async fetchOrderBooks(e,t={}){await this.loadMarkets();let i=void 0;if(void 0===e){if((i=this.ids.join(",")).length>this.options.fetchOrderBooksMaxLength){const e=this.ids.length;throw new r(this.id+" has "+e.toString()+" symbols ("+i.length.toString()+" characters) exceeding max URL length ("+this.options.fetchOrderBooksMaxLength.toString()+" characters), you are required to specify a list of symbols in the first argument to fetchOrderBooks")}}else i=(i=this.marketIds(e)).join(",");const s={markets:i},a=await this.publicGetOrderbook(this.extend(s,t)),o={};for(let e=0;e<a.length;e++){const t=a[e],i=this.getSymbolFromMarketId(this.safeString(t,"market")),s=this.safeInteger(t,"timestamp");o[i]={bids:this.sortBy(this.parseBidsAsks(t.orderbook_units,"bid_price","bid_size"),0,!0),asks:this.sortBy(this.parseBidsAsks(t.orderbook_units,"ask_price","ask_size"),0),timestamp:s,datetime:this.iso8601(s),nonce:void 0}}return o}async fetchOrderBook(e,t,i={}){const s=await this.fetchOrderBooks([e],i);return this.safeValue(s,e)}parseTicker(e,t){const i=this.safeInteger(e,"trade_timestamp"),s=this.getSymbolFromMarketId(this.safeString(e,"market"),t),r=this.safeFloat(e,"prev_closing_price"),a=this.safeFloat(e,"trade_price"),o=this.safeFloat(e,"signed_change_price"),n=this.safeFloat(e,"signed_change_rate");return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high_price"),low:this.safeFloat(e,"low_price"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:this.safeFloat(e,"opening_price"),close:a,last:a,previousClose:r,change:o,percentage:n,average:void 0,baseVolume:this.safeFloat(e,"acc_trade_volume_24h"),quoteVolume:this.safeFloat(e,"acc_trade_price_24h"),info:e}}async fetchTickers(e,t={}){await this.loadMarkets();let i=void 0;if(void 0===e){if((i=this.ids.join(",")).length>this.options.fetchTickersMaxLength){const e=this.ids.length;throw new r(this.id+" has "+e.toString()+" symbols exceeding max URL length, you are required to specify a list of symbols in the first argument to fetchTickers")}}else i=(i=this.marketIds(e)).join(",");const s={markets:i},a=await this.publicGetTicker(this.extend(s,t)),o={};for(let e=0;e<a.length;e++){const t=this.parseTicker(a[e]);o[t.symbol]=t}return o}async fetchTicker(e,t={}){const i=await this.fetchTickers([e],t);return this.safeValue(i,e)}parseTrade(e,t){const i=this.safeString2(e,"sequential_id","uuid");let s=this.safeInteger(e,"timestamp");void 0===s&&(s=this.parse8601(this.safeString(e,"created_at")));let r=void 0;const a=this.safeStringLower2(e,"ask_bid","side");"ask"===a?r="sell":"bid"===a&&(r="buy");let o=this.safeFloat(e,"funds");const n=this.safeFloat2(e,"trade_price","price"),d=this.safeFloat2(e,"trade_volume","volume");void 0===o&&void 0!==d&&void 0!==n&&(o=n*d);const c=this.safeString(e,"market");let h=void 0,l=void 0,u=void 0;if(void 0!==(t=this.safeValue(this.markets_by_id,c)))u=t.symbol,l=t.quote;else{const[e,t]=c.split("-"),i=this.safeCurrencyCode(e),s=this.safeCurrencyCode(t);u=i+"/"+s,l=s}const f=this.safeString(e,a+"_fee");return void 0!==f&&(h={currency:l,cost:f}),{id:i,info:e,order:void 0,timestamp:s,datetime:this.iso8601(s),symbol:u,type:"limit",side:r,takerOrMaker:void 0,price:n,amount:d,cost:o,fee:h}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e);void 0===i&&(i=200);const a={market:r.id,count:i},o=await this.publicGetTradesTicks(this.extend(a,s));return this.parseTrades(o,r,t,i)}parseOHLCV(e,t,i="1d",s,r){return[this.parse8601(this.safeString(e,"candle_date_time_utc")),this.safeFloat(e,"opening_price"),this.safeFloat(e,"high_price"),this.safeFloat(e,"low_price"),this.safeFloat(e,"trade_price"),this.safeFloat(e,"candle_acc_trade_volume")]}async fetchOHLCV(e,t="1m",i,s,r={}){await this.loadMarkets();const a=this.market(e),o=this.parseTimeframe(t),n=this.timeframes[t];void 0===s&&(s=200);const d={market:a.id,timeframe:n,count:s};let c="publicGetCandlesTimeframe";if("minutes"===n){const e=Math.round(o/60);d.unit=e,c+="Unit"}void 0!==i&&(d.to=this.iso8601(this.sum(i,o*s*1e3)));const h=await this[c](this.extend(d,r));return this.parseOHLCVs(h,a,t,i,s)}async createOrder(e,t,i,s,r,a={}){if("market"===t&&"buy"===i&&this.options.createMarketBuyOrderRequiresPrice){if(void 0===r)throw new n(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the cost in the amount argument (the exchange-specific behaviour)");s*=r}let o=void 0;if("buy"===i)o="bid";else{if("sell"!==i)throw new n(this.id+" createOrder allows buy or sell side only!");o="ask"}await this.loadMarkets();const d={market:this.market(e).id,side:o};"limit"===t?(d.volume=this.amountToPrecision(e,s),d.price=this.priceToPrecision(e,r),d.ord_type=t):"market"===t&&("buy"===i?(d.ord_type="price",d.price=this.priceToPrecision(e,s)):"sell"===i&&(d.ord_type=t,d.volume=this.amountToPrecision(e,s)));const c=await this.privatePostOrders(this.extend(d,a));return this.parseOrder(c)}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={uuid:e},r=await this.privateDeleteOrder(this.extend(s,i));return this.parseOrder(r)}async fetchDeposits(e,t,i,s={}){await this.loadMarkets();const r={};let a=void 0;void 0!==e&&(a=this.currency(e),r.currency=a.id),void 0!==i&&(r.limit=i);const o=await this.privateGetDeposits(this.extend(r,s));return this.parseTransactions(o,a,t,i)}async fetchWithdrawals(e,t,i,s={}){await this.loadMarkets();const r={};let a=void 0;void 0!==e&&(a=this.currency(e),r.currency=a.id),void 0!==i&&(r.limit=i);const o=await this.privateGetWithdraws(this.extend(r,s));return this.parseTransactions(o,a,t,i)}parseTransactionStatus(e){return this.safeString({ACCEPTED:"ok",submitting:"pending",submitted:"pending",almost_accepted:"pending",rejected:"failed",accepted:"pending",processing:"pending",done:"ok",canceled:"canceled"},e,e)}parseTransaction(e,t){const i=this.safeString(e,"uuid"),s=this.safeFloat(e,"amount"),r=this.safeString(e,"txid"),a=this.parse8601(this.safeString(e,"done_at")),o=this.parse8601(this.safeString(e,"created_at",a));let n=this.safeString(e,"type");"withdraw"===n&&(n="withdrawal");const d=this.safeString(e,"currency"),c=this.safeCurrencyCode(d),h=this.parseTransactionStatus(this.safeString(e,"state")),l=this.safeFloat(e,"fee");return{info:e,id:i,currency:c,amount:s,address:void 0,tag:void 0,status:h,type:n,updated:a,txid:r,timestamp:o,datetime:this.iso8601(o),fee:{currency:c,cost:l}}}parseOrderStatus(e){return this.safeString({wait:"open",done:"closed",cancel:"canceled"},e,e)}parseOrder(e,t){const i=this.safeString(e,"uuid");let s=this.safeString(e,"side");s="bid"===s?"buy":"sell";let r=this.safeString(e,"ord_type");const a=this.parse8601(this.safeString(e,"created_at")),o=this.parseOrderStatus(this.safeString(e,"state"));let n=void 0,d=this.safeFloat(e,"price");const c=this.safeFloat(e,"volume"),h=this.safeFloat(e,"remaining_volume"),l=this.safeFloat(e,"executed_volume");let u=void 0;"price"===r&&(r="market",u=d,d=void 0);let f=void 0,p=void 0,m=this.safeFloat(e,"paid_fee"),y=void 0;const b=this.safeString(e,"market");let v=void 0;if(void 0!==(t=this.safeValue(this.markets_by_id,b)))v=t.symbol,y=t.quote;else{const[e,t]=b.split("-"),i=this.safeCurrencyCode(e),s=this.safeCurrencyCode(t);v=i+"/"+s,y=s}let g=this.safeValue(e,"trades",[]);const w=(g=this.parseTrades(g,t,void 0,void 0,{order:i})).length;if(w>0){n=g[w-1].timestamp;let e=!1;void 0===m&&(e=!0,m=0),u=0;for(let t=0;t<w;t++){const i=g[t];if(u=this.sum(u,i.cost),e){const e=this.safeValue(g[t],"fee",{}),i=this.safeFloat(e,"cost");void 0!==i&&(m=this.sum(m,i))}}f=u/l}return void 0!==m&&(p={currency:y,cost:m}),{info:e,id:i,timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:n,symbol:v,type:r,side:s,price:d,cost:u,average:f,amount:c,filled:l,remaining:h,status:o,fee:p,trades:g}}async fetchOrdersByState(e,t,i,s,r={}){await this.loadMarkets();const a={state:e};let o=void 0;void 0!==t&&(o=this.market(t),a.market=o.id);const n=await this.privateGetOrders(this.extend(a,r));return this.parseOrders(n,o,i,s)}async fetchOpenOrders(e,t,i,s={}){return await this.fetchOrdersByState("wait",e,t,i,s)}async fetchClosedOrders(e,t,i,s={}){return await this.fetchOrdersByState("done",e,t,i,s)}async fetchCanceledOrders(e,t,i,s={}){return await this.fetchOrdersByState("cancel",e,t,i,s)}async fetchOrder(e,t,i={}){await this.loadMarkets();const s={uuid:e},r=await this.privateGetOrder(this.extend(s,i));return this.parseOrder(r)}parseDepositAddresses(e){const t=[];for(let i=0;i<e.length;i++)t.push(this.parseDepositAddress(e[i]));return t}async fetchDepositAddresses(e,t={}){await this.loadMarkets();const i=await this.privateGetDepositsCoinAddresses(t);return this.parseDepositAddresses(i)}parseDepositAddress(e,t){const i=this.safeString(e,"deposit_address"),s=this.safeString(e,"secondary_address"),r=this.safeString(e,"currency"),a=this.safeCurrencyCode(r);return this.checkAddress(i),{currency:a,address:i,tag:s,info:e}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i=this.currency(e),s=await this.privateGetDepositsCoinAddress(this.extend({currency:i.id},t));return this.parseDepositAddress(s)}async createDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},s=await this.fetchDepositAddress(e,this.extend(i,t));return void 0!==this.safeString(s,"message")?{currency:e,address:void 0,tag:void 0,info:s}:this.parseDepositAddress(s)}async withdraw(e,t,i,s,r={}){this.checkAddress(i),await this.loadMarkets();const a=this.currency(e),o={amount:t};let n="privatePostWithdraws";"KRW"!==e?(n+="Coin",o.currency=a.id,o.address=i,void 0!==s&&(o.secondary_address=s)):n+="Krw";const d=await this[n](this.extend(o,r));return this.parseTransaction(d)}nonce(){return this.milliseconds()}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api+"/"+this.version+"/"+this.implodeParams(e,s);const n=this.omit(s,this.extractParams(e));if("GET"===i&&Object.keys(n).length&&(o+="?"+this.urlencode(n)),"private"===t){this.checkRequiredCredentials();const e=this.nonce(),t={access_key:this.apiKey,nonce:e};Object.keys(n).length&&(t.query=this.urlencode(n)),r={Authorization:"Bearer "+this.jwt(t,this.encode(this.secret))},"GET"!==i&&(a=this.json(s),r["Content-Type"]="application/json")}return{url:o,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,o,n,d,c){if(void 0===n)return;const h=this.safeValue(n,"error");if(void 0!==h){const e=this.safeString(h,"message"),t=this.safeString(h,"name"),i=this.id+" "+this.json(n),s=this.exceptions.exact;if(e in s)throw new s[e](i);if(t in s)throw new s[t](i);const a=this.exceptions.broad;let o=this.findBroadlyMatchedKey(a,e);if(void 0!==o)throw new a[o](i);if(void 0!==(o=this.findBroadlyMatchedKey(a,t)))throw new a[o](i);throw new r(i)}}}},function(e,t,i){"use strict";const s=i(1);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"vaultoro",name:"Vaultoro",countries:["CH"],rateLimit:1e3,version:"1",has:{CORS:!0,fetchMarkets:!0,fetchOrderBook:!0,fetchBalance:!0,createOrder:!0,cancelOrder:!0,fetchTrades:!0,fetchTicker:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766880-f205e870-5ee9-11e7-8fe2-0d5b15880752.jpg",api:"https://api.vaultoro.com",www:"https://www.vaultoro.com",doc:"https://api.vaultoro.com"},commonCurrencies:{GLD:"Gold"},api:{public:{get:["bidandask","buyorders","latest","latesttrades","markets","orderbook","sellorders","transactions/day","transactions/hour","transactions/month"]},private:{get:["balance","mytrades","orders"],post:["buy/{symbol}/{type}","cancel/{id}","sell/{symbol}/{type}","withdraw"]}}})}async fetchMarkets(e={}){const t=[],i=await this.publicGetMarkets(e),s=this.safeValue(i,"data"),r=this.safeString(s,"MarketCurrency"),a=this.safeString(s,"BaseCurrency"),o=this.safeCurrencyCode(r),n=this.safeCurrencyCode(a),d=o+"/"+n,c=this.safeString(s,"MarketName");return t.push({id:c,symbol:d,base:o,quote:n,baseId:r,quoteId:a,info:s}),t}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalance(e),i=this.safeValue(t,"data"),s={info:i};for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"currency_code"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeFloat(t,"cash"),o.used=this.safeFloat(t,"reserved"),s[a]=o}return this.parseBalance(s)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s=await this.publicGetOrderbook(i),r={bids:s.data[0].b,asks:s.data[1].s};return this.parseOrderBook(r,void 0,"bids","asks","Gold_Price","Gold_Amount")}parseTrade(e,t){const i=this.parse8601(this.safeString(e,"Time"));let s=void 0;void 0!==t&&(s=t.symbol);const r=this.safeFloat(e,"Gold_Price"),a=this.safeFloat(e,"Gold_Amount");let o=void 0;return void 0!==r&&void 0!==a&&(o=a*r),{id:void 0,info:e,timestamp:i,datetime:this.iso8601(i),symbol:s,order:void 0,type:void 0,side:void 0,takerOrMaker:void 0,price:r,amount:a,cost:o,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a=await this.publicGetTransactionsDay(s);return this.parseTrades(a,r,t,i)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o=this.market(e),n="privatePost"+this.capitalize(i)+"SymbolType",d={symbol:o.quoteId.toLowerCase(),type:t,gld:s,price:r||1},c=await this[n](this.extend(d,a));return{info:c,id:c.data.Order_ID}}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={id:e};return await this.privatePostCancelId(this.extend(s,i))}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api+"/";if("public"===t)o+=e;else{this.checkRequiredCredentials();const t=this.nonce();o+=this.version+"/"+this.implodeParams(e,s);const i=this.extend({nonce:t,apikey:this.apiKey},this.omit(s,this.extractParams(e)));o+="?"+this.urlencode(i),r={"Content-Type":"application/json","X-Signature":this.hmac(this.encode(o),this.encode(this.secret))}}return{url:o,method:i,body:a,headers:r}}}},function(e,t,i){"use strict";const s=i(9);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"vbtc",name:"VBTC",countries:["VN"],has:{CORS:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/27991481-1f53d1d8-6481-11e7-884e-21d17e7939db.jpg",api:{public:"https://api.blinktrade.com/api",private:"https://api.blinktrade.com/tapi"},www:"https://vbtc.exchange",doc:"https://blinktrade.com/docs"},options:{brokerId:"3"}})}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"virwox",name:"VirWoX",countries:["AT","EU"],rateLimit:1e3,has:{CORS:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766894-6da9d360-5eea-11e7-90aa-41f2711b7405.jpg",api:{public:"https://api.virwox.com/api/json.php",private:"https://www.virwox.com/api/trading.php"},www:"https://www.virwox.com",doc:"https://www.virwox.com/developers.php"},requiredCredentials:{apiKey:!0,secret:!1,login:!0,password:!0},api:{public:{get:["getInstruments","getBestPrices","getMarketDepth","estimateMarketOrder","getTradedPriceVolume","getRawTradeData","getStatistics","getTerminalList","getGridList","getGridStatistics"],post:["getInstruments","getBestPrices","getMarketDepth","estimateMarketOrder","getTradedPriceVolume","getRawTradeData","getStatistics","getTerminalList","getGridList","getGridStatistics"]},private:{get:["cancelOrder","getBalances","getCommissionDiscount","getOrders","getTransactions","placeOrder"],post:["cancelOrder","getBalances","getCommissionDiscount","getOrders","getTransactions","placeOrder"]}}})}async fetchMarkets(e={}){const t=await this.publicGetGetInstruments(e),i=this.safeValue(t,"result"),s=Object.keys(i),r=[];for(let e=0;e<s.length;e++){const t=s[e],a=this.safeValue(i,t,{}),o=this.safeString(a,"instrumentID"),n=this.safeString(a,"longCurrency"),d=this.safeString(a,"shortCurrency"),c=this.safeCurrencyCode(n),h=this.safeCurrencyCode(d),l=c+"/"+h;r.push({id:o,symbol:l,base:c,quote:h,baseId:n,quoteId:d,info:a})}return r}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGetBalances(e),i=this.safeValue(t.result,"accountList"),s={info:t};for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeFloat(t,"balance"),s[a]=o}return this.parseBalance(s)}async fetchMarketPrice(e,t={}){await this.loadMarkets();const i={symbols:[e]},s=await this.publicPostGetBestPrices(this.extend(i,t)),r=this.safeValue(s,"result");return{bid:this.safeFloat(r[0],"bestBuyPrice"),ask:this.safeFloat(r[0],"bestSellPrice")}}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={symbols:[e]};void 0!==t&&(s.buyDepth=t,s.sellDepth=t);const r=(await this.publicPostGetMarketDepth(this.extend(s,i))).result[0];return this.parseOrderBook(r,void 0,"buy","sell","price","volume")}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.milliseconds(),s=i-864e5,r={instrument:e,endDate:this.ymdhms(i),startDate:this.ymdhms(s),HLOC:1},a=await this.publicGetGetTradedPriceVolume(this.extend(r,t)),o=this.safeValue(a.result,"priceVolumeList"),n=Object.keys(o),d=n[n.length-1],c=this.safeValue(o,d),h=this.milliseconds(),l=this.safeFloat(c,"close");return{symbol:e,timestamp:h,datetime:this.iso8601(h),high:this.safeFloat(c,"high"),low:this.safeFloat(c,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:this.safeFloat(c,"open"),close:l,last:l,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeFloat(c,"longVolume"),quoteVolume:this.safeFloat(c,"shortVolume"),info:c}}parseTrade(e,t){const i=this.safeTimestamp(e,"time"),s=this.safeString(e,"tid"),r=this.safeFloat(e,"price"),a=this.safeFloat(e,"vol");let o=void 0;void 0!==r&&void 0!==a&&(o=r*a);let n=void 0;return void 0!==t&&(n=t.symbol),{id:s,timestamp:i,datetime:this.iso8601(i),order:void 0,symbol:n,type:void 0,side:void 0,takerOrMaker:void 0,price:r,amount:a,cost:o,fee:void 0,info:e}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={instrument:e,timespan:3600},o=await this.publicGetGetRawTradeData(this.extend(a,s)),n=this.safeValue(o,"result",{}),d=this.safeValue(n,"data",[]);return this.parseTrades(d,r,t,i)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();const o={instrument:this.market(e).symbol,orderType:i.toUpperCase(),amount:s};"limit"===t&&(o.price=r);const n=await this.privatePostPlaceOrder(this.extend(o,a));return{info:n,id:this.safeString(n.result,"orderID")}}async cancelOrder(e,t,i={}){const s={orderID:e};return await this.privatePostCancelOrder(this.extend(s,i))}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api[t];const n={};"private"===t&&(this.checkRequiredCredentials(),n.key=this.apiKey,n.user=this.login,n.pass=this.password);const d=this.nonce();return"GET"===i?o+="?"+this.urlencode(this.extend({method:e,id:d},n,s)):(r={"Content-Type":"application/json"},a=this.json({method:e,params:this.extend(n,s),id:d})),{url:o,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,o,n,d,c){if(200===e){if("{"!==o[0]&&"["!==o[0])throw new r(this.id+" returned a non-JSON reply: "+o);if(!("result"in n))throw new r(this.id+" malformed response: no result in response: "+o);{const e=n.result;if("errorCode"in e){if("OK"!==e.errorCode)throw new r(this.id+" error returned: "+o)}}}}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,DDoSProtection:a}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"whitebit",name:"WhiteBit",version:"v2",countries:["EE"],rateLimit:500,has:{cancelOrder:!1,CORS:!1,createDepositAddress:!1,createLimitOrder:!1,createMarketOrder:!1,createOrder:!1,deposit:!1,editOrder:!1,fetchBalance:!1,fetchBidsAsks:!1,fetchCurrencies:!0,fetchMarkets:!0,fetchOHLCV:!0,fetchOrderBook:!0,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,privateAPI:!1,publicAPI:!0},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","8h":"8h","12h":"12h","1d":"1d","3d":"3d","1w":"1w","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/66732963-8eb7dd00-ee66-11e9-849b-10d9282bb9e0.jpg",api:{web:"https://whitebit.com/",publicV2:"https://whitebit.com/api/v2/public",publicV1:"https://whitebit.com/api/v1/public"},www:"https://www.whitebit.com",doc:"https://documenter.getpostman.com/view/7473075/SVSPomwS?version=latest#intro",fees:"https://whitebit.com/fee-schedule",referral:"https://whitebit.com/referral/d9bdf40e-28f2-4b52-b2f9-cd1415d82963"},api:{web:{get:["v1/healthcheck"]},publicV1:{get:["markets","tickers","ticker","symbols","depth/result","history","kline"]},publicV2:{get:["markets","ticker","assets","fee","depth/{market}","trades/{market}"]}},fees:{trading:{tierBased:!1,percentage:!0,taker:.001,maker:.001}},options:{fetchTradesMethod:"fetchTradesV1"}})}async fetchMarkets(e={}){const t=await this.publicV2GetMarkets(e),i=this.safeValue(t,"result"),s=[];for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"name"),a=this.safeString(t,"stock"),o=this.safeString(t,"money"),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o),c={id:r,symbol:n+"/"+d,base:n,quote:d,baseId:a,quoteId:o,info:t,active:this.safeValue(t,"tradesEnabled"),precision:{amount:this.safeInteger(t,"stockPrec"),price:this.safeInteger(t,"moneyPrec")},limits:{amount:{min:this.safeFloat(t,"minAmount"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeFloat(t,"minTotal"),max:void 0}}};s.push(c)}return s}async fetchCurrencies(e={}){const t=await this.publicV2GetAssets(e),i=this.safeValue(t,"result"),s=Object.keys(i),r={};for(let e=0;e<s.length;e++){const t=s[e],a=i[t],o=this.safeValue(a,"canDeposit",!0),n=this.safeValue(a,"canWithdraw",!0),d=o&&n,c=this.safeCurrencyCode(t);r[c]={id:t,code:c,info:a,name:void 0,active:d,fee:void 0,precision:void 0,limits:{amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0},withdraw:{min:this.safeFloat(a,"minWithdrawal"),max:this.safeFloat(a,"maxWithdrawal")}}}}return r}async fetchTradingFees(e={}){const t=await this.publicV2GetFee(e),i=this.safeValue(t,"result");return{maker:this.safeFloat(i,"makerFee"),taker:this.safeFloat(i,"takerFee")}}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={market:i.id},r=await this.publicV1GetTicker(this.extend(s,t)),a=this.safeValue(r,"result",{});return this.parseTicker(a,i)}parseTicker(e,t){const i=this.safeTimestamp(e,"at",this.milliseconds());e=this.safeValue(e,"ticker",e);let s=void 0;void 0!==t&&(s=t.symbol);const r=this.safeFloat(e,"last"),a=this.safeFloat(e,"change");let o=void 0;return void 0!==a&&(o=this.numberToString(.01*a)),{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"bid"),bidVolume:void 0,ask:this.safeFloat(e,"ask"),askVolume:void 0,vwap:void 0,open:this.safeFloat(e,"open"),close:r,last:r,previousClose:void 0,change:o,percentage:a,average:void 0,baseVolume:this.safeFloat(e,"volume"),quoteVolume:this.safeFloat(e,"deal"),info:e}}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicV1GetTickers(t),s=this.safeValue(i,"result"),r=Object.keys(s),a={};for(let e=0;e<r.length;e++){const t=r[e];let i=void 0,o=t;if(t in this.markets_by_id)o=(i=this.markets_by_id[t]).symbol;else{const[e,i]=t.split("_");o=this.safeCurrencyCode(e)+"/"+this.safeCurrencyCode(i)}const n=this.parseTicker(s[t],i);a[o]=this.extend(n,{symbol:o})}return this.filterByArray(a,"symbol",e)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={market:this.market(e).id};void 0!==t&&(s.limit=t);const r=await this.publicV2GetDepthMarket(this.extend(s,i)),a=this.safeValue(r,"result",{}),o=this.parse8601(this.safeString(a,"lastUpdateTimestamp"));return this.parseOrderBook(a,o)}async fetchTradesV1(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={market:r.id,lastId:1};void 0!==i&&(a.limit=i);const o=await this.publicV1GetHistory(this.extend(a,s)),n=this.safeValue(o,"result",[]);return this.parseTrades(n,r,t,i)}async fetchTradesV2(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={market:r.id};void 0!==i&&(a.limit=i);const o=await this.publicV2GetTradesMarket(this.extend(a,s)),n=this.safeValue(o,"result",[]);return this.parseTrades(n,r,t,i)}async fetchTrades(e,t,i,s={}){const r=this.safeString(this.options,"fetchTradesMethod","fetchTradesV2");return await this[r](e,t,i,s)}parseTrade(e,t){let i=this.safeValue(e,"time");i="string"==typeof i?this.parse8601(i):parseInt(1e3*i);const s=this.safeFloat(e,"price"),r=this.safeFloat2(e,"amount","volume"),a=this.safeString2(e,"id","tradeId");let o=this.safeString(e,"type");if(void 0===o){o=this.safeValue(e,"isBuyerMaker")?"buy":"sell"}let n=void 0;void 0!==t&&(n=t.symbol);let d=void 0;return void 0!==r&&void 0!==s&&(d=r*s),{info:e,timestamp:i,datetime:this.iso8601(i),symbol:n,id:a,order:void 0,type:void 0,takerOrMaker:void 0,side:o,price:s,amount:r,cost:d,fee:void 0}}async fetchOHLCV(e,t="1m",i,s,r={}){await this.loadMarkets();const a=this.market(e),o={market:a.id,interval:this.timeframes[t]};void 0!==i&&(o.start=parseInt(i/1e3)),void 0!==s&&(o.limit=s);const n=await this.publicV1GetKline(this.extend(o,r)),d=this.safeValue(n,"result");return this.parseOHLCVs(d,a,t,i,s)}parseOHLCV(e,t,i="1m",s,r){return[1e3*e[0],parseFloat(e[1]),parseFloat(e[3]),parseFloat(e[4]),parseFloat(e[2]),parseFloat(e[5])]}async fetchStatus(e={}){const t=await this.webGetV1Healthcheck();let i="ok";return 503===this.safeInteger(t,"status")&&(i="maintenance"),this.status=this.extend(this.status,{status:i,updated:this.milliseconds()}),this.status}sign(e,t="publicV1",i="GET",s={},r,a){const o=this.omit(s,this.extractParams(e));let n=this.urls.api[t]+"/"+this.implodeParams(e,s);return Object.keys(o).length&&(n+="?"+this.urlencode(o)),{url:n,method:i,body:a,headers:r}}handleErrors(e,t,i,s,o,n,d,c,h){if(418===e||429===e)throw new a(this.id+" "+e.toString()+" "+t+" "+n);if(404===e)throw new r(this.id+" "+e.toString()+" endpoint not found");if(void 0!==d){if(!this.safeValue(d,"success")){const e=d.message;if(e)throw new r(e);{const e=this.id+" "+this.json(d);throw new r(e)}}}}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,NotSupported:a,AuthenticationError:o}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"xbtce",name:"xBTCe",countries:["RU"],rateLimit:2e3,version:"v1",has:{CORS:!1,fetchTickers:!0,createMarketOrder:!1,fetchOHLCV:!1},urls:{referral:"https://xbtce.com/?agent=XX97BTCXXXG687021000B",logo:"https://user-images.githubusercontent.com/1294454/28059414-e235970c-662c-11e7-8c3a-08e31f78684b.jpg",api:"https://cryptottlivewebapi.xbtce.net:8443/api",www:"https://www.xbtce.com",doc:["https://www.xbtce.com/tradeapi","https://support.xbtce.info/Knowledgebase/Article/View/52/25/xbtce-exchange-api"]},requiredCredentials:{apiKey:!0,secret:!0,uid:!0},api:{public:{get:["currency","currency/{filter}","level2","level2/{filter}","quotehistory/{symbol}/{periodicity}/bars/ask","quotehistory/{symbol}/{periodicity}/bars/bid","quotehistory/{symbol}/level2","quotehistory/{symbol}/ticks","symbol","symbol/{filter}","tick","tick/{filter}","ticker","ticker/{filter}","tradesession"]},private:{get:["tradeserverinfo","tradesession","currency","currency/{filter}","level2","level2/{filter}","symbol","symbol/{filter}","tick","tick/{filter}","account","asset","asset/{id}","position","position/{id}","trade","trade/{id}","quotehistory/{symbol}/{periodicity}/bars/ask","quotehistory/{symbol}/{periodicity}/bars/ask/info","quotehistory/{symbol}/{periodicity}/bars/bid","quotehistory/{symbol}/{periodicity}/bars/bid/info","quotehistory/{symbol}/level2","quotehistory/{symbol}/level2/info","quotehistory/{symbol}/periodicities","quotehistory/{symbol}/ticks","quotehistory/{symbol}/ticks/info","quotehistory/cache/{symbol}/{periodicity}/bars/ask","quotehistory/cache/{symbol}/{periodicity}/bars/bid","quotehistory/cache/{symbol}/level2","quotehistory/cache/{symbol}/ticks","quotehistory/symbols","quotehistory/version"],post:["trade","tradehistory"],put:["trade"],delete:["trade"]}},commonCurrencies:{DSH:"DASH"}})}async fetchMarkets(e={}){const t=await this.privateGetSymbol(e),i=[];for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"Symbol"),a=this.safeString(s,"MarginCurrency"),o=this.safeString(s,"ProfitCurrency"),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o);let c=n+"/"+d;c=s.IsTradeAllowed?c:r,i.push({id:r,symbol:c,base:n,quote:d,baseId:a,quoteId:o,info:s})}return i}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAsset(e),i={info:t};for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"Currency"),a=this.safeCurrencyCode(r),o={free:this.safeFloat(s,"FreeAmount"),used:this.safeFloat(s,"LockedAmount"),total:this.safeFloat(s,"Amount")};i[a]=o}return this.parseBalance(i)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={filter:this.market(e).id},r=(await this.privateGetLevel2Filter(this.extend(s,i)))[0],a=this.safeInteger(r,"Timestamp");return this.parseOrderBook(r,a,"Bids","Asks","Price","Volume")}parseTicker(e,t){let i=0,s=void 0;"LastBuyTimestamp"in e&&i<e.LastBuyTimestamp&&(i=e.LastBuyTimestamp,s=e.LastBuyPrice),"LastSellTimestamp"in e&&i<e.LastSellTimestamp&&(i=e.LastSellTimestamp,s=e.LastSellPrice),i||(i=this.milliseconds());let r=void 0;return t&&(r=t.symbol),{symbol:r,timestamp:i,datetime:this.iso8601(i),high:e.DailyBestBuyPrice,low:e.DailyBestSellPrice,bid:e.BestBid,bidVolume:void 0,ask:e.BestAsk,askVolume:void 0,vwap:void 0,open:void 0,close:s,last:s,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:e.DailyTradedTotalVolume,quoteVolume:void 0,info:e}}async fetchTickers(e,t={}){await this.loadMarkets();const i=await this.publicGetTicker(t),s=this.indexBy(i,"Symbol"),r=Object.keys(s),a={};for(let e=0;e<r.length;e++){const t=r[e];let i=void 0,o=void 0;if(t in this.markets_by_id)o=(i=this.markets_by_id[t]).symbol;else{const e=t.slice(0,3),i=t.slice(3,6);o=this.safeCurrencyCode(e)+"/"+this.safeCurrencyCode(i)}const n=s[t];a[o]=this.parseTicker(n,i)}return a}async fetchTicker(e,t={}){await this.loadMarkets();const i=this.market(e),s={filter:i.id},a=await this.publicGetTickerFilter(this.extend(s,t));if(a.length<1)throw new r(this.id+" fetchTicker returned empty response, xBTCe public API error");const o=this.indexBy(a,"Symbol")[i.id];return this.parseTicker(o,i)}async fetchTrades(e,t,i,s={}){return await this.loadMarkets(),await this.privateGetTrade(s)}parseOHLCV(e,t,i="1m",s,r){return[e.Timestamp,e.Open,e.High,e.Low,e.Close,e.Volume]}async fetchOHLCV(e,t="1m",i,s,r={}){throw new a(this.id+" fetchOHLCV is disabled by the exchange")}async createOrder(e,t,i,s,a,o={}){if(await this.loadMarkets(),"market"===t)throw new r(this.id+" allows limit orders only");const n={pair:this.marketId(e),type:i,amount:s,rate:a},d=await this.privatePostTrade(this.extend(n,o));return{info:d,id:d.Id.toString()}}async cancelOrder(e,t,i={}){const s={Type:"Cancel",Id:e};return await this.privateDeleteTrade(this.extend(s,i))}nonce(){return this.milliseconds()}sign(e,t="public",i="GET",s={},r,a){if(!this.apiKey)throw new o(this.id+" requires apiKey for all requests, their public API is always busy");if(!this.uid)throw new o(this.id+" requires uid property for authentication and trading, their public API is always busy");let n=this.urls.api+"/"+this.version;"public"===t&&(n+="/"+t),n+="/"+this.implodeParams(e,s);const d=this.omit(s,this.extractParams(e));if("public"===t)Object.keys(d).length&&(n+="?"+this.urlencode(d));else{this.checkRequiredCredentials(),r={"Accept-Encoding":"gzip, deflate"};const e=this.nonce().toString();"POST"===i&&(Object.keys(d).length?(r["Content-Type"]="application/json",a=this.json(d)):n+="?"+this.urlencode(d));let t=e+this.uid+this.apiKey+i+n;a&&(t+=a);const s=this.hmac(this.encode(t),this.encode(this.secret),"sha256","base64"),o=this.uid+":"+this.apiKey+":"+e+":"+this.decode(s);r.Authorization="HMAC "+o}return{url:n,method:i,body:a,headers:r}}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,ArgumentsRequired:a,ExchangeNotAvailable:o,InvalidNonce:n,InsufficientFunds:d,OrderNotFound:c,DDoSProtection:h,InvalidOrder:l,AuthenticationError:u}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"yobit",name:"YoBit",countries:["RU"],rateLimit:3e3,version:"3",has:{CORS:!1,createDepositAddress:!0,createMarketOrder:!1,fetchClosedOrders:"emulated",fetchDepositAddress:!0,fetchDeposits:!1,fetchMyTrades:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBooks:!0,fetchOrders:"emulated",fetchTickers:!0,fetchTransactions:!1,fetchWithdrawals:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766910-cdcbfdae-5eea-11e7-9859-03fea873272d.jpg",api:{public:"https://yobit.net/api",private:"https://yobit.net/tapi"},www:"https://www.yobit.net",doc:"https://www.yobit.net/en/api/",fees:"https://www.yobit.net/en/fees/"},api:{public:{get:["depth/{pair}","info","ticker/{pair}","trades/{pair}"]},private:{post:["ActiveOrders","CancelOrder","GetDepositAddress","getInfo","OrderInfo","Trade","TradeHistory","WithdrawCoinsToAddress"]}},fees:{trading:{maker:.002,taker:.002},funding:{withdraw:{}}},commonCurrencies:{AIR:"AirCoin",ANI:"ANICoin",ANT:"AntsCoin",ATMCHA:"ATM",ASN:"Ascension",AST:"Astral",ATM:"Autumncoin",BCC:"BCH",BCS:"BitcoinStake",BLN:"Bulleon",BOT:"BOTcoin",BON:"BONES",BPC:"BitcoinPremium",BTS:"Bitshares2",CAT:"BitClave",CMT:"CometCoin",COV:"Coven Coin",COVX:"COV",CPC:"Capricoin",CS:"CryptoSpots",DCT:"Discount",DGD:"DarkGoldCoin",DIRT:"DIRTY",DROP:"FaucetCoin",DSH:"DASH",EKO:"EkoCoin",ENTER:"ENTRC",EPC:"ExperienceCoin",ESC:"EdwardSnowden",EUROPE:"EUROP",EXT:"LifeExtension",FUNK:"FUNKCoin",GCC:"GlobalCryptocurrency",GEN:"Genstake",GENE:"Genesiscoin",GOLD:"GoldMint",GOT:"Giotto Coin",HTML5:"HTML",HYPERX:"HYPER",ICN:"iCoin",INSANE:"INSN",JNT:"JointCoin",JPC:"JupiterCoin",KNC:"KingN Coin",LBTCX:"LiteBitcoin",LIZI:"LiZi",LOC:"LocoCoin",LOCX:"LOC",LUNYR:"LUN",LUN:"LunarCoin",MDT:"Midnight",NAV:"NavajoCoin",NBT:"NiceBytes",OMG:"OMGame",PAC:"$PAC",PLAY:"PlayCoin",PIVX:"Darknet",PRS:"PRE",PUTIN:"PUT",STK:"StakeCoin",SUB:"Subscriptio",PAY:"EPAY",PLC:"Platin Coin",RCN:"RCoin",REP:"Republicoin",RUR:"RUB",XIN:"XINCoin"},options:{fetchOrdersRequiresSymbol:!0,fetchTickersMaxLength:512},exceptions:{exact:{803:l,804:l,805:l,806:l,807:l,831:d,832:d,833:c},broad:{"Invalid pair name":r,"invalid api key":u,"invalid sign":u,"api key dont have trade permission":u,"invalid parameter":l,"invalid order":l,"Requests too often":h,"not available":o,"data unavailable":o,"external service unavailable":o,"Total transaction amount":r,"Insufficient funds":d,"invalid key":u,"invalid nonce":n}}})}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGetInfo(e),i=this.safeValue(t,"return",{}),s={info:t},r=this.safeValue(i,"funds",{}),a=this.safeValue(i,"funds_incl_orders",{}),o=Object.keys(this.extend(r,a));for(let e=0;e<o.length;e++){const t=o[e],i=this.safeCurrencyCode(t),n=this.account();n.free=this.safeFloat(r,t),n.total=this.safeFloat(a,t),s[i]=n}return this.parseBalance(s)}async fetchMarkets(e={}){const t=await this.publicGetInfo(e),i=this.safeValue(t,"pairs"),s=Object.keys(i),r=[];for(let e=0;e<s.length;e++){const t=s[e],a=i[t],[o,n]=t.split("_");let d=o.toUpperCase(),c=n.toUpperCase();const h=(d=this.safeCurrencyCode(d))+"/"+(c=this.safeCurrencyCode(c)),l={amount:this.safeInteger(a,"decimal_places"),price:this.safeInteger(a,"decimal_places")},u={amount:{min:this.safeFloat(a,"min_amount"),max:this.safeFloat(a,"max_amount")},price:{min:this.safeFloat(a,"min_price"),max:this.safeFloat(a,"max_price")},cost:{min:this.safeFloat(a,"min_total")}},f=0===this.safeInteger(a,"hidden");r.push({id:t,symbol:h,base:d,quote:c,baseId:o,quoteId:n,active:f,taker:a.fee/100,precision:l,limits:u,info:a})}return r}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s=this.market(e),a={pair:s.id};void 0!==t&&(a.limit=t);const o=await this.publicGetDepthPair(this.extend(a,i));if(!(s.id in o))throw new r(this.id+" "+s.symbol+" order book is empty or not available");const n=o[s.id];return this.parseOrderBook(n)}async fetchOrderBooks(e,t={}){await this.loadMarkets();let i=void 0;if(void 0===e){if((i=this.ids.join("-")).length>2048){const e=this.ids.length;throw new r(this.id+" has "+e.toString()+" symbols exceeding max URL length, you are required to specify a list of symbols in the first argument to fetchOrderBooks")}}else i=(i=this.marketIds(e)).join("-");const s={pair:i},a=await this.publicGetDepthPair(this.extend(s,t)),o={};i=Object.keys(a);for(let e=0;e<i.length;e++){const t=i[e];let s=t;if(t in this.markets_by_id){s=this.markets_by_id[t].symbol}o[s]=this.parseOrderBook(a[t])}return o}parseTicker(e,t){const i=this.safeTimestamp(e,"updated");let s=void 0;void 0!==t&&(s=t.symbol);const r=this.safeFloat(e,"last");return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"buy"),bidVolume:void 0,ask:this.safeFloat(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:this.safeFloat(e,"avg"),baseVolume:this.safeFloat(e,"vol_cur"),quoteVolume:this.safeFloat(e,"vol"),info:e}}async fetchTickers(e,t={}){await this.loadMarkets();let i=this.ids;if(void 0===e){const e=i.length;i=i.join("-");const t=this.safeInteger(this.options,"fetchTickersMaxLength",2048);if(i.length>this.options.fetchTickersMaxLength)throw new a(this.id+" has "+e.toString()+" markets exceeding max URL length for this endpoint ("+t.toString()+" characters), please, specify a list of symbols of interest in the first argument to fetchTickers")}else i=(i=this.marketIds(e)).join("-");const s={pair:i},r=await this.publicGetTickerPair(this.extend(s,t)),o={},n=Object.keys(r);for(let e=0;e<n.length;e++){const t=n[e],i=r[t];let s=t,a=void 0;t in this.markets_by_id&&(s=(a=this.markets_by_id[t]).symbol),o[s]=this.parseTicker(i,a)}return o}async fetchTicker(e,t={}){return(await this.fetchTickers([e],t))[e]}parseTrade(e,t){const i=this.safeTimestamp(e,"timestamp");let s=this.safeString(e,"type");"ask"===s?s="sell":"bid"===s&&(s="buy");const r=this.safeFloat2(e,"rate","price"),a=this.safeString2(e,"trade_id","tid"),o=this.safeString(e,"order_id");if("pair"in e){const i=this.safeString(e,"pair");t=this.safeValue(this.markets_by_id,i,t)}let n=void 0;void 0!==t&&(n=t.symbol);const d=this.safeFloat(e,"amount");let c=void 0,h=void 0;const l=this.safeFloat(e,"commission");if(void 0!==l){const t=this.safeString(e,"commissionCurrency");h={cost:l,currency:this.safeCurrencyCode(t)}}const u=this.safeValue(e,"is_your_order");void 0!==u&&(c="taker",u&&(c="maker"),void 0===h&&(h=this.calculateFee(n,"limit",s,d,r,c)));let f=void 0;return void 0!==d&&void 0!==r&&(f=d*r),{id:a,order:o,timestamp:i,datetime:this.iso8601(i),symbol:n,type:"limit",side:s,takerOrMaker:c,price:r,amount:d,cost:f,fee:h,info:e}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={pair:r.id};void 0!==i&&(a.limit=i);const o=await this.publicGetTradesPair(this.extend(a,s));if(Array.isArray(o)){if(0===o.length)return[]}return this.parseTrades(o[r.id],r,t,i)}async createOrder(e,t,i,s,a,o={}){if("market"===t)throw new r(this.id+" allows limit orders only");await this.loadMarkets();const n={pair:this.market(e).id,type:i,amount:this.amountToPrecision(e,s),rate:this.priceToPrecision(e,a)};a=parseFloat(a),s=parseFloat(s);const d=await this.privatePostTrade(this.extend(n,o));let c=void 0,h="open",l=0,u=s;"return"in d&&("0"===(c=this.safeString(d.return,"order_id"))&&(c=this.safeString(d.return,"init_order_id"),h="closed"),l=this.safeFloat(d.return,"received",0),u=this.safeFloat(d.return,"remains",s));const f=this.milliseconds(),p={id:c,timestamp:f,datetime:this.iso8601(f),lastTradeTimestamp:void 0,status:h,symbol:e,type:t,side:i,price:a,cost:a*l,amount:s,remaining:u,filled:l,fee:void 0};return this.orders[c]=p,this.extend({info:d},p)}async cancelOrder(e,t,i={}){await this.loadMarkets();const s={order_id:parseInt(e)},r=await this.privatePostCancelOrder(this.extend(s,i));return e in this.orders&&(this.orders[e].status="canceled"),r}parseOrderStatus(e){return this.safeString({0:"open",1:"closed",2:"canceled",3:"open"},e,e)}parseOrder(e,t){const i=this.safeString(e,"id"),s=this.parseOrderStatus(this.safeString(e,"status")),r=this.safeTimestamp(e,"timestamp_created");let a=void 0;if(void 0===t){const i=this.safeString(e,"pair");i in this.markets_by_id&&(t=this.markets_by_id[i])}void 0!==t&&(a=t.symbol);const o=this.safeFloat(e,"amount");let n=void 0;const d=this.safeFloat(e,"rate");let c=void 0,h=void 0;"start_amount"in e?n=this.safeFloat(e,"start_amount"):i in this.orders&&(n=this.orders[i].amount),void 0!==n&&void 0!==o&&(h=d*(c=n-o));const l=this.safeString(e,"type");return{info:e,id:i,symbol:a,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,type:"limit",side:l,price:d,cost:h,amount:n,remaining:o,filled:c,status:s,fee:void 0}}parseOrders(e,t,i,s,r={}){const a=[],o=Object.keys(e);let n=void 0;void 0!==t&&(n=t.symbol);for(let i=0;i<o.length;i++){const s=o[i],n=this.extend({id:s},e[s]);a.push(this.extend(this.parseOrder(n,t),r))}return this.filterBySymbolSinceLimit(a,n,i,s)}async fetchOrder(e,t,i={}){await this.loadMarkets();const s={order_id:parseInt(e)},r=await this.privatePostOrderInfo(this.extend(s,i));e=e.toString();const a=this.parseOrder(this.extend({id:e},r.return[e])),o=e in this.orders?this.orders[e]:{};return this.orders[e]=this.extend(o,a),this.orders[e]}updateCachedOrders(e,t){for(let t=0;t<e.length;t++){const i=e[t].id;this.orders[i]=e[t]}const i=this.indexBy(e,"id"),s=Object.keys(this.orders);for(let e=0;e<s.length;e++){const r=s[e];let a=this.orders[r];if(!(r in i)){if(void 0!==t&&t!==a.symbol)continue;"open"===a.status&&(void 0===(a=this.extend(a,{status:"closed",cost:void 0,filled:a.amount,remaining:0})).cost&&void 0!==a.filled&&(a.cost=a.filled*a.price),this.orders[r]=a)}}return this.toArray(this.orders)}async fetchOrders(e,t,i,s={}){if(void 0===e)throw new a(this.id+" fetchOrders requires a symbol argument");await this.loadMarkets();const r={};if(void 0!==e){const t=this.market(e);r.pair=t.id}const o=await this.privatePostActiveOrders(this.extend(r,s));let n=[];"return"in o&&(n=this.parseOrders(o.return,void 0));const d=this.updateCachedOrders(n,e),c=this.filterBySymbol(d,e);return this.filterBySinceLimit(c,t,i)}async fetchOpenOrders(e,t,i,s={}){const r=await this.fetchOrders(e,t,i,s);return this.filterBy(r,"status","open")}async fetchClosedOrders(e,t,i,s={}){const r=await this.fetchOrders(e,t,i,s);return this.filterBy(r,"status","closed")}async fetchMyTrades(e,t,i,s={}){if(void 0===e)throw new a(this.id+" fetchMyTrades requires a `symbol` argument");await this.loadMarkets();const r=this.market(e),o={pair:r.id};void 0!==i&&(o.count=parseInt(i)),void 0!==t&&(o.since=parseInt(t/1e3));const n=await this.privatePostTradeHistory(this.extend(o,s)),d=this.safeValue(n,"return",{}),c=Object.keys(d),h=[];for(let e=0;e<c.length;e++){const t=c[e],i=this.parseTrade(this.extend(d[t],{trade_id:t}),r);h.push(i)}return this.filterBySymbolSinceLimit(h,e,t,i)}async createDepositAddress(e,t={}){const i=await this.fetchDepositAddress(e,this.extend({need_new:1},t)),s=this.safeString(i,"address");return this.checkAddress(s),{currency:e,address:s,tag:void 0,info:i.info}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={coinName:this.currency(e).id,need_new:0},s=await this.privatePostGetDepositAddress(this.extend(i,t)),r=this.safeString(s.return,"address");return this.checkAddress(r),{currency:e,address:r,tag:void 0,info:s}}async withdraw(e,t,i,s,a={}){this.checkAddress(i),await this.loadMarkets();const o={coinName:this.currency(e).id,amount:t,address:i};if(void 0!==s)throw new r(this.id+" withdraw() does not support the tag argument yet due to a lack of docs on withdrawing with tag/memo on behalf of the exchange.");return{info:await this.privatePostWithdrawCoinsToAddress(this.extend(o,a)),id:void 0}}calculateFee(e,t,i,s,r,a="taker",o={}){const n=this.markets[e];let d="quote";const c=n[a];let h=parseFloat(this.costToPrecision(e,s*c));return"sell"===i?h*=r:d="base",{type:a,currency:n[d],rate:c,cost:h}}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api[t];const n=this.omit(s,this.extractParams(e));if("private"===t){this.checkRequiredCredentials();const t=this.nonce();a=this.urlencode(this.extend({nonce:t,method:e},n));const i=this.hmac(this.encode(a),this.encode(this.secret),"sha512");r={"Content-Type":"application/x-www-form-urlencoded",Key:this.apiKey,Sign:i}}else"public"===t?(o+="/"+this.version+"/"+this.implodeParams(e,s),Object.keys(n).length&&(o+="?"+this.urlencode(n))):(o+="/"+this.implodeParams(e,s),"GET"===i?Object.keys(n).length&&(o+="?"+this.urlencode(n)):Object.keys(n).length&&(a=this.json(n),r={"Content-Type":"application/json"}));return{url:o,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,o,n,d,c){if(void 0!==n&&"success"in n){let e=this.safeValue(n,"success",!1);if("string"==typeof e&&(e="true"===e||"1"===e),!e){const e=this.safeString(n,"code"),t=this.safeString(n,"error"),i=this.id+" "+this.json(n),s=this.exceptions.exact;if(e in s)throw new s[e](i);if(t in s)throw new s[t](i);const a=this.exceptions.broad,o=this.findBroadlyMatchedKey(a,t);if(void 0!==o)throw new a[o](i);throw new r(i)}}}}},function(e,t,i){"use strict";const s=i(1),{ExchangeError:r,BadRequest:a}=i(0);e.exports=class extends s{describe(){return this.deepExtend(super.describe(),{id:"zaif",name:"Zaif",countries:["JP"],rateLimit:2e3,version:"1",has:{CORS:!1,createMarketOrder:!1,fetchOpenOrders:!0,fetchClosedOrders:!0,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766927-39ca2ada-5eeb-11e7-972f-1b4199518ca6.jpg",api:"https://api.zaif.jp",www:"https://zaif.jp",doc:["https://techbureau-api-document.readthedocs.io/ja/latest/index.html","https://corp.zaif.jp/api-docs","https://corp.zaif.jp/api-docs/api_links","https://www.npmjs.com/package/zaif.jp","https://github.com/you21979/node-zaif"],fees:"https://zaif.jp/fee?lang=en"},fees:{trading:{percentage:!0,taker:.001,maker:0}},api:{public:{get:["depth/{pair}","currencies/{pair}","currencies/all","currency_pairs/{pair}","currency_pairs/all","last_price/{pair}","ticker/{pair}","trades/{pair}"]},private:{post:["active_orders","cancel_order","deposit_history","get_id_info","get_info","get_info2","get_personal_info","trade","trade_history","withdraw","withdraw_history"]},ecapi:{post:["createInvoice","getInvoice","getInvoiceIdsByOrderNumber","cancelInvoice"]},tlapi:{post:["get_positions","position_history","active_positions","create_position","change_position","cancel_position"]},fapi:{get:["groups/{group_id}","last_price/{group_id}/{pair}","ticker/{group_id}/{pair}","trades/{group_id}/{pair}","depth/{group_id}/{pair}"]}},options:{fees:{"BTC/JPY":{maker:0,taker:0},"BCH/JPY":{maker:0,taker:.003},"BCH/BTC":{maker:0,taker:.003},"PEPECASH/JPY":{maker:0,taker:1e-4},"PEPECASH/BT":{maker:0,taker:1e-4}}},exceptions:{exact:{"unsupported currency_pair":a},broad:{}}})}async fetchMarkets(e={}){const t=await this.publicGetCurrencyPairsAll(e),i=[];for(let e=0;e<t.length;e++){const s=t[e],r=this.safeString(s,"currency_pair"),a=this.safeString(s,"name"),[o,n]=a.split("/"),d=this.safeCurrencyCode(o),c=this.safeCurrencyCode(n),h=d+"/"+c,l={amount:-Math.log10(s.item_unit_step),price:s.aux_unit_point},u=this.safeValue(this.options.fees,h,this.fees.trading),f=u.taker,p=u.maker;i.push({id:r,symbol:h,base:d,quote:c,baseId:o,quoteId:n,active:!0,precision:l,taker:f,maker:p,limits:{amount:{min:this.safeFloat(s,"item_unit_min"),max:void 0},price:{min:this.safeFloat(s,"aux_unit_min"),max:void 0},cost:{min:void 0,max:void 0}},info:s})}return i}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGetInfo(e),i=this.safeValue(t,"return",{}),s={info:t},r=this.safeValue(i,"funds",{}),a=Object.keys(r);for(let e=0;e<a.length;e++){const t=a[e],o=this.safeCurrencyCode(t),n=this.safeValue(r,t),d={free:n,used:0,total:n};"deposit"in i&&t in i.deposit&&(d.total=this.safeFloat(i.deposit,t),d.used=d.total-d.free),s[o]=d}return this.parseBalance(s)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();const s={pair:this.marketId(e)},r=await this.publicGetDepthPair(this.extend(s,i));return this.parseOrderBook(r)}async fetchTicker(e,t={}){await this.loadMarkets();const i={pair:this.marketId(e)},s=await this.publicGetTickerPair(this.extend(i,t)),r=this.milliseconds(),a=this.safeFloat(s,"vwap"),o=this.safeFloat(s,"volume");let n=void 0;void 0!==o&&void 0!==a&&(n=o*a);const d=this.safeFloat(s,"last");return{symbol:e,timestamp:r,datetime:this.iso8601(r),high:this.safeFloat(s,"high"),low:this.safeFloat(s,"low"),bid:this.safeFloat(s,"bid"),bidVolume:void 0,ask:this.safeFloat(s,"ask"),askVolume:void 0,vwap:a,open:void 0,close:d,last:d,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:o,quoteVolume:n,info:s}}parseTrade(e,t){let i=this.safeString(e,"trade_type");i="bid"===i?"buy":"sell";const s=this.safeTimestamp(e,"date"),r=this.safeString2(e,"id","tid"),a=this.safeFloat(e,"price"),o=this.safeFloat(e,"amount");let n=void 0;if(void 0!==a&&void 0!==o&&(n=o*a),void 0===t){const i=this.safeString(e,"currency_pair");i in this.markets_by_id&&(t=this.markets_by_id[i])}let d=void 0;return void 0!==t&&(d=t.symbol),{id:r,info:e,timestamp:s,datetime:this.iso8601(s),symbol:d,type:void 0,side:i,order:void 0,takerOrMaker:void 0,price:a,amount:o,cost:n,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();const r=this.market(e),a={pair:r.id};let o=await this.publicGetTradesPair(this.extend(a,s));if(1===o.length){const e=o[0];Object.keys(e).length||(o=[])}return this.parseTrades(o,r,t,i)}async createOrder(e,t,i,s,a,o={}){if(await this.loadMarkets(),"limit"!==t)throw new r(this.id+" allows limit orders only");const n={currency_pair:this.marketId(e),action:"buy"===i?"bid":"ask",amount:s,price:a},d=await this.privatePostTrade(this.extend(n,o));return{info:d,id:d.return.order_id.toString()}}async cancelOrder(e,t,i={}){const s={order_id:e};return await this.privatePostCancelOrder(this.extend(s,i))}parseOrder(e,t){let i=this.safeString(e,"action");i="bid"===i?"buy":"sell";const s=this.safeTimestamp(e,"timestamp");if(!t){const i=this.safeString(e,"currency_pair");i in this.markets_by_id&&(t=this.markets_by_id[i])}const r=this.safeFloat(e,"price"),a=this.safeFloat(e,"amount");let o=void 0;void 0!==r&&void 0!==a&&(o=r*a);const n=this.safeString(e,"id");let d=void 0;return void 0!==t&&(d=t.symbol),{id:n,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,status:"open",symbol:d,type:"limit",side:i,price:r,cost:o,amount:a,filled:void 0,remaining:void 0,trades:void 0,fee:void 0}}parseOrders(e,t,i,s,r={}){const a=[],o=Object.keys(e);let n=void 0;void 0!==t&&(n=t.symbol);for(let i=0;i<o.length;i++){const s=o[i],n=this.extend({id:s},e[s]);a.push(this.extend(this.parseOrder(n,t),r))}return this.filterBySymbolSinceLimit(a,n,i,s)}async fetchOpenOrders(e,t,i,s={}){await this.loadMarkets();let r=void 0;const a={};void 0!==e&&(r=this.market(e),a.currency_pair=r.id);const o=await this.privatePostActiveOrders(this.extend(a,s));return this.parseOrders(o.return,r,t,i)}async fetchClosedOrders(e,t,i,s={}){await this.loadMarkets();let r=void 0;const a={};void 0!==e&&(r=this.market(e),a.currency_pair=r.id);const o=await this.privatePostTradeHistory(this.extend(a,s));return this.parseOrders(o.return,r,t,i)}async withdraw(e,t,i,s,a={}){this.checkAddress(i),await this.loadMarkets();const o=this.currency(e);if("JPY"===e)throw new r(this.id+" withdraw() does not allow "+e+" withdrawals");const n={currency:o.id,amount:t,address:i};void 0!==s&&(n.message=s);const d=await this.privatePostWithdraw(this.extend(n,a));return{info:d,id:d.return.txid,fee:d.return.fee}}nonce(){return parseFloat(this.milliseconds()/1e3).toFixed(8)}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api+"/";if("public"===t)o+="api/"+this.version+"/"+this.implodeParams(e,s);else if("fapi"===t)o+="fapi/"+this.version+"/"+this.implodeParams(e,s);else{this.checkRequiredCredentials(),o+="ecapi"===t?"ecapi":"tlapi"===t?"tlapi":"tapi";const i=this.nonce();a=this.urlencode(this.extend({method:e,nonce:i},s)),r={"Content-Type":"application/x-www-form-urlencoded",Key:this.apiKey,Sign:this.hmac(this.encode(a),this.encode(this.secret),"sha512")}}return{url:o,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,o,n,d,c){if(void 0===n)return;const h=this.id+" "+o,l=this.safeString(n,"error");if(void 0!==l){const e=this.exceptions.exact;if(l in e)throw new e[l](h);const t=this.exceptions.broad,i=this.findBroadlyMatchedKey(t,l);if(void 0!==i)throw new t[i](h);throw new r(h)}if(!this.safeValue(n,"success",!0))throw new r(h)}}}]);